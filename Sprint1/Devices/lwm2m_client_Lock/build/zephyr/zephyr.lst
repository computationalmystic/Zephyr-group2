
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00001000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
    1000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
    1003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
    1008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
    100b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
    100c:	0f 01 15 b8 10 00 00 	lgdtl  0x10b8


#ifdef CONFIG_SET_GDT
	/* If we set our own GDT, update the segment registers as well.
	 */
	movw	$DATA_SEG, %ax	/* data segment selector (entry = 3) */
    1013:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
    1017:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
    1019:	8e c0                	mov    %eax,%es
	movw	%ax, %ss	/* set SS */
    101b:	8e d0                	mov    %eax,%ss
	xorw	%ax, %ax	/* AX = 0 */
    101d:	66 31 c0             	xor    %ax,%ax
	movw	%ax, %fs	/* Zero FS */
    1020:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* Zero GS */
    1022:	8e e8                	mov    %eax,%gs

	ljmp	$CODE_SEG, $__csSet	/* set CS = 0x08 */
    1024:	ea 2b 10 00 00 08 00 	ljmp   $0x8,$0x102b

0000102b <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
    102b:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
    102e:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
    1031:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
    1034:	bc 10 8a 40 00       	mov    $0x408a10,%esp
	/* In this configuration, all stacks, including IRQ stack, are declared
	 * with a 4K non-present guard page preceding the stack buffer
	 */
	addl	$(CONFIG_ISR_STACK_SIZE + 4096), %esp
#else
	addl	$CONFIG_ISR_STACK_SIZE, %esp
    1039:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
    103f:	bf 00 a0 40 00       	mov    $0x40a000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
    1044:	be 70 b3 02 00       	mov    $0x2b370,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
    1049:	b9 00 30 00 00       	mov    $0x3000,%ecx

	call	_x86_data_copy
    104e:	e8 4b 00 00 00       	call   109e <_x86_data_copy>
	 * Clear BSS: bzero (__bss_start, __bss_num_words*4)
	 *
	 * It's assumed that BSS size will be a multiple of a long (4 bytes),
	 * and aligned on a double word (32-bit) boundary
	 */
	movl	$__bss_start, %edi	/* load BSS start address */
    1053:	bf 00 00 40 00       	mov    $0x400000,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes in .bss */
    1058:	b9 5a 11 00 00       	mov    $0x115a,%ecx
	call	_x86_bss_zero
    105d:	e8 36 00 00 00       	call   1098 <_x86_bss_zero>
#endif

#ifdef CONFIG_X86_MMU

	/* load the page directory address into the registers*/
	movl $z_x86_kernel_pdpt, %eax
    1062:	b8 00 b0 40 00       	mov    $0x40b000,%eax
	movl %eax, %cr3
    1067:	0f 22 d8             	mov    %eax,%cr3

	/* Enable PAE */
	movl %cr4, %eax
    106a:	0f 20 e0             	mov    %cr4,%eax
	orl $CR4_PAE_ENABLE, %eax
    106d:	83 c8 20             	or     $0x20,%eax
	movl %eax, %cr4
    1070:	0f 22 e0             	mov    %eax,%cr4

	/* IA32_EFER NXE bit set */
	movl $0xC0000080, %ecx
    1073:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
    1078:	0f 32                	rdmsr  
	orl $0x800, %eax
    107a:	0d 00 08 00 00       	or     $0x800,%eax
	wrmsr
    107f:	0f 30                	wrmsr  

	/* Enable paging (CR0.PG, bit 31) / write protect (CR0.WP, bit 16) */
	movl %cr0, %eax
    1081:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PG_WP_ENABLE, %eax
    1084:	0d 00 00 01 80       	or     $0x80010000,%eax
	movl %eax, %cr0
    1089:	0f 22 c0             	mov    %eax,%cr0

#if defined(CONFIG_X86_ENABLE_TSS)
	mov $MAIN_TSS, %ax
	ltr %ax
#endif
	lidt	z_x86_idt		/* load 32-bit operand size IDT */
    108c:	0f 01 1d a1 10 00 00 	lidtl  0x10a1

	/* Jump to C portion of kernel initialization and never return */

	jmp	z_cstart
    1093:	e9 8f 1c 02 00       	jmp    22d27 <z_cstart>

00001098 <_x86_bss_zero>:

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
    1098:	31 c0                	xor    %eax,%eax
	cld
    109a:	fc                   	cld    
	rep
    109b:	f3 ab                	rep stos %eax,%es:(%edi)
	stosl				/* zero memory per 4 bytes */

#endif /* CONFIG_SSE */
	ret
    109d:	c3                   	ret    

0000109e <_x86_data_copy>:
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
    109e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	movsl				/* copy data 4 bytes at a time */
	ret
    10a0:	c3                   	ret    

000010a1 <z_x86_idt>:
    10a1:	ff 07 f0 aa 02 00 90 02 b0 ad 1b 00 00 00 00 fe     ................
    10b1:	4f 52 e4 8d 74 26 00                                OR..t&.

000010b8 <_gdt>:
    10b8:	17 00 b8 10 00 00 00 00 ff ff 00 00 00 9b cf 00     ................
    10c8:	ff ff 00 00 00 93 cf 00                             ........

000010d0 <__divdi3>:
    10d0:	55                   	push   %ebp
    10d1:	89 e5                	mov    %esp,%ebp
    10d3:	57                   	push   %edi
    10d4:	56                   	push   %esi
    10d5:	53                   	push   %ebx
    10d6:	83 ec 2c             	sub    $0x2c,%esp
    10d9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    10e0:	8b 55 0c             	mov    0xc(%ebp),%edx
    10e3:	8b 45 08             	mov    0x8(%ebp),%eax
    10e6:	8b 75 10             	mov    0x10(%ebp),%esi
    10e9:	8b 7d 14             	mov    0x14(%ebp),%edi
    10ec:	85 d2                	test   %edx,%edx
    10ee:	79 0e                	jns    10fe <__divdi3+0x2e>
    10f0:	f7 d8                	neg    %eax
    10f2:	83 d2 00             	adc    $0x0,%edx
    10f5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
    10fc:	f7 da                	neg    %edx
    10fe:	85 ff                	test   %edi,%edi
    1100:	79 0a                	jns    110c <__divdi3+0x3c>
    1102:	f7 de                	neg    %esi
    1104:	f7 55 dc             	notl   -0x24(%ebp)
    1107:	83 d7 00             	adc    $0x0,%edi
    110a:	f7 df                	neg    %edi
    110c:	89 f3                	mov    %esi,%ebx
    110e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1111:	89 d6                	mov    %edx,%esi
    1113:	85 ff                	test   %edi,%edi
    1115:	75 2d                	jne    1144 <__divdi3+0x74>
    1117:	39 d3                	cmp    %edx,%ebx
    1119:	76 04                	jbe    111f <__divdi3+0x4f>
    111b:	f7 f3                	div    %ebx
    111d:	eb 1e                	jmp    113d <__divdi3+0x6d>
    111f:	85 db                	test   %ebx,%ebx
    1121:	75 0b                	jne    112e <__divdi3+0x5e>
    1123:	b8 01 00 00 00       	mov    $0x1,%eax
    1128:	31 d2                	xor    %edx,%edx
    112a:	f7 f3                	div    %ebx
    112c:	89 c3                	mov    %eax,%ebx
    112e:	89 f0                	mov    %esi,%eax
    1130:	31 d2                	xor    %edx,%edx
    1132:	f7 f3                	div    %ebx
    1134:	89 c6                	mov    %eax,%esi
    1136:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1139:	89 f7                	mov    %esi,%edi
    113b:	f7 f3                	div    %ebx
    113d:	89 c3                	mov    %eax,%ebx
    113f:	e9 90 00 00 00       	jmp    11d4 <__bss_num_words+0x7a>
    1144:	39 d7                	cmp    %edx,%edi
    1146:	0f 87 80 00 00 00    	ja     11cc <__bss_num_words+0x72>
    114c:	0f bd c7             	bsr    %edi,%eax
    114f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1152:	83 75 e4 1f          	xorl   $0x1f,-0x1c(%ebp)
    1156:	75 15                	jne    116d <__bss_num_words+0x13>
    1158:	39 d7                	cmp    %edx,%edi
    115a:	bf 00 00 00 00       	mov    $0x0,%edi
    115f:	72 05                	jb     1166 <__bss_num_words+0xc>
    1161:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
    1164:	77 68                	ja     11ce <__bss_num_words+0x74>
    1166:	bb 01 00 00 00       	mov    $0x1,%ebx
    116b:	eb 67                	jmp    11d4 <__bss_num_words+0x7a>
    116d:	b8 20 00 00 00       	mov    $0x20,%eax
    1172:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    1175:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    1178:	89 da                	mov    %ebx,%edx
    117a:	d3 e7                	shl    %cl,%edi
    117c:	88 c1                	mov    %al,%cl
    117e:	d3 ea                	shr    %cl,%edx
    1180:	09 fa                	or     %edi,%edx
    1182:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    1185:	d3 e3                	shl    %cl,%ebx
    1187:	89 55 d8             	mov    %edx,-0x28(%ebp)
    118a:	88 c1                	mov    %al,%cl
    118c:	89 f2                	mov    %esi,%edx
    118e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    1191:	d3 ea                	shr    %cl,%edx
    1193:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    1196:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    1199:	d3 e6                	shl    %cl,%esi
    119b:	88 c1                	mov    %al,%cl
    119d:	d3 eb                	shr    %cl,%ebx
    119f:	09 f3                	or     %esi,%ebx
    11a1:	89 d8                	mov    %ebx,%eax
    11a3:	f7 75 d8             	divl   -0x28(%ebp)
    11a6:	89 d6                	mov    %edx,%esi
    11a8:	89 c7                	mov    %eax,%edi
    11aa:	89 c3                	mov    %eax,%ebx
    11ac:	f7 65 d4             	mull   -0x2c(%ebp)
    11af:	89 45 d8             	mov    %eax,-0x28(%ebp)
    11b2:	39 d6                	cmp    %edx,%esi
    11b4:	72 11                	jb     11c7 <__bss_num_words+0x6d>
    11b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    11b9:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    11bc:	d3 e0                	shl    %cl,%eax
    11be:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    11c1:	73 0f                	jae    11d2 <__bss_num_words+0x78>
    11c3:	39 d6                	cmp    %edx,%esi
    11c5:	75 0b                	jne    11d2 <__bss_num_words+0x78>
    11c7:	8d 5f ff             	lea    -0x1(%edi),%ebx
    11ca:	eb 06                	jmp    11d2 <__bss_num_words+0x78>
    11cc:	31 ff                	xor    %edi,%edi
    11ce:	31 db                	xor    %ebx,%ebx
    11d0:	eb 02                	jmp    11d4 <__bss_num_words+0x7a>
    11d2:	31 ff                	xor    %edi,%edi
    11d4:	89 d8                	mov    %ebx,%eax
    11d6:	89 fa                	mov    %edi,%edx
    11d8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    11dc:	74 07                	je     11e5 <__bss_num_words+0x8b>
    11de:	f7 d8                	neg    %eax
    11e0:	83 d2 00             	adc    $0x0,%edx
    11e3:	f7 da                	neg    %edx
    11e5:	83 c4 2c             	add    $0x2c,%esp
    11e8:	5b                   	pop    %ebx
    11e9:	5e                   	pop    %esi
    11ea:	5f                   	pop    %edi
    11eb:	5d                   	pop    %ebp
    11ec:	c3                   	ret    

000011ed <__udivdi3>:
    11ed:	55                   	push   %ebp
    11ee:	89 e5                	mov    %esp,%ebp
    11f0:	57                   	push   %edi
    11f1:	56                   	push   %esi
    11f2:	53                   	push   %ebx
    11f3:	83 ec 1c             	sub    $0x1c,%esp
    11f6:	8b 55 14             	mov    0x14(%ebp),%edx
    11f9:	8b 45 08             	mov    0x8(%ebp),%eax
    11fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    11ff:	8b 7d 0c             	mov    0xc(%ebp),%edi
    1202:	8b 75 10             	mov    0x10(%ebp),%esi
    1205:	89 d1                	mov    %edx,%ecx
    1207:	85 d2                	test   %edx,%edx
    1209:	75 31                	jne    123c <__udivdi3+0x4f>
    120b:	39 fe                	cmp    %edi,%esi
    120d:	76 06                	jbe    1215 <__udivdi3+0x28>
    120f:	89 fa                	mov    %edi,%edx
    1211:	f7 f6                	div    %esi
    1213:	eb 20                	jmp    1235 <__udivdi3+0x48>
    1215:	89 f3                	mov    %esi,%ebx
    1217:	85 f6                	test   %esi,%esi
    1219:	75 0b                	jne    1226 <__udivdi3+0x39>
    121b:	b8 01 00 00 00       	mov    $0x1,%eax
    1220:	31 d2                	xor    %edx,%edx
    1222:	f7 f6                	div    %esi
    1224:	89 c3                	mov    %eax,%ebx
    1226:	89 f8                	mov    %edi,%eax
    1228:	31 d2                	xor    %edx,%edx
    122a:	f7 f3                	div    %ebx
    122c:	89 c7                	mov    %eax,%edi
    122e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1231:	89 f9                	mov    %edi,%ecx
    1233:	f7 f3                	div    %ebx
    1235:	89 c3                	mov    %eax,%ebx
    1237:	e9 94 00 00 00       	jmp    12d0 <__udivdi3+0xe3>
    123c:	39 fa                	cmp    %edi,%edx
    123e:	0f 87 84 00 00 00    	ja     12c8 <__udivdi3+0xdb>
    1244:	0f bd c2             	bsr    %edx,%eax
    1247:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    124a:	83 75 e4 1f          	xorl   $0x1f,-0x1c(%ebp)
    124e:	75 15                	jne    1265 <__udivdi3+0x78>
    1250:	39 fa                	cmp    %edi,%edx
    1252:	b9 00 00 00 00       	mov    $0x0,%ecx
    1257:	72 05                	jb     125e <__udivdi3+0x71>
    1259:	3b 75 e0             	cmp    -0x20(%ebp),%esi
    125c:	77 6c                	ja     12ca <__udivdi3+0xdd>
    125e:	bb 01 00 00 00       	mov    $0x1,%ebx
    1263:	eb 6b                	jmp    12d0 <__udivdi3+0xe3>
    1265:	b8 20 00 00 00       	mov    $0x20,%eax
    126a:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    126d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    1270:	89 f3                	mov    %esi,%ebx
    1272:	d3 e2                	shl    %cl,%edx
    1274:	88 c1                	mov    %al,%cl
    1276:	d3 eb                	shr    %cl,%ebx
    1278:	89 d9                	mov    %ebx,%ecx
    127a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    127d:	09 d1                	or     %edx,%ecx
    127f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    1282:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    1285:	d3 e6                	shl    %cl,%esi
    1287:	89 75 d8             	mov    %esi,-0x28(%ebp)
    128a:	88 c1                	mov    %al,%cl
    128c:	89 fe                	mov    %edi,%esi
    128e:	d3 ee                	shr    %cl,%esi
    1290:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    1293:	89 f2                	mov    %esi,%edx
    1295:	d3 e7                	shl    %cl,%edi
    1297:	88 c1                	mov    %al,%cl
    1299:	d3 eb                	shr    %cl,%ebx
    129b:	09 fb                	or     %edi,%ebx
    129d:	89 d8                	mov    %ebx,%eax
    129f:	f7 75 dc             	divl   -0x24(%ebp)
    12a2:	89 d6                	mov    %edx,%esi
    12a4:	89 c7                	mov    %eax,%edi
    12a6:	89 c3                	mov    %eax,%ebx
    12a8:	f7 65 d8             	mull   -0x28(%ebp)
    12ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
    12ae:	39 d6                	cmp    %edx,%esi
    12b0:	72 11                	jb     12c3 <__udivdi3+0xd6>
    12b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    12b5:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    12b8:	d3 e0                	shl    %cl,%eax
    12ba:	3b 45 dc             	cmp    -0x24(%ebp),%eax
    12bd:	73 0f                	jae    12ce <__udivdi3+0xe1>
    12bf:	39 d6                	cmp    %edx,%esi
    12c1:	75 0b                	jne    12ce <__udivdi3+0xe1>
    12c3:	8d 5f ff             	lea    -0x1(%edi),%ebx
    12c6:	eb 06                	jmp    12ce <__udivdi3+0xe1>
    12c8:	31 c9                	xor    %ecx,%ecx
    12ca:	31 db                	xor    %ebx,%ebx
    12cc:	eb 02                	jmp    12d0 <__udivdi3+0xe3>
    12ce:	31 c9                	xor    %ecx,%ecx
    12d0:	89 d8                	mov    %ebx,%eax
    12d2:	89 ca                	mov    %ecx,%edx
    12d4:	83 c4 1c             	add    $0x1c,%esp
    12d7:	5b                   	pop    %ebx
    12d8:	5e                   	pop    %esi
    12d9:	5f                   	pop    %edi
    12da:	5d                   	pop    %ebp
    12db:	c3                   	ret    

000012dc <firmware_get_buf>:
}
#endif

#if defined(CONFIG_LWM2M_FIRMWARE_UPDATE_OBJ_SUPPORT)
static void *firmware_get_buf(u16_t obj_inst_id, size_t *data_len)
{
    12dc:	55                   	push   %ebp
    12dd:	89 e5                	mov    %esp,%ebp
	*data_len = sizeof(firmware_buf);
    12df:	8b 45 0c             	mov    0xc(%ebp),%eax
    12e2:	c7 00 40 00 00 00    	movl   $0x40,(%eax)
	return firmware_buf;
}
    12e8:	b8 00 00 40 00       	mov    $0x400000,%eax
    12ed:	5d                   	pop    %ebp
    12ee:	c3                   	ret    

000012ef <rd_client_event>:
	return 0;
}

static void rd_client_event(struct lwm2m_ctx *client,
			    enum lwm2m_rd_client_event client_event)
{
    12ef:	55                   	push   %ebp
    12f0:	89 e5                	mov    %esp,%ebp
	switch (client_event) {
    12f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    12f5:	8d 50 ff             	lea    -0x1(%eax),%edx
    12f8:	83 fa 08             	cmp    $0x8,%edx
    12fb:	0f 87 6d 01 00 00    	ja     146e <rd_client_event+0x17f>
    1301:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
	case LWM2M_RD_CLIENT_EVENT_REG_UPDATE_COMPLETE:
		LOG_DBG("Registration update complete");
		break;

	case LWM2M_RD_CLIENT_EVENT_DEREGISTER_FAILURE:
		LOG_DBG("Deregister failure!");
    1306:	a8 04                	test   $0x4,%al
	switch (client_event) {
    1308:	ff 24 95 6c 5c 02 00 	jmp    *0x25c6c(,%edx,4)
		LOG_DBG("Bootstrap registration failure!");
    130f:	0f 84 59 01 00 00    	je     146e <rd_client_event+0x17f>
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    1315:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    131a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    131f:	c1 e8 03             	shr    $0x3,%eax
    1322:	c1 e0 06             	shl    $0x6,%eax
    1325:	83 c8 04             	or     $0x4,%eax
    1328:	50                   	push   %eax
    1329:	68 a4 5c 02 00       	push   $0x25ca4
    132e:	68 44 66 02 00       	push   $0x26644
    1333:	e9 2e 01 00 00       	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Bootstrap registration complete");
    1338:	0f 84 30 01 00 00    	je     146e <rd_client_event+0x17f>
    133e:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    1343:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1348:	c1 e8 03             	shr    $0x3,%eax
    134b:	c1 e0 06             	shl    $0x6,%eax
    134e:	83 c8 04             	or     $0x4,%eax
    1351:	50                   	push   %eax
    1352:	68 a4 5c 02 00       	push   $0x25ca4
    1357:	68 68 66 02 00       	push   $0x26668
    135c:	e9 05 01 00 00       	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Bootstrap transfer complete");
    1361:	0f 84 07 01 00 00    	je     146e <rd_client_event+0x17f>
    1367:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    136c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1371:	c1 e8 03             	shr    $0x3,%eax
    1374:	c1 e0 06             	shl    $0x6,%eax
    1377:	83 c8 04             	or     $0x4,%eax
    137a:	50                   	push   %eax
    137b:	68 a4 5c 02 00       	push   $0x25ca4
    1380:	68 8c 66 02 00       	push   $0x2668c
    1385:	e9 dc 00 00 00       	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Registration failure!");
    138a:	0f 84 de 00 00 00    	je     146e <rd_client_event+0x17f>
    1390:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    1395:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    139a:	c1 e8 03             	shr    $0x3,%eax
    139d:	c1 e0 06             	shl    $0x6,%eax
    13a0:	83 c8 04             	or     $0x4,%eax
    13a3:	50                   	push   %eax
    13a4:	68 a4 5c 02 00       	push   $0x25ca4
    13a9:	68 ac 66 02 00       	push   $0x266ac
    13ae:	e9 b3 00 00 00       	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Registration complete");
    13b3:	0f 84 b5 00 00 00    	je     146e <rd_client_event+0x17f>
    13b9:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    13be:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    13c3:	c1 e8 03             	shr    $0x3,%eax
    13c6:	c1 e0 06             	shl    $0x6,%eax
    13c9:	83 c8 04             	or     $0x4,%eax
    13cc:	50                   	push   %eax
    13cd:	68 a4 5c 02 00       	push   $0x25ca4
    13d2:	68 c6 66 02 00       	push   $0x266c6
    13d7:	e9 8a 00 00 00       	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Registration update failure!");
    13dc:	0f 84 8c 00 00 00    	je     146e <rd_client_event+0x17f>
    13e2:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    13e7:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    13ec:	c1 e8 03             	shr    $0x3,%eax
    13ef:	c1 e0 06             	shl    $0x6,%eax
    13f2:	83 c8 04             	or     $0x4,%eax
    13f5:	50                   	push   %eax
    13f6:	68 a4 5c 02 00       	push   $0x25ca4
    13fb:	68 e0 66 02 00       	push   $0x266e0
    1400:	eb 64                	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Registration update complete");
    1402:	74 6a                	je     146e <rd_client_event+0x17f>
    1404:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    1409:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    140e:	c1 e8 03             	shr    $0x3,%eax
    1411:	c1 e0 06             	shl    $0x6,%eax
    1414:	83 c8 04             	or     $0x4,%eax
    1417:	50                   	push   %eax
    1418:	68 a4 5c 02 00       	push   $0x25ca4
    141d:	68 01 67 02 00       	push   $0x26701
    1422:	eb 42                	jmp    1466 <rd_client_event+0x177>
		LOG_DBG("Deregister failure!");
    1424:	74 48                	je     146e <rd_client_event+0x17f>
    1426:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    142b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1430:	c1 e8 03             	shr    $0x3,%eax
    1433:	c1 e0 06             	shl    $0x6,%eax
    1436:	83 c8 04             	or     $0x4,%eax
    1439:	50                   	push   %eax
    143a:	68 a4 5c 02 00       	push   $0x25ca4
    143f:	68 22 67 02 00       	push   $0x26722
    1444:	eb 20                	jmp    1466 <rd_client_event+0x177>
		break;

	case LWM2M_RD_CLIENT_EVENT_DISCONNECT:
		LOG_DBG("Disconnected");
    1446:	74 26                	je     146e <rd_client_event+0x17f>
    1448:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    144d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1452:	c1 e8 03             	shr    $0x3,%eax
    1455:	c1 e0 06             	shl    $0x6,%eax
    1458:	83 c8 04             	or     $0x4,%eax
    145b:	50                   	push   %eax
    145c:	68 a4 5c 02 00       	push   $0x25ca4
    1461:	68 3a 67 02 00       	push   $0x2673a
    1466:	e8 44 20 00 00       	call   34af <log_1>
    146b:	83 c4 0c             	add    $0xc,%esp
		break;

	}
}
    146e:	c9                   	leave  
    146f:	c3                   	ret    

00001470 <firmware_update_cb>:
{
    1470:	55                   	push   %ebp
	LOG_DBG("UPDATE");
    1471:	f6 05 a0 a8 40 00 04 	testb  $0x4,0x40a8a0
{
    1478:	89 e5                	mov    %esp,%ebp
	LOG_DBG("UPDATE");
    147a:	74 26                	je     14a2 <firmware_update_cb+0x32>
    147c:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    1481:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1486:	c1 e8 03             	shr    $0x3,%eax
    1489:	c1 e0 06             	shl    $0x6,%eax
    148c:	83 c8 04             	or     $0x4,%eax
    148f:	50                   	push   %eax
    1490:	68 90 5c 02 00       	push   $0x25c90
    1495:	68 4b 67 02 00       	push   $0x2674b
    149a:	e8 10 20 00 00       	call   34af <log_1>
    149f:	83 c4 0c             	add    $0xc,%esp
	lwm2m_engine_set_u8("5/0/3", STATE_IDLE);
    14a2:	6a 00                	push   $0x0
    14a4:	68 56 67 02 00       	push   $0x26756
    14a9:	e8 0b 94 01 00       	call   1a8b9 <lwm2m_engine_set_u8>
    14ae:	58                   	pop    %eax
    14af:	5a                   	pop    %edx
	lwm2m_engine_set_u8("5/0/5", RESULT_SUCCESS);
    14b0:	6a 01                	push   $0x1
    14b2:	68 5c 67 02 00       	push   $0x2675c
    14b7:	e8 fd 93 01 00       	call   1a8b9 <lwm2m_engine_set_u8>
    14bc:	59                   	pop    %ecx
    14bd:	58                   	pop    %eax
}
    14be:	31 c0                	xor    %eax,%eax
    14c0:	c9                   	leave  
    14c1:	c3                   	ret    

000014c2 <device_factory_default_cb>:
	LOG_INF("DEVICE: FACTORY DEFAULT");
    14c2:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
{
    14c7:	55                   	push   %ebp
	LOG_INF("DEVICE: FACTORY DEFAULT");
    14c8:	83 e0 07             	and    $0x7,%eax
{
    14cb:	89 e5                	mov    %esp,%ebp
	LOG_INF("DEVICE: FACTORY DEFAULT");
    14cd:	83 f8 02             	cmp    $0x2,%eax
    14d0:	76 20                	jbe    14f2 <device_factory_default_cb+0x30>
    14d2:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    14d7:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    14dc:	c1 e8 03             	shr    $0x3,%eax
    14df:	c1 e0 06             	shl    $0x6,%eax
    14e2:	83 c8 03             	or     $0x3,%eax
    14e5:	50                   	push   %eax
    14e6:	68 62 67 02 00       	push   $0x26762
    14eb:	e8 9a 1f 00 00       	call   348a <log_0>
    14f0:	59                   	pop    %ecx
    14f1:	58                   	pop    %eax
	lwm2m_device_add_err(LWM2M_DEVICE_ERROR_GPS_FAILURE);
    14f2:	6a 03                	push   $0x3
    14f4:	e8 8f b6 01 00       	call   1cb88 <lwm2m_device_add_err>
	lwm2m_device_set_pwrsrc_current_ma(pwrsrc_usb, --usb_current);
    14f9:	a1 24 a6 40 00       	mov    0x40a624,%eax
    14fe:	48                   	dec    %eax
    14ff:	89 04 24             	mov    %eax,(%esp)
    1502:	a3 24 a6 40 00       	mov    %eax,0x40a624
    1507:	ff 35 c8 41 40 00    	pushl  0x4041c8
    150d:	e8 e2 b5 01 00       	call   1caf4 <lwm2m_device_set_pwrsrc_current_ma>
    1512:	58                   	pop    %eax
}
    1513:	31 c0                	xor    %eax,%eax
	lwm2m_device_set_pwrsrc_current_ma(pwrsrc_usb, --usb_current);
    1515:	5a                   	pop    %edx
}
    1516:	c9                   	leave  
    1517:	c3                   	ret    

00001518 <device_reboot_cb>:
	LOG_INF("DEVICE: REBOOT");
    1518:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
{
    151d:	55                   	push   %ebp
	LOG_INF("DEVICE: REBOOT");
    151e:	83 e0 07             	and    $0x7,%eax
{
    1521:	89 e5                	mov    %esp,%ebp
	LOG_INF("DEVICE: REBOOT");
    1523:	83 f8 02             	cmp    $0x2,%eax
    1526:	76 20                	jbe    1548 <device_reboot_cb+0x30>
    1528:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    152d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1532:	c1 e8 03             	shr    $0x3,%eax
    1535:	c1 e0 06             	shl    $0x6,%eax
    1538:	83 c8 03             	or     $0x3,%eax
    153b:	50                   	push   %eax
    153c:	68 7a 67 02 00       	push   $0x2677a
    1541:	e8 44 1f 00 00       	call   348a <log_0>
    1546:	59                   	pop    %ecx
    1547:	58                   	pop    %eax
	lwm2m_device_add_err(LWM2M_DEVICE_ERROR_LOW_POWER);
    1548:	6a 01                	push   $0x1
    154a:	e8 39 b6 01 00       	call   1cb88 <lwm2m_device_add_err>
	lwm2m_device_set_pwrsrc_voltage_mv(pwrsrc_bat, --battery_voltage);
    154f:	a1 28 a6 40 00       	mov    0x40a628,%eax
    1554:	48                   	dec    %eax
    1555:	89 04 24             	mov    %eax,(%esp)
    1558:	a3 28 a6 40 00       	mov    %eax,0x40a628
    155d:	ff 35 cc 41 40 00    	pushl  0x4041cc
    1563:	e8 f8 b4 01 00       	call   1ca60 <lwm2m_device_set_pwrsrc_voltage_mv>
    1568:	58                   	pop    %eax
}
    1569:	31 c0                	xor    %eax,%eax
	lwm2m_device_set_pwrsrc_voltage_mv(pwrsrc_bat, --battery_voltage);
    156b:	5a                   	pop    %edx
}
    156c:	c9                   	leave  
    156d:	c3                   	ret    

0000156e <timer_digital_state_cb>:
{
    156e:	55                   	push   %ebp
    156f:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
    1574:	89 e5                	mov    %esp,%ebp
	if (*digital_state) {
    1576:	83 e0 07             	and    $0x7,%eax
    1579:	8b 55 0c             	mov    0xc(%ebp),%edx
    157c:	80 3a 00             	cmpb   $0x0,(%edx)
    157f:	74 20                	je     15a1 <timer_digital_state_cb+0x33>
		LOG_INF("TIMER: ON");
    1581:	83 f8 02             	cmp    $0x2,%eax
    1584:	76 40                	jbe    15c6 <timer_digital_state_cb+0x58>
    1586:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    158b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    1590:	c1 e8 03             	shr    $0x3,%eax
    1593:	c1 e0 06             	shl    $0x6,%eax
    1596:	83 c8 03             	or     $0x3,%eax
    1599:	50                   	push   %eax
    159a:	68 89 67 02 00       	push   $0x26789
    159f:	eb 1e                	jmp    15bf <timer_digital_state_cb+0x51>
		LOG_INF("TIMER: OFF");
    15a1:	83 f8 02             	cmp    $0x2,%eax
    15a4:	76 20                	jbe    15c6 <timer_digital_state_cb+0x58>
    15a6:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    15ab:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    15b0:	c1 e8 03             	shr    $0x3,%eax
    15b3:	c1 e0 06             	shl    $0x6,%eax
    15b6:	83 c8 03             	or     $0x3,%eax
    15b9:	50                   	push   %eax
    15ba:	68 93 67 02 00       	push   $0x26793
    15bf:	e8 c6 1e 00 00       	call   348a <log_0>
    15c4:	58                   	pop    %eax
    15c5:	5a                   	pop    %edx
}
    15c6:	31 c0                	xor    %eax,%eax
    15c8:	c9                   	leave  
    15c9:	c3                   	ret    

000015ca <firmware_block_received_cb>:
{
    15ca:	55                   	push   %ebp
	LOG_INF("FIRMWARE: BLOCK RECEIVED: len:%u last_block:%d",
    15cb:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
{
    15d0:	89 e5                	mov    %esp,%ebp
	LOG_INF("FIRMWARE: BLOCK RECEIVED: len:%u last_block:%d",
    15d2:	83 e0 07             	and    $0x7,%eax
    15d5:	83 f8 02             	cmp    $0x2,%eax
{
    15d8:	8b 55 10             	mov    0x10(%ebp),%edx
    15db:	8b 4d 14             	mov    0x14(%ebp),%ecx
	LOG_INF("FIRMWARE: BLOCK RECEIVED: len:%u last_block:%d",
    15de:	76 29                	jbe    1609 <firmware_block_received_cb+0x3f>
    15e0:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    15e5:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    15ea:	c1 e8 03             	shr    $0x3,%eax
    15ed:	c1 e0 06             	shl    $0x6,%eax
    15f0:	83 c8 03             	or     $0x3,%eax
    15f3:	50                   	push   %eax
    15f4:	0f b6 c9             	movzbl %cl,%ecx
    15f7:	51                   	push   %ecx
    15f8:	0f b7 d2             	movzwl %dx,%edx
    15fb:	52                   	push   %edx
    15fc:	68 9e 67 02 00       	push   $0x2679e
    1601:	e8 e3 1e 00 00       	call   34e9 <log_2>
    1606:	83 c4 10             	add    $0x10,%esp
}
    1609:	31 c0                	xor    %eax,%eax
    160b:	c9                   	leave  
    160c:	c3                   	ret    

0000160d <led_on_off_cb>:
{
    160d:	55                   	push   %ebp
    160e:	89 e5                	mov    %esp,%ebp
    1610:	56                   	push   %esi
    1611:	53                   	push   %ebx
	return ret;
    1612:	31 db                	xor    %ebx,%ebx
	led_val = *(u8_t *) data;
    1614:	8b 45 0c             	mov    0xc(%ebp),%eax
    1617:	0f b6 30             	movzbl (%eax),%esi
	if (led_val != led_state) {
    161a:	39 35 c0 41 40 00    	cmp    %esi,0x4041c0
    1620:	74 5c                	je     167e <CONFIG_LWM2M_PEER_PORT+0x4b>
		ret = gpio_pin_write(led_dev, LED_GPIO_PIN, led_val);
    1622:	a1 c4 41 40 00       	mov    0x4041c4,%eax
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
    1627:	8b 50 04             	mov    0x4(%eax),%edx
    162a:	56                   	push   %esi
    162b:	6a 00                	push   $0x0
    162d:	6a 00                	push   $0x0
    162f:	50                   	push   %eax
    1630:	ff 52 04             	call   *0x4(%edx)
    1633:	83 c4 10             	add    $0x10,%esp
    1636:	89 c3                	mov    %eax,%ebx
		if (ret) {
    1638:	85 c0                	test   %eax,%eax
    163a:	74 2e                	je     166a <CONFIG_LWM2M_PEER_PORT+0x37>
			LOG_ERR("Fail to write to GPIO %d", LED_GPIO_PIN);
    163c:	f6 05 a0 a8 40 00 07 	testb  $0x7,0x40a8a0
    1643:	74 39                	je     167e <CONFIG_LWM2M_PEER_PORT+0x4b>
    1645:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    164a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    164f:	c1 e8 03             	shr    $0x3,%eax
    1652:	c1 e0 06             	shl    $0x6,%eax
    1655:	83 c8 01             	or     $0x1,%eax
    1658:	50                   	push   %eax
    1659:	6a 00                	push   $0x0
    165b:	68 cd 67 02 00       	push   $0x267cd
    1660:	e8 4a 1e 00 00       	call   34af <log_1>
    1665:	83 c4 0c             	add    $0xc,%esp
    1668:	eb 14                	jmp    167e <CONFIG_LWM2M_PEER_PORT+0x4b>
		lwm2m_engine_set_s32("3311/0/5852", 0);
    166a:	6a 00                	push   $0x0
		led_state = led_val;
    166c:	89 35 c0 41 40 00    	mov    %esi,0x4041c0
		lwm2m_engine_set_s32("3311/0/5852", 0);
    1672:	68 e6 67 02 00       	push   $0x267e6
    1677:	e8 6e 92 01 00       	call   1a8ea <lwm2m_engine_set_s32>
    167c:	58                   	pop    %eax
    167d:	5a                   	pop    %edx
}
    167e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1681:	89 d8                	mov    %ebx,%eax
    1683:	5b                   	pop    %ebx
    1684:	5e                   	pop    %esi
    1685:	5d                   	pop    %ebp
    1686:	c3                   	ret    

00001687 <main>:

void main(void)
{
    1687:	55                   	push   %ebp
    1688:	89 e5                	mov    %esp,%ebp
    168a:	53                   	push   %ebx
    168b:	83 ec 10             	sub    $0x10,%esp
	int ret;

	LOG_INF(APP_BANNER);
    168e:	a1 a0 a8 40 00       	mov    0x40a8a0,%eax
    1693:	83 e0 07             	and    $0x7,%eax
    1696:	83 f8 02             	cmp    $0x2,%eax
    1699:	76 20                	jbe    16bb <main+0x34>
    169b:	b8 c4 51 02 00       	mov    $0x251c4,%eax
    16a0:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    16a5:	c1 e8 03             	shr    $0x3,%eax
    16a8:	c1 e0 06             	shl    $0x6,%eax
    16ab:	83 c8 03             	or     $0x3,%eax
    16ae:	50                   	push   %eax
    16af:	68 f2 67 02 00       	push   $0x267f2
    16b4:	e8 d1 1d 00 00       	call   348a <log_0>
    16b9:	58                   	pop    %eax
    16ba:	5a                   	pop    %edx

K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)

K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    16bb:	6a ff                	push   $0xffffffff
    16bd:	6a 00                	push   $0x0
    16bf:	68 40 00 40 00       	push   $0x400040
    16c4:	e8 df 28 02 00       	call   23fa8 <z_impl_k_sem_init>
    16c9:	83 c4 0c             	add    $0xc,%esp
	ret = lwm2m_engine_get_res_data("0/0/0",
    16cc:	8d 45 ed             	lea    -0x13(%ebp),%eax
    16cf:	50                   	push   %eax
    16d0:	8d 45 ee             	lea    -0x12(%ebp),%eax
    16d3:	50                   	push   %eax
    16d4:	8d 45 f0             	lea    -0x10(%ebp),%eax
    16d7:	50                   	push   %eax
    16d8:	68 03 68 02 00       	push   $0x26803
    16dd:	e8 4d 92 01 00       	call   1a92f <lwm2m_engine_get_res_data>
    16e2:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
    16e5:	85 c0                	test   %eax,%eax
    16e7:	0f 88 f4 02 00 00    	js     19e1 <main+0x35a>
		 strchr(SERVER_ADDR, ':') ? "]" : "");
    16ed:	6a 3a                	push   $0x3a
    16ef:	68 09 68 02 00       	push   $0x26809
    16f4:	e8 30 91 00 00       	call   a829 <strchr>
    16f9:	59                   	pop    %ecx
	snprintk(server_url, server_url_len, "coap%s//%s%s%s",
    16fa:	85 c0                	test   %eax,%eax
		 strchr(SERVER_ADDR, ':') ? "]" : "");
    16fc:	5b                   	pop    %ebx
	snprintk(server_url, server_url_len, "coap%s//%s%s%s",
    16fd:	bb 4c 92 02 00       	mov    $0x2924c,%ebx
    1702:	75 05                	jne    1709 <main+0x82>
    1704:	bb 7b 85 02 00       	mov    $0x2857b,%ebx
		 strchr(SERVER_ADDR, ':') ? "[" : "", SERVER_ADDR,
    1709:	6a 3a                	push   $0x3a
    170b:	68 09 68 02 00       	push   $0x26809
    1710:	e8 14 91 00 00       	call   a829 <strchr>
    1715:	59                   	pop    %ecx
	snprintk(server_url, server_url_len, "coap%s//%s%s%s",
    1716:	85 c0                	test   %eax,%eax
		 strchr(SERVER_ADDR, ':') ? "[" : "", SERVER_ADDR,
    1718:	5a                   	pop    %edx
	snprintk(server_url, server_url_len, "coap%s//%s%s%s",
    1719:	ba 25 a8 02 00       	mov    $0x2a825,%edx
    171e:	75 05                	jne    1725 <main+0x9e>
    1720:	ba 7b 85 02 00       	mov    $0x2857b,%edx
    1725:	53                   	push   %ebx
    1726:	68 09 68 02 00       	push   $0x26809
    172b:	52                   	push   %edx
    172c:	68 c5 a7 02 00       	push   $0x2a7c5
    1731:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1735:	68 15 68 02 00       	push   $0x26815
    173a:	50                   	push   %eax
    173b:	ff 75 f0             	pushl  -0x10(%ebp)
    173e:	e8 9a 14 00 00       	call   2bdd <snprintk>
    1743:	83 c4 1c             	add    $0x1c,%esp
	lwm2m_engine_set_u8("0/0/2",
    1746:	6a 03                	push   $0x3
    1748:	68 24 68 02 00       	push   $0x26824
    174d:	e8 67 91 01 00       	call   1a8b9 <lwm2m_engine_set_u8>
    1752:	5b                   	pop    %ebx
    1753:	58                   	pop    %eax
	lwm2m_engine_set_res_data("3/0/0", CLIENT_MANUFACTURER,
    1754:	6a 01                	push   $0x1
    1756:	6a 07                	push   $0x7
    1758:	68 2a 68 02 00       	push   $0x2682a
    175d:	68 31 68 02 00       	push   $0x26831
    1762:	e8 a1 90 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    1767:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_set_res_data("3/0/1", CLIENT_MODEL_NUMBER,
    176a:	6a 01                	push   $0x1
    176c:	6a 18                	push   $0x18
    176e:	68 37 68 02 00       	push   $0x26837
    1773:	68 4f 68 02 00       	push   $0x2684f
    1778:	e8 8b 90 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    177d:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_set_res_data("3/0/2", CLIENT_SERIAL_NUMBER,
    1780:	6a 01                	push   $0x1
    1782:	6a 0a                	push   $0xa
    1784:	68 55 68 02 00       	push   $0x26855
    1789:	68 5f 68 02 00       	push   $0x2685f
    178e:	e8 75 90 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    1793:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_set_res_data("3/0/3", CLIENT_FIRMWARE_VER,
    1796:	6a 01                	push   $0x1
    1798:	6a 04                	push   $0x4
    179a:	68 65 68 02 00       	push   $0x26865
    179f:	68 69 68 02 00       	push   $0x26869
    17a4:	e8 5f 90 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    17a9:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_register_exec_callback("3/0/4", device_reboot_cb);
    17ac:	68 18 15 00 00       	push   $0x1518
    17b1:	68 6f 68 02 00       	push   $0x2686f
    17b6:	e8 08 93 01 00       	call   1aac3 <lwm2m_engine_register_exec_callback>
    17bb:	58                   	pop    %eax
    17bc:	5a                   	pop    %edx
	lwm2m_engine_register_exec_callback("3/0/5", device_factory_default_cb);
    17bd:	68 c2 14 00 00       	push   $0x14c2
    17c2:	68 75 68 02 00       	push   $0x26875
    17c7:	e8 f7 92 01 00       	call   1aac3 <lwm2m_engine_register_exec_callback>
    17cc:	59                   	pop    %ecx
    17cd:	5b                   	pop    %ebx
	lwm2m_engine_set_u8("3/0/9", 95); /* battery level */
    17ce:	6a 5f                	push   $0x5f
    17d0:	68 7b 68 02 00       	push   $0x2687b
    17d5:	e8 df 90 01 00       	call   1a8b9 <lwm2m_engine_set_u8>
    17da:	58                   	pop    %eax
    17db:	5a                   	pop    %edx
	lwm2m_engine_set_u32("3/0/10", 15); /* mem free */
    17dc:	6a 0f                	push   $0xf
    17de:	68 81 68 02 00       	push   $0x26881
    17e3:	e8 ed 90 01 00       	call   1a8d5 <lwm2m_engine_set_u32>
    17e8:	59                   	pop    %ecx
    17e9:	5b                   	pop    %ebx
	lwm2m_engine_set_res_data("3/0/17", CLIENT_DEVICE_TYPE,
    17ea:	6a 01                	push   $0x1
    17ec:	6a 11                	push   $0x11
    17ee:	68 88 68 02 00       	push   $0x26888
    17f3:	68 99 68 02 00       	push   $0x26899
    17f8:	e8 0b 90 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    17fd:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_set_res_data("3/0/18", CLIENT_HW_VER,
    1800:	6a 01                	push   $0x1
    1802:	6a 06                	push   $0x6
    1804:	68 a0 68 02 00       	push   $0x268a0
    1809:	68 a6 68 02 00       	push   $0x268a6
    180e:	e8 f5 8f 01 00       	call   1a808 <lwm2m_engine_set_res_data>
    1813:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_set_u8("3/0/20", LWM2M_DEVICE_BATTERY_STATUS_CHARGING);
    1816:	6a 01                	push   $0x1
    1818:	68 ad 68 02 00       	push   $0x268ad
    181d:	e8 97 90 01 00       	call   1a8b9 <lwm2m_engine_set_u8>
    1822:	58                   	pop    %eax
    1823:	5a                   	pop    %edx
	lwm2m_engine_set_u32("3/0/21", 25); /* mem total */
    1824:	6a 19                	push   $0x19
    1826:	68 b4 68 02 00       	push   $0x268b4
    182b:	e8 a5 90 01 00       	call   1a8d5 <lwm2m_engine_set_u32>
    1830:	59                   	pop    %ecx
    1831:	5b                   	pop    %ebx
	pwrsrc_bat = lwm2m_device_add_pwrsrc(LWM2M_DEVICE_PWR_SRC_TYPE_BAT_INT);
    1832:	6a 01                	push   $0x1
    1834:	e8 9a b1 01 00       	call   1c9d3 <lwm2m_device_add_pwrsrc>
    1839:	5a                   	pop    %edx
    183a:	a3 cc 41 40 00       	mov    %eax,0x4041cc
	if (pwrsrc_bat < 0) {
    183f:	85 c0                	test   %eax,%eax
    1841:	79 36                	jns    1879 <main+0x1f2>
		LOG_ERR("LWM2M battery power source enable error (err:%d)",
    1843:	f6 05 a0 a8 40 00 07 	testb  $0x7,0x40a8a0
    184a:	74 23                	je     186f <main+0x1e8>
    184c:	ba c4 51 02 00       	mov    $0x251c4,%edx
    1851:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
    1857:	c1 ea 03             	shr    $0x3,%edx
    185a:	c1 e2 06             	shl    $0x6,%edx
    185d:	83 ca 01             	or     $0x1,%edx
    1860:	52                   	push   %edx
    1861:	50                   	push   %eax
    1862:	68 bb 68 02 00       	push   $0x268bb
    1867:	e8 43 1c 00 00       	call   34af <log_1>
    186c:	83 c4 0c             	add    $0xc,%esp
		return pwrsrc_bat;
    186f:	a1 cc 41 40 00       	mov    0x4041cc,%eax
    1874:	e9 64 01 00 00       	jmp    19dd <main+0x356>
	lwm2m_device_set_pwrsrc_voltage_mv(pwrsrc_bat, battery_voltage);
    1879:	ff 35 28 a6 40 00    	pushl  0x40a628
    187f:	50                   	push   %eax
    1880:	e8 db b1 01 00       	call   1ca60 <lwm2m_device_set_pwrsrc_voltage_mv>
    1885:	59                   	pop    %ecx
    1886:	5b                   	pop    %ebx
	lwm2m_device_set_pwrsrc_current_ma(pwrsrc_bat, battery_current);
    1887:	6a 7d                	push   $0x7d
    1889:	ff 35 cc 41 40 00    	pushl  0x4041cc
    188f:	e8 60 b2 01 00       	call   1caf4 <lwm2m_device_set_pwrsrc_current_ma>
    1894:	58                   	pop    %eax
    1895:	5a                   	pop    %edx
	pwrsrc_usb = lwm2m_device_add_pwrsrc(LWM2M_DEVICE_PWR_SRC_TYPE_USB);
    1896:	6a 05                	push   $0x5
    1898:	e8 36 b1 01 00       	call   1c9d3 <lwm2m_device_add_pwrsrc>
    189d:	59                   	pop    %ecx
    189e:	a3 c8 41 40 00       	mov    %eax,0x4041c8
	if (pwrsrc_usb < 0) {
    18a3:	85 c0                	test   %eax,%eax
    18a5:	79 36                	jns    18dd <main+0x256>
		LOG_ERR("LWM2M usb power source enable error (err:%d)",
    18a7:	f6 05 a0 a8 40 00 07 	testb  $0x7,0x40a8a0
    18ae:	74 23                	je     18d3 <main+0x24c>
    18b0:	ba c4 51 02 00       	mov    $0x251c4,%edx
    18b5:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
    18bb:	c1 ea 03             	shr    $0x3,%edx
    18be:	c1 e2 06             	shl    $0x6,%edx
    18c1:	83 ca 01             	or     $0x1,%edx
    18c4:	52                   	push   %edx
    18c5:	50                   	push   %eax
    18c6:	68 ec 68 02 00       	push   $0x268ec
    18cb:	e8 df 1b 00 00       	call   34af <log_1>
    18d0:	83 c4 0c             	add    $0xc,%esp
		return pwrsrc_usb;
    18d3:	a1 c8 41 40 00       	mov    0x4041c8,%eax
    18d8:	e9 00 01 00 00       	jmp    19dd <main+0x356>
	lwm2m_device_set_pwrsrc_voltage_mv(pwrsrc_usb, usb_voltage);
    18dd:	68 88 13 00 00       	push   $0x1388
    18e2:	50                   	push   %eax
    18e3:	e8 78 b1 01 00       	call   1ca60 <lwm2m_device_set_pwrsrc_voltage_mv>
    18e8:	58                   	pop    %eax
    18e9:	5a                   	pop    %edx
	lwm2m_device_set_pwrsrc_current_ma(pwrsrc_usb, usb_current);
    18ea:	ff 35 24 a6 40 00    	pushl  0x40a624
    18f0:	ff 35 c8 41 40 00    	pushl  0x4041c8
    18f6:	e8 f9 b1 01 00       	call   1caf4 <lwm2m_device_set_pwrsrc_current_ma>
    18fb:	59                   	pop    %ecx
    18fc:	5b                   	pop    %ebx
	lwm2m_engine_register_pre_write_callback("5/0/0", firmware_get_buf);
    18fd:	68 dc 12 00 00       	push   $0x12dc
    1902:	68 19 69 02 00       	push   $0x26919
    1907:	e8 63 91 01 00       	call   1aa6f <lwm2m_engine_register_pre_write_callback>
    190c:	58                   	pop    %eax
    190d:	5a                   	pop    %edx
	lwm2m_firmware_set_write_cb(firmware_block_received_cb);
    190e:	68 ca 15 00 00       	push   $0x15ca
    1913:	e8 72 de 01 00       	call   1f78a <lwm2m_firmware_set_write_cb>
	lwm2m_firmware_set_update_cb(firmware_update_cb);
    1918:	c7 04 24 70 14 00 00 	movl   $0x1470,(%esp)
    191f:	e8 79 de 01 00       	call   1f79d <lwm2m_firmware_set_update_cb>
	lwm2m_engine_create_obj_inst("3303/0");
    1924:	c7 04 24 1f 69 02 00 	movl   $0x2691f,(%esp)
    192b:	e8 37 8e 01 00       	call   1a767 <lwm2m_engine_create_obj_inst>
	lwm2m_engine_set_float32("3303/0/5700", &float_value);
    1930:	8d 45 f4             	lea    -0xc(%ebp),%eax
	float_value.val1 = 25;
    1933:	c7 45 f4 19 00 00 00 	movl   $0x19,-0xc(%ebp)
	lwm2m_engine_set_float32("3303/0/5700", &float_value);
    193a:	89 04 24             	mov    %eax,(%esp)
    193d:	68 26 69 02 00       	push   $0x26926
	float_value.val2 = 500000;
    1942:	c7 45 f8 20 a1 07 00 	movl   $0x7a120,-0x8(%ebp)
	lwm2m_engine_set_float32("3303/0/5700", &float_value);
    1949:	e8 cd 8f 01 00       	call   1a91b <lwm2m_engine_set_float32>
    194e:	59                   	pop    %ecx
    194f:	5b                   	pop    %ebx

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
    1950:	68 32 69 02 00       	push   $0x26932
    1955:	e8 33 13 02 00       	call   22c8d <z_impl_device_get_binding>
    195a:	5a                   	pop    %edx
	led_dev = device_get_binding(LED_GPIO_PORT);
    195b:	a3 c4 41 40 00       	mov    %eax,0x4041c4
	if (!led_dev) {
    1960:	85 c0                	test   %eax,%eax
    1962:	74 49                	je     19ad <main+0x326>
	return api->config(port, access_op, pin, flags);
    1964:	8b 50 04             	mov    0x4(%eax),%edx
    1967:	6a 01                	push   $0x1
    1969:	6a 00                	push   $0x0
    196b:	6a 00                	push   $0x0
    196d:	50                   	push   %eax
    196e:	ff 12                	call   *(%edx)
    1970:	83 c4 10             	add    $0x10,%esp
	if (ret) {
    1973:	85 c0                	test   %eax,%eax
    1975:	75 36                	jne    19ad <main+0x326>
	ret = gpio_pin_write(led_dev, LED_GPIO_PIN, 0);
    1977:	a1 c4 41 40 00       	mov    0x4041c4,%eax
	return api->write(port, access_op, pin, value);
    197c:	8b 50 04             	mov    0x4(%eax),%edx
    197f:	6a 00                	push   $0x0
    1981:	6a 00                	push   $0x0
    1983:	6a 00                	push   $0x0
    1985:	50                   	push   %eax
    1986:	ff 52 04             	call   *0x4(%edx)
    1989:	83 c4 10             	add    $0x10,%esp
	if (ret) {
    198c:	85 c0                	test   %eax,%eax
    198e:	75 1d                	jne    19ad <main+0x326>
		lwm2m_engine_create_obj_inst("3311/0");
    1990:	68 39 69 02 00       	push   $0x26939
    1995:	e8 cd 8d 01 00       	call   1a767 <lwm2m_engine_create_obj_inst>
		lwm2m_engine_register_post_write_callback("3311/0/5850",
    199a:	c7 04 24 0d 16 00 00 	movl   $0x160d,(%esp)
    19a1:	68 40 69 02 00       	push   $0x26940
    19a6:	e8 ee 90 01 00       	call   1aa99 <lwm2m_engine_register_post_write_callback>
    19ab:	59                   	pop    %ecx
    19ac:	5b                   	pop    %ebx
	lwm2m_engine_create_obj_inst("3340/0");
    19ad:	68 4c 69 02 00       	push   $0x2694c
    19b2:	e8 b0 8d 01 00       	call   1a767 <lwm2m_engine_create_obj_inst>
	lwm2m_engine_register_post_write_callback("3340/0/5543",
    19b7:	c7 04 24 6e 15 00 00 	movl   $0x156e,(%esp)
    19be:	68 53 69 02 00       	push   $0x26953
    19c3:	e8 d1 90 01 00       	call   1aa99 <lwm2m_engine_register_post_write_callback>
    19c8:	59                   	pop    %ecx
    19c9:	5b                   	pop    %ebx
	lwm2m_engine_set_string("3340/0/5750", "Test timer");
    19ca:	68 5f 69 02 00       	push   $0x2695f
    19cf:	68 6a 69 02 00       	push   $0x2696a
    19d4:	e8 bc 8e 01 00       	call   1a895 <lwm2m_engine_set_string>
    19d9:	58                   	pop    %eax
    19da:	5a                   	pop    %edx

	k_sem_init(&quit_lock, 0, UINT_MAX);

	ret = lwm2m_setup();
	if (ret < 0) {
    19db:	eb 32                	jmp    1a0f <main+0x388>
    19dd:	85 c0                	test   %eax,%eax
    19df:	79 2e                	jns    1a0f <main+0x388>
		LOG_ERR("Cannot setup LWM2M fields (%d)", ret);
    19e1:	f6 05 a0 a8 40 00 07 	testb  $0x7,0x40a8a0
    19e8:	74 5e                	je     1a48 <main+0x3c1>
    19ea:	ba c4 51 02 00       	mov    $0x251c4,%edx
    19ef:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
    19f5:	c1 ea 03             	shr    $0x3,%edx
    19f8:	c1 e2 06             	shl    $0x6,%edx
    19fb:	83 ca 01             	or     $0x1,%edx
    19fe:	52                   	push   %edx
    19ff:	50                   	push   %eax
    1a00:	68 76 69 02 00       	push   $0x26976
    1a05:	e8 a5 1a 00 00       	call   34af <log_1>
    1a0a:	83 c4 0c             	add    $0xc,%esp
    1a0d:	eb 39                	jmp    1a48 <main+0x3c1>
		return;
	}

	(void)memset(&client, 0x0, sizeof(client));
    1a0f:	68 88 01 00 00       	push   $0x188
    1a14:	6a 00                	push   $0x0
    1a16:	68 60 00 40 00       	push   $0x400060
    1a1b:	e8 80 8f 00 00       	call   a9a0 <memset>
    1a20:	83 c4 0c             	add    $0xc,%esp
#if defined(CONFIG_LWM2M_DTLS_SUPPORT)
	client.tls_tag = TLS_TAG;
#endif

	/* client.sec_obj_inst is 0 as a starting point */
	lwm2m_rd_client_start(&client, CONFIG_BOARD, rd_client_event);
    1a23:	68 ef 12 00 00       	push   $0x12ef
    1a28:	68 95 69 02 00       	push   $0x26995
    1a2d:	68 60 00 40 00       	push   $0x400060
    1a32:	e8 1d d6 01 00       	call   1f054 <lwm2m_rd_client_start>
    1a37:	83 c4 0c             	add    $0xc,%esp

K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    1a3a:	6a ff                	push   $0xffffffff
    1a3c:	68 40 00 40 00       	push   $0x400040
    1a41:	e8 fc 25 02 00       	call   24042 <z_impl_k_sem_take>
    1a46:	58                   	pop    %eax
    1a47:	5a                   	pop    %edx
	k_sem_take(&quit_lock, K_FOREVER);
}
    1a48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1a4b:	c9                   	leave  
    1a4c:	c3                   	ret    

00001a4d <_check_fd>:
	errno = ENFILE;
	return -1;
}

static int _check_fd(int fd)
{
    1a4d:	55                   	push   %ebp
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    1a4e:	83 f8 03             	cmp    $0x3,%eax
{
    1a51:	89 e5                	mov    %esp,%ebp
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    1a53:	77 0c                	ja     1a61 <_check_fd+0x14>
	if (fdtable[fd].obj == NULL) {
		errno = EBADF;
		return -1;
	}

	return 0;
    1a55:	31 d2                	xor    %edx,%edx
	if (fdtable[fd].obj == NULL) {
    1a57:	83 3c c5 00 02 40 00 	cmpl   $0x0,0x400200(,%eax,8)
    1a5e:	00 
    1a5f:	75 0e                	jne    1a6f <_check_fd+0x22>

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE0(K_SYSCALL_Z_ERRNO, z_errno, int *)
    1a61:	e8 82 12 02 00       	call   22ce8 <z_impl_z_errno>
		errno = EBADF;
    1a66:	83 ca ff             	or     $0xffffffff,%edx
    1a69:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
}
    1a6f:	89 d0                	mov    %edx,%eax
    1a71:	5d                   	pop    %ebp
    1a72:	c3                   	ret    

00001a73 <z_get_fd_obj_and_vtable>:

	return fd_entry->obj;
}

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable)
{
    1a73:	55                   	push   %ebp
    1a74:	89 e5                	mov    %esp,%ebp
    1a76:	53                   	push   %ebx
    1a77:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
    1a7a:	89 d8                	mov    %ebx,%eax
    1a7c:	e8 cc ff ff ff       	call   1a4d <_check_fd>
    1a81:	31 d2                	xor    %edx,%edx
    1a83:	85 c0                	test   %eax,%eax
    1a85:	78 13                	js     1a9a <z_get_fd_obj_and_vtable+0x27>
		return NULL;
	}

	fd_entry = &fdtable[fd];
	*vtable = fd_entry->vtable;
    1a87:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a8a:	8b 14 dd 04 02 40 00 	mov    0x400204(,%ebx,8),%edx
    1a91:	89 10                	mov    %edx,(%eax)

	return fd_entry->obj;
    1a93:	8b 14 dd 00 02 40 00 	mov    0x400200(,%ebx,8),%edx
}
    1a9a:	5b                   	pop    %ebx
    1a9b:	89 d0                	mov    %edx,%eax
    1a9d:	5d                   	pop    %ebp
    1a9e:	c3                   	ret    

00001a9f <z_reserve_fd>:

int z_reserve_fd(void)
{
    1a9f:	55                   	push   %ebp
    1aa0:	89 e5                	mov    %esp,%ebp
    1aa2:	53                   	push   %ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    1aa3:	6a ff                	push   $0xffffffff
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    1aa5:	31 db                	xor    %ebx,%ebx
    1aa7:	68 00 aa 40 00       	push   $0x40aa00
    1aac:	e8 32 19 02 00       	call   233e3 <z_impl_k_mutex_lock>
    1ab1:	5a                   	pop    %edx
    1ab2:	59                   	pop    %ecx
		if (fdtable[fd].obj == NULL) {
    1ab3:	83 3c dd 00 02 40 00 	cmpl   $0x0,0x400200(,%ebx,8)
    1aba:	00 
    1abb:	74 16                	je     1ad3 <z_reserve_fd+0x34>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    1abd:	43                   	inc    %ebx
    1abe:	83 fb 04             	cmp    $0x4,%ebx
    1ac1:	75 f0                	jne    1ab3 <z_reserve_fd+0x14>
    1ac3:	e8 20 12 02 00       	call   22ce8 <z_impl_z_errno>
	return -1;
    1ac8:	83 cb ff             	or     $0xffffffff,%ebx
	errno = ENFILE;
    1acb:	c7 00 17 00 00 00    	movl   $0x17,(%eax)
	int fd;

	(void)k_mutex_lock(&fdtable_lock, K_FOREVER);

	fd = _find_fd_entry();
	if (fd >= 0) {
    1ad1:	eb 0b                	jmp    1ade <z_reserve_fd+0x3f>
		/* Mark entry as used, z_finalize_fd() will fill it in. */
		fdtable[fd].obj = FD_OBJ_RESERVED;
    1ad3:	c7 04 dd 00 02 40 00 	movl   $0x1,0x400200(,%ebx,8)
    1ada:	01 00 00 00 
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    1ade:	68 00 aa 40 00       	push   $0x40aa00
    1ae3:	e8 f2 19 02 00       	call   234da <z_impl_k_mutex_unlock>
    1ae8:	58                   	pop    %eax
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
    1ae9:	89 d8                	mov    %ebx,%eax
    1aeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1aee:	c9                   	leave  
    1aef:	c3                   	ret    

00001af0 <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
    1af0:	55                   	push   %ebp
    1af1:	89 e5                	mov    %esp,%ebp
    1af3:	8b 45 08             	mov    0x8(%ebp),%eax
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = obj;
    1af6:	8b 55 0c             	mov    0xc(%ebp),%edx
    1af9:	89 14 c5 00 02 40 00 	mov    %edx,0x400200(,%eax,8)
	fdtable[fd].vtable = vtable;
    1b00:	8b 55 10             	mov    0x10(%ebp),%edx
    1b03:	89 14 c5 04 02 40 00 	mov    %edx,0x400204(,%eax,8)
}
    1b0a:	5d                   	pop    %ebp
    1b0b:	c3                   	ret    

00001b0c <z_free_fd>:

void z_free_fd(int fd)
{
    1b0c:	55                   	push   %ebp
    1b0d:	89 e5                	mov    %esp,%ebp
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = NULL;
    1b0f:	8b 45 08             	mov    0x8(%ebp),%eax
}
    1b12:	5d                   	pop    %ebp
	fdtable[fd].obj = NULL;
    1b13:	c7 04 c5 00 02 40 00 	movl   $0x0,0x400200(,%eax,8)
    1b1a:	00 00 00 00 
}
    1b1e:	c3                   	ret    

00001b1f <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
    1b1f:	55                   	push   %ebp
    1b20:	89 e5                	mov    %esp,%ebp
    1b22:	56                   	push   %esi
    1b23:	53                   	push   %ebx
    1b24:	6b da 0c             	imul   $0xc,%edx,%ebx
    1b27:	03 58 0c             	add    0xc(%eax),%ebx
	u32_t *bitarray = level <= p->max_inline_level ?
    1b2a:	0f be 40 0b          	movsbl 0xb(%eax),%eax
		&p->levels[level].bits : p->levels[level].bits_p;
    1b2e:	39 d0                	cmp    %edx,%eax
    1b30:	7d 02                	jge    1b34 <get_bit_ptr+0x15>
    1b32:	8b 1b                	mov    (%ebx),%ebx

	*word = &bitarray[bn / 32];
    1b34:	89 c8                	mov    %ecx,%eax
    1b36:	be 20 00 00 00       	mov    $0x20,%esi
    1b3b:	99                   	cltd   
    1b3c:	f7 fe                	idiv   %esi
    1b3e:	8d 14 83             	lea    (%ebx,%eax,4),%edx
    1b41:	8b 45 08             	mov    0x8(%ebp),%eax
    1b44:	89 10                	mov    %edx,(%eax)

	return bn & 0x1f;
    1b46:	89 c8                	mov    %ecx,%eax
}
    1b48:	5b                   	pop    %ebx
	return bn & 0x1f;
    1b49:	83 e0 1f             	and    $0x1f,%eax
}
    1b4c:	5e                   	pop    %esi
    1b4d:	5d                   	pop    %ebp
    1b4e:	c3                   	ret    

00001b4f <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
    1b4f:	55                   	push   %ebp
    1b50:	89 e5                	mov    %esp,%ebp
    1b52:	53                   	push   %ebx
    1b53:	53                   	push   %ebx
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
    1b54:	8d 5d f8             	lea    -0x8(%ebp),%ebx
    1b57:	53                   	push   %ebx
    1b58:	e8 c2 ff ff ff       	call   1b1f <get_bit_ptr>
    1b5d:	5a                   	pop    %edx

	*word |= (1<<bit);
    1b5e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1b61:	ba 01 00 00 00       	mov    $0x1,%edx
    1b66:	88 c1                	mov    %al,%cl
    1b68:	d3 e2                	shl    %cl,%edx
    1b6a:	09 13                	or     %edx,(%ebx)
}
    1b6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1b6f:	c9                   	leave  
    1b70:	c3                   	ret    

00001b71 <clear_free_bit>:

static void clear_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
    1b71:	55                   	push   %ebp
    1b72:	89 e5                	mov    %esp,%ebp
    1b74:	53                   	push   %ebx
    1b75:	53                   	push   %ebx
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
    1b76:	8d 5d f8             	lea    -0x8(%ebp),%ebx
    1b79:	53                   	push   %ebx
    1b7a:	e8 a0 ff ff ff       	call   1b1f <get_bit_ptr>
    1b7f:	5a                   	pop    %edx

	*word &= ~(1<<bit);
    1b80:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1b83:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    1b88:	88 c1                	mov    %al,%cl
    1b8a:	d3 c2                	rol    %cl,%edx
    1b8c:	21 13                	and    %edx,(%ebx)
}
    1b8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1b91:	c9                   	leave  
    1b92:	c3                   	ret    

00001b93 <pool_irq_lock.isra.2.part.3>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
    1b93:	9c                   	pushf  
    1b94:	fa                   	cli    
    1b95:	58                   	pop    %eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
    1b96:	c3                   	ret    

00001b97 <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1b97:	a8 01                	test   $0x1,%al
    1b99:	74 07                	je     1ba2 <pool_irq_unlock.isra.4+0xb>
 *
 */

static ALWAYS_INLINE void z_arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
    1b9b:	0f ba e2 09          	bt     $0x9,%edx
    1b9f:	73 01                	jae    1ba2 <pool_irq_unlock.isra.4+0xb>
 * @return N/A
 */

static ALWAYS_INLINE void z_do_irq_unlock(void)
{
	__asm__ volatile (
    1ba1:	fb                   	sti    
		irq_unlock(key);
	}
}
    1ba2:	c3                   	ret    

00001ba3 <z_sys_mem_pool_base_init>:
{
    1ba3:	55                   	push   %ebp
	for (i = 0; i < p->n_levels; i++) {
    1ba4:	31 c9                	xor    %ecx,%ecx
{
    1ba6:	89 e5                	mov    %esp,%ebp
    1ba8:	57                   	push   %edi
    1ba9:	56                   	push   %esi
    1baa:	53                   	push   %ebx
    1bab:	83 ec 0c             	sub    $0xc,%esp
    1bae:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    1bb1:	8b 43 04             	mov    0x4(%ebx),%eax
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    1bb4:	8b 33                	mov    (%ebx),%esi
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    1bb6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	p->max_inline_level = -1;
    1bb9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    1bbd:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    1bc1:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    1bc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    1bc8:	01 c6                	add    %eax,%esi
	for (i = 0; i < p->n_levels; i++) {
    1bca:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
    1bce:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1bd1:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    1bd4:	7e 43                	jle    1c19 <z_sys_mem_pool_base_init+0x76>
		int nblocks = buflen / sz;
    1bd6:	31 d2                	xor    %edx,%edx
    1bd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bdb:	f7 75 f0             	divl   -0x10(%ebp)
		sys_dlist_init(&p->levels[i].free_list);
    1bde:	6b d1 0c             	imul   $0xc,%ecx,%edx
    1be1:	03 53 0c             	add    0xc(%ebx),%edx
		if (nblocks < 32) {
    1be4:	83 f8 1f             	cmp    $0x1f,%eax
		sys_dlist_init(&p->levels[i].free_list);
    1be7:	8d 7a 04             	lea    0x4(%edx),%edi
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    1bea:	89 7a 04             	mov    %edi,0x4(%edx)
	list->tail = (sys_dnode_t *)list;
    1bed:	89 7a 08             	mov    %edi,0x8(%edx)
		if (nblocks < 32) {
    1bf0:	7f 05                	jg     1bf7 <z_sys_mem_pool_base_init+0x54>
			p->max_inline_level = i;
    1bf2:	88 4b 0b             	mov    %cl,0xb(%ebx)
    1bf5:	eb 10                	jmp    1c07 <z_sys_mem_pool_base_init+0x64>
			bits += (nblocks + 31)/32;
    1bf7:	83 c0 1f             	add    $0x1f,%eax
			p->levels[i].bits_p = bits;
    1bfa:	89 32                	mov    %esi,(%edx)
			bits += (nblocks + 31)/32;
    1bfc:	bf 20 00 00 00       	mov    $0x20,%edi
    1c01:	99                   	cltd   
    1c02:	f7 ff                	idiv   %edi
    1c04:	8d 34 86             	lea    (%esi,%eax,4),%esi
		sz = _ALIGN4(sz / 4);
    1c07:	8b 45 f0             	mov    -0x10(%ebp),%eax
	for (i = 0; i < p->n_levels; i++) {
    1c0a:	41                   	inc    %ecx
		sz = _ALIGN4(sz / 4);
    1c0b:	c1 e8 02             	shr    $0x2,%eax
    1c0e:	83 c0 03             	add    $0x3,%eax
    1c11:	83 e0 fc             	and    $0xfffffffc,%eax
    1c14:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1c17:	eb b8                	jmp    1bd1 <z_sys_mem_pool_base_init+0x2e>
	for (i = 0; i < p->n_max; i++) {
    1c19:	31 f6                	xor    %esi,%esi
    1c1b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    1c1f:	39 f0                	cmp    %esi,%eax
    1c21:	7e 2c                	jle    1c4f <z_sys_mem_pool_base_init+0xac>
	return (u8_t *)p->buf + lsz * block;
    1c23:	8b 43 04             	mov    0x4(%ebx),%eax
		sys_dlist_append(&p->levels[0].free_list, block);
    1c26:	8b 53 0c             	mov    0xc(%ebx),%edx
	return (u8_t *)p->buf + lsz * block;
    1c29:	0f af c6             	imul   %esi,%eax
    1c2c:	03 03                	add    (%ebx),%eax
		sys_dlist_append(&p->levels[0].free_list, block);
    1c2e:	8d 4a 04             	lea    0x4(%edx),%ecx
    1c31:	89 08                	mov    %ecx,(%eax)
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
    1c33:	8b 4a 08             	mov    0x8(%edx),%ecx
    1c36:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
    1c39:	8b 4a 08             	mov    0x8(%edx),%ecx
    1c3c:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
    1c3e:	89 42 08             	mov    %eax,0x8(%edx)
		set_free_bit(p, 0, i);
    1c41:	89 f1                	mov    %esi,%ecx
    1c43:	31 d2                	xor    %edx,%edx
    1c45:	89 d8                	mov    %ebx,%eax
	for (i = 0; i < p->n_max; i++) {
    1c47:	46                   	inc    %esi
		set_free_bit(p, 0, i);
    1c48:	e8 02 ff ff ff       	call   1b4f <set_free_bit>
    1c4d:	eb cc                	jmp    1c1b <z_sys_mem_pool_base_init+0x78>
}
    1c4f:	83 c4 0c             	add    $0xc,%esp
    1c52:	5b                   	pop    %ebx
    1c53:	5e                   	pop    %esi
    1c54:	5f                   	pop    %edi
    1c55:	5d                   	pop    %ebp
    1c56:	c3                   	ret    

00001c57 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
    1c57:	55                   	push   %ebp
    1c58:	89 e5                	mov    %esp,%ebp
    1c5a:	57                   	push   %edi
    1c5b:	56                   	push   %esi
    1c5c:	53                   	push   %ebx
    1c5d:	83 ec 20             	sub    $0x20,%esp
    1c60:	8b 5d 08             	mov    0x8(%ebp),%ebx
    1c63:	8b 75 0c             	mov    0xc(%ebp),%esi
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    1c66:	0f b6 4b 0a          	movzbl 0xa(%ebx),%ecx
    1c6a:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
    1c71:	29 c4                	sub    %eax,%esp
    1c73:	8d 54 24 03          	lea    0x3(%esp),%edx
    1c77:	c1 ea 02             	shr    $0x2,%edx
    1c7a:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
    1c81:	89 45 f0             	mov    %eax,-0x10(%ebp)
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = _ALIGN4(p->max_sz);
    1c84:	8b 43 04             	mov    0x4(%ebx),%eax
    1c87:	83 c0 03             	add    $0x3,%eax
    1c8a:	83 e0 fc             	and    $0xfffffffc,%eax
    1c8d:	89 04 95 00 00 00 00 	mov    %eax,0x0(,%edx,4)
	for (i = 0; i < p->n_levels; i++) {
    1c94:	31 c0                	xor    %eax,%eax
    1c96:	8d 78 ff             	lea    -0x1(%eax),%edi
    1c99:	39 c1                	cmp    %eax,%ecx
    1c9b:	89 7d ec             	mov    %edi,-0x14(%ebp)
    1c9e:	7e 27                	jle    1cc7 <z_sys_mem_pool_block_alloc+0x70>
		if (i > 0) {
    1ca0:	85 c0                	test   %eax,%eax
    1ca2:	74 1b                	je     1cbf <z_sys_mem_pool_block_alloc+0x68>
			lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
    1ca4:	8b 7d f0             	mov    -0x10(%ebp),%edi
    1ca7:	8b 7c 87 fc          	mov    -0x4(%edi,%eax,4),%edi
    1cab:	89 fa                	mov    %edi,%edx
    1cad:	89 7d e8             	mov    %edi,-0x18(%ebp)
    1cb0:	c1 ea 02             	shr    $0x2,%edx
    1cb3:	8b 7d f0             	mov    -0x10(%ebp),%edi
    1cb6:	83 c2 03             	add    $0x3,%edx
    1cb9:	83 e2 fc             	and    $0xfffffffc,%edx
    1cbc:	89 14 87             	mov    %edx,(%edi,%eax,4)
		}

		if (lsizes[i] < size) {
    1cbf:	8b 7d f0             	mov    -0x10(%ebp),%edi
    1cc2:	39 34 87             	cmp    %esi,(%edi,%eax,4)
    1cc5:	73 19                	jae    1ce0 <z_sys_mem_pool_block_alloc+0x89>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
    1cc7:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
    1ccb:	75 16                	jne    1ce3 <z_sys_mem_pool_block_alloc+0x8c>
		*data_p = NULL;
    1ccd:	8b 45 18             	mov    0x18(%ebp),%eax
    1cd0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -ENOMEM;
    1cd6:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    1cdb:	e9 4f 01 00 00       	jmp    1e2f <z_sys_mem_pool_block_alloc+0x1d8>
	for (i = 0; i < p->n_levels; i++) {
    1ce0:	40                   	inc    %eax
    1ce1:	eb b3                	jmp    1c96 <z_sys_mem_pool_block_alloc+0x3f>
		return 0;
    1ce3:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1ce5:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    1ce9:	74 05                	je     1cf0 <z_sys_mem_pool_block_alloc+0x99>
    1ceb:	e8 a3 fe ff ff       	call   1b93 <pool_irq_lock.isra.2.part.3>
	 * its the three unused children needs to be performed
	 * atomically, otherwise we open up a situation where we can
	 * "steal" the top level block of the whole heap, causing a
	 * spurious -ENOMEM.
	 */
	key = pool_irq_lock(p);
    1cf0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (i = alloc_l; i >= 0; i--) {
    1cf3:	8b 53 0c             	mov    0xc(%ebx),%edx
    1cf6:	6b 45 ec 0c          	imul   $0xc,-0x14(%ebp),%eax
	block = sys_dlist_get(&p->levels[l].free_list);
    1cfa:	8b 75 ec             	mov    -0x14(%ebp),%esi
    1cfd:	8d 44 02 04          	lea    0x4(%edx,%eax,1),%eax
	return list->head == list;
    1d01:	8b 38                	mov    (%eax),%edi

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    1d03:	39 c7                	cmp    %eax,%edi
    1d05:	0f 84 e2 00 00 00    	je     1ded <z_sys_mem_pool_block_alloc+0x196>
	node->prev->next = node->next;
    1d0b:	8b 57 04             	mov    0x4(%edi),%edx
    1d0e:	8b 07                	mov    (%edi),%eax
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    1d10:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1d13:	89 02                	mov    %eax,(%edx)
	node->next->prev = node->prev;
    1d15:	89 50 04             	mov    %edx,0x4(%eax)
	node->next = NULL;
    1d18:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	node->prev = NULL;
    1d1e:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
    1d25:	89 f8                	mov    %edi,%eax
    1d27:	2b 03                	sub    (%ebx),%eax
    1d29:	99                   	cltd   
    1d2a:	f7 3c b1             	idivl  (%ecx,%esi,4)
		clear_free_bit(p, l, block_num(p, block, lsz));
    1d2d:	89 c1                	mov    %eax,%ecx
    1d2f:	89 f2                	mov    %esi,%edx
    1d31:	89 d8                	mov    %ebx,%eax
    1d33:	e8 39 fe ff ff       	call   1b71 <clear_free_bit>
		/* Found one.  Iteratively break it down to the size
		 * we need.  Note that we relax the lock to allow a
		 * pending interrupt to fire so we don't hurt latency
		 * by locking the full loop.
		 */
		if (data != NULL) {
    1d38:	8d 46 01             	lea    0x1(%esi),%eax
    1d3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for (from_l = i; from_l < alloc_l; from_l++) {
    1d3e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    1d41:	8a 43 10             	mov    0x10(%ebx),%al
    1d44:	8d 51 ff             	lea    -0x1(%ecx),%edx
    1d47:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    1d4a:	0f 8e ac 00 00 00    	jle    1dfc <z_sys_mem_pool_block_alloc+0x1a5>
				pool_irq_unlock(p, key);
    1d50:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1d53:	e8 3f fe ff ff       	call   1b97 <pool_irq_unlock.isra.4>
		return 0;
    1d58:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1d5a:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    1d5e:	74 05                	je     1d65 <z_sys_mem_pool_block_alloc+0x10e>
    1d60:	e8 2e fe ff ff       	call   1b93 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
    1d65:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    1d68:	89 f8                	mov    %edi,%eax
    1d6a:	2b 03                	sub    (%ebx),%eax
    1d6c:	8b 75 e8             	mov    -0x18(%ebp),%esi
    1d6f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	for (i = 1; i < 4; i++) {
    1d72:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    1d79:	99                   	cltd   
    1d7a:	f7 7c b1 fc          	idivl  -0x4(%ecx,%esi,4)
		int lbn = 4*bn + i;
    1d7e:	c1 e0 02             	shl    $0x2,%eax
    1d81:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1d84:	6b c6 0c             	imul   $0xc,%esi,%eax
    1d87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		int lsz = lsizes[l + 1];
    1d8a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    1d8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
		void *block2 = (lsz * i) + (char *)block;
    1d90:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		set_free_bit(p, l + 1, lbn);
    1d93:	8b 55 e8             	mov    -0x18(%ebp),%edx
		int lsz = lsizes[l + 1];
    1d96:	8b 04 88             	mov    (%eax,%ecx,4),%eax
		set_free_bit(p, l + 1, lbn);
    1d99:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		void *block2 = (lsz * i) + (char *)block;
    1d9c:	0f af f0             	imul   %eax,%esi
		set_free_bit(p, l + 1, lbn);
    1d9f:	03 4d d8             	add    -0x28(%ebp),%ecx
		int lsz = lsizes[l + 1];
    1da2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		set_free_bit(p, l + 1, lbn);
    1da5:	89 d8                	mov    %ebx,%eax
		void *block2 = (lsz * i) + (char *)block;
    1da7:	01 fe                	add    %edi,%esi
		set_free_bit(p, l + 1, lbn);
    1da9:	e8 a1 fd ff ff       	call   1b4f <set_free_bit>
	return ((u8_t *)block + bsz - 1 - (u8_t *)p->buf) < buf_size(p);
    1dae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1db1:	8d 54 06 ff          	lea    -0x1(%esi,%eax,1),%edx
	return p->n_max * p->max_sz;
    1db5:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    1db9:	0f af 43 04          	imul   0x4(%ebx),%eax
	return ((u8_t *)block + bsz - 1 - (u8_t *)p->buf) < buf_size(p);
    1dbd:	2b 13                	sub    (%ebx),%edx
		if (block_fits(p, block2, lsz)) {
    1dbf:	39 c2                	cmp    %eax,%edx
    1dc1:	73 19                	jae    1ddc <z_sys_mem_pool_block_alloc+0x185>
			sys_dlist_append(&p->levels[l + 1].free_list, block2);
    1dc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    1dc6:	03 43 0c             	add    0xc(%ebx),%eax
    1dc9:	8d 50 04             	lea    0x4(%eax),%edx
    1dcc:	89 16                	mov    %edx,(%esi)
	node->prev = list->tail;
    1dce:	8b 50 08             	mov    0x8(%eax),%edx
    1dd1:	89 56 04             	mov    %edx,0x4(%esi)
	list->tail->next = node;
    1dd4:	8b 50 08             	mov    0x8(%eax),%edx
    1dd7:	89 32                	mov    %esi,(%edx)
	list->tail = node;
    1dd9:	89 70 08             	mov    %esi,0x8(%eax)
	for (i = 1; i < 4; i++) {
    1ddc:	ff 45 e4             	incl   -0x1c(%ebp)
    1ddf:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
    1de3:	75 a5                	jne    1d8a <z_sys_mem_pool_block_alloc+0x133>
    1de5:	ff 45 e8             	incl   -0x18(%ebp)
    1de8:	e9 51 ff ff ff       	jmp    1d3e <z_sys_mem_pool_block_alloc+0xe7>
	for (i = alloc_l; i >= 0; i--) {
    1ded:	4e                   	dec    %esi
    1dee:	83 e8 0c             	sub    $0xc,%eax
    1df1:	83 fe ff             	cmp    $0xffffffff,%esi
    1df4:	0f 85 07 ff ff ff    	jne    1d01 <z_sys_mem_pool_block_alloc+0xaa>
    1dfa:	31 ff                	xor    %edi,%edi
				data = block_break(p, data, from_l, lsizes);
			}
			break;
		}
	}
	pool_irq_unlock(p, key);
    1dfc:	8a 43 10             	mov    0x10(%ebx),%al
    1dff:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1e02:	e8 90 fd ff ff       	call   1b97 <pool_irq_unlock.isra.4>

	*data_p = data;
    1e07:	8b 45 18             	mov    0x18(%ebp),%eax

	if (data == NULL) {
    1e0a:	85 ff                	test   %edi,%edi
	*data_p = data;
    1e0c:	89 38                	mov    %edi,(%eax)
		return -ENOMEM;
    1e0e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (data == NULL) {
    1e13:	74 1a                	je     1e2f <z_sys_mem_pool_block_alloc+0x1d8>
	}

	*level_p = alloc_l;
    1e15:	8b 45 10             	mov    0x10(%ebp),%eax
    1e18:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    1e1b:	89 08                	mov    %ecx,(%eax)
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
    1e1d:	89 f8                	mov    %edi,%eax
    1e1f:	2b 03                	sub    (%ebx),%eax
    1e21:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    1e24:	99                   	cltd   
    1e25:	f7 3c 8b             	idivl  (%ebx,%ecx,4)
	*block_p = block_num(p, data, lsizes[alloc_l]);
    1e28:	8b 55 14             	mov    0x14(%ebp),%edx
    1e2b:	89 02                	mov    %eax,(%edx)

	return 0;
    1e2d:	31 c0                	xor    %eax,%eax
}
    1e2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1e32:	5b                   	pop    %ebx
    1e33:	5e                   	pop    %esi
    1e34:	5f                   	pop    %edi
    1e35:	5d                   	pop    %ebp
    1e36:	c3                   	ret    

00001e37 <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
    1e37:	55                   	push   %ebp
    1e38:	89 e5                	mov    %esp,%ebp
    1e3a:	57                   	push   %edi
    1e3b:	56                   	push   %esi
    1e3c:	53                   	push   %ebx
    1e3d:	83 ec 18             	sub    $0x18,%esp
    1e40:	8b 5d 08             	mov    0x8(%ebp),%ebx
    1e43:	8b 55 0c             	mov    0xc(%ebp),%edx
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    1e46:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
    1e4a:	c1 e0 02             	shl    $0x2,%eax
    1e4d:	29 c4                	sub    %eax,%esp
    1e4f:	8d 4c 24 03          	lea    0x3(%esp),%ecx
    1e53:	c1 e9 02             	shr    $0x2,%ecx
    1e56:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
    1e5d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = _ALIGN4(p->max_sz);
    1e60:	8b 43 04             	mov    0x4(%ebx),%eax
    1e63:	83 c0 03             	add    $0x3,%eax
    1e66:	83 e0 fc             	and    $0xfffffffc,%eax
    1e69:	89 04 8d 00 00 00 00 	mov    %eax,0x0(,%ecx,4)
	for (i = 1; i <= level; i++) {
    1e70:	b9 01 00 00 00       	mov    $0x1,%ecx
    1e75:	39 ca                	cmp    %ecx,%edx
    1e77:	72 1c                	jb     1e95 <z_sys_mem_pool_block_free+0x5e>
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
    1e79:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1e7c:	8b 7d dc             	mov    -0x24(%ebp),%edi
    1e7f:	8b 44 88 fc          	mov    -0x4(%eax,%ecx,4),%eax
    1e83:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1e86:	c1 e8 02             	shr    $0x2,%eax
    1e89:	83 c0 03             	add    $0x3,%eax
    1e8c:	83 e0 fc             	and    $0xfffffffc,%eax
    1e8f:	89 04 8f             	mov    %eax,(%edi,%ecx,4)
	for (i = 1; i <= level; i++) {
    1e92:	41                   	inc    %ecx
    1e93:	eb e0                	jmp    1e75 <z_sys_mem_pool_block_free+0x3e>
	}

	block_free(p, level, lsizes, block);
    1e95:	8b 45 10             	mov    0x10(%ebp),%eax
    1e98:	89 d7                	mov    %edx,%edi
    1e9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return 0;
    1e9d:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1e9f:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    1ea3:	74 05                	je     1eaa <z_sys_mem_pool_block_free+0x73>
    1ea5:	e8 e9 fc ff ff       	call   1b93 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
    1eaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	while (level >= 0) {
    1ead:	85 ff                	test   %edi,%edi
    1eaf:	0f 88 ec 00 00 00    	js     1fa1 <z_sys_mem_pool_block_free+0x16a>
		int i, lsz = lsizes[level];
    1eb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
	return (u8_t *)p->buf + lsz * block;
    1eb8:	8b 75 ec             	mov    -0x14(%ebp),%esi
		set_free_bit(p, level, bn);
    1ebb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    1ebe:	89 fa                	mov    %edi,%edx
		int i, lsz = lsizes[level];
    1ec0:	8b 04 b8             	mov    (%eax,%edi,4),%eax
	return (u8_t *)p->buf + lsz * block;
    1ec3:	0f af f0             	imul   %eax,%esi
		int i, lsz = lsizes[level];
    1ec6:	89 45 e0             	mov    %eax,-0x20(%ebp)
		set_free_bit(p, level, bn);
    1ec9:	89 d8                	mov    %ebx,%eax
	return (u8_t *)p->buf + lsz * block;
    1ecb:	03 33                	add    (%ebx),%esi
		set_free_bit(p, level, bn);
    1ecd:	e8 7d fc ff ff       	call   1b4f <set_free_bit>
		sys_dlist_append(&p->levels[level].free_list, block);
    1ed2:	6b c7 0c             	imul   $0xc,%edi,%eax
    1ed5:	03 43 0c             	add    0xc(%ebx),%eax
    1ed8:	8d 50 04             	lea    0x4(%eax),%edx
    1edb:	89 16                	mov    %edx,(%esi)
	node->prev = list->tail;
    1edd:	8b 50 08             	mov    0x8(%eax),%edx
    1ee0:	89 56 04             	mov    %edx,0x4(%esi)
	list->tail->next = node;
    1ee3:	8b 50 08             	mov    0x8(%eax),%edx
    1ee6:	89 32                	mov    %esi,(%edx)
	list->tail = node;
    1ee8:	89 70 08             	mov    %esi,0x8(%eax)
		pool_irq_unlock(p, key);
    1eeb:	8a 43 10             	mov    0x10(%ebx),%al
    1eee:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1ef1:	e8 a1 fc ff ff       	call   1b97 <pool_irq_unlock.isra.4>
		return 0;
    1ef6:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1ef8:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    1efc:	74 05                	je     1f03 <z_sys_mem_pool_block_free+0xcc>
    1efe:	e8 90 fc ff ff       	call   1b93 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
    1f03:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (level == 0 || partner_bits(p, level, bn) != 0xf) {
    1f06:	85 ff                	test   %edi,%edi
    1f08:	0f 84 9a 00 00 00    	je     1fa8 <z_sys_mem_pool_block_free+0x171>
	int bit = get_bit_ptr(p, level, bn, &word);
    1f0e:	8d 45 f0             	lea    -0x10(%ebp),%eax
    1f11:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    1f14:	50                   	push   %eax
    1f15:	89 fa                	mov    %edi,%edx
    1f17:	89 d8                	mov    %ebx,%eax
	return (*word >> (4*(bit / 4))) & 0xf;
    1f19:	be 04 00 00 00       	mov    $0x4,%esi
	int bit = get_bit_ptr(p, level, bn, &word);
    1f1e:	e8 fc fb ff ff       	call   1b1f <get_bit_ptr>
    1f23:	5a                   	pop    %edx
	return (*word >> (4*(bit / 4))) & 0xf;
    1f24:	99                   	cltd   
    1f25:	f7 fe                	idiv   %esi
    1f27:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    1f2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f31:	8b 00                	mov    (%eax),%eax
    1f33:	d3 e8                	shr    %cl,%eax
    1f35:	83 e0 0f             	and    $0xf,%eax
		if (level == 0 || partner_bits(p, level, bn) != 0xf) {
    1f38:	83 f8 0f             	cmp    $0xf,%eax
    1f3b:	75 6b                	jne    1fa8 <z_sys_mem_pool_block_free+0x171>
		for (i = 0; i < 4; i++) {
    1f3d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			int b = (bn & ~3) + i;
    1f44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	return (u8_t *)p->buf + lsz * block;
    1f47:	8b 75 e0             	mov    -0x20(%ebp),%esi
			int b = (bn & ~3) + i;
    1f4a:	83 e1 fc             	and    $0xfffffffc,%ecx
			if (block_fits(p, block_ptr(p, lsz, b), lsz)) {
    1f4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
			int b = (bn & ~3) + i;
    1f50:	03 4d e4             	add    -0x1c(%ebp),%ecx
	return (u8_t *)p->buf + lsz * block;
    1f53:	0f af f1             	imul   %ecx,%esi
			if (block_fits(p, block_ptr(p, lsz, b), lsz)) {
    1f56:	8d 54 30 ff          	lea    -0x1(%eax,%esi,1),%edx
	return p->n_max * p->max_sz;
    1f5a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    1f5e:	0f af 43 04          	imul   0x4(%ebx),%eax
			if (block_fits(p, block_ptr(p, lsz, b), lsz)) {
    1f62:	39 c2                	cmp    %eax,%edx
    1f64:	73 22                	jae    1f88 <z_sys_mem_pool_block_free+0x151>
				clear_free_bit(p, level, b);
    1f66:	89 fa                	mov    %edi,%edx
    1f68:	89 d8                	mov    %ebx,%eax
    1f6a:	e8 02 fc ff ff       	call   1b71 <clear_free_bit>
	return (u8_t *)p->buf + lsz * block;
    1f6f:	03 33                	add    (%ebx),%esi
	node->prev->next = node->next;
    1f71:	8b 56 04             	mov    0x4(%esi),%edx
    1f74:	8b 06                	mov    (%esi),%eax
    1f76:	89 02                	mov    %eax,(%edx)
	node->next->prev = node->prev;
    1f78:	89 50 04             	mov    %edx,0x4(%eax)
	node->next = NULL;
    1f7b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	node->prev = NULL;
    1f81:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
		for (i = 0; i < 4; i++) {
    1f88:	ff 45 e4             	incl   -0x1c(%ebp)
    1f8b:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
    1f8f:	75 b3                	jne    1f44 <z_sys_mem_pool_block_free+0x10d>
		bn = bn / 4;
    1f91:	8b 45 ec             	mov    -0x14(%ebp),%eax
		level = level - 1;
    1f94:	4f                   	dec    %edi
		bn = bn / 4;
    1f95:	99                   	cltd   
    1f96:	f7 7d e4             	idivl  -0x1c(%ebp)
    1f99:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1f9c:	e9 0c ff ff ff       	jmp    1ead <z_sys_mem_pool_block_free+0x76>
	return -1;
    1fa1:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
	pool_irq_unlock(p, key);
    1fa8:	8a 43 10             	mov    0x10(%ebx),%al
    1fab:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1fae:	e8 e4 fb ff ff       	call   1b97 <pool_irq_unlock.isra.4>
}
    1fb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1fb6:	5b                   	pop    %ebx
    1fb7:	5e                   	pop    %esi
    1fb8:	5f                   	pop    %edi
    1fb9:	5d                   	pop    %ebp
    1fba:	c3                   	ret    

00001fbb <set_child>:
}

static void set_child(struct rbnode *n, int side, void *val)
{
	CHECK(n);
	if (side != 0) {
    1fbb:	85 d2                	test   %edx,%edx
    1fbd:	74 04                	je     1fc3 <set_child+0x8>
		n->children[1] = val;
    1fbf:	89 48 04             	mov    %ecx,0x4(%eax)
    1fc2:	c3                   	ret    
	} else {
		uintptr_t old = (uintptr_t) n->children[0];
		uintptr_t new = (uintptr_t) val;

		n->children[0] = (void *) (new | (old & 1UL));
    1fc3:	8b 10                	mov    (%eax),%edx
    1fc5:	83 e2 01             	and    $0x1,%edx
    1fc8:	09 d1                	or     %edx,%ecx
    1fca:	89 08                	mov    %ecx,(%eax)
	}
}
    1fcc:	c3                   	ret    

00001fcd <find_and_stack>:
 * contain at least tree->max_depth entries!  Returns the number of
 * entries pushed onto the stack.
 */
static int find_and_stack(struct rbtree *tree, struct rbnode *node,
			  struct rbnode **stack)
{
    1fcd:	55                   	push   %ebp
    1fce:	89 e5                	mov    %esp,%ebp
    1fd0:	57                   	push   %edi
    1fd1:	56                   	push   %esi
    1fd2:	89 c6                	mov    %eax,%esi
    1fd4:	53                   	push   %ebx
    1fd5:	89 d7                	mov    %edx,%edi
    1fd7:	53                   	push   %ebx
	int sz = 0;

	stack[sz++] = tree->root;
    1fd8:	bb 01 00 00 00       	mov    $0x1,%ebx
    1fdd:	8b 00                	mov    (%eax),%eax
    1fdf:	89 01                	mov    %eax,(%ecx)

	while (stack[sz - 1] != node) {
    1fe1:	8b 44 99 fc          	mov    -0x4(%ecx,%ebx,4),%eax
    1fe5:	39 f8                	cmp    %edi,%eax
    1fe7:	74 2a                	je     2013 <CONFIG_SRAM_SIZE+0x17>
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
    1fe9:	50                   	push   %eax
    1fea:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1fed:	57                   	push   %edi
    1fee:	ff 56 04             	call   *0x4(%esi)
    1ff1:	5a                   	pop    %edx
	if (side != 0) {
    1ff2:	84 c0                	test   %al,%al
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
    1ff4:	59                   	pop    %ecx
		struct rbnode *ch = get_child(stack[sz - 1], side);
    1ff5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1ff8:	8b 54 99 fc          	mov    -0x4(%ecx,%ebx,4),%edx
	if (side != 0) {
    1ffc:	75 05                	jne    2003 <CONFIG_SRAM_SIZE+0x7>
		return n->children[1];
    1ffe:	8b 42 04             	mov    0x4(%edx),%eax
    2001:	eb 05                	jmp    2008 <CONFIG_SRAM_SIZE+0xc>
	uintptr_t l = (uintptr_t) n->children[0];
    2003:	8b 02                	mov    (%edx),%eax
	l &= ~1UL;
    2005:	83 e0 fe             	and    $0xfffffffe,%eax

		if (ch != NULL) {
    2008:	85 c0                	test   %eax,%eax
    200a:	74 07                	je     2013 <CONFIG_SRAM_SIZE+0x17>
			stack[sz++] = ch;
    200c:	43                   	inc    %ebx
    200d:	89 44 99 fc          	mov    %eax,-0x4(%ecx,%ebx,4)
    2011:	eb ce                	jmp    1fe1 <find_and_stack+0x14>
			break;
		}
	}

	return sz;
}
    2013:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2016:	89 d8                	mov    %ebx,%eax
    2018:	5b                   	pop    %ebx
    2019:	5e                   	pop    %esi
    201a:	5f                   	pop    %edi
    201b:	5d                   	pop    %ebp
    201c:	c3                   	ret    

0000201d <rotate>:
 *  N  c  -->  a   P
 * a b            b c
 *
 */
static void rotate(struct rbnode **stack, int stacksz)
{
    201d:	55                   	push   %ebp
	CHECK(stacksz >= 2);

	struct rbnode *parent = stack[stacksz - 2];
    201e:	8d 0c 95 f8 ff ff ff 	lea    -0x8(,%edx,4),%ecx
{
    2025:	89 e5                	mov    %esp,%ebp
    2027:	57                   	push   %edi
    2028:	56                   	push   %esi
	struct rbnode *parent = stack[stacksz - 2];
    2029:	8d 34 08             	lea    (%eax,%ecx,1),%esi
{
    202c:	53                   	push   %ebx
	struct rbnode *child = stack[stacksz - 1];
    202d:	8d 7c 08 04          	lea    0x4(%eax,%ecx,1),%edi
{
    2031:	83 ec 18             	sub    $0x18,%esp
	struct rbnode *parent = stack[stacksz - 2];
    2034:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    2037:	8b 36                	mov    (%esi),%esi
	struct rbnode *child = stack[stacksz - 1];
    2039:	8b 1f                	mov    (%edi),%ebx
{
    203b:	89 55 e8             	mov    %edx,-0x18(%ebp)
	struct rbnode *child = stack[stacksz - 1];
    203e:	89 7d e0             	mov    %edi,-0x20(%ebp)
	return get_child(parent, 1) == child ? 1 : 0;
    2041:	31 d2                	xor    %edx,%edx
	int side = get_side(parent, child);
    2043:	8b 7e 04             	mov    0x4(%esi),%edi
	return get_child(parent, 1) == child ? 1 : 0;
    2046:	39 fb                	cmp    %edi,%ebx
    2048:	0f 94 c2             	sete   %dl
    204b:	89 55 ec             	mov    %edx,-0x14(%ebp)
	if (side != 0) {
    204e:	75 05                	jne    2055 <rotate+0x38>
		return n->children[1];
    2050:	8b 53 04             	mov    0x4(%ebx),%edx
    2053:	eb 05                	jmp    205a <rotate+0x3d>
	l &= ~1UL;
    2055:	8b 13                	mov    (%ebx),%edx
    2057:	83 e2 fe             	and    $0xfffffffe,%edx
    205a:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct rbnode *a = get_child(child, side);
	struct rbnode *b = get_child(child, !side);
    205d:	31 d2                	xor    %edx,%edx
    205f:	39 fb                	cmp    %edi,%ebx
    2061:	0f 95 c2             	setne  %dl
    2064:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (side != 0) {
    2067:	74 05                	je     206e <rotate+0x51>
		return n->children[1];
    2069:	8b 7b 04             	mov    0x4(%ebx),%edi
    206c:	eb 05                	jmp    2073 <rotate+0x56>
	l &= ~1UL;
    206e:	8b 3b                	mov    (%ebx),%edi
    2070:	83 e7 fe             	and    $0xfffffffe,%edi

	if (stacksz >= 3) {
    2073:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    2077:	7e 13                	jle    208c <rotate+0x6f>
		struct rbnode *grandparent = stack[stacksz - 3];
    2079:	8b 44 08 fc          	mov    -0x4(%eax,%ecx,1),%eax
	return get_child(parent, 1) == child ? 1 : 0;
    207d:	31 d2                	xor    %edx,%edx

		set_child(grandparent, get_side(grandparent, parent), child);
    207f:	89 d9                	mov    %ebx,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
    2081:	39 70 04             	cmp    %esi,0x4(%eax)
    2084:	0f 94 c2             	sete   %dl
		set_child(grandparent, get_side(grandparent, parent), child);
    2087:	e8 2f ff ff ff       	call   1fbb <set_child>
	}

	set_child(child, side, a);
    208c:	89 d8                	mov    %ebx,%eax
    208e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2091:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2094:	e8 22 ff ff ff       	call   1fbb <set_child>
	set_child(child, !side, parent);
    2099:	89 f1                	mov    %esi,%ecx
    209b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    209e:	e8 18 ff ff ff       	call   1fbb <set_child>
	set_child(parent, side, b);
    20a3:	89 f0                	mov    %esi,%eax
    20a5:	89 f9                	mov    %edi,%ecx
    20a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    20aa:	e8 0c ff ff ff       	call   1fbb <set_child>
	stack[stacksz - 2] = child;
    20af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    20b2:	89 18                	mov    %ebx,(%eax)
	stack[stacksz - 1] = parent;
    20b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    20b7:	89 30                	mov    %esi,(%eax)
}
    20b9:	83 c4 18             	add    $0x18,%esp
    20bc:	5b                   	pop    %ebx
    20bd:	5e                   	pop    %esi
    20be:	5f                   	pop    %edi
    20bf:	5d                   	pop    %ebp
    20c0:	c3                   	ret    

000020c1 <stack_left_limb>:
 * node to iterate.  By construction node will always be a right child
 * or the root, so is_left must be false.
 */
static inline struct rbnode *stack_left_limb(struct rbnode *n,
					     struct _rb_foreach *f)
{
    20c1:	55                   	push   %ebp
	f->top++;
    20c2:	8b 4a 08             	mov    0x8(%edx),%ecx
{
    20c5:	89 e5                	mov    %esp,%ebp
    20c7:	56                   	push   %esi
    20c8:	53                   	push   %ebx
	f->stack[f->top] = n;
    20c9:	8b 32                	mov    (%edx),%esi
	f->top++;
    20cb:	8d 59 01             	lea    0x1(%ecx),%ebx
    20ce:	89 5a 08             	mov    %ebx,0x8(%edx)
	f->stack[f->top] = n;
    20d1:	89 04 9e             	mov    %eax,(%esi,%ebx,4)
	f->is_left[f->top] = 0;
    20d4:	8b 5a 04             	mov    0x4(%edx),%ebx
    20d7:	c6 44 0b 01 00       	movb   $0x0,0x1(%ebx,%ecx,1)
	uintptr_t l = (uintptr_t) n->children[0];
    20dc:	8b 00                	mov    (%eax),%eax
	return (struct rbnode *) l;
    20de:	8b 4a 08             	mov    0x8(%edx),%ecx

	while ((n = get_child(n, 0)) != NULL) {
    20e1:	83 e0 fe             	and    $0xfffffffe,%eax
    20e4:	8b 1a                	mov    (%edx),%ebx
    20e6:	74 13                	je     20fb <stack_left_limb+0x3a>
		f->top++;
    20e8:	8d 71 01             	lea    0x1(%ecx),%esi
    20eb:	89 72 08             	mov    %esi,0x8(%edx)
		f->stack[f->top] = n;
    20ee:	89 04 b3             	mov    %eax,(%ebx,%esi,4)
		f->is_left[f->top] = 1;
    20f1:	8b 5a 04             	mov    0x4(%edx),%ebx
    20f4:	c6 44 0b 01 01       	movb   $0x1,0x1(%ebx,%ecx,1)
    20f9:	eb e1                	jmp    20dc <stack_left_limb+0x1b>
	}

	return f->stack[f->top];
    20fb:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
}
    20fe:	5b                   	pop    %ebx
    20ff:	5e                   	pop    %esi
    2100:	5d                   	pop    %ebp
    2101:	c3                   	ret    

00002102 <fix_missing_black.part.2>:
static void fix_missing_black(struct rbnode **stack, int stacksz,
    2102:	55                   	push   %ebp
    2103:	89 e5                	mov    %esp,%ebp
    2105:	57                   	push   %edi
    2106:	56                   	push   %esi
    2107:	53                   	push   %ebx
    2108:	83 ec 1c             	sub    $0x1c,%esp
    210b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    210e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    2111:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	while (stacksz > 1) {
    2114:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
    2118:	0f 8e 8e 01 00 00    	jle    22ac <fix_missing_black.part.2+0x1aa>
		struct rbnode *n = stack[stacksz - 1];
    211e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2121:	8d 0c 85 fc ff ff ff 	lea    -0x4(,%eax,4),%ecx
    2128:	8b 45 ec             	mov    -0x14(%ebp),%eax
    212b:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
    212e:	8b 07                	mov    (%edi),%eax
    2130:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct rbnode *parent = stack[stacksz - 2];
    2133:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2136:	8b 74 08 fc          	mov    -0x4(%eax,%ecx,1),%esi
		int n_side = get_side(parent, n);
    213a:	8b 46 04             	mov    0x4(%esi),%eax
	return get_child(parent, 1) == child ? 1 : 0;
    213d:	89 c2                	mov    %eax,%edx
		int n_side = get_side(parent, n);
    213f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return get_child(parent, 1) == child ? 1 : 0;
    2142:	31 c0                	xor    %eax,%eax
    2144:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    2147:	0f 94 c0             	sete   %al
    214a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (side != 0) {
    214d:	89 d3                	mov    %edx,%ebx
    214f:	75 05                	jne    2156 <fix_missing_black.part.2+0x54>
	l &= ~1UL;
    2151:	8b 1e                	mov    (%esi),%ebx
    2153:	83 e3 fe             	and    $0xfffffffe,%ebx
		if (!is_black(sib)) {
    2156:	f6 03 01             	testb  $0x1,(%ebx)
    2159:	75 3a                	jne    2195 <fix_missing_black.part.2+0x93>
			rotate(stack, stacksz);
    215b:	8b 45 ec             	mov    -0x14(%ebp),%eax
			stack[stacksz - 1] = sib;
    215e:	89 1f                	mov    %ebx,(%edi)
			rotate(stack, stacksz);
    2160:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2163:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    2166:	e8 b2 fe ff ff       	call   201d <rotate>
	*p = (*p & ~1UL) | color;
    216b:	83 26 fe             	andl   $0xfffffffe,(%esi)
			stack[stacksz++] = n;
    216e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2171:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    2174:	8b 75 f0             	mov    -0x10(%ebp),%esi
	*p = (*p & ~1UL) | color;
    2177:	83 0b 01             	orl    $0x1,(%ebx)
			stack[stacksz++] = n;
    217a:	89 74 08 04          	mov    %esi,0x4(%eax,%ecx,1)
	if (side != 0) {
    217e:	8b 45 f0             	mov    -0x10(%ebp),%eax
			stack[stacksz++] = n;
    2181:	ff 45 e8             	incl   -0x18(%ebp)
			parent = stack[stacksz - 2];
    2184:	8b 37                	mov    (%edi),%esi
	if (side != 0) {
    2186:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    2189:	74 05                	je     2190 <fix_missing_black.part.2+0x8e>
		return n->children[1];
    218b:	8b 5e 04             	mov    0x4(%esi),%ebx
    218e:	eb 05                	jmp    2195 <fix_missing_black.part.2+0x93>
	l &= ~1UL;
    2190:	8b 1e                	mov    (%esi),%ebx
    2192:	83 e3 fe             	and    $0xfffffffe,%ebx
    2195:	8b 03                	mov    (%ebx),%eax
		return n->children[1];
    2197:	8b 53 04             	mov    0x4(%ebx),%edx
	l &= ~1UL;
    219a:	83 e0 fe             	and    $0xfffffffe,%eax
    219d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return (struct rbnode *) l;
    21a0:	89 c7                	mov    %eax,%edi
		if ((!c0 || is_black(c0)) && (!c1 || is_black(c1))) {
    21a2:	74 09                	je     21ad <fix_missing_black.part.2+0xab>
    21a4:	f6 00 01             	testb  $0x1,(%eax)
    21a7:	0f 84 ef 00 00 00    	je     229c <fix_missing_black.part.2+0x19a>
    21ad:	85 d2                	test   %edx,%edx
    21af:	74 05                	je     21b6 <fix_missing_black.part.2+0xb4>
    21b1:	f6 02 01             	testb  $0x1,(%edx)
    21b4:	74 2f                	je     21e5 <fix_missing_black.part.2+0xe3>
			if (n == null_node) {
    21b6:	8b 7d d8             	mov    -0x28(%ebp),%edi
    21b9:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    21bc:	75 0c                	jne    21ca <fix_missing_black.part.2+0xc8>
				set_child(parent, n_side, NULL);
    21be:	31 c9                	xor    %ecx,%ecx
    21c0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    21c3:	89 f0                	mov    %esi,%eax
    21c5:	e8 f1 fd ff ff       	call   1fbb <set_child>
	return ((uintptr_t)n->children[0]) & 1UL;
    21ca:	8b 06                	mov    (%esi),%eax
	*p = (*p & ~1UL) | color;
    21cc:	83 23 fe             	andl   $0xfffffffe,(%ebx)
			if (is_black(parent)) {
    21cf:	a8 01                	test   $0x1,%al
    21d1:	74 08                	je     21db <fix_missing_black.part.2+0xd9>
				stacksz--;
    21d3:	ff 4d e8             	decl   -0x18(%ebp)
    21d6:	e9 39 ff ff ff       	jmp    2114 <fix_missing_black.part.2+0x12>
	*p = (*p & ~1UL) | color;
    21db:	83 c8 01             	or     $0x1,%eax
    21de:	89 06                	mov    %eax,(%esi)
				return;
    21e0:	e9 c7 00 00 00       	jmp    22ac <fix_missing_black.part.2+0x1aa>
	if (side != 0) {
    21e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    21e8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    21eb:	0f 84 9b 00 00 00    	je     228c <fix_missing_black.part.2+0x18a>
		return n->children[1];
    21f1:	89 d0                	mov    %edx,%eax
		if (!(outer && is_red(outer))) {
    21f3:	f6 00 01             	testb  $0x1,(%eax)
    21f6:	74 54                	je     224c <fix_missing_black.part.2+0x14a>
	if (side != 0) {
    21f8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    21fb:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
    21fe:	75 02                	jne    2202 <fix_missing_black.part.2+0x100>
    2200:	89 d7                	mov    %edx,%edi
			stack[stacksz - 1] = sib;
    2202:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2205:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2208:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
    220f:	01 c1                	add    %eax,%ecx
    2211:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    2214:	89 19                	mov    %ebx,(%ecx)
			stack[stacksz++] = inner;
    2216:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2219:	89 7c 01 04          	mov    %edi,0x4(%ecx,%eax,1)
    221d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2220:	8d 50 01             	lea    0x1(%eax),%edx
			rotate(stack, stacksz);
    2223:	89 c8                	mov    %ecx,%eax
    2225:	e8 f3 fd ff ff       	call   201d <rotate>
	*p = (*p & ~1UL) | color;
    222a:	83 23 fe             	andl   $0xfffffffe,(%ebx)
			sib = stack[stacksz - 2];
    222d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
	*p = (*p & ~1UL) | color;
    2230:	83 0f 01             	orl    $0x1,(%edi)
	if (side != 0) {
    2233:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			sib = stack[stacksz - 2];
    2236:	8b 19                	mov    (%ecx),%ebx
	if (side != 0) {
    2238:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    223b:	74 05                	je     2242 <fix_missing_black.part.2+0x140>
		return n->children[1];
    223d:	8b 43 04             	mov    0x4(%ebx),%eax
    2240:	eb 05                	jmp    2247 <fix_missing_black.part.2+0x145>
	l &= ~1UL;
    2242:	8b 03                	mov    (%ebx),%eax
    2244:	83 e0 fe             	and    $0xfffffffe,%eax
			stack[stacksz - 2] = n;
    2247:	8b 7d f0             	mov    -0x10(%ebp),%edi
    224a:	89 39                	mov    %edi,(%ecx)
	return ((uintptr_t)n->children[0]) & 1UL;
    224c:	8b 16                	mov    (%esi),%edx
	*p = (*p & ~1UL) | color;
    224e:	8b 0b                	mov    (%ebx),%ecx
    2250:	83 e1 fe             	and    $0xfffffffe,%ecx
	return ((uintptr_t)n->children[0]) & 1UL;
    2253:	83 e2 01             	and    $0x1,%edx
	*p = (*p & ~1UL) | color;
    2256:	09 ca                	or     %ecx,%edx
		stack[stacksz - 1] = sib;
    2258:	8b 7d e8             	mov    -0x18(%ebp),%edi
	*p = (*p & ~1UL) | color;
    225b:	89 13                	mov    %edx,(%ebx)
		rotate(stack, stacksz);
    225d:	89 fa                	mov    %edi,%edx
	*p = (*p & ~1UL) | color;
    225f:	83 0e 01             	orl    $0x1,(%esi)
    2262:	83 08 01             	orl    $0x1,(%eax)
		stack[stacksz - 1] = sib;
    2265:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2268:	89 5c b8 fc          	mov    %ebx,-0x4(%eax,%edi,4)
		rotate(stack, stacksz);
    226c:	e8 ac fd ff ff       	call   201d <rotate>
		if (n == null_node) {
    2271:	8b 7d d8             	mov    -0x28(%ebp),%edi
    2274:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    2277:	75 33                	jne    22ac <fix_missing_black.part.2+0x1aa>
			set_child(parent, n_side, NULL);
    2279:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
    227c:	83 c4 1c             	add    $0x1c,%esp
			set_child(parent, n_side, NULL);
    227f:	89 f0                	mov    %esi,%eax
    2281:	31 c9                	xor    %ecx,%ecx
}
    2283:	5b                   	pop    %ebx
    2284:	5e                   	pop    %esi
    2285:	5f                   	pop    %edi
    2286:	5d                   	pop    %ebp
			set_child(parent, n_side, NULL);
    2287:	e9 2f fd ff ff       	jmp    1fbb <set_child>
	return (struct rbnode *) l;
    228c:	8b 45 e0             	mov    -0x20(%ebp),%eax
		if (!(outer && is_red(outer))) {
    228f:	85 c0                	test   %eax,%eax
    2291:	0f 84 61 ff ff ff    	je     21f8 <fix_missing_black.part.2+0xf6>
    2297:	e9 57 ff ff ff       	jmp    21f3 <fix_missing_black.part.2+0xf1>
	if (side != 0) {
    229c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    229f:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
    22a2:	0f 84 4b ff ff ff    	je     21f3 <fix_missing_black.part.2+0xf1>
		return n->children[1];
    22a8:	89 d0                	mov    %edx,%eax
    22aa:	eb e3                	jmp    228f <fix_missing_black.part.2+0x18d>
}
    22ac:	83 c4 1c             	add    $0x1c,%esp
    22af:	5b                   	pop    %ebx
    22b0:	5e                   	pop    %esi
    22b1:	5f                   	pop    %edi
    22b2:	5d                   	pop    %ebp
    22b3:	c3                   	ret    

000022b4 <z_rb_get_minmax>:
{
    22b4:	55                   	push   %ebp
    22b5:	89 e5                	mov    %esp,%ebp
	for (n = tree->root; n && get_child(n, side); n = get_child(n, side)) {
    22b7:	8b 45 08             	mov    0x8(%ebp),%eax
{
    22ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	for (n = tree->root; n && get_child(n, side); n = get_child(n, side)) {
    22bd:	8b 00                	mov    (%eax),%eax
    22bf:	85 c0                	test   %eax,%eax
    22c1:	74 16                	je     22d9 <z_rb_get_minmax+0x25>
	if (side != 0) {
    22c3:	85 c9                	test   %ecx,%ecx
    22c5:	74 05                	je     22cc <z_rb_get_minmax+0x18>
		return n->children[1];
    22c7:	8b 50 04             	mov    0x4(%eax),%edx
    22ca:	eb 05                	jmp    22d1 <z_rb_get_minmax+0x1d>
	l &= ~1UL;
    22cc:	8b 10                	mov    (%eax),%edx
    22ce:	83 e2 fe             	and    $0xfffffffe,%edx
	for (n = tree->root; n && get_child(n, side); n = get_child(n, side)) {
    22d1:	85 d2                	test   %edx,%edx
    22d3:	74 04                	je     22d9 <z_rb_get_minmax+0x25>
    22d5:	89 d0                	mov    %edx,%eax
    22d7:	eb e6                	jmp    22bf <z_rb_get_minmax+0xb>
}
    22d9:	5d                   	pop    %ebp
    22da:	c3                   	ret    

000022db <rb_insert>:
{
    22db:	55                   	push   %ebp
    22dc:	89 e5                	mov    %esp,%ebp
    22de:	57                   	push   %edi
    22df:	56                   	push   %esi
    22e0:	53                   	push   %ebx
    22e1:	83 ec 1c             	sub    $0x1c,%esp
    22e4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    22e7:	8b 7d 08             	mov    0x8(%ebp),%edi
		n->children[0] = (void *) (new | (old & 1UL));
    22ea:	83 23 01             	andl   $0x1,(%ebx)
		n->children[1] = val;
    22ed:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	if (!tree->root) {
    22f4:	83 3f 00             	cmpl   $0x0,(%edi)
    22f7:	75 11                	jne    230a <rb_insert+0x2f>
		tree->max_depth = 1;
    22f9:	c7 47 08 01 00 00 00 	movl   $0x1,0x8(%edi)
		tree->root = node;
    2300:	89 1f                	mov    %ebx,(%edi)
	*p = (*p & ~1UL) | color;
    2302:	83 0b 01             	orl    $0x1,(%ebx)
		return;
    2305:	e9 0c 01 00 00       	jmp    2416 <rb_insert+0x13b>
    230a:	89 e0                	mov    %esp,%eax
	int stacksz = find_and_stack(tree, node, stack);
    230c:	89 da                	mov    %ebx,%edx
    230e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	struct rbnode *stack[tree->max_depth + 1];
    2311:	8b 47 08             	mov    0x8(%edi),%eax
    2314:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
    231b:	29 c4                	sub    %eax,%esp
    231d:	8d 44 24 03          	lea    0x3(%esp),%eax
    2321:	c1 e8 02             	shr    $0x2,%eax
    2324:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2327:	c1 e0 02             	shl    $0x2,%eax
	int stacksz = find_and_stack(tree, node, stack);
    232a:	89 c1                	mov    %eax,%ecx
	struct rbnode *stack[tree->max_depth + 1];
    232c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int stacksz = find_and_stack(tree, node, stack);
    232f:	89 f8                	mov    %edi,%eax
    2331:	e8 97 fc ff ff       	call   1fcd <find_and_stack>
    2336:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct rbnode *parent = stack[stacksz - 1];
    2339:	8b 45 f0             	mov    -0x10(%ebp),%eax
    233c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    233f:	8d 34 88             	lea    (%eax,%ecx,4),%esi
    2342:	8b 46 fc             	mov    -0x4(%esi),%eax
    2345:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
    2348:	50                   	push   %eax
    2349:	53                   	push   %ebx
    234a:	ff 57 04             	call   *0x4(%edi)
    234d:	5a                   	pop    %edx
    234e:	83 f0 01             	xor    $0x1,%eax
    2351:	59                   	pop    %ecx
	set_child(parent, side, node);
    2352:	89 d9                	mov    %ebx,%ecx
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
    2354:	0f b6 d0             	movzbl %al,%edx
	set_child(parent, side, node);
    2357:	8b 45 e8             	mov    -0x18(%ebp),%eax
    235a:	e8 5c fc ff ff       	call   1fbb <set_child>
	stack[stacksz++] = node;
    235f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2362:	40                   	inc    %eax
	*p = (*p & ~1UL) | color;
    2363:	83 23 fe             	andl   $0xfffffffe,(%ebx)
	stack[stacksz++] = node;
    2366:	89 1e                	mov    %ebx,(%esi)
    2368:	89 45 ec             	mov    %eax,-0x14(%ebp)
    236b:	89 c3                	mov    %eax,%ebx
	while (stacksz > 1) {
    236d:	83 fb 01             	cmp    $0x1,%ebx
    2370:	7e 7d                	jle    23ef <rb_insert+0x114>
		struct rbnode *parent = stack[stacksz - 2];
    2372:	8b 56 fc             	mov    -0x4(%esi),%edx
	return ((uintptr_t)n->children[0]) & 1UL;
    2375:	8d 46 fc             	lea    -0x4(%esi),%eax
    2378:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (is_black(parent)) {
    237b:	f6 02 01             	testb  $0x1,(%edx)
    237e:	75 7c                	jne    23fc <rb_insert+0x121>
		struct rbnode *grandparent = stack[stacksz - 3];
    2380:	8b 4e f8             	mov    -0x8(%esi),%ecx
		int side = get_side(grandparent, parent);
    2383:	8d 46 f8             	lea    -0x8(%esi),%eax
    2386:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2389:	8b 41 04             	mov    0x4(%ecx),%eax
    238c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (side != 0) {
    238f:	39 c2                	cmp    %eax,%edx
    2391:	75 05                	jne    2398 <rb_insert+0xbd>
	l &= ~1UL;
    2393:	8b 01                	mov    (%ecx),%eax
    2395:	83 e0 fe             	and    $0xfffffffe,%eax
		if ((aunt != NULL) && is_red(aunt)) {
    2398:	85 c0                	test   %eax,%eax
    239a:	74 16                	je     23b2 <rb_insert+0xd7>
	return ((uintptr_t)n->children[0]) & 1UL;
    239c:	83 ee 08             	sub    $0x8,%esi
		if ((aunt != NULL) && is_red(aunt)) {
    239f:	f6 00 01             	testb  $0x1,(%eax)
    23a2:	75 0e                	jne    23b2 <rb_insert+0xd7>
	*p = (*p & ~1UL) | color;
    23a4:	83 21 fe             	andl   $0xfffffffe,(%ecx)
			stacksz -= 2;
    23a7:	83 eb 02             	sub    $0x2,%ebx
	*p = (*p & ~1UL) | color;
    23aa:	83 0a 01             	orl    $0x1,(%edx)
    23ad:	83 08 01             	orl    $0x1,(%eax)
			continue;
    23b0:	eb bb                	jmp    236d <rb_insert+0x92>
	return get_child(parent, 1) == child ? 1 : 0;
    23b2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    23b5:	8b 72 04             	mov    0x4(%edx),%esi
    23b8:	3b 55 e8             	cmp    -0x18(%ebp),%edx
    23bb:	0f 94 c0             	sete   %al
    23be:	39 74 99 fc          	cmp    %esi,-0x4(%ecx,%ebx,4)
    23c2:	0f 94 c2             	sete   %dl
		if (parent_side != side) {
    23c5:	38 d0                	cmp    %dl,%al
    23c7:	74 09                	je     23d2 <rb_insert+0xf7>
			rotate(stack, stacksz);
    23c9:	89 da                	mov    %ebx,%edx
    23cb:	89 c8                	mov    %ecx,%eax
    23cd:	e8 4b fc ff ff       	call   201d <rotate>
		rotate(stack, stacksz - 1);
    23d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23d5:	8d 53 ff             	lea    -0x1(%ebx),%edx
    23d8:	e8 40 fc ff ff       	call   201d <rotate>
		set_color(stack[stacksz - 3], BLACK);
    23dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    23e0:	8b 00                	mov    (%eax),%eax
	*p = (*p & ~1UL) | color;
    23e2:	83 08 01             	orl    $0x1,(%eax)
		set_color(stack[stacksz - 2], RED);
    23e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    23e8:	8b 00                	mov    (%eax),%eax
	*p = (*p & ~1UL) | color;
    23ea:	83 20 fe             	andl   $0xfffffffe,(%eax)
    23ed:	eb 0d                	jmp    23fc <rb_insert+0x121>
	set_color(stack[0], BLACK);
    23ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    23f2:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
	*p = (*p & ~1UL) | color;
    23f9:	83 08 01             	orl    $0x1,(%eax)
	if (stacksz > tree->max_depth) {
    23fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23ff:	39 47 08             	cmp    %eax,0x8(%edi)
    2402:	7d 03                	jge    2407 <rb_insert+0x12c>
		tree->max_depth = stacksz;
    2404:	89 47 08             	mov    %eax,0x8(%edi)
	tree->root = stack[0];
    2407:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    240a:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
    2411:	89 07                	mov    %eax,(%edi)
	CHECK(is_black(tree->root));
    2413:	8b 65 d8             	mov    -0x28(%ebp),%esp
}
    2416:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2419:	5b                   	pop    %ebx
    241a:	5e                   	pop    %esi
    241b:	5f                   	pop    %edi
    241c:	5d                   	pop    %ebp
    241d:	c3                   	ret    

0000241e <rb_remove>:
{
    241e:	55                   	push   %ebp
    241f:	89 e5                	mov    %esp,%ebp
    2421:	57                   	push   %edi
    2422:	56                   	push   %esi
    2423:	53                   	push   %ebx
    2424:	83 ec 18             	sub    $0x18,%esp
	struct rbnode *stack[tree->max_depth + 1];
    2427:	8b 45 08             	mov    0x8(%ebp),%eax
{
    242a:	89 65 e0             	mov    %esp,-0x20(%ebp)
    242d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct rbnode *stack[tree->max_depth + 1];
    2430:	8b 40 08             	mov    0x8(%eax),%eax
	int stacksz = find_and_stack(tree, node, stack);
    2433:	89 da                	mov    %ebx,%edx
	struct rbnode *stack[tree->max_depth + 1];
    2435:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
    243c:	29 c4                	sub    %eax,%esp
    243e:	8d 44 24 03          	lea    0x3(%esp),%eax
    2442:	c1 e8 02             	shr    $0x2,%eax
    2445:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2448:	c1 e0 02             	shl    $0x2,%eax
    244b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int stacksz = find_and_stack(tree, node, stack);
    244e:	89 c1                	mov    %eax,%ecx
    2450:	8b 45 08             	mov    0x8(%ebp),%eax
    2453:	e8 75 fb ff ff       	call   1fcd <find_and_stack>
    2458:	89 c7                	mov    %eax,%edi
	if (node != stack[stacksz - 1]) {
    245a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    245d:	8d 04 b8             	lea    (%eax,%edi,4),%eax
    2460:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2463:	39 58 fc             	cmp    %ebx,-0x4(%eax)
    2466:	0f 85 81 01 00 00    	jne    25ed <rb_remove+0x1cf>
	if (get_child(node, 0) && get_child(node, 1)) {
    246c:	8b 33                	mov    (%ebx),%esi
    246e:	83 e6 fe             	and    $0xfffffffe,%esi
    2471:	0f 84 e4 00 00 00    	je     255b <rb_remove+0x13d>
    2477:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    247b:	0f 84 da 00 00 00    	je     255b <rb_remove+0x13d>
		hiparent = stacksz > 1 ? stack[stacksz - 2] : NULL;
    2481:	31 c0                	xor    %eax,%eax
    2483:	83 ff 01             	cmp    $0x1,%edi
    2486:	7e 06                	jle    248e <rb_remove+0x70>
    2488:	8b 45 ec             	mov    -0x14(%ebp),%eax
    248b:	8b 40 f8             	mov    -0x8(%eax),%eax
		stack[stacksz++] = node2;
    248e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2491:	47                   	inc    %edi
    2492:	89 31                	mov    %esi,(%ecx)
		return n->children[1];
    2494:	8b 56 04             	mov    0x4(%esi),%edx
		while (get_child(node2, 1)) {
    2497:	85 d2                	test   %edx,%edx
    2499:	74 0c                	je     24a7 <rb_remove+0x89>
			stack[stacksz++] = node2;
    249b:	47                   	inc    %edi
    249c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    249f:	89 d6                	mov    %edx,%esi
    24a1:	89 54 b9 fc          	mov    %edx,-0x4(%ecx,%edi,4)
    24a5:	eb ed                	jmp    2494 <rb_remove+0x76>
		loparent = stack[stacksz - 2];
    24a7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		if (hiparent != NULL) {
    24aa:	85 c0                	test   %eax,%eax
    24ac:	8d 0c b9             	lea    (%ecx,%edi,4),%ecx
    24af:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		loparent = stack[stacksz - 2];
    24b2:	8b 49 f8             	mov    -0x8(%ecx),%ecx
    24b5:	89 4d e8             	mov    %ecx,-0x18(%ebp)
		if (hiparent != NULL) {
    24b8:	74 11                	je     24cb <rb_remove+0xad>
	return get_child(parent, 1) == child ? 1 : 0;
    24ba:	31 d2                	xor    %edx,%edx
			set_child(hiparent, get_side(hiparent, node), node2);
    24bc:	89 f1                	mov    %esi,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
    24be:	39 58 04             	cmp    %ebx,0x4(%eax)
    24c1:	0f 94 c2             	sete   %dl
			set_child(hiparent, get_side(hiparent, node), node2);
    24c4:	e8 f2 fa ff ff       	call   1fbb <set_child>
    24c9:	eb 05                	jmp    24d0 <rb_remove+0xb2>
			tree->root = node2;
    24cb:	8b 45 08             	mov    0x8(%ebp),%eax
    24ce:	89 30                	mov    %esi,(%eax)
		if (loparent == node) {
    24d0:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
    24d3:	75 17                	jne    24ec <rb_remove+0xce>
		n->children[0] = (void *) (new | (old & 1UL));
    24d5:	8b 03                	mov    (%ebx),%eax
	l &= ~1UL;
    24d7:	8b 16                	mov    (%esi),%edx
		n->children[0] = (void *) (new | (old & 1UL));
    24d9:	83 e0 01             	and    $0x1,%eax
	l &= ~1UL;
    24dc:	83 e2 fe             	and    $0xfffffffe,%edx
		n->children[0] = (void *) (new | (old & 1UL));
    24df:	09 d0                	or     %edx,%eax
    24e1:	89 03                	mov    %eax,(%ebx)
    24e3:	8b 06                	mov    (%esi),%eax
    24e5:	83 e0 01             	and    $0x1,%eax
    24e8:	09 d8                	or     %ebx,%eax
    24ea:	eb 2c                	jmp    2518 <rb_remove+0xfa>
	return get_child(parent, 1) == child ? 1 : 0;
    24ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24ef:	31 d2                	xor    %edx,%edx
			set_child(loparent, get_side(loparent, node2), node);
    24f1:	89 d9                	mov    %ebx,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
    24f3:	39 70 04             	cmp    %esi,0x4(%eax)
    24f6:	0f 94 c2             	sete   %dl
			set_child(loparent, get_side(loparent, node2), node);
    24f9:	e8 bd fa ff ff       	call   1fbb <set_child>
	uintptr_t l = (uintptr_t) n->children[0];
    24fe:	8b 13                	mov    (%ebx),%edx
		n->children[0] = (void *) (new | (old & 1UL));
    2500:	89 d0                	mov    %edx,%eax
	l &= ~1UL;
    2502:	8b 0e                	mov    (%esi),%ecx
		n->children[0] = (void *) (new | (old & 1UL));
    2504:	83 e0 01             	and    $0x1,%eax
	l &= ~1UL;
    2507:	83 e1 fe             	and    $0xfffffffe,%ecx
		n->children[0] = (void *) (new | (old & 1UL));
    250a:	09 c8                	or     %ecx,%eax
	l &= ~1UL;
    250c:	83 e2 fe             	and    $0xfffffffe,%edx
		n->children[0] = (void *) (new | (old & 1UL));
    250f:	89 03                	mov    %eax,(%ebx)
    2511:	8b 06                	mov    (%esi),%eax
    2513:	83 e0 01             	and    $0x1,%eax
    2516:	09 d0                	or     %edx,%eax
    2518:	89 06                	mov    %eax,(%esi)
		stack[stacksz0 - 1] = stack[stacksz - 1];
    251a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		return n->children[1];
    251d:	8b 43 04             	mov    0x4(%ebx),%eax
		n->children[1] = val;
    2520:	89 46 04             	mov    %eax,0x4(%esi)
		tmp = stack[stacksz0 - 1];
    2523:	8b 45 ec             	mov    -0x14(%ebp),%eax
		stack[stacksz0 - 1] = stack[stacksz - 1];
    2526:	8b 51 fc             	mov    -0x4(%ecx),%edx
    2529:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		tmp = stack[stacksz0 - 1];
    252c:	8b 40 fc             	mov    -0x4(%eax),%eax
		n->children[1] = val;
    252f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		stack[stacksz0 - 1] = stack[stacksz - 1];
    2536:	89 51 fc             	mov    %edx,-0x4(%ecx)
		stack[stacksz - 1] = tmp;
    2539:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    253c:	89 41 fc             	mov    %eax,-0x4(%ecx)
	return ((uintptr_t)n->children[0]) & 1UL;
    253f:	8b 0b                	mov    (%ebx),%ecx
    2541:	8b 16                	mov    (%esi),%edx
	*p = (*p & ~1UL) | color;
    2543:	89 c8                	mov    %ecx,%eax
    2545:	83 e0 fe             	and    $0xfffffffe,%eax
	return ((uintptr_t)n->children[0]) & 1UL;
    2548:	83 e2 01             	and    $0x1,%edx
	*p = (*p & ~1UL) | color;
    254b:	09 c2                	or     %eax,%edx
	return ((uintptr_t)n->children[0]) & 1UL;
    254d:	83 e1 01             	and    $0x1,%ecx
	*p = (*p & ~1UL) | color;
    2550:	89 13                	mov    %edx,(%ebx)
    2552:	8b 06                	mov    (%esi),%eax
    2554:	83 e0 fe             	and    $0xfffffffe,%eax
    2557:	09 c8                	or     %ecx,%eax
    2559:	89 06                	mov    %eax,(%esi)
	uintptr_t l = (uintptr_t) n->children[0];
    255b:	8b 13                	mov    (%ebx),%edx
	if (child == NULL) {
    255d:	89 d6                	mov    %edx,%esi
    255f:	83 e6 fe             	and    $0xfffffffe,%esi
    2562:	75 03                	jne    2567 <rb_remove+0x149>
		return n->children[1];
    2564:	8b 73 04             	mov    0x4(%ebx),%esi
	if (stacksz < 2) {
    2567:	83 ff 01             	cmp    $0x1,%edi
    256a:	7f 1a                	jg     2586 <rb_remove+0x168>
		tree->root = child;
    256c:	8b 45 08             	mov    0x8(%ebp),%eax
		if (child != NULL) {
    256f:	85 f6                	test   %esi,%esi
		tree->root = child;
    2571:	89 30                	mov    %esi,(%eax)
		if (child != NULL) {
    2573:	74 05                	je     257a <rb_remove+0x15c>
	*p = (*p & ~1UL) | color;
    2575:	83 0e 01             	orl    $0x1,(%esi)
    2578:	eb 73                	jmp    25ed <rb_remove+0x1cf>
			tree->max_depth = 0;
    257a:	8b 45 08             	mov    0x8(%ebp),%eax
    257d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    2584:	eb 67                	jmp    25ed <rb_remove+0x1cf>
	struct rbnode *parent = stack[stacksz - 2];
    2586:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (!child) {
    2589:	85 f6                	test   %esi,%esi
    258b:	8d 04 b8             	lea    (%eax,%edi,4),%eax
    258e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct rbnode *parent = stack[stacksz - 2];
    2591:	8b 40 f8             	mov    -0x8(%eax),%eax
	if (!child) {
    2594:	75 18                	jne    25ae <rb_remove+0x190>
		if (is_black(node)) {
    2596:	80 e2 01             	and    $0x1,%dl
    2599:	89 d9                	mov    %ebx,%ecx
    259b:	75 37                	jne    25d4 <rb_remove+0x1b6>
	return get_child(parent, 1) == child ? 1 : 0;
    259d:	31 d2                	xor    %edx,%edx
    259f:	39 58 04             	cmp    %ebx,0x4(%eax)
    25a2:	0f 94 c2             	sete   %dl
			set_child(parent, get_side(parent, node), NULL);
    25a5:	31 c9                	xor    %ecx,%ecx
    25a7:	e8 0f fa ff ff       	call   1fbb <set_child>
    25ac:	eb 30                	jmp    25de <rb_remove+0x1c0>
	return get_child(parent, 1) == child ? 1 : 0;
    25ae:	31 d2                	xor    %edx,%edx
		set_child(parent, get_side(parent, node), child);
    25b0:	89 f1                	mov    %esi,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
    25b2:	39 58 04             	cmp    %ebx,0x4(%eax)
    25b5:	0f 94 c2             	sete   %dl
		set_child(parent, get_side(parent, node), child);
    25b8:	e8 fe f9 ff ff       	call   1fbb <set_child>
		if (is_red(node) || is_red(child)) {
    25bd:	f6 03 01             	testb  $0x1,(%ebx)
    25c0:	74 05                	je     25c7 <rb_remove+0x1a9>
    25c2:	f6 06 01             	testb  $0x1,(%esi)
    25c5:	75 05                	jne    25cc <rb_remove+0x1ae>
	*p = (*p & ~1UL) | color;
    25c7:	83 0e 01             	orl    $0x1,(%esi)
    25ca:	eb 12                	jmp    25de <rb_remove+0x1c0>
			stack[stacksz - 1] = child;
    25cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    25cf:	31 c9                	xor    %ecx,%ecx
    25d1:	89 70 fc             	mov    %esi,-0x4(%eax)
	while (stacksz > 1) {
    25d4:	89 fa                	mov    %edi,%edx
    25d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    25d9:	e8 24 fb ff ff       	call   2102 <fix_missing_black.part.2>
	tree->root = stack[0];
    25de:	8b 45 dc             	mov    -0x24(%ebp),%eax
    25e1:	8b 7d 08             	mov    0x8(%ebp),%edi
    25e4:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
    25eb:	89 07                	mov    %eax,(%edi)
    25ed:	8b 65 e0             	mov    -0x20(%ebp),%esp
}
    25f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    25f3:	5b                   	pop    %ebx
    25f4:	5e                   	pop    %esi
    25f5:	5f                   	pop    %edi
    25f6:	5d                   	pop    %ebp
    25f7:	c3                   	ret    

000025f8 <z_rb_foreach_next>:
 * node/stack[top] is the left child of stack[top-1]).  The special
 * case of top == -1 indicates that the stack is uninitialized and we
 * need to push an initial stack starting at the root.
 */
struct rbnode *z_rb_foreach_next(struct rbtree *tree, struct _rb_foreach *f)
{
    25f8:	55                   	push   %ebp
    25f9:	89 e5                	mov    %esp,%ebp
    25fb:	57                   	push   %edi
    25fc:	56                   	push   %esi
	struct rbnode *n;

	if (!tree->root) {
    25fd:	8b 45 08             	mov    0x8(%ebp),%eax
{
    2600:	53                   	push   %ebx
    2601:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (!tree->root) {
    2604:	8b 00                	mov    (%eax),%eax
    2606:	85 c0                	test   %eax,%eax
    2608:	75 04                	jne    260e <z_rb_foreach_next+0x16>
		return NULL;
    260a:	31 c0                	xor    %eax,%eax
    260c:	eb 54                	jmp    2662 <z_rb_foreach_next+0x6a>
	}

	/* Initialization condition, pick the leftmost child of the
	 * root as our first node, initializing the stack on the way.
	 */
	if (f->top == -1) {
    260e:	8b 4a 08             	mov    0x8(%edx),%ecx
    2611:	83 f9 ff             	cmp    $0xffffffff,%ecx
    2614:	74 13                	je     2629 <z_rb_foreach_next+0x31>
	}

	/* The next child from a given node is the leftmost child of
	 * it's right subtree if it has a right child
	 */
	n = get_child(f->stack[f->top], 1);
    2616:	8b 1a                	mov    (%edx),%ebx
    2618:	8d 3c 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edi
		return n->children[1];
    261f:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
    2622:	8b 40 04             	mov    0x4(%eax),%eax
	if (n != NULL) {
    2625:	85 c0                	test   %eax,%eax
    2627:	74 09                	je     2632 <z_rb_foreach_next+0x3a>
		f->top--;
	}

	f->top--;
	return f->top >= 0 ? f->stack[f->top] : NULL;
}
    2629:	5b                   	pop    %ebx
    262a:	5e                   	pop    %esi
    262b:	5f                   	pop    %edi
    262c:	5d                   	pop    %ebp
		return stack_left_limb(n, f);
    262d:	e9 8f fa ff ff       	jmp    20c1 <stack_left_limb>
	if (f->is_left[f->top] != 0) {
    2632:	8b 72 04             	mov    0x4(%edx),%esi
    2635:	80 3c 0e 00          	cmpb   $0x0,(%esi,%ecx,1)
    2639:	74 13                	je     264e <z_rb_foreach_next+0x56>
		return f->stack[--f->top];
    263b:	49                   	dec    %ecx
    263c:	8b 44 3b fc          	mov    -0x4(%ebx,%edi,1),%eax
    2640:	89 4a 08             	mov    %ecx,0x8(%edx)
    2643:	eb 1d                	jmp    2662 <z_rb_foreach_next+0x6a>
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
    2645:	80 3c 0e 00          	cmpb   $0x0,(%esi,%ecx,1)
    2649:	75 0d                	jne    2658 <z_rb_foreach_next+0x60>
		f->top--;
    264b:	89 42 08             	mov    %eax,0x8(%edx)
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
    264e:	8b 4a 08             	mov    0x8(%edx),%ecx
    2651:	85 c9                	test   %ecx,%ecx
    2653:	8d 41 ff             	lea    -0x1(%ecx),%eax
    2656:	7f ed                	jg     2645 <z_rb_foreach_next+0x4d>
	f->top--;
    2658:	89 42 08             	mov    %eax,0x8(%edx)
	return f->top >= 0 ? f->stack[f->top] : NULL;
    265b:	85 c0                	test   %eax,%eax
    265d:	78 ab                	js     260a <z_rb_foreach_next+0x12>
    265f:	8b 04 83             	mov    (%ebx,%eax,4),%eax
}
    2662:	5b                   	pop    %ebx
    2663:	5e                   	pop    %esi
    2664:	5f                   	pop    %edi
    2665:	5d                   	pop    %ebp
    2666:	c3                   	ret    

00002667 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    2667:	55                   	push   %ebp
    2668:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
    266a:	ff 75 14             	pushl  0x14(%ebp)
    266d:	ff 75 10             	pushl  0x10(%ebp)
    2670:	ff 75 0c             	pushl  0xc(%ebp)
    2673:	ff 55 08             	call   *0x8(%ebp)
    2676:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    2679:	e8 24 19 02 00       	call   23fa2 <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
    267e:	50                   	push   %eax
    267f:	e8 db 1c 02 00       	call   2435f <z_impl_k_thread_abort>
    2684:	58                   	pop    %eax

00002685 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
    2685:	55                   	push   %ebp
    2686:	89 e5                	mov    %esp,%ebp
    2688:	56                   	push   %esi
    2689:	53                   	push   %ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    268a:	6a ff                	push   $0xffffffff
    268c:	ff 75 08             	pushl  0x8(%ebp)
    268f:	e8 43 10 02 00       	call   236d7 <z_impl_k_queue_get>
    2694:	5a                   	pop    %edx
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
    2695:	85 c0                	test   %eax,%eax
    2697:	59                   	pop    %ecx
    2698:	74 f0                	je     268a <z_work_q_main+0x5>
    269a:	89 c2                	mov    %eax,%edx
			continue;
		}

		handler = work->handler;
    269c:	8b 48 04             	mov    0x4(%eax),%ecx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    269f:	8b 40 08             	mov    0x8(%eax),%eax
    26a2:	89 c6                	mov    %eax,%esi
    26a4:	89 c3                	mov    %eax,%ebx
    26a6:	83 e6 fe             	and    $0xfffffffe,%esi
    26a9:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
    26ae:	75 f2                	jne    26a2 <z_work_q_main+0x1d>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
    26b0:	80 e3 01             	and    $0x1,%bl
    26b3:	74 04                	je     26b9 <z_work_q_main+0x34>
					      K_WORK_STATE_PENDING)) {
			handler(work);
    26b5:	52                   	push   %edx
    26b6:	ff d1                	call   *%ecx
    26b8:	58                   	pop    %eax
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
    26b9:	e8 84 17 02 00       	call   23e42 <z_impl_k_yield>
    26be:	eb ca                	jmp    268a <z_work_q_main+0x5>

000026c0 <z_arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    26c0:	31 c0                	xor    %eax,%eax
    26c2:	c3                   	ret    

000026c3 <print_err>:
{
	return _char_out;
}

static void print_err(out_func_t out, void *ctx)
{
    26c3:	55                   	push   %ebp
    26c4:	89 e5                	mov    %esp,%ebp
    26c6:	56                   	push   %esi
    26c7:	53                   	push   %ebx
    26c8:	89 c3                	mov    %eax,%ebx
	out('E', ctx);
    26ca:	52                   	push   %edx
{
    26cb:	89 d6                	mov    %edx,%esi
	out('E', ctx);
    26cd:	6a 45                	push   $0x45
    26cf:	ff d3                	call   *%ebx
    26d1:	58                   	pop    %eax
    26d2:	5a                   	pop    %edx
	out('R', ctx);
    26d3:	56                   	push   %esi
    26d4:	6a 52                	push   $0x52
    26d6:	ff d3                	call   *%ebx
    26d8:	59                   	pop    %ecx
    26d9:	58                   	pop    %eax
	out('R', ctx);
    26da:	56                   	push   %esi
    26db:	6a 52                	push   $0x52
    26dd:	ff d3                	call   *%ebx
    26df:	58                   	pop    %eax
    26e0:	5a                   	pop    %edx
}
    26e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    26e4:	5b                   	pop    %ebx
    26e5:	5e                   	pop    %esi
    26e6:	5d                   	pop    %ebp
    26e7:	c3                   	ret    

000026e8 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    26e8:	55                   	push   %ebp
    26e9:	89 e5                	mov    %esp,%ebp
    26eb:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
    26ee:	ff 00                	incl   (%eax)
	return _char_out(c);
}
    26f0:	5d                   	pop    %ebp
	return _char_out(c);
    26f1:	ff 25 2c a6 40 00    	jmp    *0x40a62c

000026f7 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    26f7:	55                   	push   %ebp
    26f8:	89 e5                	mov    %esp,%ebp
    26fa:	57                   	push   %edi
    26fb:	56                   	push   %esi
    26fc:	89 c7                	mov    %eax,%edi
    26fe:	53                   	push   %ebx
    26ff:	89 d6                	mov    %edx,%esi
    2701:	83 ec 1c             	sub    $0x1c,%esp
    2704:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2707:	8b 45 0c             	mov    0xc(%ebp),%eax
    270a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    270d:	85 c0                	test   %eax,%eax
    270f:	7f 07                	jg     2718 <_printk_dec_ulong+0x21>
    2711:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    2718:	31 db                	xor    %ebx,%ebx
    271a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
    2721:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
    2725:	0f 94 c3             	sete   %bl
    2728:	4b                   	dec    %ebx
    2729:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    2730:	83 e3 f0             	and    $0xfffffff0,%ebx
    2733:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    273a:	83 c3 30             	add    $0x30,%ebx
    273d:	c7 45 e8 ff c9 9a 3b 	movl   $0x3b9ac9ff,-0x18(%ebp)
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
    2744:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2747:	40                   	inc    %eax
    2748:	89 45 d8             	mov    %eax,-0x28(%ebp)
    274b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    274e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2751:	72 06                	jb     2759 <_printk_dec_ulong+0x62>
    2753:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2757:	74 1d                	je     2776 <_printk_dec_ulong+0x7f>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
    2759:	8b 45 f0             	mov    -0x10(%ebp),%eax
    275c:	31 d2                	xor    %edx,%edx
    275e:	f7 75 d8             	divl   -0x28(%ebp)
    2761:	56                   	push   %esi
    2762:	83 c0 30             	add    $0x30,%eax
    2765:	50                   	push   %eax
    2766:	ff d7                	call   *%edi
    2768:	59                   	pop    %ecx
			digits++;
    2769:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)((remainder / (pos + 1)) + 48), ctx);
    276c:	58                   	pop    %eax
			found_largest_digit = 1;
    276d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    2774:	eb 1e                	jmp    2794 <_printk_dec_ulong+0x9d>
		} else if (remaining <= min_width
    2776:	8b 55 dc             	mov    -0x24(%ebp),%edx
    2779:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    277c:	7c 0f                	jl     278d <_printk_dec_ulong+0x96>
    277e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
    2782:	77 09                	ja     278d <_printk_dec_ulong+0x96>
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    2784:	56                   	push   %esi
    2785:	53                   	push   %ebx
    2786:	ff d7                	call   *%edi
			digits++;
    2788:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    278b:	58                   	pop    %eax
    278c:	5a                   	pop    %edx
			digits++;
    278d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		}
		remaining--;
		remainder %= (pos + 1);
    2794:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2797:	31 d2                	xor    %edx,%edx
    2799:	f7 75 d8             	divl   -0x28(%ebp)
		remaining--;
    279c:	ff 4d dc             	decl   -0x24(%ebp)
		pos /= 10;
    279f:	8b 45 e8             	mov    -0x18(%ebp),%eax
		remainder %= (pos + 1);
    27a2:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
    27a5:	b9 0a 00 00 00       	mov    $0xa,%ecx
    27aa:	31 d2                	xor    %edx,%edx
    27ac:	f7 f1                	div    %ecx
    27ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
	while (pos >= 9) {
    27b1:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    27b5:	75 8d                	jne    2744 <_printk_dec_ulong+0x4d>
	}
	out((int)(remainder + 48), ctx);
    27b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    27ba:	56                   	push   %esi
    27bb:	83 c0 30             	add    $0x30,%eax
    27be:	50                   	push   %eax
    27bf:	ff d7                	call   *%edi
    27c1:	59                   	pop    %ecx
    27c2:	5b                   	pop    %ebx

	if (padding == PAD_SPACE_AFTER) {
    27c3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
    27c7:	75 14                	jne    27dd <_printk_dec_ulong+0xe6>
		remaining = min_width - digits;
    27c9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    27cc:	2b 5d e0             	sub    -0x20(%ebp),%ebx
		while (remaining-- > 0) {
    27cf:	85 db                	test   %ebx,%ebx
    27d1:	7e 0a                	jle    27dd <_printk_dec_ulong+0xe6>
			out(' ', ctx);
    27d3:	56                   	push   %esi
    27d4:	4b                   	dec    %ebx
    27d5:	6a 20                	push   $0x20
    27d7:	ff d7                	call   *%edi
    27d9:	58                   	pop    %eax
    27da:	5a                   	pop    %edx
    27db:	eb f2                	jmp    27cf <_printk_dec_ulong+0xd8>
		}
	}
}
    27dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    27e0:	5b                   	pop    %ebx
    27e1:	5e                   	pop    %esi
    27e2:	5f                   	pop    %edi
    27e3:	5d                   	pop    %ebp
    27e4:	c3                   	ret    

000027e5 <str_out>:
	int max;
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
    27e5:	55                   	push   %ebp
    27e6:	89 e5                	mov    %esp,%ebp
    27e8:	57                   	push   %edi
    27e9:	56                   	push   %esi
    27ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    27ed:	53                   	push   %ebx
    27ee:	8b 45 08             	mov    0x8(%ebp),%eax
    27f1:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!ctx->str || ctx->count >= ctx->max) {
    27f4:	8b 0a                	mov    (%edx),%ecx
    27f6:	85 c9                	test   %ecx,%ecx
    27f8:	8d 7b 01             	lea    0x1(%ebx),%edi
    27fb:	74 07                	je     2804 <str_out+0x1f>
    27fd:	8b 72 04             	mov    0x4(%edx),%esi
    2800:	39 de                	cmp    %ebx,%esi
    2802:	7f 05                	jg     2809 <str_out+0x24>
		ctx->count++;
    2804:	89 7a 08             	mov    %edi,0x8(%edx)
		return c;
    2807:	eb 11                	jmp    281a <str_out+0x35>
	}

	if (ctx->count == ctx->max - 1) {
    2809:	4e                   	dec    %esi
    280a:	01 d9                	add    %ebx,%ecx
		ctx->str[ctx->count++] = '\0';
    280c:	89 7a 08             	mov    %edi,0x8(%edx)
	if (ctx->count == ctx->max - 1) {
    280f:	39 de                	cmp    %ebx,%esi
    2811:	75 05                	jne    2818 <str_out+0x33>
		ctx->str[ctx->count++] = '\0';
    2813:	c6 01 00             	movb   $0x0,(%ecx)
    2816:	eb 02                	jmp    281a <str_out+0x35>
	} else {
		ctx->str[ctx->count++] = c;
    2818:	88 01                	mov    %al,(%ecx)
	}

	return c;
}
    281a:	5b                   	pop    %ebx
    281b:	5e                   	pop    %esi
    281c:	5f                   	pop    %edi
    281d:	5d                   	pop    %ebp
    281e:	c3                   	ret    

0000281f <__printk_hook_install>:
{
    281f:	55                   	push   %ebp
    2820:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
    2822:	8b 45 08             	mov    0x8(%ebp),%eax
}
    2825:	5d                   	pop    %ebp
	_char_out = fn;
    2826:	a3 2c a6 40 00       	mov    %eax,0x40a62c
}
    282b:	c3                   	ret    

0000282c <_vprintk>:
{
    282c:	55                   	push   %ebp
    282d:	89 e5                	mov    %esp,%ebp
    282f:	57                   	push   %edi
    2830:	56                   	push   %esi
	int might_format = 0; /* 1 if encountered a '%' */
    2831:	31 ff                	xor    %edi,%edi
{
    2833:	53                   	push   %ebx
    2834:	83 ec 24             	sub    $0x24,%esp
	int long_ctr = 0;
    2837:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
{
    283e:	8b 5d 14             	mov    0x14(%ebp),%ebx
	int min_width = -1;
    2841:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	enum pad_type padding = PAD_NONE;
    2848:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	while (*fmt) {
    284f:	8b 45 10             	mov    0x10(%ebp),%eax
    2852:	0f be 00             	movsbl (%eax),%eax
    2855:	84 c0                	test   %al,%al
    2857:	0f 84 41 03 00 00    	je     2b9e <_vprintk+0x372>
		if (!might_format) {
    285d:	85 ff                	test   %edi,%edi
    285f:	75 16                	jne    2877 <_vprintk+0x4b>
			if (*fmt != '%') {
    2861:	3c 25                	cmp    $0x25,%al
    2863:	0f 84 f1 02 00 00    	je     2b5a <_vprintk+0x32e>
				out((int)*fmt, ctx);
    2869:	ff 75 0c             	pushl  0xc(%ebp)
    286c:	50                   	push   %eax
    286d:	ff 55 08             	call   *0x8(%ebp)
    2870:	5e                   	pop    %esi
    2871:	58                   	pop    %eax
    2872:	e9 15 03 00 00       	jmp    2b8c <_vprintk+0x360>
			switch (*fmt) {
    2877:	3c 64                	cmp    $0x64,%al
    2879:	0f 84 d9 00 00 00    	je     2958 <_vprintk+0x12c>
    287f:	7f 4a                	jg     28cb <_vprintk+0x9f>
    2881:	3c 39                	cmp    $0x39,%al
    2883:	7f 26                	jg     28ab <_vprintk+0x7f>
    2885:	3c 31                	cmp    $0x31,%al
    2887:	0f 8d 97 00 00 00    	jge    2924 <_vprintk+0xf8>
    288d:	3c 2d                	cmp    $0x2d,%al
    288f:	0f 84 e1 02 00 00    	je     2b76 <_vprintk+0x34a>
    2895:	3c 30                	cmp    $0x30,%al
    2897:	74 7b                	je     2914 <_vprintk+0xe8>
    2899:	3c 25                	cmp    $0x25,%al
    289b:	0f 85 9e 02 00 00    	jne    2b3f <_vprintk+0x313>
				out((int)'%', ctx);
    28a1:	ff 75 0c             	pushl  0xc(%ebp)
    28a4:	6a 25                	push   $0x25
    28a6:	e9 a8 02 00 00       	jmp    2b53 <_vprintk+0x327>
			switch (*fmt) {
    28ab:	3c 58                	cmp    $0x58,%al
    28ad:	0f 84 5f 01 00 00    	je     2a12 <_vprintk+0x1e6>
    28b3:	3c 63                	cmp    $0x63,%al
    28b5:	0f 85 84 02 00 00    	jne    2b3f <_vprintk+0x313>
				out(c, ctx);
    28bb:	ff 75 0c             	pushl  0xc(%ebp)
    28be:	ff 33                	pushl  (%ebx)
				int c = va_arg(ap, int);
    28c0:	8d 73 04             	lea    0x4(%ebx),%esi
				out(c, ctx);
    28c3:	ff 55 08             	call   *0x8(%ebp)
    28c6:	e9 70 02 00 00       	jmp    2b3b <_vprintk+0x30f>
			switch (*fmt) {
    28cb:	3c 70                	cmp    $0x70,%al
    28cd:	0f 84 1d 01 00 00    	je     29f0 <_vprintk+0x1c4>
    28d3:	7f 0c                	jg     28e1 <_vprintk+0xb5>
    28d5:	3c 69                	cmp    $0x69,%al
    28d7:	74 7f                	je     2958 <_vprintk+0x12c>
    28d9:	3c 6c                	cmp    $0x6c,%al
    28db:	74 73                	je     2950 <_vprintk+0x124>
    28dd:	3c 68                	cmp    $0x68,%al
    28df:	eb 28                	jmp    2909 <_vprintk+0xdd>
    28e1:	3c 75                	cmp    $0x75,%al
    28e3:	0f 84 b6 00 00 00    	je     299f <_vprintk+0x173>
    28e9:	7f 14                	jg     28ff <_vprintk+0xd3>
    28eb:	3c 73                	cmp    $0x73,%al
    28ed:	0f 85 4c 02 00 00    	jne    2b3f <_vprintk+0x313>
				char *s = va_arg(ap, char *);
    28f3:	8b 3b                	mov    (%ebx),%edi
    28f5:	8d 73 04             	lea    0x4(%ebx),%esi
    28f8:	89 fb                	mov    %edi,%ebx
				while (*s)
    28fa:	e9 09 02 00 00       	jmp    2b08 <_vprintk+0x2dc>
			switch (*fmt) {
    28ff:	3c 78                	cmp    $0x78,%al
    2901:	0f 84 0b 01 00 00    	je     2a12 <_vprintk+0x1e6>
    2907:	3c 7a                	cmp    $0x7a,%al
    2909:	0f 84 7d 02 00 00    	je     2b8c <_vprintk+0x360>
    290f:	e9 2b 02 00 00       	jmp    2b3f <_vprintk+0x313>
				if (min_width < 0 && padding == PAD_NONE) {
    2914:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    2918:	79 0a                	jns    2924 <_vprintk+0xf8>
    291a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    291e:	0f 84 5b 02 00 00    	je     2b7f <_vprintk+0x353>
				if (min_width < 0) {
    2924:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    2928:	79 05                	jns    292f <_vprintk+0x103>
					min_width = *fmt - '0';
    292a:	83 e8 30             	sub    $0x30,%eax
    292d:	eb 08                	jmp    2937 <_vprintk+0x10b>
					min_width = 10 * min_width + *fmt - '0';
    292f:	6b 55 f0 0a          	imul   $0xa,-0x10(%ebp),%edx
    2933:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
    2937:	89 45 f0             	mov    %eax,-0x10(%ebp)
				if (padding == PAD_NONE) {
    293a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    293e:	0f 85 48 02 00 00    	jne    2b8c <_vprintk+0x360>
					padding = PAD_SPACE_BEFORE;
    2944:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    294b:	e9 3c 02 00 00       	jmp    2b8c <_vprintk+0x360>
				long_ctr++;
    2950:	ff 45 e8             	incl   -0x18(%ebp)
    2953:	e9 34 02 00 00       	jmp    2b8c <_vprintk+0x360>
				if (long_ctr == 0) {
    2958:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    295c:	74 06                	je     2964 <_vprintk+0x138>
				} else if (long_ctr == 1) {
    295e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
    2962:	75 07                	jne    296b <_vprintk+0x13f>
					long ld = va_arg(ap, long);
    2964:	8d 73 04             	lea    0x4(%ebx),%esi
    2967:	8b 0b                	mov    (%ebx),%ecx
					d = (s32_t)ld;
    2969:	eb 19                	jmp    2984 <_vprintk+0x158>
					long long lld = va_arg(ap, long long);
    296b:	8b 0b                	mov    (%ebx),%ecx
    296d:	8d 73 08             	lea    0x8(%ebx),%esi
					if (lld > INT32_MAX ||
    2970:	89 c8                	mov    %ecx,%eax
					long long lld = va_arg(ap, long long);
    2972:	8b 5b 04             	mov    0x4(%ebx),%ebx
					if (lld > INT32_MAX ||
    2975:	05 00 00 00 80       	add    $0x80000000,%eax
    297a:	89 da                	mov    %ebx,%edx
    297c:	83 d2 00             	adc    $0x0,%edx
    297f:	83 fa 00             	cmp    $0x0,%edx
    2982:	77 46                	ja     29ca <_vprintk+0x19e>
				if (d < 0) {
    2984:	85 c9                	test   %ecx,%ecx
    2986:	79 52                	jns    29da <_vprintk+0x1ae>
					out((int)'-', ctx);
    2988:	ff 75 0c             	pushl  0xc(%ebp)
    298b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    298e:	6a 2d                	push   $0x2d
    2990:	ff 55 08             	call   *0x8(%ebp)
    2993:	59                   	pop    %ecx
					d = -d;
    2994:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					out((int)'-', ctx);
    2997:	5b                   	pop    %ebx
					min_width--;
    2998:	ff 4d f0             	decl   -0x10(%ebp)
					d = -d;
    299b:	f7 d9                	neg    %ecx
				_printk_dec_ulong(out, ctx, d, padding,
    299d:	eb 3b                	jmp    29da <_vprintk+0x1ae>
				if (long_ctr == 0) {
    299f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    29a3:	74 06                	je     29ab <_vprintk+0x17f>
				} else if (long_ctr == 1) {
    29a5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
    29a9:	75 07                	jne    29b2 <_vprintk+0x186>
					long lu = va_arg(ap, unsigned long);
    29ab:	8d 73 04             	lea    0x4(%ebx),%esi
    29ae:	8b 0b                	mov    (%ebx),%ecx
					u = (u32_t)lu;
    29b0:	eb 28                	jmp    29da <_vprintk+0x1ae>
					if (llu > INT32_MAX) {
    29b2:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
					unsigned long long llu =
    29b7:	8b 0b                	mov    (%ebx),%ecx
					if (llu > INT32_MAX) {
    29b9:	39 ca                	cmp    %ecx,%edx
					unsigned long long llu =
    29bb:	8b 43 04             	mov    0x4(%ebx),%eax
					if (llu > INT32_MAX) {
    29be:	ba 00 00 00 00       	mov    $0x0,%edx
					unsigned long long llu =
    29c3:	8d 73 08             	lea    0x8(%ebx),%esi
					if (llu > INT32_MAX) {
    29c6:	19 c2                	sbb    %eax,%edx
    29c8:	73 10                	jae    29da <_vprintk+0x1ae>
						print_err(out, ctx);
    29ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    29cd:	8b 45 08             	mov    0x8(%ebp),%eax
    29d0:	e8 ee fc ff ff       	call   26c3 <print_err>
						break;
    29d5:	e9 ae 01 00 00       	jmp    2b88 <_vprintk+0x35c>
				_printk_dec_ulong(out, ctx, u, padding,
    29da:	ff 75 f0             	pushl  -0x10(%ebp)
    29dd:	ff 75 ec             	pushl  -0x14(%ebp)
    29e0:	8b 55 0c             	mov    0xc(%ebp),%edx
    29e3:	8b 45 08             	mov    0x8(%ebp),%eax
    29e6:	e8 0c fd ff ff       	call   26f7 <_printk_dec_ulong>
    29eb:	e9 4b 01 00 00       	jmp    2b3b <_vprintk+0x30f>
				  out('0', ctx);
    29f0:	ff 75 0c             	pushl  0xc(%ebp)
    29f3:	6a 30                	push   $0x30
    29f5:	ff 55 08             	call   *0x8(%ebp)
    29f8:	59                   	pop    %ecx
    29f9:	5e                   	pop    %esi
				  out('x', ctx);
    29fa:	ff 75 0c             	pushl  0xc(%ebp)
    29fd:	6a 78                	push   $0x78
    29ff:	ff 55 08             	call   *0x8(%ebp)
    2a02:	58                   	pop    %eax
				  min_width = 8;
    2a03:	c7 45 f0 08 00 00 00 	movl   $0x8,-0x10(%ebp)
				  out('x', ctx);
    2a0a:	5a                   	pop    %edx
				  padding = PAD_ZERO_BEFORE;
    2a0b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
					x = va_arg(ap, unsigned long);
    2a12:	8b 03                	mov    (%ebx),%eax
				if (long_ctr < 2) {
    2a14:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
    2a18:	7f 0d                	jg     2a27 <_vprintk+0x1fb>
					x = va_arg(ap, unsigned long);
    2a1a:	31 d2                	xor    %edx,%edx
    2a1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    2a1f:	89 55 d8             	mov    %edx,-0x28(%ebp)
    2a22:	83 c3 04             	add    $0x4,%ebx
    2a25:	eb 0c                	jmp    2a33 <_vprintk+0x207>
					x = va_arg(ap, unsigned long long);
    2a27:	8b 53 04             	mov    0x4(%ebx),%edx
    2a2a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    2a2d:	89 55 d8             	mov    %edx,-0x28(%ebp)
    2a30:	83 c3 08             	add    $0x8,%ebx
	int remaining = 16; /* 16 digits max */
    2a33:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
	int digits = 0;
    2a3a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	int found_largest_digit = 0;
    2a41:	31 f6                	xor    %esi,%esi
	int size = sizeof(num) * 2;
    2a43:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
    2a4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2a4d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    2a50:	48                   	dec    %eax
    2a51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2a54:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    2a5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2a5e:	0f ad d0             	shrd   %cl,%edx,%eax
    2a61:	d3 ea                	shr    %cl,%edx
    2a63:	f6 c1 20             	test   $0x20,%cl
    2a66:	74 02                	je     2a6a <_vprintk+0x23e>
    2a68:	89 d0                	mov    %edx,%eax
		if (nibble || found_largest_digit || size == 1) {
    2a6a:	24 0f                	and    $0xf,%al
    2a6c:	75 0f                	jne    2a7d <_vprintk+0x251>
    2a6e:	83 e6 01             	and    $0x1,%esi
    2a71:	75 0a                	jne    2a7d <_vprintk+0x251>
			nibble += nibble > 9 ? 87 : 48;
    2a73:	b2 30                	mov    $0x30,%dl
		if (nibble || found_largest_digit || size == 1) {
    2a75:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    2a79:	75 2f                	jne    2aaa <_vprintk+0x27e>
    2a7b:	eb 0c                	jmp    2a89 <_vprintk+0x25d>
			nibble += nibble > 9 ? 87 : 48;
    2a7d:	3c 09                	cmp    $0x9,%al
    2a7f:	0f 9f c2             	setg   %dl
    2a82:	4a                   	dec    %edx
    2a83:	83 e2 d9             	and    $0xffffffd9,%edx
    2a86:	83 c2 57             	add    $0x57,%edx
			out((int)nibble, ctx);
    2a89:	ff 75 0c             	pushl  0xc(%ebp)
			nibble += nibble > 9 ? 87 : 48;
    2a8c:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
    2a8e:	0f be c0             	movsbl %al,%eax
    2a91:	50                   	push   %eax
    2a92:	ff 55 08             	call   *0x8(%ebp)
    2a95:	58                   	pop    %eax
			digits++;
    2a96:	ff 45 d0             	incl   -0x30(%ebp)
			out((int)nibble, ctx);
    2a99:	5a                   	pop    %edx
	for (; size; size--) {
    2a9a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    2a9e:	74 3f                	je     2adf <_vprintk+0x2b3>
			found_largest_digit = 1;
    2aa0:	89 fe                	mov    %edi,%esi
		char nibble = (num >> ((size - 1) << 2) & 0xf);
    2aa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2aa5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2aa8:	eb a0                	jmp    2a4a <_vprintk+0x21e>
		if (remaining-- <= min_width) {
    2aaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2aad:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    2ab0:	8d 70 ff             	lea    -0x1(%eax),%esi
    2ab3:	0f 8c db 00 00 00    	jl     2b94 <_vprintk+0x368>
			if (padding == PAD_ZERO_BEFORE) {
    2ab9:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    2abd:	75 07                	jne    2ac6 <_vprintk+0x29a>
				out('0', ctx);
    2abf:	ff 75 0c             	pushl  0xc(%ebp)
    2ac2:	6a 30                	push   $0x30
    2ac4:	eb 0f                	jmp    2ad5 <_vprintk+0x2a9>
			} else if (padding == PAD_SPACE_BEFORE) {
    2ac6:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
    2aca:	0f 85 c4 00 00 00    	jne    2b94 <_vprintk+0x368>
				out(' ', ctx);
    2ad0:	ff 75 0c             	pushl  0xc(%ebp)
    2ad3:	6a 20                	push   $0x20
    2ad5:	ff 55 08             	call   *0x8(%ebp)
    2ad8:	59                   	pop    %ecx
    2ad9:	58                   	pop    %eax
    2ada:	e9 b5 00 00 00       	jmp    2b94 <_vprintk+0x368>
			might_format = 0;
    2adf:	31 ff                	xor    %edi,%edi
	if (padding == PAD_SPACE_AFTER) {
    2ae1:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    2ae5:	0f 85 a1 00 00 00    	jne    2b8c <_vprintk+0x360>
		remaining = min_width * 2 - digits;
    2aeb:	8b 75 f0             	mov    -0x10(%ebp),%esi
    2aee:	01 f6                	add    %esi,%esi
    2af0:	2b 75 d0             	sub    -0x30(%ebp),%esi
		while (remaining-- > 0) {
    2af3:	85 f6                	test   %esi,%esi
    2af5:	0f 8e 8f 00 00 00    	jle    2b8a <_vprintk+0x35e>
			out(' ', ctx);
    2afb:	ff 75 0c             	pushl  0xc(%ebp)
    2afe:	4e                   	dec    %esi
    2aff:	6a 20                	push   $0x20
    2b01:	ff 55 08             	call   *0x8(%ebp)
    2b04:	58                   	pop    %eax
    2b05:	5a                   	pop    %edx
    2b06:	eb eb                	jmp    2af3 <_vprintk+0x2c7>
				while (*s)
    2b08:	0f be 03             	movsbl (%ebx),%eax
    2b0b:	84 c0                	test   %al,%al
    2b0d:	74 0c                	je     2b1b <_vprintk+0x2ef>
					out((int)(*s++), ctx);
    2b0f:	ff 75 0c             	pushl  0xc(%ebp)
    2b12:	43                   	inc    %ebx
    2b13:	50                   	push   %eax
    2b14:	ff 55 08             	call   *0x8(%ebp)
    2b17:	59                   	pop    %ecx
    2b18:	58                   	pop    %eax
    2b19:	eb ed                	jmp    2b08 <_vprintk+0x2dc>
				if (padding == PAD_SPACE_AFTER) {
    2b1b:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    2b1f:	75 67                	jne    2b88 <_vprintk+0x35c>
					int remaining = min_width - (s - start);
    2b21:	29 fb                	sub    %edi,%ebx
    2b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2b26:	29 d8                	sub    %ebx,%eax
    2b28:	89 c3                	mov    %eax,%ebx
					while (remaining-- > 0) {
    2b2a:	85 db                	test   %ebx,%ebx
    2b2c:	7e 5a                	jle    2b88 <_vprintk+0x35c>
						out(' ', ctx);
    2b2e:	ff 75 0c             	pushl  0xc(%ebp)
    2b31:	4b                   	dec    %ebx
    2b32:	6a 20                	push   $0x20
    2b34:	ff 55 08             	call   *0x8(%ebp)
    2b37:	58                   	pop    %eax
    2b38:	5a                   	pop    %edx
    2b39:	eb ef                	jmp    2b2a <_vprintk+0x2fe>
				out(c, ctx);
    2b3b:	5f                   	pop    %edi
    2b3c:	58                   	pop    %eax
				break;
    2b3d:	eb 49                	jmp    2b88 <_vprintk+0x35c>
				out((int)'%', ctx);
    2b3f:	ff 75 0c             	pushl  0xc(%ebp)
    2b42:	6a 25                	push   $0x25
    2b44:	ff 55 08             	call   *0x8(%ebp)
    2b47:	59                   	pop    %ecx
				out((int)*fmt, ctx);
    2b48:	8b 45 10             	mov    0x10(%ebp),%eax
				out((int)'%', ctx);
    2b4b:	5e                   	pop    %esi
				out((int)*fmt, ctx);
    2b4c:	ff 75 0c             	pushl  0xc(%ebp)
    2b4f:	0f be 00             	movsbl (%eax),%eax
    2b52:	50                   	push   %eax
    2b53:	ff 55 08             	call   *0x8(%ebp)
    2b56:	58                   	pop    %eax
    2b57:	5a                   	pop    %edx
				break;
    2b58:	eb 30                	jmp    2b8a <_vprintk+0x35e>
				long_ctr = 0;
    2b5a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
    2b61:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
				padding = PAD_NONE;
    2b68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				might_format = 1;
    2b6f:	bf 01 00 00 00       	mov    $0x1,%edi
    2b74:	eb 16                	jmp    2b8c <_vprintk+0x360>
				padding = PAD_SPACE_AFTER;
    2b76:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    2b7d:	eb 0d                	jmp    2b8c <_vprintk+0x360>
					padding = PAD_ZERO_BEFORE;
    2b7f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    2b86:	eb 04                	jmp    2b8c <_vprintk+0x360>
				char *s = va_arg(ap, char *);
    2b88:	89 f3                	mov    %esi,%ebx
			might_format = 0;
    2b8a:	31 ff                	xor    %edi,%edi
		++fmt;
    2b8c:	ff 45 10             	incl   0x10(%ebp)
    2b8f:	e9 bb fc ff ff       	jmp    284f <_vprintk+0x23>
					x = va_arg(ap, unsigned long long);
    2b94:	89 75 e0             	mov    %esi,-0x20(%ebp)
    2b97:	31 f6                	xor    %esi,%esi
    2b99:	e9 04 ff ff ff       	jmp    2aa2 <_vprintk+0x276>
}
    2b9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2ba1:	5b                   	pop    %ebx
    2ba2:	5e                   	pop    %esi
    2ba3:	5f                   	pop    %edi
    2ba4:	5d                   	pop    %ebp
    2ba5:	c3                   	ret    

00002ba6 <vprintk>:
{
    2ba6:	55                   	push   %ebp
    2ba7:	89 e5                	mov    %esp,%ebp
    2ba9:	50                   	push   %eax
	_vprintk(char_out, &ctx, fmt, ap);
    2baa:	ff 75 0c             	pushl  0xc(%ebp)
    2bad:	ff 75 08             	pushl  0x8(%ebp)
    2bb0:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct out_context ctx = { 0 };
    2bb3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk(char_out, &ctx, fmt, ap);
    2bba:	50                   	push   %eax
    2bbb:	68 e8 26 00 00       	push   $0x26e8
    2bc0:	e8 67 fc ff ff       	call   282c <_vprintk>
    2bc5:	83 c4 10             	add    $0x10,%esp
}
    2bc8:	c9                   	leave  
    2bc9:	c3                   	ret    

00002bca <printk>:
{
    2bca:	55                   	push   %ebp
    2bcb:	89 e5                	mov    %esp,%ebp
	va_start(ap, fmt);
    2bcd:	8d 45 0c             	lea    0xc(%ebp),%eax
		vprintk(fmt, ap);
    2bd0:	50                   	push   %eax
    2bd1:	ff 75 08             	pushl  0x8(%ebp)
    2bd4:	e8 cd ff ff ff       	call   2ba6 <vprintk>
    2bd9:	58                   	pop    %eax
    2bda:	5a                   	pop    %edx
}
    2bdb:	c9                   	leave  
    2bdc:	c3                   	ret    

00002bdd <snprintk>:

int snprintk(char *str, size_t size, const char *fmt, ...)
{
    2bdd:	55                   	push   %ebp
    2bde:	89 e5                	mov    %esp,%ebp
    2be0:	53                   	push   %ebx
    2be1:	83 ec 0c             	sub    $0xc,%esp
	struct str_context ctx = { str, size, 0 };
    2be4:	8b 45 0c             	mov    0xc(%ebp),%eax
{
    2be7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct str_context ctx = { str, size, 0 };
    2bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	va_list ap;

	va_start(ap, fmt);
    2bed:	8d 45 14             	lea    0x14(%ebp),%eax
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2bf0:	50                   	push   %eax
    2bf1:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2bf4:	ff 75 10             	pushl  0x10(%ebp)
	struct str_context ctx = { str, size, 0 };
    2bf7:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    2bfa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c01:	50                   	push   %eax
    2c02:	68 e5 27 00 00       	push   $0x27e5
    2c07:	e8 20 fc ff ff       	call   282c <_vprintk>
	va_end(ap);

	if (ctx.count < ctx.max) {
    2c0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c0f:	83 c4 10             	add    $0x10,%esp
	if (ctx.count < ctx.max) {
    2c12:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2c15:	7d 04                	jge    2c1b <snprintk+0x3e>
		str[ctx.count] = '\0';
    2c17:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
	}

	return ctx.count;
}
    2c1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2c1e:	c9                   	leave  
    2c1f:	c3                   	ret    

00002c20 <vsnprintk>:

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    2c20:	55                   	push   %ebp
    2c21:	89 e5                	mov    %esp,%ebp
    2c23:	53                   	push   %ebx
    2c24:	83 ec 0c             	sub    $0xc,%esp
	struct str_context ctx = { str, size, 0 };

	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c27:	ff 75 14             	pushl  0x14(%ebp)
    2c2a:	ff 75 10             	pushl  0x10(%ebp)
	struct str_context ctx = { str, size, 0 };
    2c2d:	8b 45 0c             	mov    0xc(%ebp),%eax
{
    2c30:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct str_context ctx = { str, size, 0 };
    2c33:	89 45 f4             	mov    %eax,-0xc(%ebp)
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c36:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2c39:	50                   	push   %eax
	struct str_context ctx = { str, size, 0 };
    2c3a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c3d:	68 e5 27 00 00       	push   $0x27e5
	struct str_context ctx = { str, size, 0 };
    2c42:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c49:	e8 de fb ff ff       	call   282c <_vprintk>

	if (ctx.count < ctx.max) {
    2c4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2c51:	83 c4 10             	add    $0x10,%esp
	if (ctx.count < ctx.max) {
    2c54:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2c57:	7d 04                	jge    2c5d <vsnprintk+0x3d>
		str[ctx.count] = '\0';
    2c59:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
	}

	return ctx.count;
}
    2c5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2c60:	c9                   	leave  
    2c61:	c3                   	ret    

00002c62 <ring_buf_space_get>:
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline int ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
    2c62:	8b 10                	mov    (%eax),%edx
    2c64:	8b 48 04             	mov    0x4(%eax),%ecx
    2c67:	8b 40 10             	mov    0x10(%eax),%eax
	if (tail < head) {
    2c6a:	39 d1                	cmp    %edx,%ecx
	return (size - tail) + head - 1;
    2c6c:	8d 44 02 ff          	lea    -0x1(%edx,%eax,1),%eax
	if (tail < head) {
    2c70:	73 03                	jae    2c75 <ring_buf_space_get+0x13>
		return head - tail - 1;
    2c72:	8d 42 ff             	lea    -0x1(%edx),%eax
	return (size - tail) + head - 1;
    2c75:	29 c8                	sub    %ecx,%eax
}
    2c77:	c3                   	ret    

00002c78 <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

u32_t ring_buf_put_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
    2c78:	55                   	push   %ebp
    2c79:	89 e5                	mov    %esp,%ebp
    2c7b:	57                   	push   %edi
    2c7c:	56                   	push   %esi
    2c7d:	53                   	push   %ebx
    2c7e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	u32_t space, trail_size, allocated;

	space = z_ring_buf_custom_space_get(buf->size, buf->head,
    2c81:	8b 53 08             	mov    0x8(%ebx),%edx
    2c84:	8b 0b                	mov    (%ebx),%ecx
    2c86:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
    2c89:	39 ca                	cmp    %ecx,%edx
    2c8b:	73 03                	jae    2c90 <ring_buf_put_claim+0x18>
		return head - tail - 1;
    2c8d:	49                   	dec    %ecx
    2c8e:	eb 04                	jmp    2c94 <ring_buf_put_claim+0x1c>
	return (size - tail) + head - 1;
    2c90:	8d 4c 31 ff          	lea    -0x1(%ecx,%esi,1),%ecx
	/* Limit requested size to available size. */
	size = MIN(size, space);
	trail_size = buf->size - buf->misc.byte_mode.tmp_tail;

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
    2c94:	89 f0                	mov    %esi,%eax
    2c96:	29 d1                	sub    %edx,%ecx
    2c98:	29 d0                	sub    %edx,%eax
    2c9a:	3b 45 10             	cmp    0x10(%ebp),%eax
    2c9d:	76 03                	jbe    2ca2 <ring_buf_put_claim+0x2a>
    2c9f:	8b 45 10             	mov    0x10(%ebp),%eax
    2ca2:	39 c8                	cmp    %ecx,%eax
    2ca4:	76 02                	jbe    2ca8 <ring_buf_put_claim+0x30>
    2ca6:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
    2ca8:	8b 7b 14             	mov    0x14(%ebx),%edi
    2cab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2cae:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_tail =
		wrap(buf->misc.byte_mode.tmp_tail + allocated, buf->size);
    2cb0:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
    2cb2:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
    2cb4:	39 d6                	cmp    %edx,%esi
    2cb6:	77 02                	ja     2cba <ring_buf_put_claim+0x42>
    2cb8:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_tail =
    2cba:	89 53 08             	mov    %edx,0x8(%ebx)

	return allocated;
}
    2cbd:	5b                   	pop    %ebx
    2cbe:	5e                   	pop    %esi
    2cbf:	5f                   	pop    %edi
    2cc0:	5d                   	pop    %ebp
    2cc1:	c3                   	ret    

00002cc2 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, u32_t size)
{
    2cc2:	55                   	push   %ebp
    2cc3:	89 e5                	mov    %esp,%ebp
    2cc5:	56                   	push   %esi
    2cc6:	53                   	push   %ebx
    2cc7:	8b 75 08             	mov    0x8(%ebp),%esi
    2cca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (size > ring_buf_space_get(buf)) {
    2ccd:	89 f0                	mov    %esi,%eax
    2ccf:	e8 8e ff ff ff       	call   2c62 <ring_buf_space_get>
    2cd4:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    2cd9:	39 d8                	cmp    %ebx,%eax
    2cdb:	72 16                	jb     2cf3 <ring_buf_put_finish+0x31>
		return -EINVAL;
	}

	buf->tail = wrap(buf->tail + size, buf->size);
    2cdd:	8b 46 04             	mov    0x4(%esi),%eax
    2ce0:	8b 56 10             	mov    0x10(%esi),%edx
    2ce3:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
    2ce5:	39 c2                	cmp    %eax,%edx
    2ce7:	77 02                	ja     2ceb <ring_buf_put_finish+0x29>
    2ce9:	29 d0                	sub    %edx,%eax
	buf->tail = wrap(buf->tail + size, buf->size);
    2ceb:	89 46 04             	mov    %eax,0x4(%esi)
	buf->misc.byte_mode.tmp_tail = buf->tail;
    2cee:	89 46 08             	mov    %eax,0x8(%esi)

	return 0;
    2cf1:	31 d2                	xor    %edx,%edx
}
    2cf3:	5b                   	pop    %ebx
    2cf4:	89 d0                	mov    %edx,%eax
    2cf6:	5e                   	pop    %esi
    2cf7:	5d                   	pop    %ebp
    2cf8:	c3                   	ret    

00002cf9 <ring_buf_put>:

u32_t ring_buf_put(struct ring_buf *buf, const u8_t *data, u32_t size)
{
    2cf9:	55                   	push   %ebp
    2cfa:	89 e5                	mov    %esp,%ebp
    2cfc:	57                   	push   %edi
    2cfd:	56                   	push   %esi
    2cfe:	53                   	push   %ebx
	u8_t *dst;
	u32_t partial_size;
	u32_t total_size = 0U;
    2cff:	31 db                	xor    %ebx,%ebx
{
    2d01:	51                   	push   %ecx
    2d02:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
    2d05:	ff 75 10             	pushl  0x10(%ebp)
    2d08:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2d0b:	50                   	push   %eax
    2d0c:	ff 75 08             	pushl  0x8(%ebp)
    2d0f:	e8 64 ff ff ff       	call   2c78 <ring_buf_put_claim>
    2d14:	83 c4 0c             	add    $0xc,%esp
		memcpy(dst, data, partial_size);
    2d17:	50                   	push   %eax
		partial_size = ring_buf_put_claim(buf, &dst, size);
    2d18:	89 c6                	mov    %eax,%esi
		memcpy(dst, data, partial_size);
    2d1a:	57                   	push   %edi
		total_size += partial_size;
    2d1b:	01 f3                	add    %esi,%ebx
		memcpy(dst, data, partial_size);
    2d1d:	ff 75 f0             	pushl  -0x10(%ebp)
		size -= partial_size;
		data += partial_size;
    2d20:	01 f7                	add    %esi,%edi
		memcpy(dst, data, partial_size);
    2d22:	e8 0a 7c 00 00       	call   a931 <memcpy>
    2d27:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
    2d2a:	29 75 10             	sub    %esi,0x10(%ebp)
    2d2d:	74 04                	je     2d33 <ring_buf_put+0x3a>
    2d2f:	85 f6                	test   %esi,%esi
    2d31:	75 d2                	jne    2d05 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
    2d33:	53                   	push   %ebx
    2d34:	ff 75 08             	pushl  0x8(%ebp)
    2d37:	e8 86 ff ff ff       	call   2cc2 <ring_buf_put_finish>
    2d3c:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    2d3d:	89 d8                	mov    %ebx,%eax
	err = ring_buf_put_finish(buf, total_size);
    2d3f:	5a                   	pop    %edx
}
    2d40:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2d43:	5b                   	pop    %ebx
    2d44:	5e                   	pop    %esi
    2d45:	5f                   	pop    %edi
    2d46:	5d                   	pop    %ebp
    2d47:	c3                   	ret    

00002d48 <ring_buf_get_claim>:

u32_t ring_buf_get_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
    2d48:	55                   	push   %ebp
    2d49:	89 e5                	mov    %esp,%ebp
    2d4b:	57                   	push   %edi
    2d4c:	56                   	push   %esi
    2d4d:	53                   	push   %ebx
    2d4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	u32_t space, granted_size, trail_size;

	space = (buf->size - 1) -
		z_ring_buf_custom_space_get(buf->size,
    2d51:	8b 53 0c             	mov    0xc(%ebx),%edx
    2d54:	8b 43 04             	mov    0x4(%ebx),%eax
	space = (buf->size - 1) -
    2d57:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
    2d5a:	39 d0                	cmp    %edx,%eax
		return head - tail - 1;
    2d5c:	8d 4a ff             	lea    -0x1(%edx),%ecx
	if (tail < head) {
    2d5f:	72 04                	jb     2d65 <ring_buf_get_claim+0x1d>
	return (size - tail) + head - 1;
    2d61:	8d 4c 16 ff          	lea    -0x1(%esi,%edx,1),%ecx
    2d65:	29 c1                	sub    %eax,%ecx
    2d67:	8d 46 ff             	lea    -0x1(%esi),%eax
    2d6a:	29 c8                	sub    %ecx,%eax

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
    2d6c:	89 f1                	mov    %esi,%ecx
    2d6e:	29 d1                	sub    %edx,%ecx
    2d70:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    2d73:	76 03                	jbe    2d78 <ring_buf_get_claim+0x30>
    2d75:	8b 4d 10             	mov    0x10(%ebp),%ecx
    2d78:	39 c8                	cmp    %ecx,%eax
    2d7a:	76 02                	jbe    2d7e <ring_buf_get_claim+0x36>
    2d7c:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
    2d7e:	8b 7b 14             	mov    0x14(%ebx),%edi
    2d81:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2d84:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_head =
		wrap(buf->misc.byte_mode.tmp_head + granted_size, buf->size);
    2d86:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
    2d88:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
    2d8a:	39 d6                	cmp    %edx,%esi
    2d8c:	77 02                	ja     2d90 <ring_buf_get_claim+0x48>
    2d8e:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_head =
    2d90:	89 53 0c             	mov    %edx,0xc(%ebx)

	return granted_size;
}
    2d93:	5b                   	pop    %ebx
    2d94:	5e                   	pop    %esi
    2d95:	5f                   	pop    %edi
    2d96:	5d                   	pop    %ebp
    2d97:	c3                   	ret    

00002d98 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, u32_t size)
{
    2d98:	55                   	push   %ebp
    2d99:	89 e5                	mov    %esp,%ebp
    2d9b:	57                   	push   %edi
    2d9c:	56                   	push   %esi
    2d9d:	8b 75 08             	mov    0x8(%ebp),%esi
    2da0:	53                   	push   %ebx
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
    2da1:	89 f0                	mov    %esi,%eax
{
    2da3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
    2da6:	e8 b7 fe ff ff       	call   2c62 <ring_buf_space_get>
    2dab:	8b 7e 10             	mov    0x10(%esi),%edi
    2dae:	8d 57 ff             	lea    -0x1(%edi),%edx
    2db1:	29 c2                	sub    %eax,%edx
    2db3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	if (size > allocated) {
    2db8:	39 da                	cmp    %ebx,%edx
    2dba:	72 11                	jb     2dcd <ring_buf_get_finish+0x35>
		return -EINVAL;
	}

	buf->head = wrap(buf->head + size, buf->size);
    2dbc:	8b 06                	mov    (%esi),%eax
    2dbe:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
    2dc0:	39 c7                	cmp    %eax,%edi
    2dc2:	77 02                	ja     2dc6 <ring_buf_get_finish+0x2e>
    2dc4:	29 f8                	sub    %edi,%eax
	buf->head = wrap(buf->head + size, buf->size);
    2dc6:	89 06                	mov    %eax,(%esi)
	buf->misc.byte_mode.tmp_head = buf->head;
    2dc8:	89 46 0c             	mov    %eax,0xc(%esi)

	return 0;
    2dcb:	31 c0                	xor    %eax,%eax
}
    2dcd:	5b                   	pop    %ebx
    2dce:	5e                   	pop    %esi
    2dcf:	5f                   	pop    %edi
    2dd0:	5d                   	pop    %ebp
    2dd1:	c3                   	ret    

00002dd2 <ring_buf_get>:

u32_t ring_buf_get(struct ring_buf *buf, u8_t *data, u32_t size)
{
    2dd2:	55                   	push   %ebp
    2dd3:	89 e5                	mov    %esp,%ebp
    2dd5:	57                   	push   %edi
    2dd6:	56                   	push   %esi
    2dd7:	53                   	push   %ebx
	u8_t *src;
	u32_t partial_size;
	u32_t total_size = 0U;
    2dd8:	31 db                	xor    %ebx,%ebx
{
    2dda:	51                   	push   %ecx
    2ddb:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
    2dde:	ff 75 10             	pushl  0x10(%ebp)
    2de1:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2de4:	50                   	push   %eax
    2de5:	ff 75 08             	pushl  0x8(%ebp)
    2de8:	e8 5b ff ff ff       	call   2d48 <ring_buf_get_claim>
    2ded:	83 c4 0c             	add    $0xc,%esp
		memcpy(data, src, partial_size);
    2df0:	50                   	push   %eax
		partial_size = ring_buf_get_claim(buf, &src, size);
    2df1:	89 c6                	mov    %eax,%esi
		memcpy(data, src, partial_size);
    2df3:	ff 75 f0             	pushl  -0x10(%ebp)
		total_size += partial_size;
    2df6:	01 f3                	add    %esi,%ebx
		memcpy(data, src, partial_size);
    2df8:	57                   	push   %edi
		size -= partial_size;
		data += partial_size;
    2df9:	01 f7                	add    %esi,%edi
		memcpy(data, src, partial_size);
    2dfb:	e8 31 7b 00 00       	call   a931 <memcpy>
    2e00:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
    2e03:	29 75 10             	sub    %esi,0x10(%ebp)
    2e06:	74 04                	je     2e0c <ring_buf_get+0x3a>
    2e08:	85 f6                	test   %esi,%esi
    2e0a:	75 d2                	jne    2dde <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
    2e0c:	53                   	push   %ebx
    2e0d:	ff 75 08             	pushl  0x8(%ebp)
    2e10:	e8 83 ff ff ff       	call   2d98 <ring_buf_get_finish>
    2e15:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    2e16:	89 d8                	mov    %ebx,%eax
	err = ring_buf_get_finish(buf, total_size);
    2e18:	5a                   	pop    %edx
}
    2e19:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2e1c:	5b                   	pop    %ebx
    2e1d:	5e                   	pop    %esi
    2e1e:	5f                   	pop    %edi
    2e1f:	5d                   	pop    %ebp
    2e20:	c3                   	ret    

00002e21 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_UNKNOWN, 1);

GEN_ABS_SYM_END
    2e21:	c3                   	ret    

00002e22 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
    2e22:	80 e2 08             	and    $0x8,%dl
    2e25:	74 0b                	je     2e32 <foldcase+0x10>
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    2e27:	8d 50 bf             	lea    -0x41(%eax),%edx
    2e2a:	83 fa 19             	cmp    $0x19,%edx
    2e2d:	77 03                	ja     2e32 <foldcase+0x10>
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
    2e2f:	83 c0 20             	add    $0x20,%eax
        return tolower(ch);
    return ch;
}
    2e32:	c3                   	ret    

00002e33 <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
    2e33:	55                   	push   %ebp
    2e34:	89 e5                	mov    %esp,%ebp
    2e36:	57                   	push   %edi
    2e37:	56                   	push   %esi
    2e38:	53                   	push   %ebx
    2e39:	83 ec 20             	sub    $0x20,%esp
    2e3c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
    2e3f:	85 c0                	test   %eax,%eax
    2e41:	74 04                	je     2e47 <fnmatchx+0x14>
    2e43:	85 d2                	test   %edx,%edx
    2e45:	75 0a                	jne    2e51 <fnmatchx+0x1e>
    {
        return FNM_NOMATCH;
    2e47:	b8 01 00 00 00       	mov    $0x1,%eax
    2e4c:	e9 33 03 00 00       	jmp    3184 <__data_num_words+0x184>
    2e51:	89 c3                	mov    %eax,%ebx
    }

    if (recursion-- == 0)
        return FNM_NORES;
    2e53:	b8 03 00 00 00       	mov    $0x3,%eax
    if (recursion-- == 0)
    2e58:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    2e5c:	0f 84 22 03 00 00    	je     3184 <__data_num_words+0x184>
    2e62:	89 cf                	mov    %ecx,%edi
    2e64:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    for (stringstart = string;;) {
        switch (c = FOLDCASE(*pattern++, flags)) {
    2e67:	8d 43 01             	lea    0x1(%ebx),%eax
    2e6a:	89 fa                	mov    %edi,%edx
    2e6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2e6f:	0f b6 03             	movzbl (%ebx),%eax
    2e72:	e8 ab ff ff ff       	call   2e22 <foldcase>
    2e77:	8a 16                	mov    (%esi),%dl
    2e79:	0f be c8             	movsbl %al,%ecx
    2e7c:	88 55 f3             	mov    %dl,-0xd(%ebp)
    2e7f:	3c 3f                	cmp    $0x3f,%al
    2e81:	74 43                	je     2ec6 <fnmatchx+0x93>
    2e83:	7f 12                	jg     2e97 <fnmatchx+0x64>
    2e85:	84 c0                	test   %al,%al
    2e87:	74 23                	je     2eac <fnmatchx+0x79>
    2e89:	3c 2a                	cmp    $0x2a,%al
    2e8b:	0f 85 da 02 00 00    	jne    316b <__data_num_words+0x16b>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
                return FNM_NOMATCH;
            ++string;
            break;
        case '*':
            c = FOLDCASE(*pattern, flags);
    2e91:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    2e95:	eb 7e                	jmp    2f15 <fnmatchx+0xe2>
        switch (c = FOLDCASE(*pattern++, flags)) {
    2e97:	3c 5b                	cmp    $0x5b,%al
    2e99:	0f 84 51 01 00 00    	je     2ff0 <fnmatchx+0x1bd>
    2e9f:	3c 5c                	cmp    $0x5c,%al
    2ea1:	0f 84 a4 02 00 00    	je     314b <__data_num_words+0x14b>
    2ea7:	e9 bf 02 00 00       	jmp    316b <__data_num_words+0x16b>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    2eac:	83 e7 10             	and    $0x10,%edi
    2eaf:	74 0c                	je     2ebd <fnmatchx+0x8a>
                return 0;
    2eb1:	31 c0                	xor    %eax,%eax
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    2eb3:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
    2eb7:	0f 84 c7 02 00 00    	je     3184 <__data_num_words+0x184>
            return *string == EOS ? 0 : FNM_NOMATCH;
    2ebd:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    2ec1:	e9 b4 00 00 00       	jmp    2f7a <fnmatchx+0x147>
            if (*string == EOS)
    2ec6:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    2eca:	0f 84 77 ff ff ff    	je     2e47 <fnmatchx+0x14>
            if (*string == '/' && (flags & FNM_PATHNAME))
    2ed0:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
    2ed4:	75 0d                	jne    2ee3 <fnmatchx+0xb0>
    2ed6:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2edc:	74 2e                	je     2f0c <fnmatchx+0xd9>
    2ede:	e9 64 ff ff ff       	jmp    2e47 <fnmatchx+0x14>
            if (*string == '.' && (flags & FNM_PERIOD) &&
    2ee3:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
    2ee7:	75 23                	jne    2f0c <fnmatchx+0xd9>
    2ee9:	f7 c7 04 00 00 00    	test   $0x4,%edi
    2eef:	74 1b                	je     2f0c <fnmatchx+0xd9>
    2ef1:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
    2ef4:	0f 84 4d ff ff ff    	je     2e47 <fnmatchx+0x14>
                (string == stringstart ||
    2efa:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2f00:	74 0a                	je     2f0c <fnmatchx+0xd9>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    2f02:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
    2f06:	0f 84 3b ff ff ff    	je     2e47 <fnmatchx+0x14>
            ++string;
    2f0c:	46                   	inc    %esi
                if (*string != '[')
                    return FNM_NOMATCH;
            } else
                pattern = r;
            ++string;
            break;
    2f0d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    2f10:	e9 52 ff ff ff       	jmp    2e67 <fnmatchx+0x34>
                c = FOLDCASE(*++pattern, flags);
    2f15:	89 fa                	mov    %edi,%edx
    2f17:	e8 06 ff ff ff       	call   2e22 <foldcase>
            while (c == '*')
    2f1c:	3c 2a                	cmp    $0x2a,%al
    2f1e:	75 0b                	jne    2f2b <fnmatchx+0xf8>
                c = FOLDCASE(*++pattern, flags);
    2f20:	ff 45 ec             	incl   -0x14(%ebp)
    2f23:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f26:	0f b6 00             	movzbl (%eax),%eax
    2f29:	eb ea                	jmp    2f15 <fnmatchx+0xe2>
            if (*string == '.' && (flags & FNM_PERIOD) &&
    2f2b:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
    2f2f:	75 23                	jne    2f54 <fnmatchx+0x121>
    2f31:	f7 c7 04 00 00 00    	test   $0x4,%edi
    2f37:	74 1b                	je     2f54 <fnmatchx+0x121>
    2f39:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
    2f3c:	0f 84 05 ff ff ff    	je     2e47 <fnmatchx+0x14>
                (string == stringstart ||
    2f42:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2f48:	74 0a                	je     2f54 <fnmatchx+0x121>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    2f4a:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
    2f4e:	0f 84 f3 fe ff ff    	je     2e47 <fnmatchx+0x14>
            if (c == EOS) {
    2f54:	84 c0                	test   %al,%al
    2f56:	75 2d                	jne    2f85 <fnmatchx+0x152>
                if (flags & FNM_PATHNAME)
    2f58:	89 f8                	mov    %edi,%eax
    2f5a:	83 e0 02             	and    $0x2,%eax
    2f5d:	0f 84 21 02 00 00    	je     3184 <__data_num_words+0x184>
                return 0;
    2f63:	31 c0                	xor    %eax,%eax
                        0 : FNM_NOMATCH;
    2f65:	83 e7 10             	and    $0x10,%edi
    2f68:	0f 85 16 02 00 00    	jne    3184 <__data_num_words+0x184>
                        strchr(string, '/') == NULL ?
    2f6e:	6a 2f                	push   $0x2f
    2f70:	56                   	push   %esi
    2f71:	e8 b3 78 00 00       	call   a829 <strchr>
    2f76:	5e                   	pop    %esi
                        0 : FNM_NOMATCH;
    2f77:	85 c0                	test   %eax,%eax
                        strchr(string, '/') == NULL ?
    2f79:	5f                   	pop    %edi
                        0 : FNM_NOMATCH;
    2f7a:	0f 95 c0             	setne  %al
    2f7d:	0f b6 c0             	movzbl %al,%eax
    2f80:	e9 ff 01 00 00       	jmp    3184 <__data_num_words+0x184>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    2f85:	3c 2f                	cmp    $0x2f,%al
    2f87:	75 45                	jne    2fce <fnmatchx+0x19b>
    2f89:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2f8f:	74 3d                	je     2fce <fnmatchx+0x19b>
                if ((string = strchr(string, '/')) == NULL)
    2f91:	6a 2f                	push   $0x2f
    2f93:	56                   	push   %esi
    2f94:	e8 90 78 00 00       	call   a829 <strchr>
    2f99:	59                   	pop    %ecx
    2f9a:	89 c6                	mov    %eax,%esi
    2f9c:	5b                   	pop    %ebx
    2f9d:	85 c0                	test   %eax,%eax
    2f9f:	0f 85 68 ff ff ff    	jne    2f0d <fnmatchx+0xda>
    2fa5:	e9 9d fe ff ff       	jmp    2e47 <fnmatchx+0x14>
    if (recursion-- == 0)
    2faa:	8b 45 08             	mov    0x8(%ebp),%eax
                switch ((e = fnmatchx(pattern, string,
    2fad:	89 f9                	mov    %edi,%ecx
    if (recursion-- == 0)
    2faf:	48                   	dec    %eax
                switch ((e = fnmatchx(pattern, string,
    2fb0:	83 e1 fb             	and    $0xfffffffb,%ecx
    2fb3:	50                   	push   %eax
    2fb4:	89 f2                	mov    %esi,%edx
    2fb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2fb9:	e8 75 fe ff ff       	call   2e33 <fnmatchx>
    2fbe:	5a                   	pop    %edx
    2fbf:	83 f8 01             	cmp    $0x1,%eax
    2fc2:	0f 85 bc 01 00 00    	jne    3184 <__data_num_words+0x184>
                if (test == '/' && flags & FNM_PATHNAME)
    2fc8:	80 fb 2f             	cmp    $0x2f,%bl
    2fcb:	74 16                	je     2fe3 <fnmatchx+0x1b0>
                ++string;
    2fcd:	46                   	inc    %esi
            while ((test = FOLDCASE(*string, flags)) != EOS) {
    2fce:	0f b6 06             	movzbl (%esi),%eax
    2fd1:	89 fa                	mov    %edi,%edx
    2fd3:	e8 4a fe ff ff       	call   2e22 <foldcase>
    2fd8:	89 c3                	mov    %eax,%ebx
    2fda:	84 c0                	test   %al,%al
    2fdc:	75 cc                	jne    2faa <fnmatchx+0x177>
    2fde:	e9 64 fe ff ff       	jmp    2e47 <fnmatchx+0x14>
                if (test == '/' && flags & FNM_PATHNAME)
    2fe3:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2fe9:	74 e2                	je     2fcd <fnmatchx+0x19a>
    2feb:	e9 57 fe ff ff       	jmp    2e47 <fnmatchx+0x14>
            if (*string == EOS)
    2ff0:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    2ff4:	0f 84 4d fe ff ff    	je     2e47 <fnmatchx+0x14>
            if (*string == '/' && flags & FNM_PATHNAME)
    2ffa:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
    2ffe:	75 0c                	jne    300c <__data_num_words+0xc>
    3000:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3006:	0f 85 3b fe ff ff    	jne    2e47 <fnmatchx+0x14>
            if ((r = rangematch(pattern,
    300c:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    3010:	89 fa                	mov    %edi,%edx
    3012:	e8 0b fe ff ff       	call   2e22 <foldcase>
    if (pattern == NULL)
    3017:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
            if ((r = rangematch(pattern,
    301b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (pattern == NULL)
    301e:	0f 84 23 fe ff ff    	je     2e47 <fnmatchx+0x14>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    3024:	8a 43 01             	mov    0x1(%ebx),%al
    3027:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    302a:	3c 21                	cmp    $0x21,%al
    302c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    302f:	0f 94 c2             	sete   %dl
    3032:	3c 5e                	cmp    $0x5e,%al
    3034:	0f 94 c0             	sete   %al
    3037:	08 c2                	or     %al,%dl
    3039:	88 55 f2             	mov    %dl,-0xe(%ebp)
    303c:	74 06                	je     3044 <__data_num_words+0x44>
        ++pattern;
    303e:	8d 43 02             	lea    0x2(%ebx),%eax
    3041:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    3044:	89 f8                	mov    %edi,%eax
            ok = 1;
    3046:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    304d:	83 e0 01             	and    $0x1,%eax
            ok = 1;
    3050:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    3057:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
    305a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    305d:	89 fa                	mov    %edi,%edx
    305f:	8d 48 01             	lea    0x1(%eax),%ecx
    3062:	0f b6 00             	movzbl (%eax),%eax
    3065:	e8 b8 fd ff ff       	call   2e22 <foldcase>
    306a:	0f be d8             	movsbl %al,%ebx
    306d:	3c 5d                	cmp    $0x5d,%al
    306f:	0f 84 a0 00 00 00    	je     3115 <__data_num_words+0x115>
        if (c == '/')
    3075:	3c 2f                	cmp    $0x2f,%al
    3077:	0f 84 b8 00 00 00    	je     3135 <__data_num_words+0x135>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    307d:	3c 5c                	cmp    $0x5c,%al
    307f:	75 1a                	jne    309b <__data_num_words+0x9b>
    3081:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    3085:	75 1c                	jne    30a3 <__data_num_words+0xa3>
            c = FOLDCASE(*pattern++, flags);
    3087:	8b 45 e8             	mov    -0x18(%ebp),%eax
    308a:	89 fa                	mov    %edi,%edx
    308c:	8d 48 02             	lea    0x2(%eax),%ecx
    308f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3093:	e8 8a fd ff ff       	call   2e22 <foldcase>
    3098:	0f be d8             	movsbl %al,%ebx
        if (c == EOS)
    309b:	84 db                	test   %bl,%bl
    309d:	0f 84 a4 fd ff ff    	je     2e47 <fnmatchx+0x14>
        if (*pattern == '-' 
    30a3:	80 39 2d             	cmpb   $0x2d,(%ecx)
    30a6:	75 52                	jne    30fa <__data_num_words+0xfa>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
    30a8:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
    30ac:	89 fa                	mov    %edi,%edx
    30ae:	e8 6f fd ff ff       	call   2e22 <foldcase>
    30b3:	88 45 d8             	mov    %al,-0x28(%ebp)
    30b6:	3c 5d                	cmp    $0x5d,%al
    30b8:	74 40                	je     30fa <__data_num_words+0xfa>
    30ba:	84 c0                	test   %al,%al
    30bc:	74 3c                	je     30fa <__data_num_words+0xfa>
            pattern += 2;
    30be:	8d 51 02             	lea    0x2(%ecx),%edx
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
    30c1:	3c 5c                	cmp    $0x5c,%al
            pattern += 2;
    30c3:	89 55 e8             	mov    %edx,-0x18(%ebp)
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
    30c6:	75 22                	jne    30ea <__data_num_words+0xea>
    30c8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    30cc:	75 1c                	jne    30ea <__data_num_words+0xea>
                c2 = FOLDCASE(*pattern++, flags);
    30ce:	8d 41 03             	lea    0x3(%ecx),%eax
    30d1:	89 fa                	mov    %edi,%edx
    30d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    30d6:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    30da:	e8 43 fd ff ff       	call   2e22 <foldcase>
    30df:	88 45 d8             	mov    %al,-0x28(%ebp)
            if (c2 == EOS)
    30e2:	84 c0                	test   %al,%al
    30e4:	0f 84 5d fd ff ff    	je     2e47 <fnmatchx+0x14>
            if (c <= test && test <= c2)
    30ea:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
    30ed:	7c 1a                	jl     3109 <__data_num_words+0x109>
    30ef:	0f be 55 d8          	movsbl -0x28(%ebp),%edx
    30f3:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    30f6:	7f 11                	jg     3109 <__data_num_words+0x109>
    30f8:	eb 08                	jmp    3102 <__data_num_words+0x102>
        } else if (c == test)
    30fa:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    30fd:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
    3100:	75 07                	jne    3109 <__data_num_words+0x109>
            ok = 1;
    3102:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
    3109:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    3110:	e9 45 ff ff ff       	jmp    305a <__data_num_words+0x5a>
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
    3115:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    3119:	75 88                	jne    30a3 <__data_num_words+0xa3>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    311b:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
            if ((r = rangematch(pattern,
    311f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
    3122:	0f 84 1f fd ff ff    	je     2e47 <fnmatchx+0x14>
    3128:	85 c9                	test   %ecx,%ecx
    312a:	0f 84 17 fd ff ff    	je     2e47 <fnmatchx+0x14>
            if (r == (void *)-1) {
    3130:	83 f9 ff             	cmp    $0xffffffff,%ecx
    3133:	75 0d                	jne    3142 <__data_num_words+0x142>
                if (*string != '[')
    3135:	80 7d f3 5b          	cmpb   $0x5b,-0xd(%ebp)
    3139:	0f 85 08 fd ff ff    	jne    2e47 <fnmatchx+0x14>
    313f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
            ++string;
    3142:	46                   	inc    %esi
            break;
    3143:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    3146:	e9 c2 fd ff ff       	jmp    2f0d <fnmatchx+0xda>
        case '\\':
            if (!(flags & FNM_NOESCAPE)) {
    314b:	f7 c7 01 00 00 00    	test   $0x1,%edi
    3151:	75 18                	jne    316b <__data_num_words+0x16b>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
    3153:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    3157:	89 fa                	mov    %edi,%edx
    3159:	e8 c4 fc ff ff       	call   2e22 <foldcase>
    315e:	0f be c8             	movsbl %al,%ecx
    3161:	84 c0                	test   %al,%al
    3163:	74 06                	je     316b <__data_num_words+0x16b>
    3165:	8d 43 02             	lea    0x2(%ebx),%eax
    3168:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    --pattern;
                }
            }
            /* FALLTHROUGH */
        default:
            if (c != FOLDCASE(*string++, flags))
    316b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    316f:	89 fa                	mov    %edi,%edx
    3171:	46                   	inc    %esi
    3172:	e8 ab fc ff ff       	call   2e22 <foldcase>
    3177:	39 c1                	cmp    %eax,%ecx
    3179:	0f 84 8e fd ff ff    	je     2f0d <fnmatchx+0xda>
    317f:	e9 c3 fc ff ff       	jmp    2e47 <fnmatchx+0x14>
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
    3184:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3187:	5b                   	pop    %ebx
    3188:	5e                   	pop    %esi
    3189:	5f                   	pop    %edi
    318a:	5d                   	pop    %ebp
    318b:	c3                   	ret    

0000318c <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    318c:	55                   	push   %ebp
    318d:	89 e5                	mov    %esp,%ebp
    318f:	8b 45 08             	mov    0x8(%ebp),%eax
    return fnmatchx(pattern, string, flags, 64);
    3192:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3195:	8b 55 0c             	mov    0xc(%ebp),%edx
    3198:	c7 45 08 40 00 00 00 	movl   $0x40,0x8(%ebp)
}
    319f:	5d                   	pop    %ebp
    return fnmatchx(pattern, string, flags, 64);
    31a0:	e9 8e fc ff ff       	jmp    2e33 <fnmatchx>

000031a5 <log_list_init>:
 */

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
    31a5:	55                   	push   %ebp
    31a6:	89 e5                	mov    %esp,%ebp
    31a8:	8b 45 08             	mov    0x8(%ebp),%eax
	list->tail = NULL;
    31ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = NULL;
    31b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    31b8:	5d                   	pop    %ebp
    31b9:	c3                   	ret    

000031ba <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
    31ba:	55                   	push   %ebp
    31bb:	89 e5                	mov    %esp,%ebp
    31bd:	8b 55 08             	mov    0x8(%ebp),%edx
    31c0:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (list->head == NULL) {
    31c3:	83 3a 00             	cmpl   $0x0,(%edx)
    31c6:	75 04                	jne    31cc <log_list_add_tail+0x12>
		list->head = msg;
    31c8:	89 02                	mov    %eax,(%edx)
    31ca:	eb 05                	jmp    31d1 <log_list_add_tail+0x17>
	} else {
		list->tail->next = msg;
    31cc:	8b 4a 04             	mov    0x4(%edx),%ecx
    31cf:	89 01                	mov    %eax,(%ecx)
	}

	list->tail = msg;
    31d1:	89 42 04             	mov    %eax,0x4(%edx)
	msg->next = NULL;
    31d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    31da:	5d                   	pop    %ebp
    31db:	c3                   	ret    

000031dc <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
    31dc:	55                   	push   %ebp
    31dd:	89 e5                	mov    %esp,%ebp
	return list->head;
    31df:	8b 45 08             	mov    0x8(%ebp),%eax
}
    31e2:	5d                   	pop    %ebp
	return list->head;
    31e3:	8b 00                	mov    (%eax),%eax
}
    31e5:	c3                   	ret    

000031e6 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    31e6:	55                   	push   %ebp
    31e7:	89 e5                	mov    %esp,%ebp
    31e9:	8b 55 08             	mov    0x8(%ebp),%edx
	struct log_msg *msg = list->head;
    31ec:	8b 02                	mov    (%edx),%eax

	if (list->head != NULL) {
    31ee:	85 c0                	test   %eax,%eax
    31f0:	74 04                	je     31f6 <log_list_head_get+0x10>
		list->head = list->head->next;
    31f2:	8b 08                	mov    (%eax),%ecx
    31f4:	89 0a                	mov    %ecx,(%edx)
	}

	return msg;
}
    31f6:	5d                   	pop    %ebp
    31f7:	c3                   	ret    

000031f8 <dummy_timestamp>:
static timestamp_get_t timestamp_func = dummy_timestamp;

static u32_t dummy_timestamp(void)
{
	return 0;
}
    31f8:	31 c0                	xor    %eax,%eax
    31fa:	c3                   	ret    

000031fb <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    31fb:	55                   	push   %ebp
    31fc:	89 e5                	mov    %esp,%ebp
    31fe:	50                   	push   %eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    31ff:	6a 00                	push   $0x0
    3201:	8d 45 fc             	lea    -0x4(%ebp),%eax
	union log_msg_chunk *msg = NULL;
    3204:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    320b:	50                   	push   %eax
    320c:	68 a0 02 40 00       	push   $0x4002a0
    3211:	e8 b7 fc 01 00       	call   22ecd <k_mem_slab_alloc>
    3216:	83 c4 0c             	add    $0xc,%esp
	if (err != 0) {
    3219:	85 c0                	test   %eax,%eax
    321b:	74 08                	je     3225 <z_log_msg_std_alloc+0x2a>
		msg = log_msg_no_space_handle();
    321d:	e8 e0 07 00 00       	call   3a02 <log_msg_no_space_handle>
    3222:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return msg;
    3225:	8b 45 fc             	mov    -0x4(%ebp),%eax
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();

	if (msg != NULL) {
    3228:	85 c0                	test   %eax,%eax
    322a:	74 0d                	je     3239 <z_log_msg_std_alloc+0x3e>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    322c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0;
    3233:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
    3239:	c9                   	leave  
    323a:	c3                   	ret    

0000323b <timestamp_get>:
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    323b:	e9 b2 16 02 00       	jmp    248f2 <z_impl_k_uptime_get_32>

00003240 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    3240:	55                   	push   %ebp
    3241:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
    3243:	6a 00                	push   $0x0
    3245:	6a 00                	push   $0x0
    3247:	6a 0e                	push   $0xe
    3249:	6a 00                	push   $0x0
    324b:	6a 00                	push   $0x0
    324d:	6a 00                	push   $0x0
    324f:	68 af 37 00 00       	push   $0x37af
    3254:	68 00 03 00 00       	push   $0x300
    3259:	68 70 51 40 00       	push   $0x405170
    325e:	68 20 02 40 00       	push   $0x400220
    3263:	e8 b4 0f 02 00       	call   2421c <z_impl_k_thread_create>
    3268:	83 c4 28             	add    $0x28,%esp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
    326b:	68 c6 6c 02 00       	push   $0x26cc6
    3270:	68 20 02 40 00       	push   $0x400220
    3275:	e8 25 0f 02 00       	call   2419f <z_impl_k_thread_name_set>
    327a:	58                   	pop    %eax
	} else {
		log_init();
	}

	return 0;
}
    327b:	31 c0                	xor    %eax,%eax
    327d:	5a                   	pop    %edx
    327e:	c9                   	leave  
    327f:	c3                   	ret    

00003280 <log_core_init>:
{
    3280:	55                   	push   %ebp
    3281:	89 e5                	mov    %esp,%ebp
    3283:	53                   	push   %ebx
		log_msg_pool_init();
    3284:	e8 52 07 00 00       	call   39db <log_msg_pool_init>
		log_list_init(&list);
    3289:	68 e0 41 40 00       	push   $0x4041e0
    328e:	e8 12 ff ff ff       	call   31a5 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    3293:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    329a:	6a 34                	push   $0x34
    329c:	68 70 54 40 00       	push   $0x405470
    32a1:	68 60 02 40 00       	push   $0x400260
    32a6:	e8 cf fb 01 00       	call   22e7a <k_mem_slab_init>
    32ab:	83 c4 10             	add    $0x10,%esp
	timestamp_func = timestamp_get;
    32ae:	c7 05 30 a6 40 00 3b 	movl   $0x323b,0x40a630
    32b5:	32 00 00 
	log_output_timestamp_freq_set(freq);
    32b8:	68 e8 03 00 00       	push   $0x3e8
    32bd:	e8 44 11 00 00       	call   4406 <log_output_timestamp_freq_set>
    32c2:	ba 84 52 02 00       	mov    $0x25284,%edx
    32c7:	58                   	pop    %eax
    32c8:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
		for (int i = 0; i < log_sources_count(); i++) {
    32ce:	31 c0                	xor    %eax,%eax
    32d0:	c1 ea 03             	shr    $0x3,%edx
    32d3:	39 d0                	cmp    %edx,%eax
    32d5:	74 20                	je     32f7 <log_core_init+0x77>
			LOG_FILTER_SLOT_SET(filters,
    32d7:	8b 0c 85 5c a8 40 00 	mov    0x40a85c(,%eax,4),%ecx
    32de:	8a 1c c5 40 51 02 00 	mov    0x25140(,%eax,8),%bl
    32e5:	83 e1 f8             	and    $0xfffffff8,%ecx
    32e8:	83 e3 07             	and    $0x7,%ebx
    32eb:	09 d9                	or     %ebx,%ecx
    32ed:	89 0c 85 5c a8 40 00 	mov    %ecx,0x40a85c(,%eax,4)
		for (int i = 0; i < log_sources_count(); i++) {
    32f4:	40                   	inc    %eax
    32f5:	eb dc                	jmp    32d3 <log_core_init+0x53>
}
    32f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    32fa:	c9                   	leave  
    32fb:	c3                   	ret    

000032fc <dropped_notify>:
{
    32fc:	55                   	push   %ebp
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    32fd:	31 c0                	xor    %eax,%eax
    32ff:	89 e5                	mov    %esp,%ebp
    3301:	57                   	push   %edi
    3302:	56                   	push   %esi
    3303:	53                   	push   %ebx
    3304:	51                   	push   %ecx
    3305:	87 05 d4 41 40 00    	xchg   %eax,0x4041d4
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    330b:	bb 94 52 02 00       	mov    $0x25294,%ebx
    3310:	be 84 52 02 00       	mov    $0x25284,%esi
    3315:	81 eb 84 52 02 00    	sub    $0x25284,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
    331b:	31 ff                	xor    %edi,%edi
    331d:	c1 fb 04             	sar    $0x4,%ebx
    3320:	39 df                	cmp    %ebx,%edi
    3322:	7d 24                	jge    3348 <dropped_notify+0x4c>
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend);
	return backend->cb->active;
    3324:	8b 56 04             	mov    0x4(%esi),%edx
		if (log_backend_is_active(backend)) {
    3327:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    332b:	74 15                	je     3342 <dropped_notify+0x46>
	if (backend->api->dropped != NULL) {
    332d:	8b 16                	mov    (%esi),%edx
    332f:	8b 52 0c             	mov    0xc(%edx),%edx
    3332:	85 d2                	test   %edx,%edx
    3334:	74 0c                	je     3342 <dropped_notify+0x46>
		backend->api->dropped(backend, cnt);
    3336:	50                   	push   %eax
    3337:	89 45 f0             	mov    %eax,-0x10(%ebp)
    333a:	56                   	push   %esi
    333b:	ff d2                	call   *%edx
    333d:	58                   	pop    %eax
    333e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3341:	5a                   	pop    %edx
	for (int i = 0; i < log_backend_count_get(); i++) {
    3342:	47                   	inc    %edi
    3343:	83 c6 10             	add    $0x10,%esi
    3346:	eb d8                	jmp    3320 <dropped_notify+0x24>
}
    3348:	8d 65 f4             	lea    -0xc(%ebp),%esp
    334b:	5b                   	pop    %ebx
    334c:	5e                   	pop    %esi
    334d:	5f                   	pop    %edi
    334e:	5d                   	pop    %ebp
    334f:	c3                   	ret    

00003350 <log_process>:
{
    3350:	55                   	push   %ebp
    3351:	89 e5                	mov    %esp,%ebp
    3353:	57                   	push   %edi
    3354:	56                   	push   %esi
    3355:	53                   	push   %ebx
    3356:	83 ec 08             	sub    $0x8,%esp
    3359:	8b 45 08             	mov    0x8(%ebp),%eax
    335c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!backend_attached && !bypass) {
    335f:	8a 45 f0             	mov    -0x10(%ebp),%al
    3362:	0a 05 56 45 40 00    	or     0x404556,%al
    3368:	0f 84 b0 00 00 00    	je     341e <log_process+0xce>
	__asm__ volatile (
    336e:	9c                   	pushf  
    336f:	fa                   	cli    
    3370:	5e                   	pop    %esi
	msg = log_list_head_get(&list);
    3371:	68 e0 41 40 00       	push   $0x4041e0
    3376:	e8 6b fe ff ff       	call   31e6 <log_list_head_get>
    337b:	5a                   	pop    %edx
    337c:	89 c3                	mov    %eax,%ebx
    337e:	0f ba e6 09          	bt     $0x9,%esi
    3382:	73 01                	jae    3385 <log_process+0x35>
	__asm__ volatile (
    3384:	fb                   	sti    
	if (msg != NULL) {
    3385:	85 db                	test   %ebx,%ebx
    3387:	74 71                	je     33fa <log_process+0xaa>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    3389:	f0 ff 0d d8 41 40 00 	lock decl 0x4041d8
	if (!bypass) {
    3390:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
    3394:	74 09                	je     339f <log_process+0x4f>
	log_msg_put(msg);
    3396:	53                   	push   %ebx
    3397:	e8 bd 07 00 00       	call   3b59 <log_msg_put>
    339c:	58                   	pop    %eax
    339d:	eb 5b                	jmp    33fa <log_process+0xaa>
	return __log_backends_end - __log_backends_start;
    339f:	b8 94 52 02 00       	mov    $0x25294,%eax
    33a4:	be 84 52 02 00       	mov    $0x25284,%esi
    33a9:	2d 84 52 02 00       	sub    $0x25284,%eax
		for (int i = 0; i < log_backend_count_get(); i++) {
    33ae:	31 ff                	xor    %edi,%edi
    33b0:	c1 f8 04             	sar    $0x4,%eax
    33b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    33b6:	3b 7d ec             	cmp    -0x14(%ebp),%edi
    33b9:	7d db                	jge    3396 <log_process+0x46>
			if (log_backend_is_active(backend) &&
    33bb:	8b 4e 04             	mov    0x4(%esi),%ecx
    33be:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
    33c2:	74 30                	je     33f4 <log_process+0xa4>
	return msg->hdr.ids.source_id;
    33c4:	66 8b 43 0a          	mov    0xa(%ebx),%ax
	return msg->hdr.ids.level;
    33c8:	8a 53 0a             	mov    0xa(%ebx),%dl
	return msg->hdr.ids.source_id;
    33cb:	66 c1 e8 06          	shr    $0x6,%ax
	return msg->hdr.ids.level;
    33cf:	83 e2 07             	and    $0x7,%edx
		return LOG_FILTER_SLOT_GET(filters,
    33d2:	0f b6 49 04          	movzbl 0x4(%ecx),%ecx
	return msg->hdr.ids.source_id;
    33d6:	0f b7 c0             	movzwl %ax,%eax
    33d9:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
    33dc:	8b 04 85 5c a8 40 00 	mov    0x40a85c(,%eax,4),%eax
    33e3:	d3 e8                	shr    %cl,%eax
    33e5:	83 e0 07             	and    $0x7,%eax
			if (log_backend_is_active(backend) &&
    33e8:	39 c2                	cmp    %eax,%edx
    33ea:	77 08                	ja     33f4 <log_process+0xa4>
	backend->api->put(backend, msg);
    33ec:	8b 06                	mov    (%esi),%eax
    33ee:	53                   	push   %ebx
    33ef:	56                   	push   %esi
    33f0:	ff 10                	call   *(%eax)
    33f2:	59                   	pop    %ecx
    33f3:	58                   	pop    %eax
		for (int i = 0; i < log_backend_count_get(); i++) {
    33f4:	47                   	inc    %edi
    33f5:	83 c6 10             	add    $0x10,%esi
    33f8:	eb bc                	jmp    33b6 <log_process+0x66>
	if (!bypass && dropped_cnt) {
    33fa:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
    33fe:	75 0e                	jne    340e <log_process+0xbe>
    3400:	83 3d d4 41 40 00 00 	cmpl   $0x0,0x4041d4
    3407:	74 05                	je     340e <log_process+0xbe>
		dropped_notify();
    3409:	e8 ee fe ff ff       	call   32fc <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    340e:	68 e0 41 40 00       	push   $0x4041e0
    3413:	e8 c4 fd ff ff       	call   31dc <log_list_head_peek>
    3418:	5a                   	pop    %edx
    3419:	85 c0                	test   %eax,%eax
    341b:	0f 95 c0             	setne  %al
}
    341e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3421:	5b                   	pop    %ebx
    3422:	5e                   	pop    %esi
    3423:	5f                   	pop    %edi
    3424:	5d                   	pop    %ebp
    3425:	c3                   	ret    

00003426 <msg_finalize>:
{
    3426:	55                   	push   %ebp
    3427:	89 e5                	mov    %esp,%ebp
    3429:	56                   	push   %esi
    342a:	53                   	push   %ebx
	msg->hdr.ids = src_level;
    342b:	66 89 50 0a          	mov    %dx,0xa(%eax)
{
    342f:	89 c3                	mov    %eax,%ebx
	msg->hdr.timestamp = timestamp_func();
    3431:	ff 15 30 a6 40 00    	call   *0x40a630
    3437:	89 43 0c             	mov    %eax,0xc(%ebx)
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    343a:	f0 ff 05 d8 41 40 00 	lock incl 0x4041d8
	__asm__ volatile (
    3441:	9c                   	pushf  
    3442:	fa                   	cli    
    3443:	5e                   	pop    %esi
	log_list_add_tail(&list, msg);
    3444:	53                   	push   %ebx
    3445:	68 e0 41 40 00       	push   $0x4041e0
    344a:	e8 6b fd ff ff       	call   31ba <log_list_add_tail>
    344f:	0f ba e6 09          	bt     $0x9,%esi
    3453:	5a                   	pop    %edx
    3454:	59                   	pop    %ecx
    3455:	73 01                	jae    3458 <msg_finalize+0x32>
	__asm__ volatile (
    3457:	fb                   	sti    
	if (panic_mode) {
    3458:	80 3d 57 45 40 00 00 	cmpb   $0x0,0x404557
    345f:	74 09                	je     346a <msg_finalize+0x44>
		(void)log_process(false);
    3461:	6a 00                	push   $0x0
    3463:	e8 e8 fe ff ff       	call   3350 <log_process>
    3468:	eb 18                	jmp    3482 <msg_finalize+0x5c>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    346a:	83 3d d8 41 40 00 0a 	cmpl   $0xa,0x4041d8
    3471:	75 10                	jne    3483 <msg_finalize+0x5d>
		    (proc_tid != NULL)) {
    3473:	a1 d0 41 40 00       	mov    0x4041d0,%eax
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    3478:	85 c0                	test   %eax,%eax
    347a:	74 07                	je     3483 <msg_finalize+0x5d>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
    347c:	50                   	push   %eax
    347d:	e8 dc 0a 02 00       	call   23f5e <z_impl_k_wakeup>
    3482:	58                   	pop    %eax
}
    3483:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3486:	5b                   	pop    %ebx
    3487:	5e                   	pop    %esi
    3488:	5d                   	pop    %ebp
    3489:	c3                   	ret    

0000348a <log_0>:
{
    348a:	55                   	push   %ebp
    348b:	89 e5                	mov    %esp,%ebp
    348d:	56                   	push   %esi
    348e:	53                   	push   %ebx
    348f:	8b 75 08             	mov    0x8(%ebp),%esi
    3492:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    3495:	e8 61 fd ff ff       	call   31fb <z_log_msg_std_alloc>

	if (msg != NULL) {
    349a:	85 c0                	test   %eax,%eax
    349c:	74 0d                	je     34ab <log_0+0x21>
		msg->str = str;
    349e:	89 70 10             	mov    %esi,0x10(%eax)
	msg_finalize(msg, src_level);
    34a1:	89 da                	mov    %ebx,%edx
}
    34a3:	5b                   	pop    %ebx
    34a4:	5e                   	pop    %esi
    34a5:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
    34a6:	e9 7b ff ff ff       	jmp    3426 <msg_finalize>
}
    34ab:	5b                   	pop    %ebx
    34ac:	5e                   	pop    %esi
    34ad:	5d                   	pop    %ebp
    34ae:	c3                   	ret    

000034af <log_1>:
{
    34af:	55                   	push   %ebp
    34b0:	89 e5                	mov    %esp,%ebp
    34b2:	57                   	push   %edi
    34b3:	56                   	push   %esi
    34b4:	53                   	push   %ebx
    34b5:	8b 7d 08             	mov    0x8(%ebp),%edi
    34b8:	8b 75 0c             	mov    0xc(%ebp),%esi
    34bb:	8b 5d 10             	mov    0x10(%ebp),%ebx
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       u32_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    34be:	e8 38 fd ff ff       	call   31fb <z_log_msg_std_alloc>

	if (msg != NULL) {
    34c3:	85 c0                	test   %eax,%eax
    34c5:	74 1d                	je     34e4 <log_1+0x35>
		msg->str = str;
		msg->hdr.params.std.nargs = 1;
    34c7:	8a 48 09             	mov    0x9(%eax),%cl
		msg->str = str;
    34ca:	89 78 10             	mov    %edi,0x10(%eax)
		msg->hdr.params.std.nargs = 1;
    34cd:	83 e1 0f             	and    $0xf,%ecx
		msg->payload.single.args[0] = arg1;
    34d0:	89 70 14             	mov    %esi,0x14(%eax)
		msg->hdr.params.std.nargs = 1;
    34d3:	83 c9 10             	or     $0x10,%ecx
	msg_finalize(msg, src_level);
    34d6:	89 da                	mov    %ebx,%edx
    34d8:	88 48 09             	mov    %cl,0x9(%eax)
}
    34db:	5b                   	pop    %ebx
    34dc:	5e                   	pop    %esi
    34dd:	5f                   	pop    %edi
    34de:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
    34df:	e9 42 ff ff ff       	jmp    3426 <msg_finalize>
}
    34e4:	5b                   	pop    %ebx
    34e5:	5e                   	pop    %esi
    34e6:	5f                   	pop    %edi
    34e7:	5d                   	pop    %ebp
    34e8:	c3                   	ret    

000034e9 <log_2>:
{
    34e9:	55                   	push   %ebp
    34ea:	89 e5                	mov    %esp,%ebp
    34ec:	57                   	push   %edi
    34ed:	56                   	push   %esi
    34ee:	53                   	push   %ebx
    34ef:	53                   	push   %ebx
    34f0:	8b 55 14             	mov    0x14(%ebp),%edx
    34f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
    34f6:	8b 7d 0c             	mov    0xc(%ebp),%edi
    34f9:	8b 75 10             	mov    0x10(%ebp),%esi
    34fc:	89 55 f0             	mov    %edx,-0x10(%ebp)
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       u32_t arg1,
					       u32_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    34ff:	e8 f7 fc ff ff       	call   31fb <z_log_msg_std_alloc>

	if (msg != NULL) {
    3504:	85 c0                	test   %eax,%eax
    3506:	74 22                	je     352a <log_2+0x41>
		msg->str = str;
		msg->hdr.params.std.nargs = 2;
    3508:	8a 48 09             	mov    0x9(%eax),%cl
		msg->str = str;
    350b:	89 58 10             	mov    %ebx,0x10(%eax)
		msg->hdr.params.std.nargs = 2;
    350e:	83 e1 0f             	and    $0xf,%ecx
		msg->payload.single.args[0] = arg1;
    3511:	89 78 14             	mov    %edi,0x14(%eax)
		msg->hdr.params.std.nargs = 2;
    3514:	83 c9 20             	or     $0x20,%ecx
		msg->payload.single.args[1] = arg2;
    3517:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 2;
    351a:	88 48 09             	mov    %cl,0x9(%eax)
	msg_finalize(msg, src_level);
    351d:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
    3520:	59                   	pop    %ecx
    3521:	5b                   	pop    %ebx
    3522:	5e                   	pop    %esi
    3523:	5f                   	pop    %edi
    3524:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
    3525:	e9 fc fe ff ff       	jmp    3426 <msg_finalize>
}
    352a:	58                   	pop    %eax
    352b:	5b                   	pop    %ebx
    352c:	5e                   	pop    %esi
    352d:	5f                   	pop    %edi
    352e:	5d                   	pop    %ebp
    352f:	c3                   	ret    

00003530 <log_3>:
{
    3530:	55                   	push   %ebp
    3531:	89 e5                	mov    %esp,%ebp
    3533:	57                   	push   %edi
    3534:	56                   	push   %esi
    3535:	53                   	push   %ebx
    3536:	83 ec 08             	sub    $0x8,%esp
    3539:	8b 55 08             	mov    0x8(%ebp),%edx
    353c:	8b 45 18             	mov    0x18(%ebp),%eax
    353f:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3542:	8b 7d 0c             	mov    0xc(%ebp),%edi
    3545:	8b 75 10             	mov    0x10(%ebp),%esi
    3548:	8b 5d 14             	mov    0x14(%ebp),%ebx
    354b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
static inline struct log_msg *log_msg_create_3(const char *str,
					       u32_t arg1,
					       u32_t arg2,
					       u32_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    354f:	e8 a7 fc ff ff       	call   31fb <z_log_msg_std_alloc>

	if (msg != NULL) {
    3554:	85 c0                	test   %eax,%eax
    3556:	74 2a                	je     3582 <log_3+0x52>
		msg->str = str;
    3558:	8b 55 ec             	mov    -0x14(%ebp),%edx
		msg->hdr.params.std.nargs = 3;
		msg->payload.single.args[0] = arg1;
    355b:	89 78 14             	mov    %edi,0x14(%eax)
		msg->str = str;
    355e:	89 50 10             	mov    %edx,0x10(%eax)
		msg->hdr.params.std.nargs = 3;
    3561:	8a 50 09             	mov    0x9(%eax),%dl
    3564:	83 e2 0f             	and    $0xf,%edx
		msg->payload.single.args[1] = arg2;
    3567:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 3;
    356a:	83 ca 30             	or     $0x30,%edx
		msg->payload.single.args[2] = arg3;
    356d:	89 58 1c             	mov    %ebx,0x1c(%eax)
		msg->hdr.params.std.nargs = 3;
    3570:	88 50 09             	mov    %dl,0x9(%eax)
	msg_finalize(msg, src_level);
    3573:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
}
    3577:	59                   	pop    %ecx
    3578:	5b                   	pop    %ebx
    3579:	5b                   	pop    %ebx
    357a:	5e                   	pop    %esi
    357b:	5f                   	pop    %edi
    357c:	5d                   	pop    %ebp
	msg_finalize(msg, src_level);
    357d:	e9 a4 fe ff ff       	jmp    3426 <msg_finalize>
}
    3582:	58                   	pop    %eax
    3583:	5a                   	pop    %edx
    3584:	5b                   	pop    %ebx
    3585:	5e                   	pop    %esi
    3586:	5f                   	pop    %edi
    3587:	5d                   	pop    %ebp
    3588:	c3                   	ret    

00003589 <log_n>:
{
    3589:	55                   	push   %ebp
    358a:	89 e5                	mov    %esp,%ebp
    358c:	53                   	push   %ebx
	struct log_msg *msg = log_msg_create_n(str, args, narg);
    358d:	ff 75 10             	pushl  0x10(%ebp)
    3590:	ff 75 0c             	pushl  0xc(%ebp)
    3593:	ff 75 08             	pushl  0x8(%ebp)
{
    3596:	8b 5d 14             	mov    0x14(%ebp),%ebx
	struct log_msg *msg = log_msg_create_n(str, args, narg);
    3599:	e8 de 05 00 00       	call   3b7c <log_msg_create_n>
    359e:	83 c4 0c             	add    $0xc,%esp
	if (msg == NULL) {
    35a1:	85 c0                	test   %eax,%eax
    35a3:	74 0b                	je     35b0 <log_n+0x27>
	msg_finalize(msg, src_level);
    35a5:	89 da                	mov    %ebx,%edx
}
    35a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    35aa:	c9                   	leave  
	msg_finalize(msg, src_level);
    35ab:	e9 76 fe ff ff       	jmp    3426 <msg_finalize>
}
    35b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    35b3:	c9                   	leave  
    35b4:	c3                   	ret    

000035b5 <log_dropped>:
    35b5:	f0 ff 05 d4 41 40 00 	lock incl 0x4041d4
}
    35bc:	c3                   	ret    

000035bd <log_source_name_get>:
{
    35bd:	55                   	push   %ebp
    35be:	ba 84 52 02 00       	mov    $0x25284,%edx
    35c3:	89 e5                	mov    %esp,%ebp
    35c5:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
    35cb:	c1 ea 03             	shr    $0x3,%edx
    35ce:	31 c0                	xor    %eax,%eax
    35d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    35d3:	39 d1                	cmp    %edx,%ecx
    35d5:	73 07                	jae    35de <log_source_name_get+0x21>
	return __log_const_start[source_id].name;
    35d7:	8b 04 cd 3c 51 02 00 	mov    0x2513c(,%ecx,8),%eax
}
    35de:	5d                   	pop    %ebp
    35df:	c3                   	ret    

000035e0 <log_filter_set>:
{
    35e0:	55                   	push   %ebp
    35e1:	89 e5                	mov    %esp,%ebp
    35e3:	57                   	push   %edi
    35e4:	56                   	push   %esi
    35e5:	8b 45 08             	mov    0x8(%ebp),%eax
    35e8:	53                   	push   %ebx
    35e9:	8b 55 10             	mov    0x10(%ebp),%edx
		if (backend == NULL) {
    35ec:	85 c0                	test   %eax,%eax
    35ee:	75 43                	jne    3633 <log_filter_set+0x53>
	return __log_backends_end - __log_backends_start;
    35f0:	be 94 52 02 00       	mov    $0x25294,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
    35f5:	31 ff                	xor    %edi,%edi
    35f7:	81 ee 84 52 02 00    	sub    $0x25284,%esi
			u32_t max = 0U;
    35fd:	31 db                	xor    %ebx,%ebx
    35ff:	c1 fe 04             	sar    $0x4,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
    3602:	39 f7                	cmp    %esi,%edi
    3604:	0f 8d 84 00 00 00    	jge    368e <log_filter_set+0xae>
				current = log_filter_set(backend, domain_id,
    360a:	ff 75 14             	pushl  0x14(%ebp)
    360d:	89 f8                	mov    %edi,%eax
    360f:	89 55 10             	mov    %edx,0x10(%ebp)
    3612:	c1 e0 04             	shl    $0x4,%eax
    3615:	52                   	push   %edx
    3616:	ff 75 0c             	pushl  0xc(%ebp)
    3619:	05 84 52 02 00       	add    $0x25284,%eax
    361e:	50                   	push   %eax
    361f:	e8 bc ff ff ff       	call   35e0 <log_filter_set>
    3624:	83 c4 10             	add    $0x10,%esp
				max = MAX(current, max);
    3627:	8b 55 10             	mov    0x10(%ebp),%edx
    362a:	39 c3                	cmp    %eax,%ebx
    362c:	73 02                	jae    3630 <log_filter_set+0x50>
    362e:	89 c3                	mov    %eax,%ebx
			for (int i = 0; i < log_backend_count_get(); i++) {
    3630:	47                   	inc    %edi
    3631:	eb cf                	jmp    3602 <log_filter_set+0x22>
		return log_compiled_level_get(src_id);
    3633:	0f b6 1c d5 40 51 02 	movzbl 0x25140(,%edx,8),%ebx
    363a:	00 
			level = MIN(level, max);
    363b:	3b 5d 14             	cmp    0x14(%ebp),%ebx
    363e:	76 03                	jbe    3643 <log_filter_set+0x63>
    3640:	8b 5d 14             	mov    0x14(%ebp),%ebx
	return backend->cb->id;
    3643:	8b 40 04             	mov    0x4(%eax),%eax
			LOG_FILTER_SLOT_SET(filters,
    3646:	89 de                	mov    %ebx,%esi
    3648:	83 e6 07             	and    $0x7,%esi
    364b:	0f b6 48 04          	movzbl 0x4(%eax),%ecx
    364f:	b8 07 00 00 00       	mov    $0x7,%eax
    3654:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
    3657:	d3 e0                	shl    %cl,%eax
    3659:	f7 d0                	not    %eax
    365b:	23 04 95 5c a8 40 00 	and    0x40a85c(,%edx,4),%eax
    3662:	d3 e6                	shl    %cl,%esi
    3664:	09 f0                	or     %esi,%eax
    3666:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32_t max_filter = LOG_LEVEL_NONE;
    366b:	31 f6                	xor    %esi,%esi
		u32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
    366d:	89 c7                	mov    %eax,%edi
    366f:	d3 ef                	shr    %cl,%edi
    3671:	83 e7 07             	and    $0x7,%edi
    3674:	39 fe                	cmp    %edi,%esi
    3676:	73 02                	jae    367a <log_filter_set+0x9a>
    3678:	89 fe                	mov    %edi,%esi
    367a:	83 c1 03             	add    $0x3,%ecx
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
    367d:	83 f9 1e             	cmp    $0x1e,%ecx
    3680:	75 eb                	jne    366d <log_filter_set+0x8d>
			LOG_FILTER_SLOT_SET(filters,
    3682:	83 e0 f8             	and    $0xfffffff8,%eax
    3685:	09 f0                	or     %esi,%eax
    3687:	89 04 95 5c a8 40 00 	mov    %eax,0x40a85c(,%edx,4)
}
    368e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3691:	89 d8                	mov    %ebx,%eax
    3693:	5b                   	pop    %ebx
    3694:	5e                   	pop    %esi
    3695:	5f                   	pop    %edi
    3696:	5d                   	pop    %ebp
    3697:	c3                   	ret    

00003698 <log_backend_enable>:
{
    3698:	55                   	push   %ebp
    3699:	89 e5                	mov    %esp,%ebp
    369b:	57                   	push   %edi
    369c:	56                   	push   %esi
		for (int i = 0; i < log_sources_count(); i++) {
    369d:	31 ff                	xor    %edi,%edi
{
    369f:	8b 75 08             	mov    0x8(%ebp),%esi
    36a2:	53                   	push   %ebx
	id += backend - log_backend_get(0);
    36a3:	89 f0                	mov    %esi,%eax
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    36a5:	bb 84 52 02 00       	mov    $0x25284,%ebx
    36aa:	2d 84 52 02 00       	sub    $0x25284,%eax
	backend->cb->id = id;
    36af:	8b 56 04             	mov    0x4(%esi),%edx
    36b2:	c1 f8 04             	sar    $0x4,%eax
    36b5:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    36bb:	c1 eb 03             	shr    $0x3,%ebx
    36be:	40                   	inc    %eax
	log_backend_id_set(backend, id);
    36bf:	88 42 04             	mov    %al,0x4(%edx)
		for (int i = 0; i < log_sources_count(); i++) {
    36c2:	39 df                	cmp    %ebx,%edi
    36c4:	74 12                	je     36d8 <log_backend_enable+0x40>
			log_filter_set(backend,
    36c6:	ff 75 10             	pushl  0x10(%ebp)
    36c9:	57                   	push   %edi
		for (int i = 0; i < log_sources_count(); i++) {
    36ca:	47                   	inc    %edi
			log_filter_set(backend,
    36cb:	6a 00                	push   $0x0
    36cd:	56                   	push   %esi
    36ce:	e8 0d ff ff ff       	call   35e0 <log_filter_set>
    36d3:	83 c4 10             	add    $0x10,%esp
    36d6:	eb ea                	jmp    36c2 <log_backend_enable+0x2a>
	log_backend_activate(backend, ctx);
    36d8:	8b 46 04             	mov    0x4(%esi),%eax
	backend->cb->ctx = ctx;
    36db:	8b 55 0c             	mov    0xc(%ebp),%edx
	backend_attached = true;
    36de:	c6 05 56 45 40 00 01 	movb   $0x1,0x404556
    36e5:	89 10                	mov    %edx,(%eax)
	backend->cb->active = true;
    36e7:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
    36eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
    36ee:	5b                   	pop    %ebx
    36ef:	5e                   	pop    %esi
    36f0:	5f                   	pop    %edi
    36f1:	5d                   	pop    %ebp
    36f2:	c3                   	ret    

000036f3 <log_init>:
    36f3:	b8 01 00 00 00       	mov    $0x1,%eax
    36f8:	f0 0f c1 05 dc 41 40 	lock xadd %eax,0x4041dc
    36ff:	00 
	if (atomic_inc(&initialized) != 0) {
    3700:	85 c0                	test   %eax,%eax
    3702:	75 4b                	jne    374f <log_init+0x5c>
{
    3704:	55                   	push   %ebp
    3705:	89 e5                	mov    %esp,%ebp
    3707:	57                   	push   %edi
    3708:	56                   	push   %esi
	for (i = 0; i < log_backend_count_get(); i++) {
    3709:	31 ff                	xor    %edi,%edi
{
    370b:	53                   	push   %ebx
	return __log_backends_end - __log_backends_start;
    370c:	bb 94 52 02 00       	mov    $0x25294,%ebx
    3711:	81 eb 84 52 02 00    	sub    $0x25284,%ebx
    3717:	be 84 52 02 00       	mov    $0x25284,%esi
    371c:	c1 fb 04             	sar    $0x4,%ebx
	for (i = 0; i < log_backend_count_get(); i++) {
    371f:	39 df                	cmp    %ebx,%edi
    3721:	7d 24                	jge    3747 <log_init+0x54>
		if (backend->autostart) {
    3723:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
    3727:	74 18                	je     3741 <log_init+0x4e>
			if (backend->api->init != NULL) {
    3729:	8b 06                	mov    (%esi),%eax
    372b:	8b 40 14             	mov    0x14(%eax),%eax
    372e:	85 c0                	test   %eax,%eax
    3730:	74 02                	je     3734 <log_init+0x41>
				backend->api->init();
    3732:	ff d0                	call   *%eax
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    3734:	6a 04                	push   $0x4
    3736:	6a 00                	push   $0x0
    3738:	56                   	push   %esi
    3739:	e8 5a ff ff ff       	call   3698 <log_backend_enable>
    373e:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < log_backend_count_get(); i++) {
    3741:	47                   	inc    %edi
    3742:	83 c6 10             	add    $0x10,%esi
    3745:	eb d8                	jmp    371f <log_init+0x2c>
}
    3747:	8d 65 f4             	lea    -0xc(%ebp),%esp
    374a:	5b                   	pop    %ebx
    374b:	5e                   	pop    %esi
    374c:	5f                   	pop    %edi
    374d:	5d                   	pop    %ebp
    374e:	c3                   	ret    
    374f:	c3                   	ret    

00003750 <log_panic>:
	if (panic_mode) {
    3750:	80 3d 57 45 40 00 00 	cmpb   $0x0,0x404557
    3757:	75 55                	jne    37ae <log_panic+0x5e>
{
    3759:	55                   	push   %ebp
    375a:	89 e5                	mov    %esp,%ebp
    375c:	57                   	push   %edi
    375d:	56                   	push   %esi
	for (int i = 0; i < log_backend_count_get(); i++) {
    375e:	31 ff                	xor    %edi,%edi
{
    3760:	53                   	push   %ebx
	log_init();
    3761:	e8 8d ff ff ff       	call   36f3 <log_init>
    3766:	bb 94 52 02 00       	mov    $0x25294,%ebx
    376b:	be 84 52 02 00       	mov    $0x25284,%esi
    3770:	81 eb 84 52 02 00    	sub    $0x25284,%ebx
    3776:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
    3779:	39 df                	cmp    %ebx,%edi
    377b:	7d 16                	jge    3793 <log_panic+0x43>
	return backend->cb->active;
    377d:	8b 46 04             	mov    0x4(%esi),%eax
		if (log_backend_is_active(backend)) {
    3780:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    3784:	74 07                	je     378d <log_panic+0x3d>
	backend->api->panic(backend);
    3786:	8b 06                	mov    (%esi),%eax
    3788:	56                   	push   %esi
    3789:	ff 50 10             	call   *0x10(%eax)
    378c:	59                   	pop    %ecx
	for (int i = 0; i < log_backend_count_get(); i++) {
    378d:	47                   	inc    %edi
    378e:	83 c6 10             	add    $0x10,%esi
    3791:	eb e6                	jmp    3779 <log_panic+0x29>
		while (log_process(false) == true) {
    3793:	6a 00                	push   $0x0
    3795:	e8 b6 fb ff ff       	call   3350 <log_process>
    379a:	5a                   	pop    %edx
    379b:	84 c0                	test   %al,%al
    379d:	75 f4                	jne    3793 <log_panic+0x43>
	panic_mode = true;
    379f:	c6 05 57 45 40 00 01 	movb   $0x1,0x404557
}
    37a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    37a9:	5b                   	pop    %ebx
    37aa:	5e                   	pop    %esi
    37ab:	5f                   	pop    %edi
    37ac:	5d                   	pop    %ebp
    37ad:	c3                   	ret    
    37ae:	c3                   	ret    

000037af <log_process_thread_func>:
{
    37af:	55                   	push   %ebp
    37b0:	89 e5                	mov    %esp,%ebp
	log_init();
    37b2:	e8 3c ff ff ff       	call   36f3 <log_init>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    37b7:	e8 e6 07 02 00       	call   23fa2 <z_impl_k_current_get>
	proc_tid = process_tid;
    37bc:	a3 d0 41 40 00       	mov    %eax,0x4041d0
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    37c1:	85 c0                	test   %eax,%eax
    37c3:	74 10                	je     37d5 <log_process_thread_func+0x26>
	    process_tid &&
    37c5:	83 3d d8 41 40 00 09 	cmpl   $0x9,0x4041d8
    37cc:	7e 07                	jle    37d5 <log_process_thread_func+0x26>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
    37ce:	50                   	push   %eax
    37cf:	e8 8a 07 02 00       	call   23f5e <z_impl_k_wakeup>
    37d4:	59                   	pop    %ecx
		if (log_process(false) == false) {
    37d5:	6a 00                	push   $0x0
    37d7:	e8 74 fb ff ff       	call   3350 <log_process>
    37dc:	5a                   	pop    %edx
    37dd:	84 c0                	test   %al,%al
    37df:	75 f4                	jne    37d5 <log_process_thread_func+0x26>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
    37e1:	68 e8 03 00 00       	push   $0x3e8
    37e6:	e8 af 06 02 00       	call   23e9a <z_impl_k_sleep>
    37eb:	eb e7                	jmp    37d4 <log_process_thread_func+0x25>

000037ed <log_backend_disable>:
{
    37ed:	55                   	push   %ebp
    37ee:	89 e5                	mov    %esp,%ebp
    37f0:	57                   	push   %edi
    37f1:	56                   	push   %esi
		for (int i = 0; i < log_sources_count(); i++) {
    37f2:	31 f6                	xor    %esi,%esi
{
    37f4:	8b 7d 08             	mov    0x8(%ebp),%edi
    37f7:	53                   	push   %ebx
    37f8:	bb 84 52 02 00       	mov    $0x25284,%ebx
	backend->cb->active = false;
    37fd:	8b 47 04             	mov    0x4(%edi),%eax
    3800:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    3806:	c1 eb 03             	shr    $0x3,%ebx
    3809:	c6 40 05 00          	movb   $0x0,0x5(%eax)
		for (int i = 0; i < log_sources_count(); i++) {
    380d:	39 de                	cmp    %ebx,%esi
    380f:	74 11                	je     3822 <log_backend_disable+0x35>
			log_filter_set(backend,
    3811:	6a 00                	push   $0x0
    3813:	56                   	push   %esi
		for (int i = 0; i < log_sources_count(); i++) {
    3814:	46                   	inc    %esi
			log_filter_set(backend,
    3815:	6a 00                	push   $0x0
    3817:	57                   	push   %edi
    3818:	e8 c3 fd ff ff       	call   35e0 <log_filter_set>
    381d:	83 c4 10             	add    $0x10,%esp
    3820:	eb eb                	jmp    380d <log_backend_disable+0x20>
}
    3822:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3825:	5b                   	pop    %ebx
    3826:	5e                   	pop    %esi
    3827:	5f                   	pop    %edi
    3828:	5d                   	pop    %ebp
    3829:	c3                   	ret    

0000382a <log_filter_get>:
{
    382a:	55                   	push   %ebp
    382b:	89 e5                	mov    %esp,%ebp
    382d:	8b 45 10             	mov    0x10(%ebp),%eax
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
    3830:	80 7d 14 00          	cmpb   $0x0,0x14(%ebp)
    3834:	74 1b                	je     3851 <log_filter_get+0x27>
	return backend->cb->id;
    3836:	8b 55 08             	mov    0x8(%ebp),%edx
		return LOG_FILTER_SLOT_GET(filters,
    3839:	8b 04 85 5c a8 40 00 	mov    0x40a85c(,%eax,4),%eax
    3840:	8b 52 04             	mov    0x4(%edx),%edx
    3843:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
    3847:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
    384a:	d3 e8                	shr    %cl,%eax
    384c:	83 e0 07             	and    $0x7,%eax
    384f:	eb 08                	jmp    3859 <log_filter_get+0x2f>
		return log_compiled_level_get(src_id);
    3851:	0f b6 04 c5 40 51 02 	movzbl 0x25140(,%eax,8),%eax
    3858:	00 
}
    3859:	5d                   	pop    %ebp
    385a:	c3                   	ret    

0000385b <log_strdup>:
{
    385b:	55                   	push   %ebp
    385c:	89 e5                	mov    %esp,%ebp
    385e:	50                   	push   %eax
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    385f:	6a 00                	push   $0x0
    3861:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3864:	50                   	push   %eax
    3865:	68 60 02 40 00       	push   $0x400260
    386a:	e8 5e f6 01 00       	call   22ecd <k_mem_slab_alloc>
    386f:	83 c4 0c             	add    $0xc,%esp
	if (err != 0) {
    3872:	ba b3 69 02 00       	mov    $0x269b3,%edx
    3877:	85 c0                	test   %eax,%eax
    3879:	75 2a                	jne    38a5 <log_strdup+0x4a>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    387b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    387e:	b8 01 00 00 00       	mov    $0x1,%eax
    3883:	87 02                	xchg   %eax,(%edx)
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    3885:	6a 2d                	push   $0x2d
    3887:	ff 75 08             	pushl  0x8(%ebp)
    388a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    388d:	83 c0 04             	add    $0x4,%eax
    3890:	50                   	push   %eax
    3891:	e8 57 6f 00 00       	call   a7ed <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    3896:	8b 55 fc             	mov    -0x4(%ebp),%edx
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    3899:	83 c4 0c             	add    $0xc,%esp
	return dup->buf;
    389c:	83 c2 04             	add    $0x4,%edx
	dup->buf[sizeof(dup->buf) - 2] = '~';
    389f:	66 c7 42 2d 7e 00    	movw   $0x7e,0x2d(%edx)
}
    38a5:	89 d0                	mov    %edx,%eax
    38a7:	c9                   	leave  
    38a8:	c3                   	ret    

000038a9 <log_is_strdup>:
{
    38a9:	55                   	push   %ebp
    38aa:	89 e5                	mov    %esp,%ebp
    38ac:	8b 55 08             	mov    0x8(%ebp),%edx
}
    38af:	5d                   	pop    %ebp
	return ((char *)buf >= pool_first->buf) &&
    38b0:	81 fa 10 55 40 00    	cmp    $0x405510,%edx
    38b6:	0f 96 c0             	setbe  %al
    38b9:	81 fa 74 54 40 00    	cmp    $0x405474,%edx
    38bf:	0f 93 c2             	setae  %dl
    38c2:	21 d0                	and    %edx,%eax
}
    38c4:	c3                   	ret    

000038c5 <log_free>:
{
    38c5:	55                   	push   %ebp
    38c6:	89 e5                	mov    %esp,%ebp
    38c8:	51                   	push   %ecx
    38c9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    38cc:	8d 50 fc             	lea    -0x4(%eax),%edx
    38cf:	89 55 fc             	mov    %edx,-0x4(%ebp)
	if (atomic_dec(&dup->refcount) == 1) {
    38d2:	f0 ff 48 fc          	lock decl -0x4(%eax)
    38d6:	75 10                	jne    38e8 <log_free+0x23>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    38d8:	8d 45 fc             	lea    -0x4(%ebp),%eax
    38db:	50                   	push   %eax
    38dc:	68 60 02 40 00       	push   $0x400260
    38e1:	e8 4d f6 01 00       	call   22f33 <k_mem_slab_free>
    38e6:	58                   	pop    %eax
    38e7:	5a                   	pop    %edx
}
    38e8:	c9                   	leave  
    38e9:	c3                   	ret    

000038ea <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    38ea:	55                   	push   %ebp
    38eb:	89 e5                	mov    %esp,%ebp
    38ed:	57                   	push   %edi
    38ee:	56                   	push   %esi
    38ef:	89 d6                	mov    %edx,%esi
    38f1:	53                   	push   %ebx
    38f2:	83 ec 08             	sub    $0x8,%esp
    38f5:	8b 7d 0c             	mov    0xc(%ebp),%edi
	u32_t available_len = msg->hdr.params.hexdump.length;
    38f8:	8b 50 08             	mov    0x8(%eax),%edx
    38fb:	66 c1 ea 02          	shr    $0x2,%dx
{
    38ff:	89 7d f0             	mov    %edi,-0x10(%ebp)
    3902:	8a 5d f0             	mov    -0x10(%ebp),%bl
	u32_t available_len = msg->hdr.params.hexdump.length;
    3905:	0f b7 d2             	movzwl %dx,%edx
{
    3908:	88 5d ef             	mov    %bl,-0x11(%ebp)
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
    390b:	3b 55 08             	cmp    0x8(%ebp),%edx
    390e:	77 0b                	ja     391b <log_msg_hexdump_data_op+0x31>
		*length = 0;
    3910:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		return;
    3916:	e9 b8 00 00 00       	jmp    39d3 <log_msg_hexdump_data_op+0xe9>
	}

	if ((offset + *length) > available_len) {
    391b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    391e:	03 19                	add    (%ecx),%ebx
    3920:	39 d3                	cmp    %edx,%ebx
    3922:	76 07                	jbe    392b <log_msg_hexdump_data_op+0x41>
		*length = available_len - offset;
    3924:	89 d3                	mov    %edx,%ebx
    3926:	2b 5d 08             	sub    0x8(%ebp),%ebx
    3929:	89 19                	mov    %ebx,(%ecx)
	}

	req_len = *length;
    392b:	8b 19                	mov    (%ecx),%ebx

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    392d:	83 fa 0c             	cmp    $0xc,%edx
    3930:	76 13                	jbe    3945 <log_msg_hexdump_data_op+0x5b>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
		cont = msg->payload.ext.next;
    3932:	8b 78 14             	mov    0x14(%eax),%edi
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
    3935:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
    3939:	77 3f                	ja     397a <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
    393b:	83 c0 18             	add    $0x18,%eax
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    393e:	ba 08 00 00 00       	mov    $0x8,%edx
    3943:	eb 05                	jmp    394a <log_msg_hexdump_data_op+0x60>
		head_data = msg->payload.single.bytes;
    3945:	83 c0 14             	add    $0x14,%eax
	struct log_msg_cont *cont = NULL;
    3948:	31 ff                	xor    %edi,%edi
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    394a:	89 d9                	mov    %ebx,%ecx
    394c:	39 d3                	cmp    %edx,%ebx
    394e:	76 02                	jbe    3952 <log_msg_hexdump_data_op+0x68>
    3950:	89 d1                	mov    %edx,%ecx

		if (put_op) {
    3952:	03 45 08             	add    0x8(%ebp),%eax
    3955:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
    3959:	74 08                	je     3963 <log_msg_hexdump_data_op+0x79>
			(void)memcpy(&head_data[offset], data, cpy_len);
    395b:	51                   	push   %ecx
    395c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    395f:	56                   	push   %esi
    3960:	50                   	push   %eax
    3961:	eb 06                	jmp    3969 <log_msg_hexdump_data_op+0x7f>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
    3963:	51                   	push   %ecx
    3964:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    3967:	50                   	push   %eax
    3968:	56                   	push   %esi
    3969:	e8 c3 6f 00 00       	call   a931 <memcpy>
    396e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    3971:	83 c4 0c             	add    $0xc,%esp
		}

		req_len -= cpy_len;
    3974:	29 cb                	sub    %ecx,%ebx
		data += cpy_len;
    3976:	01 ce                	add    %ecx,%esi
    3978:	eb 4b                	jmp    39c5 <log_msg_hexdump_data_op+0xdb>
	} else {
		offset -= chunk_len;
    397a:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		chunk_len = HEXDUMP_BYTES_CONT_MSG;
		if (cont == NULL) {
			cont = msg->payload.ext.next;
		}

		while (offset >= chunk_len) {
    397e:	83 7d 08 1b          	cmpl   $0x1b,0x8(%ebp)
    3982:	76 41                	jbe    39c5 <log_msg_hexdump_data_op+0xdb>
			cont = cont->next;
    3984:	8b 3f                	mov    (%edi),%edi
			offset -= chunk_len;
    3986:	83 6d 08 1c          	subl   $0x1c,0x8(%ebp)
    398a:	eb f2                	jmp    397e <log_msg_hexdump_data_op+0x94>
		}
	}

	while (req_len > 0) {
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    398c:	ba 1c 00 00 00       	mov    $0x1c,%edx
    3991:	2b 55 08             	sub    0x8(%ebp),%edx
    3994:	39 da                	cmp    %ebx,%edx
    3996:	76 02                	jbe    399a <log_msg_hexdump_data_op+0xb0>
    3998:	89 da                	mov    %ebx,%edx

		if (put_op) {
    399a:	8b 45 08             	mov    0x8(%ebp),%eax
    399d:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    39a1:	8d 44 07 04          	lea    0x4(%edi,%eax,1),%eax
    39a5:	74 24                	je     39cb <log_msg_hexdump_data_op+0xe1>
			(void)memcpy(&cont->payload.bytes[offset],
    39a7:	52                   	push   %edx
    39a8:	89 55 f0             	mov    %edx,-0x10(%ebp)
    39ab:	56                   	push   %esi
    39ac:	50                   	push   %eax
				     data, cpy_len);
		} else {
			(void)memcpy(data, &cont->payload.bytes[offset],
    39ad:	e8 7f 6f 00 00       	call   a931 <memcpy>
    39b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    39b5:	83 c4 0c             	add    $0xc,%esp
				     cpy_len);
		}

		offset = 0;
		cont = cont->next;
    39b8:	8b 3f                	mov    (%edi),%edi
		req_len -= cpy_len;
    39ba:	29 d3                	sub    %edx,%ebx
		data += cpy_len;
    39bc:	01 d6                	add    %edx,%esi
		offset = 0;
    39be:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
	while (req_len > 0) {
    39c5:	85 db                	test   %ebx,%ebx
    39c7:	75 c3                	jne    398c <log_msg_hexdump_data_op+0xa2>
    39c9:	eb 08                	jmp    39d3 <log_msg_hexdump_data_op+0xe9>
			(void)memcpy(data, &cont->payload.bytes[offset],
    39cb:	52                   	push   %edx
    39cc:	89 55 f0             	mov    %edx,-0x10(%ebp)
    39cf:	50                   	push   %eax
    39d0:	56                   	push   %esi
    39d1:	eb da                	jmp    39ad <log_msg_hexdump_data_op+0xc3>
	}
}
    39d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    39d6:	5b                   	pop    %ebx
    39d7:	5e                   	pop    %esi
    39d8:	5f                   	pop    %edi
    39d9:	5d                   	pop    %ebp
    39da:	c3                   	ret    

000039db <log_msg_pool_init>:
{
    39db:	55                   	push   %ebp
    39dc:	89 e5                	mov    %esp,%ebp
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    39de:	6a 20                	push   $0x20
    39e0:	6a 20                	push   $0x20
    39e2:	68 40 55 40 00       	push   $0x405540
    39e7:	68 a0 02 40 00       	push   $0x4002a0
    39ec:	e8 89 f4 01 00       	call   22e7a <k_mem_slab_init>
    39f1:	83 c4 10             	add    $0x10,%esp
}
    39f4:	c9                   	leave  
    39f5:	c3                   	ret    

000039f6 <log_msg_get>:
{
    39f6:	55                   	push   %ebp
    39f7:	89 e5                	mov    %esp,%ebp
    39f9:	8b 45 08             	mov    0x8(%ebp),%eax
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    39fc:	f0 ff 40 04          	lock incl 0x4(%eax)
}
    3a00:	5d                   	pop    %ebp
    3a01:	c3                   	ret    

00003a02 <log_msg_no_space_handle>:
{
    3a02:	55                   	push   %ebp
    3a03:	89 e5                	mov    %esp,%ebp
    3a05:	53                   	push   %ebx
    3a06:	51                   	push   %ecx
	union log_msg_chunk *msg = NULL;
    3a07:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
			more = log_process(true);
    3a0e:	6a 01                	push   $0x1
    3a10:	e8 3b f9 ff ff       	call   3350 <log_process>
    3a15:	5a                   	pop    %edx
    3a16:	88 c3                	mov    %al,%bl
			log_dropped();
    3a18:	e8 98 fb ff ff       	call   35b5 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    3a1d:	6a 00                	push   $0x0
    3a1f:	8d 45 f8             	lea    -0x8(%ebp),%eax
    3a22:	50                   	push   %eax
    3a23:	68 a0 02 40 00       	push   $0x4002a0
    3a28:	e8 a0 f4 01 00       	call   22ecd <k_mem_slab_alloc>
    3a2d:	83 c4 0c             	add    $0xc,%esp
		} while ((err != 0) && more);
    3a30:	85 c0                	test   %eax,%eax
    3a32:	74 04                	je     3a38 <log_msg_no_space_handle+0x36>
    3a34:	84 db                	test   %bl,%bl
    3a36:	75 d6                	jne    3a0e <log_msg_no_space_handle+0xc>
}
    3a38:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3a3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3a3e:	c9                   	leave  
    3a3f:	c3                   	ret    

00003a40 <log_msg_chunk_alloc>:
{
    3a40:	55                   	push   %ebp
    3a41:	89 e5                	mov    %esp,%ebp
    3a43:	50                   	push   %eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    3a44:	6a 00                	push   $0x0
    3a46:	8d 45 fc             	lea    -0x4(%ebp),%eax
	union log_msg_chunk *msg = NULL;
    3a49:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    3a50:	50                   	push   %eax
    3a51:	68 a0 02 40 00       	push   $0x4002a0
    3a56:	e8 72 f4 01 00       	call   22ecd <k_mem_slab_alloc>
    3a5b:	83 c4 0c             	add    $0xc,%esp
	if (err != 0) {
    3a5e:	85 c0                	test   %eax,%eax
    3a60:	74 08                	je     3a6a <log_msg_chunk_alloc+0x2a>
		msg = log_msg_no_space_handle();
    3a62:	e8 9b ff ff ff       	call   3a02 <log_msg_no_space_handle>
    3a67:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
    3a6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3a6d:	c9                   	leave  
    3a6e:	c3                   	ret    

00003a6f <log_msg_nargs_get>:
{
    3a6f:	55                   	push   %ebp
    3a70:	89 e5                	mov    %esp,%ebp
	return msg->hdr.params.std.nargs;
    3a72:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3a75:	5d                   	pop    %ebp
	return msg->hdr.params.std.nargs;
    3a76:	8a 40 09             	mov    0x9(%eax),%al
    3a79:	c0 e8 04             	shr    $0x4,%al
    3a7c:	0f b6 c0             	movzbl %al,%eax
}
    3a7f:	c3                   	ret    

00003a80 <log_msg_arg_get>:
{
    3a80:	55                   	push   %ebp
		return 0;
    3a81:	31 c0                	xor    %eax,%eax
{
    3a83:	89 e5                	mov    %esp,%ebp
    3a85:	56                   	push   %esi
    3a86:	53                   	push   %ebx
    3a87:	8b 4d 08             	mov    0x8(%ebp),%ecx
    3a8a:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (arg_idx >= msg->hdr.params.std.nargs) {
    3a8d:	8a 59 09             	mov    0x9(%ecx),%bl
    3a90:	c0 eb 04             	shr    $0x4,%bl
    3a93:	0f b6 f3             	movzbl %bl,%esi
    3a96:	39 d6                	cmp    %edx,%esi
    3a98:	76 2c                	jbe    3ac6 <log_msg_arg_get+0x46>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    3a9a:	80 fb 03             	cmp    $0x3,%bl
    3a9d:	77 06                	ja     3aa5 <log_msg_arg_get+0x25>
		arg = msg->payload.single.args[arg_idx];
    3a9f:	8b 44 91 14          	mov    0x14(%ecx,%edx,4),%eax
    3aa3:	eb 21                	jmp    3ac6 <log_msg_arg_get+0x46>
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    3aa5:	83 fa 01             	cmp    $0x1,%edx
    3aa8:	77 06                	ja     3ab0 <log_msg_arg_get+0x30>
		return msg->payload.ext.data.args[arg_idx];
    3aaa:	8b 44 91 18          	mov    0x18(%ecx,%edx,4),%eax
    3aae:	eb 16                	jmp    3ac6 <log_msg_arg_get+0x46>
	cont = msg->payload.ext.next;
    3ab0:	8b 41 14             	mov    0x14(%ecx),%eax
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    3ab3:	83 ea 02             	sub    $0x2,%edx
	while (arg_idx >= ARGS_CONT_MSG) {
    3ab6:	83 fa 06             	cmp    $0x6,%edx
    3ab9:	76 07                	jbe    3ac2 <log_msg_arg_get+0x42>
		arg_idx -= ARGS_CONT_MSG;
    3abb:	83 ea 07             	sub    $0x7,%edx
		cont = cont->next;
    3abe:	8b 00                	mov    (%eax),%eax
    3ac0:	eb f4                	jmp    3ab6 <log_msg_arg_get+0x36>
	return cont->payload.args[arg_idx];
    3ac2:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
}
    3ac6:	5b                   	pop    %ebx
    3ac7:	5e                   	pop    %esi
    3ac8:	5d                   	pop    %ebp
    3ac9:	c3                   	ret    

00003aca <msg_free>:
{
    3aca:	55                   	push   %ebp
    3acb:	89 e5                	mov    %esp,%ebp
    3acd:	57                   	push   %edi
    3ace:	56                   	push   %esi
    3acf:	53                   	push   %ebx
    3ad0:	83 ec 08             	sub    $0x8,%esp
    3ad3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u32_t nargs = msg->hdr.params.std.nargs;
    3ad6:	8a 58 09             	mov    0x9(%eax),%bl
    3ad9:	c0 eb 04             	shr    $0x4,%bl
	if (log_msg_is_std(msg) && nargs) {
    3adc:	f6 40 08 01          	testb  $0x1,0x8(%eax)
    3ae0:	75 07                	jne    3ae9 <msg_free+0x1f>
    3ae2:	0f b6 db             	movzbl %bl,%ebx
    3ae5:	85 db                	test   %ebx,%ebx
    3ae7:	75 11                	jne    3afa <msg_free+0x30>
	if (msg->hdr.params.generic.ext == 1) {
    3ae9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3aec:	f6 40 08 02          	testb  $0x2,0x8(%eax)
    3af0:	74 4f                	je     3b41 <msg_free+0x77>
		cont_free(msg->payload.ext.next);
    3af2:	8b 40 14             	mov    0x14(%eax),%eax
    3af5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (cont != NULL) {
    3af8:	eb 29                	jmp    3b23 <msg_free+0x59>
		for (i = 0; i < nargs; i++) {
    3afa:	31 f6                	xor    %esi,%esi
    3afc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3aff:	39 f3                	cmp    %esi,%ebx
    3b01:	76 e6                	jbe    3ae9 <msg_free+0x1f>
			void *buf = (void *)log_msg_arg_get(msg, i);
    3b03:	56                   	push   %esi
    3b04:	50                   	push   %eax
    3b05:	e8 76 ff ff ff       	call   3a80 <log_msg_arg_get>
    3b0a:	5a                   	pop    %edx
    3b0b:	89 c7                	mov    %eax,%edi
    3b0d:	59                   	pop    %ecx
			if (log_is_strdup(buf)) {
    3b0e:	50                   	push   %eax
    3b0f:	e8 95 fd ff ff       	call   38a9 <log_is_strdup>
    3b14:	5a                   	pop    %edx
    3b15:	84 c0                	test   %al,%al
    3b17:	74 07                	je     3b20 <msg_free+0x56>
				log_free(buf);
    3b19:	57                   	push   %edi
    3b1a:	e8 a6 fd ff ff       	call   38c5 <log_free>
    3b1f:	5f                   	pop    %edi
		for (i = 0; i < nargs; i++) {
    3b20:	46                   	inc    %esi
    3b21:	eb d9                	jmp    3afc <msg_free+0x32>
	while (cont != NULL) {
    3b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3b26:	85 c0                	test   %eax,%eax
    3b28:	74 17                	je     3b41 <msg_free+0x77>
		next = cont->next;
    3b2a:	8b 18                	mov    (%eax),%ebx
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    3b2c:	8d 45 f0             	lea    -0x10(%ebp),%eax
    3b2f:	50                   	push   %eax
    3b30:	68 a0 02 40 00       	push   $0x4002a0
    3b35:	e8 f9 f3 01 00       	call   22f33 <k_mem_slab_free>
    3b3a:	59                   	pop    %ecx
		cont = next;
    3b3b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    3b3e:	5e                   	pop    %esi
		cont = next;
    3b3f:	eb e2                	jmp    3b23 <msg_free+0x59>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    3b41:	8d 45 ec             	lea    -0x14(%ebp),%eax
    3b44:	50                   	push   %eax
    3b45:	68 a0 02 40 00       	push   $0x4002a0
    3b4a:	e8 e4 f3 01 00       	call   22f33 <k_mem_slab_free>
    3b4f:	58                   	pop    %eax
    3b50:	5a                   	pop    %edx
}
    3b51:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3b54:	5b                   	pop    %ebx
    3b55:	5e                   	pop    %esi
    3b56:	5f                   	pop    %edi
    3b57:	5d                   	pop    %ebp
    3b58:	c3                   	ret    

00003b59 <log_msg_put>:
{
    3b59:	55                   	push   %ebp
    3b5a:	89 e5                	mov    %esp,%ebp
    3b5c:	8b 45 08             	mov    0x8(%ebp),%eax
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    3b5f:	f0 ff 48 04          	lock decl 0x4(%eax)
	if (msg->hdr.ref_cnt == 0) {
    3b63:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    3b67:	75 06                	jne    3b6f <log_msg_put+0x16>
}
    3b69:	5d                   	pop    %ebp
		msg_free(msg);
    3b6a:	e9 5b ff ff ff       	jmp    3aca <msg_free>
}
    3b6f:	5d                   	pop    %ebp
    3b70:	c3                   	ret    

00003b71 <log_msg_str_get>:
{
    3b71:	55                   	push   %ebp
    3b72:	89 e5                	mov    %esp,%ebp
	return msg->str;
    3b74:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3b77:	5d                   	pop    %ebp
	return msg->str;
    3b78:	8b 40 10             	mov    0x10(%eax),%eax
}
    3b7b:	c3                   	ret    

00003b7c <log_msg_create_n>:
{
    3b7c:	55                   	push   %ebp
    3b7d:	89 e5                	mov    %esp,%ebp
    3b7f:	57                   	push   %edi
    3b80:	56                   	push   %esi
    3b81:	53                   	push   %ebx
    3b82:	83 ec 0c             	sub    $0xc,%esp
    3b85:	8b 75 10             	mov    0x10(%ebp),%esi
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    3b88:	e8 b3 fe ff ff       	call   3a40 <log_msg_chunk_alloc>
    3b8d:	89 c3                	mov    %eax,%ebx
	if (msg != NULL) {
    3b8f:	85 c0                	test   %eax,%eax
    3b91:	0f 84 e7 00 00 00    	je     3c7e <log_msg_create_n+0x102>
		msg->hdr.ref_cnt = 1;
    3b97:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0;
    3b9e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    3ba4:	83 fe 03             	cmp    $0x3,%esi
    3ba7:	76 43                	jbe    3bec <log_msg_create_n+0x70>
	msg->hdr.params.generic.ext = 1;
    3ba9:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
    3baf:	8d 7e fe             	lea    -0x2(%esi),%edi
	next = &msg->payload.ext.next;
    3bb2:	8d 48 14             	lea    0x14(%eax),%ecx
	*next = NULL;
    3bb5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	while (n > 0) {
    3bbc:	85 ff                	test   %edi,%edi
    3bbe:	7e 2c                	jle    3bec <log_msg_create_n+0x70>
    3bc0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    3bc3:	e8 78 fe ff ff       	call   3a40 <log_msg_chunk_alloc>
		if (cont == NULL) {
    3bc8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    3bcb:	85 c0                	test   %eax,%eax
    3bcd:	75 0e                	jne    3bdd <log_msg_create_n+0x61>
			msg_free(msg);
    3bcf:	89 d8                	mov    %ebx,%eax
			return NULL;
    3bd1:	31 db                	xor    %ebx,%ebx
			msg_free(msg);
    3bd3:	e8 f2 fe ff ff       	call   3aca <msg_free>
	if (msg != NULL) {
    3bd8:	e9 a1 00 00 00       	jmp    3c7e <log_msg_create_n+0x102>
		*next = cont;
    3bdd:	89 01                	mov    %eax,(%ecx)
		cont->next = NULL;
    3bdf:	83 ef 07             	sub    $0x7,%edi
    3be2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		next = &cont->next;
    3be8:	89 c1                	mov    %eax,%ecx
		n -= ARGS_CONT_MSG;
    3bea:	eb d0                	jmp    3bbc <log_msg_create_n+0x40>
		msg->str = str;
    3bec:	8b 45 08             	mov    0x8(%ebp),%eax
		msg->hdr.params.std.nargs = nargs;
    3bef:	89 f2                	mov    %esi,%edx
    3bf1:	c1 e2 04             	shl    $0x4,%edx
		msg->str = str;
    3bf4:	89 43 10             	mov    %eax,0x10(%ebx)
		msg->hdr.params.std.nargs = nargs;
    3bf7:	8a 43 09             	mov    0x9(%ebx),%al
    3bfa:	83 e0 0f             	and    $0xf,%eax
    3bfd:	09 d0                	or     %edx,%eax
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    3bff:	83 fe 03             	cmp    $0x3,%esi
		msg->hdr.params.std.nargs = nargs;
    3c02:	88 43 09             	mov    %al,0x9(%ebx)
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    3c05:	76 22                	jbe    3c29 <log_msg_create_n+0xad>
	struct log_msg_cont *cont = msg->payload.ext.next;
    3c07:	8b 43 14             	mov    0x14(%ebx),%eax
		(void)memcpy(msg->payload.ext.data.args, args,
    3c0a:	6a 08                	push   $0x8
    3c0c:	ff 75 0c             	pushl  0xc(%ebp)
	struct log_msg_cont *cont = msg->payload.ext.next;
    3c0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		(void)memcpy(msg->payload.ext.data.args, args,
    3c12:	8d 43 18             	lea    0x18(%ebx),%eax
    3c15:	50                   	push   %eax
    3c16:	e8 16 6d 00 00       	call   a931 <memcpy>
		args += LOG_MSG_NARGS_HEAD_CHUNK;
    3c1b:	8b 45 0c             	mov    0xc(%ebp),%eax
		(void)memcpy(msg->payload.ext.data.args, args,
    3c1e:	83 c4 0c             	add    $0xc,%esp
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
    3c21:	8d 56 fe             	lea    -0x2(%esi),%edx
		args += LOG_MSG_NARGS_HEAD_CHUNK;
    3c24:	8d 78 08             	lea    0x8(%eax),%edi
    3c27:	eb 47                	jmp    3c70 <log_msg_create_n+0xf4>
		(void)memcpy(msg->payload.single.args, args,
    3c29:	c1 e6 02             	shl    $0x2,%esi
    3c2c:	8d 43 14             	lea    0x14(%ebx),%eax
    3c2f:	56                   	push   %esi
    3c30:	ff 75 0c             	pushl  0xc(%ebp)
    3c33:	50                   	push   %eax
    3c34:	e8 f8 6c 00 00       	call   a931 <memcpy>
    3c39:	83 c4 0c             	add    $0xc,%esp
		nargs  = 0U;
    3c3c:	eb 40                	jmp    3c7e <log_msg_create_n+0x102>
		(void)memcpy(cont->payload.args, args,
    3c3e:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
    3c45:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3c48:	51                   	push   %ecx
    3c49:	83 c0 04             	add    $0x4,%eax
    3c4c:	57                   	push   %edi
    3c4d:	89 55 e8             	mov    %edx,-0x18(%ebp)
    3c50:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    3c53:	50                   	push   %eax
    3c54:	e8 d8 6c 00 00       	call   a931 <memcpy>
		cont = cont->next;
    3c59:	8b 45 f0             	mov    -0x10(%ebp),%eax
		args += cpy_args;
    3c5c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	while (nargs != 0) {
    3c5f:	8b 55 e8             	mov    -0x18(%ebp),%edx
		(void)memcpy(cont->payload.args, args,
    3c62:	83 c4 0c             	add    $0xc,%esp
		args += cpy_args;
    3c65:	01 cf                	add    %ecx,%edi
		cont = cont->next;
    3c67:	8b 00                	mov    (%eax),%eax
	while (nargs != 0) {
    3c69:	29 f2                	sub    %esi,%edx
		cont = cont->next;
    3c6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (nargs != 0) {
    3c6e:	74 0e                	je     3c7e <log_msg_create_n+0x102>
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
    3c70:	89 d6                	mov    %edx,%esi
    3c72:	83 fa 07             	cmp    $0x7,%edx
    3c75:	76 c7                	jbe    3c3e <log_msg_create_n+0xc2>
    3c77:	be 07 00 00 00       	mov    $0x7,%esi
    3c7c:	eb c0                	jmp    3c3e <log_msg_create_n+0xc2>
}
    3c7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3c81:	89 d8                	mov    %ebx,%eax
    3c83:	5b                   	pop    %ebx
    3c84:	5e                   	pop    %esi
    3c85:	5f                   	pop    %edi
    3c86:	5d                   	pop    %ebp
    3c87:	c3                   	ret    

00003c88 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
    3c88:	55                   	push   %ebp
    3c89:	89 e5                	mov    %esp,%ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    3c8b:	8b 4d 14             	mov    0x14(%ebp),%ecx
{
    3c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c91:	8b 55 0c             	mov    0xc(%ebp),%edx
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    3c94:	89 4d 08             	mov    %ecx,0x8(%ebp)
    3c97:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3c9a:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
    3ca1:	5d                   	pop    %ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    3ca2:	e9 43 fc ff ff       	jmp    38ea <log_msg_hexdump_data_op>

00003ca7 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, u8_t *buf, size_t len,
			 void *ctx)
{
    3ca7:	55                   	push   %ebp
    3ca8:	89 e5                	mov    %esp,%ebp
    3caa:	57                   	push   %edi
    3cab:	56                   	push   %esi
    3cac:	89 d7                	mov    %edx,%edi
    3cae:	53                   	push   %ebx
    3caf:	89 c6                	mov    %eax,%esi
    3cb1:	89 cb                	mov    %ecx,%ebx
	int processed;

	do {
		processed = outf(buf, len, ctx);
    3cb3:	ff 75 08             	pushl  0x8(%ebp)
    3cb6:	53                   	push   %ebx
    3cb7:	57                   	push   %edi
    3cb8:	ff d6                	call   *%esi
    3cba:	83 c4 0c             	add    $0xc,%esp
		len -= processed;
		buf += processed;
    3cbd:	01 c7                	add    %eax,%edi
	} while (len != 0);
    3cbf:	29 c3                	sub    %eax,%ebx
    3cc1:	75 f0                	jne    3cb3 <buffer_write+0xc>
}
    3cc3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3cc6:	5b                   	pop    %ebx
    3cc7:	5e                   	pop    %esi
    3cc8:	5f                   	pop    %edi
    3cc9:	5d                   	pop    %ebp
    3cca:	c3                   	ret    

00003ccb <print_formatted>:
{
    3ccb:	55                   	push   %ebp
    3ccc:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
    3cce:	8d 45 10             	lea    0x10(%ebp),%eax
	_vprintk(out_func, (void *)log_output, fmt, args);
    3cd1:	50                   	push   %eax
    3cd2:	ff 75 0c             	pushl  0xc(%ebp)
    3cd5:	ff 75 08             	pushl  0x8(%ebp)
    3cd8:	68 1a 42 00 00       	push   $0x421a
    3cdd:	e8 4a eb ff ff       	call   282c <_vprintk>
    3ce2:	83 c4 10             	add    $0x10,%esp
}
    3ce5:	31 c0                	xor    %eax,%eax
    3ce7:	c9                   	leave  
    3ce8:	c3                   	ret    

00003ce9 <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *log_output)
{
    3ce9:	55                   	push   %ebp
    3cea:	89 e5                	mov    %esp,%ebp
    3cec:	57                   	push   %edi
    3ced:	56                   	push   %esi
    3cee:	89 d6                	mov    %edx,%esi
    3cf0:	53                   	push   %ebx
    3cf1:	83 ec 0c             	sub    $0xc,%esp
    3cf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	const char *str = log_msg_str_get(msg);
    3cf7:	50                   	push   %eax
    3cf8:	e8 74 fe ff ff       	call   3b71 <log_msg_str_get>
    3cfd:	5b                   	pop    %ebx
    3cfe:	89 c7                	mov    %eax,%edi
	u32_t nargs = log_msg_nargs_get(msg);
    3d00:	ff 75 f0             	pushl  -0x10(%ebp)
    3d03:	e8 67 fd ff ff       	call   3a6f <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
    3d08:	31 c9                	xor    %ecx,%ecx
	u32_t nargs = log_msg_nargs_get(msg);
    3d0a:	5a                   	pop    %edx
    3d0b:	89 c2                	mov    %eax,%edx
	u32_t *args = alloca(sizeof(u32_t)*nargs);
    3d0d:	8d 04 85 0c 00 00 00 	lea    0xc(,%eax,4),%eax
    3d14:	29 c4                	sub    %eax,%esp
    3d16:	8d 5c 24 0f          	lea    0xf(%esp),%ebx
    3d1a:	83 e3 f0             	and    $0xfffffff0,%ebx
	for (i = 0; i < nargs; i++) {
    3d1d:	39 d1                	cmp    %edx,%ecx
    3d1f:	74 1d                	je     3d3e <std_print+0x55>
		args[i] = log_msg_arg_get(msg, i);
    3d21:	51                   	push   %ecx
    3d22:	89 55 e8             	mov    %edx,-0x18(%ebp)
    3d25:	ff 75 f0             	pushl  -0x10(%ebp)
    3d28:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    3d2b:	e8 50 fd ff ff       	call   3a80 <log_msg_arg_get>
    3d30:	5a                   	pop    %edx
	for (i = 0; i < nargs; i++) {
    3d31:	8b 55 e8             	mov    -0x18(%ebp),%edx
		args[i] = log_msg_arg_get(msg, i);
    3d34:	59                   	pop    %ecx
    3d35:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    3d38:	89 04 8b             	mov    %eax,(%ebx,%ecx,4)
	for (i = 0; i < nargs; i++) {
    3d3b:	41                   	inc    %ecx
    3d3c:	eb df                	jmp    3d1d <std_print+0x34>
	}

	switch (log_msg_nargs_get(msg)) {
    3d3e:	ff 75 f0             	pushl  -0x10(%ebp)
    3d41:	e8 29 fd ff ff       	call   3a6f <log_msg_nargs_get>
    3d46:	59                   	pop    %ecx
    3d47:	83 f8 0f             	cmp    $0xf,%eax
    3d4a:	0f 87 44 02 00 00    	ja     3f94 <std_print+0x2ab>
    3d50:	ff 24 85 b4 5c 02 00 	jmp    *0x25cb4(,%eax,4)
	case 0:
		print_formatted(log_output, str);
    3d57:	57                   	push   %edi
    3d58:	56                   	push   %esi
    3d59:	e8 6d ff ff ff       	call   3ccb <print_formatted>
    3d5e:	58                   	pop    %eax
    3d5f:	5a                   	pop    %edx
		break;
    3d60:	e9 2f 02 00 00       	jmp    3f94 <std_print+0x2ab>
	case 1:
		print_formatted(log_output, str, args[0]);
    3d65:	ff 33                	pushl  (%ebx)
    3d67:	57                   	push   %edi
    3d68:	56                   	push   %esi
    3d69:	e8 5d ff ff ff       	call   3ccb <print_formatted>
    3d6e:	83 c4 0c             	add    $0xc,%esp
		break;
    3d71:	e9 1e 02 00 00       	jmp    3f94 <std_print+0x2ab>
	case 2:
		print_formatted(log_output, str, args[0], args[1]);
    3d76:	ff 73 04             	pushl  0x4(%ebx)
    3d79:	ff 33                	pushl  (%ebx)
    3d7b:	57                   	push   %edi
    3d7c:	56                   	push   %esi
    3d7d:	e8 49 ff ff ff       	call   3ccb <print_formatted>
    3d82:	83 c4 10             	add    $0x10,%esp
		break;
    3d85:	e9 0a 02 00 00       	jmp    3f94 <std_print+0x2ab>
	case 3:
		print_formatted(log_output, str, args[0], args[1], args[2]);
    3d8a:	ff 73 08             	pushl  0x8(%ebx)
    3d8d:	ff 73 04             	pushl  0x4(%ebx)
    3d90:	ff 33                	pushl  (%ebx)
    3d92:	57                   	push   %edi
    3d93:	56                   	push   %esi
    3d94:	e8 32 ff ff ff       	call   3ccb <print_formatted>
    3d99:	83 c4 14             	add    $0x14,%esp
		break;
    3d9c:	e9 f3 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 4:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3da1:	ff 73 0c             	pushl  0xc(%ebx)
    3da4:	ff 73 08             	pushl  0x8(%ebx)
    3da7:	ff 73 04             	pushl  0x4(%ebx)
    3daa:	ff 33                	pushl  (%ebx)
    3dac:	57                   	push   %edi
    3dad:	56                   	push   %esi
    3dae:	e8 18 ff ff ff       	call   3ccb <print_formatted>
    3db3:	83 c4 18             	add    $0x18,%esp
				args[3]);
		break;
    3db6:	e9 d9 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 5:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3dbb:	ff 73 10             	pushl  0x10(%ebx)
    3dbe:	ff 73 0c             	pushl  0xc(%ebx)
    3dc1:	ff 73 08             	pushl  0x8(%ebx)
    3dc4:	ff 73 04             	pushl  0x4(%ebx)
    3dc7:	ff 33                	pushl  (%ebx)
    3dc9:	57                   	push   %edi
    3dca:	56                   	push   %esi
    3dcb:	e8 fb fe ff ff       	call   3ccb <print_formatted>
    3dd0:	83 c4 1c             	add    $0x1c,%esp
				args[3], args[4]);
		break;
    3dd3:	e9 bc 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 6:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3dd8:	ff 73 14             	pushl  0x14(%ebx)
    3ddb:	ff 73 10             	pushl  0x10(%ebx)
    3dde:	ff 73 0c             	pushl  0xc(%ebx)
    3de1:	ff 73 08             	pushl  0x8(%ebx)
    3de4:	ff 73 04             	pushl  0x4(%ebx)
    3de7:	ff 33                	pushl  (%ebx)
    3de9:	57                   	push   %edi
    3dea:	56                   	push   %esi
    3deb:	e8 db fe ff ff       	call   3ccb <print_formatted>
    3df0:	83 c4 20             	add    $0x20,%esp
				args[3], args[4], args[5]);
		break;
    3df3:	e9 9c 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 7:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3df8:	ff 73 18             	pushl  0x18(%ebx)
    3dfb:	ff 73 14             	pushl  0x14(%ebx)
    3dfe:	ff 73 10             	pushl  0x10(%ebx)
    3e01:	ff 73 0c             	pushl  0xc(%ebx)
    3e04:	ff 73 08             	pushl  0x8(%ebx)
    3e07:	ff 73 04             	pushl  0x4(%ebx)
    3e0a:	ff 33                	pushl  (%ebx)
    3e0c:	57                   	push   %edi
    3e0d:	56                   	push   %esi
    3e0e:	e8 b8 fe ff ff       	call   3ccb <print_formatted>
    3e13:	83 c4 24             	add    $0x24,%esp
				args[3], args[4], args[5], args[6]);
		break;
    3e16:	e9 79 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 8:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3e1b:	ff 73 1c             	pushl  0x1c(%ebx)
    3e1e:	ff 73 18             	pushl  0x18(%ebx)
    3e21:	ff 73 14             	pushl  0x14(%ebx)
    3e24:	ff 73 10             	pushl  0x10(%ebx)
    3e27:	ff 73 0c             	pushl  0xc(%ebx)
    3e2a:	ff 73 08             	pushl  0x8(%ebx)
    3e2d:	ff 73 04             	pushl  0x4(%ebx)
    3e30:	ff 33                	pushl  (%ebx)
    3e32:	57                   	push   %edi
    3e33:	56                   	push   %esi
    3e34:	e8 92 fe ff ff       	call   3ccb <print_formatted>
    3e39:	83 c4 28             	add    $0x28,%esp
				args[3], args[4], args[5], args[6], args[7]);
		break;
    3e3c:	e9 53 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 9:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3e41:	ff 73 20             	pushl  0x20(%ebx)
    3e44:	ff 73 1c             	pushl  0x1c(%ebx)
    3e47:	ff 73 18             	pushl  0x18(%ebx)
    3e4a:	ff 73 14             	pushl  0x14(%ebx)
    3e4d:	ff 73 10             	pushl  0x10(%ebx)
    3e50:	ff 73 0c             	pushl  0xc(%ebx)
    3e53:	ff 73 08             	pushl  0x8(%ebx)
    3e56:	ff 73 04             	pushl  0x4(%ebx)
    3e59:	ff 33                	pushl  (%ebx)
    3e5b:	57                   	push   %edi
    3e5c:	56                   	push   %esi
    3e5d:	e8 69 fe ff ff       	call   3ccb <print_formatted>
    3e62:	83 c4 2c             	add    $0x2c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8]);
		break;
    3e65:	e9 2a 01 00 00       	jmp    3f94 <std_print+0x2ab>
	case 10:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3e6a:	ff 73 24             	pushl  0x24(%ebx)
    3e6d:	ff 73 20             	pushl  0x20(%ebx)
    3e70:	ff 73 1c             	pushl  0x1c(%ebx)
    3e73:	ff 73 18             	pushl  0x18(%ebx)
    3e76:	ff 73 14             	pushl  0x14(%ebx)
    3e79:	ff 73 10             	pushl  0x10(%ebx)
    3e7c:	ff 73 0c             	pushl  0xc(%ebx)
    3e7f:	ff 73 08             	pushl  0x8(%ebx)
    3e82:	ff 73 04             	pushl  0x4(%ebx)
    3e85:	ff 33                	pushl  (%ebx)
    3e87:	57                   	push   %edi
    3e88:	56                   	push   %esi
    3e89:	e8 3d fe ff ff       	call   3ccb <print_formatted>
    3e8e:	83 c4 30             	add    $0x30,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9]);
		break;
    3e91:	e9 fe 00 00 00       	jmp    3f94 <std_print+0x2ab>
	case 11:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3e96:	ff 73 28             	pushl  0x28(%ebx)
    3e99:	ff 73 24             	pushl  0x24(%ebx)
    3e9c:	ff 73 20             	pushl  0x20(%ebx)
    3e9f:	ff 73 1c             	pushl  0x1c(%ebx)
    3ea2:	ff 73 18             	pushl  0x18(%ebx)
    3ea5:	ff 73 14             	pushl  0x14(%ebx)
    3ea8:	ff 73 10             	pushl  0x10(%ebx)
    3eab:	ff 73 0c             	pushl  0xc(%ebx)
    3eae:	ff 73 08             	pushl  0x8(%ebx)
    3eb1:	ff 73 04             	pushl  0x4(%ebx)
    3eb4:	ff 33                	pushl  (%ebx)
    3eb6:	57                   	push   %edi
    3eb7:	56                   	push   %esi
    3eb8:	e8 0e fe ff ff       	call   3ccb <print_formatted>
    3ebd:	83 c4 34             	add    $0x34,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10]);
		break;
    3ec0:	e9 cf 00 00 00       	jmp    3f94 <std_print+0x2ab>
	case 12:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3ec5:	ff 73 2c             	pushl  0x2c(%ebx)
    3ec8:	ff 73 28             	pushl  0x28(%ebx)
    3ecb:	ff 73 24             	pushl  0x24(%ebx)
    3ece:	ff 73 20             	pushl  0x20(%ebx)
    3ed1:	ff 73 1c             	pushl  0x1c(%ebx)
    3ed4:	ff 73 18             	pushl  0x18(%ebx)
    3ed7:	ff 73 14             	pushl  0x14(%ebx)
    3eda:	ff 73 10             	pushl  0x10(%ebx)
    3edd:	ff 73 0c             	pushl  0xc(%ebx)
    3ee0:	ff 73 08             	pushl  0x8(%ebx)
    3ee3:	ff 73 04             	pushl  0x4(%ebx)
    3ee6:	ff 33                	pushl  (%ebx)
    3ee8:	57                   	push   %edi
    3ee9:	56                   	push   %esi
    3eea:	e8 dc fd ff ff       	call   3ccb <print_formatted>
    3eef:	83 c4 38             	add    $0x38,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11]);
		break;
    3ef2:	e9 9d 00 00 00       	jmp    3f94 <std_print+0x2ab>
	case 13:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3ef7:	ff 73 30             	pushl  0x30(%ebx)
    3efa:	ff 73 2c             	pushl  0x2c(%ebx)
    3efd:	ff 73 28             	pushl  0x28(%ebx)
    3f00:	ff 73 24             	pushl  0x24(%ebx)
    3f03:	ff 73 20             	pushl  0x20(%ebx)
    3f06:	ff 73 1c             	pushl  0x1c(%ebx)
    3f09:	ff 73 18             	pushl  0x18(%ebx)
    3f0c:	ff 73 14             	pushl  0x14(%ebx)
    3f0f:	ff 73 10             	pushl  0x10(%ebx)
    3f12:	ff 73 0c             	pushl  0xc(%ebx)
    3f15:	ff 73 08             	pushl  0x8(%ebx)
    3f18:	ff 73 04             	pushl  0x4(%ebx)
    3f1b:	ff 33                	pushl  (%ebx)
    3f1d:	57                   	push   %edi
    3f1e:	56                   	push   %esi
    3f1f:	e8 a7 fd ff ff       	call   3ccb <print_formatted>
    3f24:	83 c4 3c             	add    $0x3c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12]);
		break;
    3f27:	eb 6b                	jmp    3f94 <std_print+0x2ab>
	case 14:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3f29:	ff 73 34             	pushl  0x34(%ebx)
    3f2c:	ff 73 30             	pushl  0x30(%ebx)
    3f2f:	ff 73 2c             	pushl  0x2c(%ebx)
    3f32:	ff 73 28             	pushl  0x28(%ebx)
    3f35:	ff 73 24             	pushl  0x24(%ebx)
    3f38:	ff 73 20             	pushl  0x20(%ebx)
    3f3b:	ff 73 1c             	pushl  0x1c(%ebx)
    3f3e:	ff 73 18             	pushl  0x18(%ebx)
    3f41:	ff 73 14             	pushl  0x14(%ebx)
    3f44:	ff 73 10             	pushl  0x10(%ebx)
    3f47:	ff 73 0c             	pushl  0xc(%ebx)
    3f4a:	ff 73 08             	pushl  0x8(%ebx)
    3f4d:	ff 73 04             	pushl  0x4(%ebx)
    3f50:	ff 33                	pushl  (%ebx)
    3f52:	57                   	push   %edi
    3f53:	56                   	push   %esi
    3f54:	e8 72 fd ff ff       	call   3ccb <print_formatted>
    3f59:	83 c4 40             	add    $0x40,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12],
				args[13]);
		break;
    3f5c:	eb 36                	jmp    3f94 <std_print+0x2ab>
	case 15:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3f5e:	ff 73 38             	pushl  0x38(%ebx)
    3f61:	ff 73 34             	pushl  0x34(%ebx)
    3f64:	ff 73 30             	pushl  0x30(%ebx)
    3f67:	ff 73 2c             	pushl  0x2c(%ebx)
    3f6a:	ff 73 28             	pushl  0x28(%ebx)
    3f6d:	ff 73 24             	pushl  0x24(%ebx)
    3f70:	ff 73 20             	pushl  0x20(%ebx)
    3f73:	ff 73 1c             	pushl  0x1c(%ebx)
    3f76:	ff 73 18             	pushl  0x18(%ebx)
    3f79:	ff 73 14             	pushl  0x14(%ebx)
    3f7c:	ff 73 10             	pushl  0x10(%ebx)
    3f7f:	ff 73 0c             	pushl  0xc(%ebx)
    3f82:	ff 73 08             	pushl  0x8(%ebx)
    3f85:	ff 73 04             	pushl  0x4(%ebx)
    3f88:	ff 33                	pushl  (%ebx)
    3f8a:	57                   	push   %edi
    3f8b:	56                   	push   %esi
    3f8c:	e8 3a fd ff ff       	call   3ccb <print_formatted>
    3f91:	83 c4 44             	add    $0x44,%esp
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
    3f94:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3f97:	5b                   	pop    %ebx
    3f98:	5e                   	pop    %esi
    3f99:	5f                   	pop    %edi
    3f9a:	5d                   	pop    %ebp
    3f9b:	c3                   	ret    

00003f9c <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
    3f9c:	55                   	push   %ebp
    3f9d:	89 e5                	mov    %esp,%ebp
    3f9f:	57                   	push   %edi
    3fa0:	56                   	push   %esi
    3fa1:	53                   	push   %ebx
    3fa2:	89 c3                	mov    %eax,%ebx
    3fa4:	83 ec 1c             	sub    $0x1c,%esp
    3fa7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    3faa:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fad:	8b 75 08             	mov    0x8(%ebp),%esi
    3fb0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    3fb3:	8b 45 10             	mov    0x10(%ebp),%eax
    3fb6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3fb9:	8b 45 14             	mov    0x14(%ebp),%eax
    3fbc:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32_t length = 0;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    3fbf:	89 d0                	mov    %edx,%eax
    3fc1:	83 e0 01             	and    $0x1,%eax
    3fc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    3fc7:	89 d0                	mov    %edx,%eax
    3fc9:	83 e0 08             	and    $0x8,%eax
    3fcc:	89 45 e8             	mov    %eax,-0x18(%ebp)
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    3fcf:	89 d0                	mov    %edx,%eax
    3fd1:	83 e0 02             	and    $0x2,%eax
    3fd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3fd7:	74 7a                	je     4053 <prefix_print+0xb7>
	if (!format) {
    3fd9:	80 e2 44             	and    $0x44,%dl
    3fdc:	75 11                	jne    3fef <prefix_print+0x53>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    3fde:	56                   	push   %esi
    3fdf:	68 db 69 02 00       	push   $0x269db
    3fe4:	53                   	push   %ebx
    3fe5:	e8 e1 fc ff ff       	call   3ccb <print_formatted>
    3fea:	83 c4 0c             	add    $0xc,%esp
    3fed:	eb 61                	jmp    4050 <prefix_print+0xb4>
	} else if (freq != 0) {
    3fef:	8b 3d ec 41 40 00    	mov    0x4041ec,%edi
		length = 0;
    3ff5:	31 c0                	xor    %eax,%eax
	} else if (freq != 0) {
    3ff7:	85 ff                	test   %edi,%edi
    3ff9:	74 55                	je     4050 <prefix_print+0xb4>
		timestamp /= timestamp_div;
    3ffb:	89 f0                	mov    %esi,%eax
    3ffd:	31 d2                	xor    %edx,%edx
    3fff:	f7 35 e8 41 40 00    	divl   0x4041e8
    4005:	31 d2                	xor    %edx,%edx
    4007:	b9 10 0e 00 00       	mov    $0xe10,%ecx
    400c:	f7 f7                	div    %edi
    400e:	89 d6                	mov    %edx,%esi
		seconds -= hours * 3600;
    4010:	31 d2                	xor    %edx,%edx
		ms = (remainder * 1000) / freq;
    4012:	69 f6 e8 03 00 00    	imul   $0x3e8,%esi,%esi
    4018:	f7 f1                	div    %ecx
    401a:	89 55 f0             	mov    %edx,-0x10(%ebp)
    401d:	89 c1                	mov    %eax,%ecx
    401f:	31 d2                	xor    %edx,%edx
    4021:	89 f0                	mov    %esi,%eax
    4023:	f7 f7                	div    %edi
    4025:	89 c6                	mov    %eax,%esi
		us = (1000 * (1000 * remainder - (ms * freq))) / freq;
    4027:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
    402d:	31 d2                	xor    %edx,%edx
    402f:	f7 f7                	div    %edi
			length = print_formatted(log_output,
    4031:	50                   	push   %eax
    4032:	31 d2                	xor    %edx,%edx
    4034:	56                   	push   %esi
    4035:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4038:	be 3c 00 00 00       	mov    $0x3c,%esi
    403d:	f7 f6                	div    %esi
    403f:	52                   	push   %edx
    4040:	50                   	push   %eax
    4041:	51                   	push   %ecx
    4042:	68 e4 69 02 00       	push   $0x269e4
    4047:	53                   	push   %ebx
    4048:	e8 7e fc ff ff       	call   3ccb <print_formatted>
    404d:	83 c4 1c             	add    $0x1c,%esp
		length += timestamp_print(log_output, flags, timestamp);
    4050:	89 45 f0             	mov    %eax,-0x10(%ebp)
			log_output->control_block->hostname ?
			log_output->control_block->hostname :
			"zephyr");

	} else {
		color_prefix(log_output, colors_on, level);
    4053:	0f b6 75 e0          	movzbl -0x20(%ebp),%esi
	if (color) {
    4057:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    405b:	74 1f                	je     407c <prefix_print+0xe0>
		const char *color = start && (colors[level] != NULL) ?
    405d:	8b 04 b5 14 5d 02 00 	mov    0x25d14(,%esi,4),%eax
    4064:	85 c0                	test   %eax,%eax
    4066:	75 05                	jne    406d <prefix_print+0xd1>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    4068:	b8 cd 69 02 00       	mov    $0x269cd,%eax
		print_formatted(log_output, "%s", color);
    406d:	50                   	push   %eax
    406e:	68 6a a5 02 00       	push   $0x2a56a
    4073:	53                   	push   %ebx
    4074:	e8 52 fc ff ff       	call   3ccb <print_formatted>
    4079:	83 c4 0c             	add    $0xc,%esp
	int total = 0;
    407c:	31 ff                	xor    %edi,%edi
		length += ids_print(log_output, level_on, func_on,
    407e:	0f b7 4d d8          	movzwl -0x28(%ebp),%ecx
    4082:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
	if (level_on) {
    4086:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    408a:	74 23                	je     40af <prefix_print+0x113>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    408c:	ff 34 b5 28 5d 02 00 	pushl  0x25d28(,%esi,4)
    4093:	89 55 e8             	mov    %edx,-0x18(%ebp)
    4096:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    4099:	68 00 6a 02 00       	push   $0x26a00
    409e:	53                   	push   %ebx
    409f:	e8 27 fc ff ff       	call   3ccb <print_formatted>
    40a4:	83 c4 0c             	add    $0xc,%esp
    40a7:	89 c7                	mov    %eax,%edi
    40a9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    40ac:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	total += print_formatted(log_output,
    40af:	51                   	push   %ecx
    40b0:	52                   	push   %edx
    40b1:	e8 07 f5 ff ff       	call   35bd <log_source_name_get>
    40b6:	5a                   	pop    %edx
    40b7:	ba d2 69 02 00       	mov    $0x269d2,%edx
    40bc:	59                   	pop    %ecx
    40bd:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
    40c1:	74 0a                	je     40cd <prefix_print+0x131>
				(func_on &&
    40c3:	83 fe 04             	cmp    $0x4,%esi
    40c6:	75 05                	jne    40cd <prefix_print+0x131>
	total += print_formatted(log_output,
    40c8:	ba d7 69 02 00       	mov    $0x269d7,%edx
    40cd:	50                   	push   %eax
    40ce:	52                   	push   %edx
    40cf:	53                   	push   %ebx
    40d0:	e8 f6 fb ff ff       	call   3ccb <print_formatted>
    40d5:	01 f8                	add    %edi,%eax
    40d7:	83 c4 0c             	add    $0xc,%esp
		length += ids_print(log_output, level_on, func_on,
    40da:	03 45 f0             	add    -0x10(%ebp),%eax
				    domain_id, source_id, level);
	}

	return length;
}
    40dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    40e0:	5b                   	pop    %ebx
    40e1:	5e                   	pop    %esi
    40e2:	5f                   	pop    %edi
    40e3:	5d                   	pop    %ebp
    40e4:	c3                   	ret    

000040e5 <hexdump_line_print>:
{
    40e5:	55                   	push   %ebp
    40e6:	89 e5                	mov    %esp,%ebp
    40e8:	57                   	push   %edi
    40e9:	56                   	push   %esi
    40ea:	89 d6                	mov    %edx,%esi
    40ec:	53                   	push   %ebx
    40ed:	53                   	push   %ebx
    40ee:	89 c3                	mov    %eax,%ebx
    40f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    40f3:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0) {
    40f6:	a8 10                	test   $0x10,%al
    40f8:	75 18                	jne    4112 <hexdump_line_print+0x2d>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0) {
    40fa:	a8 20                	test   $0x20,%al
    40fc:	74 07                	je     4105 <hexdump_line_print+0x20>
		print_formatted(ctx, "\n");
    40fe:	68 b9 6d 02 00       	push   $0x26db9
    4103:	eb 05                	jmp    410a <hexdump_line_print+0x25>
		print_formatted(ctx, "\r\n");
    4105:	68 5f 6a 02 00       	push   $0x26a5f
    410a:	53                   	push   %ebx
    410b:	e8 bb fb ff ff       	call   3ccb <print_formatted>
    4110:	58                   	pop    %eax
    4111:	5a                   	pop    %edx
{
    4112:	31 ff                	xor    %edi,%edi
	for (int i = 0; i < prefix_offset; i++) {
    4114:	3b 7d 08             	cmp    0x8(%ebp),%edi
    4117:	7d 10                	jge    4129 <hexdump_line_print+0x44>
		print_formatted(log_output, " ");
    4119:	68 98 86 02 00       	push   $0x28698
	for (int i = 0; i < prefix_offset; i++) {
    411e:	47                   	inc    %edi
		print_formatted(log_output, " ");
    411f:	53                   	push   %ebx
    4120:	e8 a6 fb ff ff       	call   3ccb <print_formatted>
    4125:	59                   	pop    %ecx
    4126:	58                   	pop    %eax
    4127:	eb eb                	jmp    4114 <hexdump_line_print+0x2f>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    4129:	31 ff                	xor    %edi,%edi
		if (i < length) {
    412b:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    412e:	76 15                	jbe    4145 <hexdump_line_print+0x60>
			print_formatted(log_output, "%02x ", data[i]);
    4130:	0f b6 04 3e          	movzbl (%esi,%edi,1),%eax
    4134:	50                   	push   %eax
    4135:	68 06 6a 02 00       	push   $0x26a06
    413a:	53                   	push   %ebx
    413b:	e8 8b fb ff ff       	call   3ccb <print_formatted>
    4140:	83 c4 0c             	add    $0xc,%esp
    4143:	eb 0d                	jmp    4152 <hexdump_line_print+0x6d>
			print_formatted(log_output, "   ");
    4145:	68 96 86 02 00       	push   $0x28696
    414a:	53                   	push   %ebx
    414b:	e8 7b fb ff ff       	call   3ccb <print_formatted>
    4150:	58                   	pop    %eax
    4151:	5a                   	pop    %edx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    4152:	47                   	inc    %edi
    4153:	83 ff 08             	cmp    $0x8,%edi
    4156:	75 d3                	jne    412b <hexdump_line_print+0x46>
	print_formatted(log_output, "|");
    4158:	68 0c 6a 02 00       	push   $0x26a0c
    415d:	53                   	push   %ebx
    415e:	e8 68 fb ff ff       	call   3ccb <print_formatted>
    4163:	59                   	pop    %ecx
    4164:	5f                   	pop    %edi
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    4165:	31 ff                	xor    %edi,%edi
		if (i < length) {
    4167:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    416a:	76 22                	jbe    418e <hexdump_line_print+0xa9>
			      isprint((int)c) ? c : '.');
    416c:	0f be 04 3e          	movsbl (%esi,%edi,1),%eax
	return (int)((((unsigned)c) >= ' ') &&
    4170:	8d 48 e0             	lea    -0x20(%eax),%ecx
			print_formatted(log_output, "%c",
    4173:	83 f9 5e             	cmp    $0x5e,%ecx
    4176:	76 05                	jbe    417d <hexdump_line_print+0x98>
    4178:	b8 2e 00 00 00       	mov    $0x2e,%eax
    417d:	50                   	push   %eax
    417e:	68 d6 6d 02 00       	push   $0x26dd6
    4183:	53                   	push   %ebx
    4184:	e8 42 fb ff ff       	call   3ccb <print_formatted>
    4189:	83 c4 0c             	add    $0xc,%esp
    418c:	eb 0d                	jmp    419b <hexdump_line_print+0xb6>
			print_formatted(log_output, " ");
    418e:	68 98 86 02 00       	push   $0x28698
    4193:	53                   	push   %ebx
    4194:	e8 32 fb ff ff       	call   3ccb <print_formatted>
    4199:	58                   	pop    %eax
    419a:	5a                   	pop    %edx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    419b:	47                   	inc    %edi
    419c:	83 ff 08             	cmp    $0x8,%edi
    419f:	75 c6                	jne    4167 <hexdump_line_print+0x82>
}
    41a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    41a4:	5b                   	pop    %ebx
    41a5:	5e                   	pop    %esi
    41a6:	5f                   	pop    %edi
    41a7:	5d                   	pop    %ebp
    41a8:	c3                   	ret    

000041a9 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
    41a9:	55                   	push   %ebp
    41aa:	89 e5                	mov    %esp,%ebp
    41ac:	56                   	push   %esi
    41ad:	53                   	push   %ebx
    41ae:	89 d6                	mov    %edx,%esi
    41b0:	89 c3                	mov    %eax,%ebx
	if (color) {
    41b2:	83 e2 01             	and    $0x1,%edx
    41b5:	74 13                	je     41ca <postfix_print+0x21>
		print_formatted(log_output, "%s", color);
    41b7:	68 cd 69 02 00       	push   $0x269cd
    41bc:	68 6a a5 02 00       	push   $0x2a56a
    41c1:	50                   	push   %eax
    41c2:	e8 04 fb ff ff       	call   3ccb <print_formatted>
    41c7:	83 c4 0c             	add    $0xc,%esp
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0) {
    41ca:	f7 c6 10 00 00 00    	test   $0x10,%esi
    41d0:	75 19                	jne    41eb <postfix_print+0x42>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0) {
    41d2:	83 e6 20             	and    $0x20,%esi
    41d5:	74 07                	je     41de <postfix_print+0x35>
		print_formatted(ctx, "\n");
    41d7:	68 b9 6d 02 00       	push   $0x26db9
    41dc:	eb 05                	jmp    41e3 <postfix_print+0x3a>
		print_formatted(ctx, "\r\n");
    41de:	68 5f 6a 02 00       	push   $0x26a5f
    41e3:	53                   	push   %ebx
    41e4:	e8 e2 fa ff ff       	call   3ccb <print_formatted>
    41e9:	58                   	pop    %eax
    41ea:	5a                   	pop    %edx
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    41eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
    41ee:	5b                   	pop    %ebx
    41ef:	5e                   	pop    %esi
    41f0:	5d                   	pop    %ebp
    41f1:	c3                   	ret    

000041f2 <log_output_flush>:
{
    41f2:	55                   	push   %ebp
    41f3:	89 e5                	mov    %esp,%ebp
    41f5:	53                   	push   %ebx
    41f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
		     log_output->control_block->ctx);
    41f9:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(log_output->func, log_output->buf,
    41fc:	8b 53 08             	mov    0x8(%ebx),%edx
    41ff:	ff 70 04             	pushl  0x4(%eax)
    4202:	8b 08                	mov    (%eax),%ecx
    4204:	8b 03                	mov    (%ebx),%eax
    4206:	e8 9c fa ff ff       	call   3ca7 <buffer_write>
    420b:	58                   	pop    %eax
	log_output->control_block->offset = 0;
    420c:	8b 43 04             	mov    0x4(%ebx),%eax
}
    420f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	log_output->control_block->offset = 0;
    4212:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    4218:	c9                   	leave  
    4219:	c3                   	ret    

0000421a <out_func>:
{
    421a:	55                   	push   %ebp
    421b:	89 e5                	mov    %esp,%ebp
    421d:	53                   	push   %ebx
    421e:	8b 45 0c             	mov    0xc(%ebp),%eax
	out_ctx->buf[out_ctx->control_block->offset] = (u8_t)c;
    4221:	8a 5d 08             	mov    0x8(%ebp),%bl
    4224:	8b 50 04             	mov    0x4(%eax),%edx
    4227:	8b 48 08             	mov    0x8(%eax),%ecx
    422a:	8b 12                	mov    (%edx),%edx
    422c:	88 1c 11             	mov    %bl,(%ecx,%edx,1)
	out_ctx->control_block->offset++;
    422f:	8b 48 04             	mov    0x4(%eax),%ecx
    4232:	8b 19                	mov    (%ecx),%ebx
    4234:	8d 53 01             	lea    0x1(%ebx),%edx
    4237:	89 11                	mov    %edx,(%ecx)
	if (out_ctx->control_block->offset == out_ctx->size) {
    4239:	3b 50 0c             	cmp    0xc(%eax),%edx
    423c:	75 07                	jne    4245 <out_func+0x2b>
		log_output_flush(out_ctx);
    423e:	50                   	push   %eax
    423f:	e8 ae ff ff ff       	call   41f2 <log_output_flush>
    4244:	58                   	pop    %eax
}
    4245:	31 c0                	xor    %eax,%eax
    4247:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    424a:	c9                   	leave  
    424b:	c3                   	ret    

0000424c <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
    424c:	55                   	push   %ebp
    424d:	89 e5                	mov    %esp,%ebp
    424f:	57                   	push   %edi
    4250:	56                   	push   %esi
    4251:	53                   	push   %ebx
    4252:	83 ec 14             	sub    $0x14,%esp
	u16_t source_id = (u16_t)log_msg_source_id_get(msg);
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	int prefix_offset;

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    4255:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
{
    425c:	8b 7d 0c             	mov    0xc(%ebp),%edi
    425f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return msg->hdr.ids.level;
    4262:	8a 47 0a             	mov    0xa(%edi),%al
    4265:	66 8b 4f 08          	mov    0x8(%edi),%cx
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    4269:	88 c2                	mov    %al,%dl
    426b:	80 e2 07             	and    $0x7,%dl
    426e:	88 55 e7             	mov    %dl,-0x19(%ebp)
    4271:	74 30                	je     42a3 <log_output_msg_process+0x57>
	return msg->hdr.ids.domain_id;
    4273:	c0 e8 03             	shr    $0x3,%al
	return msg->hdr.ids.source_id;
    4276:	66 8b 57 0a          	mov    0xa(%edi),%dx
    427a:	66 c1 ea 06          	shr    $0x6,%dx
    427e:	83 e0 07             	and    $0x7,%eax
    4281:	0f b7 d2             	movzwl %dx,%edx
    4284:	52                   	push   %edx
    4285:	8b 55 10             	mov    0x10(%ebp),%edx
    4288:	50                   	push   %eax
    4289:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
    428d:	50                   	push   %eax
    428e:	89 d8                	mov    %ebx,%eax
    4290:	ff 77 0c             	pushl  0xc(%edi)
    4293:	f7 d1                	not    %ecx
    4295:	83 e1 01             	and    $0x1,%ecx
    4298:	e8 ff fc ff ff       	call   3f9c <prefix_print>
    429d:	83 c4 10             	add    $0x10,%esp
    42a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    42a3:	f6 47 08 01          	testb  $0x1,0x8(%edi)
    42a7:	75 18                	jne    42c1 <log_output_msg_process+0x75>
		std_print(msg, log_output);
    42a9:	89 da                	mov    %ebx,%edx
    42ab:	89 f8                	mov    %edi,%eax
    42ad:	e8 37 fa ff ff       	call   3ce9 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    42b2:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
    42b6:	0f 84 c3 00 00 00    	je     437f <log_output_msg_process+0x133>
    42bc:	e9 b0 00 00 00       	jmp    4371 <log_output_msg_process+0x125>
	} else if (raw_string) {
    42c1:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
    42c5:	75 5a                	jne    4321 <log_output_msg_process+0xd5>
	bool eol = false;
    42c7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	size_t offset = 0;
    42cb:	31 f6                	xor    %esi,%esi
		length = log_output->size;
    42cd:	8b 43 0c             	mov    0xc(%ebx),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    42d0:	56                   	push   %esi
		length = log_output->size;
    42d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    42d4:	8d 45 ec             	lea    -0x14(%ebp),%eax
    42d7:	50                   	push   %eax
    42d8:	ff 73 08             	pushl  0x8(%ebx)
    42db:	57                   	push   %edi
    42dc:	e8 a7 f9 ff ff       	call   3c88 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    42e1:	8b 53 04             	mov    0x4(%ebx),%edx
    42e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    42e7:	83 c4 10             	add    $0x10,%esp
		if (length != 0) {
    42ea:	85 c0                	test   %eax,%eax
		log_output->control_block->offset = length;
    42ec:	89 02                	mov    %eax,(%edx)
		if (length != 0) {
    42ee:	74 0c                	je     42fc <log_output_msg_process+0xb0>
			eol = (log_output->buf[length - 1] == '\n');
    42f0:	8b 53 08             	mov    0x8(%ebx),%edx
    42f3:	80 7c 02 ff 0a       	cmpb   $0xa,-0x1(%edx,%eax,1)
    42f8:	0f 94 45 e7          	sete   -0x19(%ebp)
		log_output_flush(log_output);
    42fc:	53                   	push   %ebx
    42fd:	e8 f0 fe ff ff       	call   41f2 <log_output_flush>
    4302:	58                   	pop    %eax
		offset += length;
    4303:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4306:	01 c6                	add    %eax,%esi
	} while (length > 0);
    4308:	85 c0                	test   %eax,%eax
    430a:	75 c1                	jne    42cd <log_output_msg_process+0x81>
	if (eol) {
    430c:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
    4310:	74 6d                	je     437f <log_output_msg_process+0x133>
		print_formatted(log_output, "\r");
    4312:	68 0e 6a 02 00       	push   $0x26a0e
    4317:	53                   	push   %ebx
    4318:	e8 ae f9 ff ff       	call   3ccb <print_formatted>
    431d:	5e                   	pop    %esi
    431e:	5f                   	pop    %edi
	if (!raw_string) {
    431f:	eb 5e                	jmp    437f <log_output_msg_process+0x133>
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    4321:	57                   	push   %edi
    4322:	e8 4a f8 ff ff       	call   3b71 <log_msg_str_get>
    4327:	89 04 24             	mov    %eax,(%esp)
    432a:	68 6a a5 02 00       	push   $0x2a56a
    432f:	53                   	push   %ebx
	u32_t offset = 0U;
    4330:	31 f6                	xor    %esi,%esi
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    4332:	e8 94 f9 ff ff       	call   3ccb <print_formatted>
    4337:	83 c4 0c             	add    $0xc,%esp
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    433a:	56                   	push   %esi
    433b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    433e:	50                   	push   %eax
    433f:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4342:	52                   	push   %edx
		length = sizeof(buf);
    4343:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    434a:	57                   	push   %edi
    434b:	e8 38 f9 ff ff       	call   3c88 <log_msg_hexdump_data_get>
		if (length) {
    4350:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    4353:	83 c4 10             	add    $0x10,%esp
		if (length) {
    4356:	85 c9                	test   %ecx,%ecx
    4358:	74 17                	je     4371 <log_output_msg_process+0x125>
			hexdump_line_print(log_output, buf, length,
    435a:	ff 75 10             	pushl  0x10(%ebp)
    435d:	ff 75 e0             	pushl  -0x20(%ebp)
    4360:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4363:	89 d8                	mov    %ebx,%eax
    4365:	e8 7b fd ff ff       	call   40e5 <hexdump_line_print>
    436a:	5a                   	pop    %edx
    436b:	59                   	pop    %ecx
			offset += length;
    436c:	03 75 e8             	add    -0x18(%ebp),%esi
    436f:	eb c9                	jmp    433a <log_output_msg_process+0xee>
		postfix_print(log_output, flags, level);
    4371:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
    4375:	8b 55 10             	mov    0x10(%ebp),%edx
    4378:	89 d8                	mov    %ebx,%eax
    437a:	e8 2a fe ff ff       	call   41a9 <postfix_print>
	}

	log_output_flush(log_output);
    437f:	53                   	push   %ebx
    4380:	e8 6d fe ff ff       	call   41f2 <log_output_flush>
    4385:	58                   	pop    %eax
}
    4386:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4389:	5b                   	pop    %ebx
    438a:	5e                   	pop    %esi
    438b:	5f                   	pop    %edi
    438c:	5d                   	pop    %ebp
    438d:	c3                   	ret    

0000438e <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    438e:	55                   	push   %ebp
    438f:	89 e5                	mov    %esp,%ebp
    4391:	57                   	push   %edi
    4392:	56                   	push   %esi
    4393:	53                   	push   %ebx
    4394:	83 ec 0c             	sub    $0xc,%esp
    4397:	8b 45 08             	mov    0x8(%ebp),%eax
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
    439a:	8b 18                	mov    (%eax),%ebx
	struct device *dev = (struct device *)log_output->control_block->ctx;
    439c:	8b 40 04             	mov    0x4(%eax),%eax
    439f:	8b 70 04             	mov    0x4(%eax),%esi

	cnt = MIN(cnt, 9999);
    43a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    43a5:	3d 0f 27 00 00       	cmp    $0x270f,%eax
    43aa:	76 05                	jbe    43b1 <log_output_dropped_process+0x23>
    43ac:	b8 0f 27 00 00       	mov    $0x270f,%eax
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    43b1:	50                   	push   %eax
    43b2:	8d 7d ef             	lea    -0x11(%ebp),%edi
    43b5:	68 4b 9d 02 00       	push   $0x29d4b
    43ba:	6a 05                	push   $0x5
    43bc:	57                   	push   %edi
    43bd:	e8 c0 73 00 00       	call   b782 <snprintf>
    43c2:	83 c4 10             	add    $0x10,%esp
    43c5:	89 45 e8             	mov    %eax,-0x18(%ebp)

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    43c8:	b9 04 00 00 00       	mov    $0x4,%ecx
    43cd:	89 d8                	mov    %ebx,%eax
    43cf:	ba 0c 5d 02 00       	mov    $0x25d0c,%edx
    43d4:	56                   	push   %esi
    43d5:	e8 cd f8 ff ff       	call   3ca7 <buffer_write>
	buffer_write(outf, buf, len, dev);
    43da:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    43dd:	89 fa                	mov    %edi,%edx
    43df:	89 d8                	mov    %ebx,%eax
    43e1:	89 34 24             	mov    %esi,(%esp)
    43e4:	e8 be f8 ff ff       	call   3ca7 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    43e9:	89 d8                	mov    %ebx,%eax
    43eb:	b9 17 00 00 00       	mov    $0x17,%ecx
    43f0:	ba f4 5c 02 00       	mov    $0x25cf4,%edx
    43f5:	89 34 24             	mov    %esi,(%esp)
    43f8:	e8 aa f8 ff ff       	call   3ca7 <buffer_write>
    43fd:	58                   	pop    %eax
}
    43fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4401:	5b                   	pop    %ebx
    4402:	5e                   	pop    %esi
    4403:	5f                   	pop    %edi
    4404:	5d                   	pop    %ebp
    4405:	c3                   	ret    

00004406 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
    4406:	55                   	push   %ebp
	timestamp_div = 1U;
    4407:	c7 05 e8 41 40 00 01 	movl   $0x1,0x4041e8
    440e:	00 00 00 
{
    4411:	89 e5                	mov    %esp,%ebp
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    4413:	31 c9                	xor    %ecx,%ecx
    4415:	ba 01 00 00 00       	mov    $0x1,%edx
{
    441a:	8b 45 08             	mov    0x8(%ebp),%eax
	while (frequency > 1000000) {
    441d:	3d 40 42 0f 00       	cmp    $0xf4240,%eax
    4422:	76 08                	jbe    442c <log_output_timestamp_freq_set+0x26>
		frequency /= 2;
    4424:	d1 e8                	shr    %eax
		timestamp_div *= 2;
    4426:	01 d2                	add    %edx,%edx
    4428:	b1 01                	mov    $0x1,%cl
    442a:	eb f1                	jmp    441d <log_output_timestamp_freq_set+0x17>
    442c:	84 c9                	test   %cl,%cl
    442e:	74 06                	je     4436 <log_output_timestamp_freq_set+0x30>
    4430:	89 15 e8 41 40 00    	mov    %edx,0x4041e8
	}

	freq = frequency;
    4436:	a3 ec 41 40 00       	mov    %eax,0x4041ec
}
    443b:	5d                   	pop    %ebp
    443c:	c3                   	ret    

0000443d <severity_lvl_get>:
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
    443d:	55                   	push   %ebp
    443e:	31 d2                	xor    %edx,%edx
    4440:	89 e5                	mov    %esp,%ebp
    4442:	8b 45 0c             	mov    0xc(%ebp),%eax
    4445:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
    4448:	83 f9 04             	cmp    $0x4,%ecx
	entry->handler = NULL;
    444b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
    4452:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &dsub_module_name;
    4459:	c7 40 08 70 5d 02 00 	movl   $0x25d70,0x8(%eax)
					severity_lvls_sorted[idx] : NULL;
    4460:	77 07                	ja     4469 <severity_lvl_get+0x2c>
    4462:	8b 14 8d 78 5d 02 00 	mov    0x25d78(,%ecx,4),%edx
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
    4469:	89 10                	mov    %edx,(%eax)
}
    446b:	5d                   	pop    %ebp
    446c:	c3                   	ret    

0000446d <log_halt>:

static int log_halt(const struct shell *shell,
		    const struct log_backend *backend,
		    size_t argc,
		    char **argv)
{
    446d:	55                   	push   %ebp
    446e:	89 e5                	mov    %esp,%ebp
	backend->cb->active = false;
    4470:	8b 45 0c             	mov    0xc(%ebp),%eax
    4473:	8b 40 04             	mov    0x4(%eax),%eax
    4476:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	log_backend_deactivate(backend);
	return 0;
}
    447a:	31 c0                	xor    %eax,%eax
    447c:	5d                   	pop    %ebp
    447d:	c3                   	ret    

0000447e <log_go>:

static int log_go(const struct shell *shell,
		  const struct log_backend *backend,
		  size_t argc,
		  char **argv)
{
    447e:	55                   	push   %ebp
    447f:	89 e5                	mov    %esp,%ebp
	backend->cb->active = true;
    4481:	8b 45 0c             	mov    0xc(%ebp),%eax
    4484:	8b 40 04             	mov    0x4(%eax),%eax
    4487:	c6 40 05 01          	movb   $0x1,0x5(%eax)
	log_backend_activate(backend, backend->cb->ctx);
	return 0;
}
    448b:	31 c0                	xor    %eax,%eax
    448d:	5d                   	pop    %ebp
    448e:	c3                   	ret    

0000448f <backend_name_get>:
	SHELL_CMD(status, NULL, "Logger status", cmd_log_backend_status),
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
    448f:	55                   	push   %ebp
	return __log_backends_end - __log_backends_start;
    4490:	ba 94 52 02 00       	mov    $0x25294,%edx
    4495:	89 e5                	mov    %esp,%ebp
    4497:	81 ea 84 52 02 00    	sub    $0x25284,%edx
    449d:	c1 fa 04             	sar    $0x4,%edx
    44a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    44a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
	entry->syntax  = NULL;

	if (idx < log_backend_count_get()) {
    44a6:	39 ca                	cmp    %ecx,%edx
	entry->handler = NULL;
    44a8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
    44af:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &sub_log_backend;
    44b6:	c7 40 08 60 5d 02 00 	movl   $0x25d60,0x8(%eax)
	entry->syntax  = NULL;
    44bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (idx < log_backend_count_get()) {
    44c3:	76 0b                	jbe    44d0 <backend_name_get+0x41>
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
    44c5:	c1 e1 04             	shl    $0x4,%ecx
    44c8:	8b 91 8c 52 02 00    	mov    0x2528c(%ecx),%edx
    44ce:	89 10                	mov    %edx,(%eax)
	}
}
    44d0:	5d                   	pop    %ebp
    44d1:	c3                   	ret    

000044d2 <cmd_log_backends_list>:
{
    44d2:	55                   	push   %ebp
    44d3:	89 e5                	mov    %esp,%ebp
    44d5:	57                   	push   %edi
    44d6:	56                   	push   %esi
	for (int i = 0; i < backend_count; i++) {
    44d7:	31 ff                	xor    %edi,%edi
{
    44d9:	53                   	push   %ebx
    44da:	bb 94 52 02 00       	mov    $0x25294,%ebx
    44df:	81 eb 84 52 02 00    	sub    $0x25284,%ebx
    44e5:	be 84 52 02 00       	mov    $0x25284,%esi
    44ea:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < backend_count; i++) {
    44ed:	39 df                	cmp    %ebx,%edi
    44ef:	7d 34                	jge    4525 <cmd_log_backends_list+0x53>
			      backend->cb->id);
    44f1:	8b 56 04             	mov    0x4(%esi),%edx
		shell_fprintf(shell, SHELL_NORMAL,
    44f4:	b8 30 6a 02 00       	mov    $0x26a30,%eax
    44f9:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
    44fd:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    4501:	75 05                	jne    4508 <cmd_log_backends_list+0x36>
    4503:	b8 38 6a 02 00       	mov    $0x26a38,%eax
    4508:	51                   	push   %ecx
	for (int i = 0; i < backend_count; i++) {
    4509:	47                   	inc    %edi
		shell_fprintf(shell, SHELL_NORMAL,
    450a:	50                   	push   %eax
    450b:	83 c6 10             	add    $0x10,%esi
    450e:	ff 76 f8             	pushl  -0x8(%esi)
    4511:	68 41 6a 02 00       	push   $0x26a41
    4516:	6a 00                	push   $0x0
    4518:	ff 75 08             	pushl  0x8(%ebp)
    451b:	e8 a2 16 00 00       	call   5bc2 <shell_fprintf>
    4520:	83 c4 18             	add    $0x18,%esp
    4523:	eb c8                	jmp    44ed <cmd_log_backends_list+0x1b>
}
    4525:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4528:	31 c0                	xor    %eax,%eax
    452a:	5b                   	pop    %ebx
    452b:	5e                   	pop    %esi
    452c:	5f                   	pop    %edi
    452d:	5d                   	pop    %ebp
    452e:	c3                   	ret    

0000452f <log_status>:
{
    452f:	55                   	push   %ebp
    4530:	b8 84 52 02 00       	mov    $0x25284,%eax
    4535:	89 e5                	mov    %esp,%ebp
    4537:	57                   	push   %edi
    4538:	56                   	push   %esi
    4539:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    453e:	c1 e8 03             	shr    $0x3,%eax
    4541:	53                   	push   %ebx
    4542:	83 ec 0c             	sub    $0xc,%esp
    4545:	89 45 f0             	mov    %eax,-0x10(%ebp)
    4548:	8b 7d 0c             	mov    0xc(%ebp),%edi
    454b:	8b 75 08             	mov    0x8(%ebp),%esi
	return backend->cb->active;
    454e:	8b 47 04             	mov    0x4(%edi),%eax
	if (!log_backend_is_active(backend)) {
    4551:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    4555:	75 10                	jne    4567 <log_status+0x38>
		shell_warn(shell, "Logs are halted!");
    4557:	68 62 6a 02 00       	push   $0x26a62
    455c:	6a 04                	push   $0x4
    455e:	56                   	push   %esi
    455f:	e8 5e 16 00 00       	call   5bc2 <shell_fprintf>
    4564:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    4567:	68 74 6a 02 00       	push   $0x26a74
	for (i = 0U; i < modules_cnt; i++) {
    456c:	31 db                	xor    %ebx,%ebx
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    456e:	68 80 6a 02 00       	push   $0x26a80
    4573:	6a 00                	push   $0x0
    4575:	56                   	push   %esi
    4576:	e8 47 16 00 00       	call   5bc2 <shell_fprintf>
    457b:	83 c4 10             	add    $0x10,%esp
	shell_fprintf(shell, SHELL_NORMAL,
    457e:	68 9e 6a 02 00       	push   $0x26a9e
    4583:	6a 00                	push   $0x0
    4585:	56                   	push   %esi
    4586:	e8 37 16 00 00       	call   5bc2 <shell_fprintf>
    458b:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
    458e:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
    4591:	74 5c                	je     45ef <log_status+0xc0>
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    4593:	6a 01                	push   $0x1
    4595:	53                   	push   %ebx
    4596:	6a 00                	push   $0x0
    4598:	57                   	push   %edi
    4599:	e8 8c f2 ff ff       	call   382a <log_filter_get>
    459e:	83 c4 10             	add    $0x10,%esp
    45a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    45a4:	6a 00                	push   $0x0
    45a6:	53                   	push   %ebx
    45a7:	6a 00                	push   $0x0
    45a9:	57                   	push   %edi
    45aa:	e8 7b f2 ff ff       	call   382a <log_filter_get>
    45af:	83 c4 10             	add    $0x10,%esp
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    45b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    45b5:	8b 0c 85 8c 5d 02 00 	mov    0x25d8c(,%eax,4),%ecx
    45bc:	53                   	push   %ebx
    45bd:	8b 14 95 8c 5d 02 00 	mov    0x25d8c(,%edx,4),%edx
    45c4:	6a 00                	push   $0x0
    45c6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    45c9:	89 55 ec             	mov    %edx,-0x14(%ebp)
    45cc:	e8 ec ef ff ff       	call   35bd <log_source_name_get>
    45d1:	5a                   	pop    %edx
    45d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    45d5:	59                   	pop    %ecx
    45d6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    45d9:	51                   	push   %ecx
	for (i = 0U; i < modules_cnt; i++) {
    45da:	43                   	inc    %ebx
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    45db:	52                   	push   %edx
    45dc:	50                   	push   %eax
    45dd:	68 db 6a 02 00       	push   $0x26adb
    45e2:	6a 00                	push   $0x0
    45e4:	56                   	push   %esi
    45e5:	e8 d8 15 00 00       	call   5bc2 <shell_fprintf>
    45ea:	83 c4 18             	add    $0x18,%esp
    45ed:	eb 9f                	jmp    458e <log_status+0x5f>
}
    45ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
    45f2:	31 c0                	xor    %eax,%eax
    45f4:	5b                   	pop    %ebx
    45f5:	5e                   	pop    %esi
    45f6:	5f                   	pop    %edi
    45f7:	5d                   	pop    %ebp
    45f8:	c3                   	ret    

000045f9 <module_name_get>:
{
    45f9:	55                   	push   %ebp
    45fa:	89 e5                	mov    %esp,%ebp
    45fc:	53                   	push   %ebx
    45fd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	entry->handler = NULL;
    4600:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	entry->help  = NULL;
    4607:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	entry->subcmd = &dsub_module_name;
    460e:	c7 43 08 70 5d 02 00 	movl   $0x25d70,0x8(%ebx)
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
    4615:	ff 75 08             	pushl  0x8(%ebp)
    4618:	6a 00                	push   $0x0
    461a:	e8 9e ef ff ff       	call   35bd <log_source_name_get>
    461f:	5a                   	pop    %edx
    4620:	59                   	pop    %ecx
    4621:	89 03                	mov    %eax,(%ebx)
}
    4623:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4626:	c9                   	leave  
    4627:	c3                   	ret    

00004628 <filters_set>:
{
    4628:	55                   	push   %ebp
    4629:	89 e5                	mov    %esp,%ebp
    462b:	57                   	push   %edi
    462c:	56                   	push   %esi
    462d:	89 ce                	mov    %ecx,%esi
    462f:	53                   	push   %ebx
    4630:	83 ec 14             	sub    $0x14,%esp
    4633:	89 45 f0             	mov    %eax,-0x10(%ebp)
    4636:	b8 84 52 02 00       	mov    $0x25284,%eax
    463b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    463e:	2d 3c 51 02 00       	sub    $0x2513c,%eax
	int cnt = all ? log_sources_count() : argc;
    4643:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4646:	c1 e8 03             	shr    $0x3,%eax
    4649:	85 c9                	test   %ecx,%ecx
    464b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    464e:	75 03                	jne    4653 <filters_set+0x2b>
    4650:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (!backend->cb->active) {
    4653:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4656:	8b 40 04             	mov    0x4(%eax),%eax
    4659:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    465d:	75 12                	jne    4671 <filters_set+0x49>
		shell_warn(shell, "Backend not active.");
    465f:	68 ef 6a 02 00       	push   $0x26aef
    4664:	6a 04                	push   $0x4
    4666:	ff 75 f0             	pushl  -0x10(%ebp)
    4669:	e8 54 15 00 00       	call   5bc2 <shell_fprintf>
    466e:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
    4671:	31 db                	xor    %ebx,%ebx
	for (i = 0; i < cnt; i++) {
    4673:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
    4676:	0f 8d 9b 00 00 00    	jge    4717 <filters_set+0xef>
		id = all ? i : module_id_get(argv[i]);
    467c:	89 da                	mov    %ebx,%edx
    467e:	85 f6                	test   %esi,%esi
    4680:	74 4b                	je     46cd <filters_set+0xa5>
    4682:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0U; i < modules_cnt; i++) {
    4685:	31 d2                	xor    %edx,%edx
		id = all ? i : module_id_get(argv[i]);
    4687:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
	for (i = 0U; i < modules_cnt; i++) {
    468a:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    468d:	74 23                	je     46b2 <filters_set+0x8a>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
    468f:	52                   	push   %edx
    4690:	89 55 e0             	mov    %edx,-0x20(%ebp)
    4693:	6a 00                	push   $0x0
    4695:	e8 23 ef ff ff       	call   35bd <log_source_name_get>
    469a:	5a                   	pop    %edx
    469b:	59                   	pop    %ecx
		if (strncmp(tmp_name, name, 64) == 0) {
    469c:	6a 40                	push   $0x40
    469e:	57                   	push   %edi
    469f:	50                   	push   %eax
    46a0:	e8 f1 61 00 00       	call   a896 <strncmp>
    46a5:	83 c4 0c             	add    $0xc,%esp
    46a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
    46ab:	85 c0                	test   %eax,%eax
    46ad:	74 1e                	je     46cd <filters_set+0xa5>
	for (i = 0U; i < modules_cnt; i++) {
    46af:	42                   	inc    %edx
    46b0:	eb d8                	jmp    468a <filters_set+0x62>
			shell_error(shell, "%s: unknown source name.", argv[i]);
    46b2:	8b 45 08             	mov    0x8(%ebp),%eax
    46b5:	ff 34 98             	pushl  (%eax,%ebx,4)
    46b8:	68 1a 6b 02 00       	push   $0x26b1a
    46bd:	6a 02                	push   $0x2
    46bf:	ff 75 f0             	pushl  -0x10(%ebp)
    46c2:	e8 fb 14 00 00       	call   5bc2 <shell_fprintf>
    46c7:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cnt; i++) {
    46ca:	43                   	inc    %ebx
    46cb:	eb a6                	jmp    4673 <filters_set+0x4b>
			u32_t set_lvl = log_filter_set(backend,
    46cd:	ff 75 0c             	pushl  0xc(%ebp)
    46d0:	52                   	push   %edx
    46d1:	6a 00                	push   $0x0
    46d3:	ff 75 e4             	pushl  -0x1c(%ebp)
    46d6:	e8 05 ef ff ff       	call   35e0 <log_filter_set>
    46db:	83 c4 10             	add    $0x10,%esp
    46de:	89 c7                	mov    %eax,%edi
			if (set_lvl != level) {
    46e0:	39 45 0c             	cmp    %eax,0xc(%ebp)
    46e3:	74 e5                	je     46ca <filters_set+0xa2>
						CONFIG_LOG_DOMAIN_ID, i) :
    46e5:	85 f6                	test   %esi,%esi
    46e7:	75 0c                	jne    46f5 <filters_set+0xcd>
					log_source_name_get(
    46e9:	53                   	push   %ebx
    46ea:	6a 00                	push   $0x0
    46ec:	e8 cc ee ff ff       	call   35bd <log_source_name_get>
    46f1:	5a                   	pop    %edx
    46f2:	59                   	pop    %ecx
    46f3:	eb 06                	jmp    46fb <filters_set+0xd3>
						CONFIG_LOG_DOMAIN_ID, i) :
    46f5:	8b 45 08             	mov    0x8(%ebp),%eax
    46f8:	8b 04 98             	mov    (%eax,%ebx,4),%eax
				shell_warn(shell, "%s: level set to %s.",
    46fb:	ff 34 bd 8c 5d 02 00 	pushl  0x25d8c(,%edi,4)
    4702:	50                   	push   %eax
    4703:	68 04 6b 02 00       	push   $0x26b04
    4708:	6a 04                	push   $0x4
    470a:	ff 75 f0             	pushl  -0x10(%ebp)
    470d:	e8 b0 14 00 00       	call   5bc2 <shell_fprintf>
    4712:	83 c4 14             	add    $0x14,%esp
    4715:	eb b3                	jmp    46ca <filters_set+0xa2>
}
    4717:	8d 65 f4             	lea    -0xc(%ebp),%esp
    471a:	5b                   	pop    %ebx
    471b:	5e                   	pop    %esi
    471c:	5f                   	pop    %edi
    471d:	5d                   	pop    %ebp
    471e:	c3                   	ret    

0000471f <log_disable>:
{
    471f:	55                   	push   %ebp
    4720:	89 e5                	mov    %esp,%ebp
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
    4722:	6a 00                	push   $0x0
    4724:	8b 45 10             	mov    0x10(%ebp),%eax
    4727:	8b 55 0c             	mov    0xc(%ebp),%edx
    472a:	8d 48 ff             	lea    -0x1(%eax),%ecx
    472d:	8b 45 14             	mov    0x14(%ebp),%eax
    4730:	83 c0 04             	add    $0x4,%eax
    4733:	50                   	push   %eax
    4734:	8b 45 08             	mov    0x8(%ebp),%eax
    4737:	e8 ec fe ff ff       	call   4628 <filters_set>
    473c:	58                   	pop    %eax
    473d:	5a                   	pop    %edx
}
    473e:	31 c0                	xor    %eax,%eax
    4740:	c9                   	leave  
    4741:	c3                   	ret    

00004742 <shell_backend_cmd_execute>:
{
    4742:	55                   	push   %ebp
    4743:	89 e5                	mov    %esp,%ebp
    4745:	57                   	push   %edi
    4746:	56                   	push   %esi
	for (int i = 0; i < log_backend_count_get(); i++) {
    4747:	31 f6                	xor    %esi,%esi
{
    4749:	53                   	push   %ebx
    474a:	83 ec 18             	sub    $0x18,%esp
    474d:	89 55 e8             	mov    %edx,-0x18(%ebp)
	char const *name = argv[-1];
    4750:	8b 59 fc             	mov    -0x4(%ecx),%ebx
    4753:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	size_t slen = strlen(name);
    4756:	53                   	push   %ebx
{
    4757:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t slen = strlen(name);
    475a:	e8 04 61 00 00       	call   a863 <strlen>
    475f:	5a                   	pop    %edx
    4760:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return __log_backends_end - __log_backends_start;
    4763:	b8 94 52 02 00       	mov    $0x25294,%eax
    4768:	2d 84 52 02 00       	sub    $0x25284,%eax
    476d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    4770:	c1 f8 04             	sar    $0x4,%eax
    4773:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < log_backend_count_get(); i++) {
    4776:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
    4779:	7d 42                	jge    47bd <shell_backend_cmd_execute+0x7b>
		if (strncmp(name, backend->name, slen) == 0) {
    477b:	ff 75 ec             	pushl  -0x14(%ebp)
    477e:	89 f2                	mov    %esi,%edx
    4780:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    4783:	c1 e2 04             	shl    $0x4,%edx
    4786:	89 55 e0             	mov    %edx,-0x20(%ebp)
    4789:	ff b2 8c 52 02 00    	pushl  0x2528c(%edx)
    478f:	53                   	push   %ebx
    4790:	e8 01 61 00 00       	call   a896 <strncmp>
    4795:	83 c4 0c             	add    $0xc,%esp
    4798:	89 c7                	mov    %eax,%edi
    479a:	85 c0                	test   %eax,%eax
    479c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    479f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    47a2:	74 03                	je     47a7 <shell_backend_cmd_execute+0x65>
	for (int i = 0; i < log_backend_count_get(); i++) {
    47a4:	46                   	inc    %esi
    47a5:	eb cf                	jmp    4776 <shell_backend_cmd_execute+0x34>
		func(shell, backend, argc, argv);
    47a7:	51                   	push   %ecx
	return &__log_backends_start[idx];
    47a8:	8d 9a 84 52 02 00    	lea    0x25284(%edx),%ebx
    47ae:	ff 75 e8             	pushl  -0x18(%ebp)
    47b1:	53                   	push   %ebx
    47b2:	ff 75 f0             	pushl  -0x10(%ebp)
    47b5:	ff 55 08             	call   *0x8(%ebp)
    47b8:	83 c4 10             	add    $0x10,%esp
	return 0;
    47bb:	eb 18                	jmp    47d5 <shell_backend_cmd_execute+0x93>
		shell_error(shell, "Invalid backend: %s", name);
    47bd:	53                   	push   %ebx
		return -ENOEXEC;
    47be:	bf f8 ff ff ff       	mov    $0xfffffff8,%edi
		shell_error(shell, "Invalid backend: %s", name);
    47c3:	68 34 6b 02 00       	push   $0x26b34
    47c8:	6a 02                	push   $0x2
    47ca:	ff 75 f0             	pushl  -0x10(%ebp)
    47cd:	e8 f0 13 00 00       	call   5bc2 <shell_fprintf>
    47d2:	83 c4 10             	add    $0x10,%esp
}
    47d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
    47d8:	89 f8                	mov    %edi,%eax
    47da:	5b                   	pop    %ebx
    47db:	5e                   	pop    %esi
    47dc:	5f                   	pop    %edi
    47dd:	5d                   	pop    %ebp
    47de:	c3                   	ret    

000047df <cmd_log_backend_status>:
{
    47df:	55                   	push   %ebp
    47e0:	89 e5                	mov    %esp,%ebp
	shell_backend_cmd_execute(shell, argc, argv, log_status);
    47e2:	68 2f 45 00 00       	push   $0x452f
    47e7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    47ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    47ed:	8b 45 08             	mov    0x8(%ebp),%eax
    47f0:	e8 4d ff ff ff       	call   4742 <shell_backend_cmd_execute>
    47f5:	58                   	pop    %eax
}
    47f6:	31 c0                	xor    %eax,%eax
    47f8:	c9                   	leave  
    47f9:	c3                   	ret    

000047fa <cmd_log_backend_halt>:
{
    47fa:	55                   	push   %ebp
    47fb:	89 e5                	mov    %esp,%ebp
    47fd:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
    4800:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4803:	8b 55 0c             	mov    0xc(%ebp),%edx
    4806:	c7 45 08 6d 44 00 00 	movl   $0x446d,0x8(%ebp)
}
    480d:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
    480e:	e9 2f ff ff ff       	jmp    4742 <shell_backend_cmd_execute>

00004813 <cmd_log_backend_go>:
{
    4813:	55                   	push   %ebp
    4814:	89 e5                	mov    %esp,%ebp
    4816:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
    4819:	8b 4d 10             	mov    0x10(%ebp),%ecx
    481c:	8b 55 0c             	mov    0xc(%ebp),%edx
    481f:	c7 45 08 7e 44 00 00 	movl   $0x447e,0x8(%ebp)
}
    4826:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
    4827:	e9 16 ff ff ff       	jmp    4742 <shell_backend_cmd_execute>

0000482c <cmd_log_backend_enable>:
{
    482c:	55                   	push   %ebp
    482d:	89 e5                	mov    %esp,%ebp
    482f:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
    4832:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4835:	8b 55 0c             	mov    0xc(%ebp),%edx
    4838:	c7 45 08 f7 48 00 00 	movl   $0x48f7,0x8(%ebp)
}
    483f:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
    4840:	e9 fd fe ff ff       	jmp    4742 <shell_backend_cmd_execute>

00004845 <cmd_log_backend_disable>:
{
    4845:	55                   	push   %ebp
    4846:	89 e5                	mov    %esp,%ebp
    4848:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
    484b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    484e:	8b 55 0c             	mov    0xc(%ebp),%edx
    4851:	c7 45 08 1f 47 00 00 	movl   $0x471f,0x8(%ebp)
}
    4858:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
    4859:	e9 e4 fe ff ff       	jmp    4742 <shell_backend_cmd_execute>

0000485e <shell_state_precheck>:
	if (shell->log_backend->control_block->state
    485e:	8b 50 1c             	mov    0x1c(%eax),%edx
    4861:	8b 52 0c             	mov    0xc(%edx),%edx
    4864:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
    4868:	75 17                	jne    4881 <shell_state_precheck+0x23>
{
    486a:	55                   	push   %ebp
    486b:	89 e5                	mov    %esp,%ebp
		shell_error(shell, "Shell log backend not initialized.");
    486d:	68 49 6b 02 00       	push   $0x26b49
    4872:	6a 02                	push   $0x2
    4874:	50                   	push   %eax
    4875:	e8 48 13 00 00       	call   5bc2 <shell_fprintf>
    487a:	83 c4 0c             	add    $0xc,%esp
    487d:	31 c0                	xor    %eax,%eax
}
    487f:	c9                   	leave  
    4880:	c3                   	ret    
	return true;
    4881:	b0 01                	mov    $0x1,%al
}
    4883:	c3                   	ret    

00004884 <cmd_log_self_halt>:
{
    4884:	55                   	push   %ebp
    4885:	89 e5                	mov    %esp,%ebp
    4887:	53                   	push   %ebx
    4888:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
    488b:	89 d8                	mov    %ebx,%eax
    488d:	e8 cc ff ff ff       	call   485e <shell_state_precheck>
    4892:	84 c0                	test   %al,%al
    4894:	74 0c                	je     48a2 <cmd_log_self_halt+0x1e>
	return log_halt(shell, shell->log_backend->backend, argc, argv);
    4896:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_deactivate(backend);
    4899:	8b 00                	mov    (%eax),%eax
	backend->cb->active = false;
    489b:	8b 40 04             	mov    0x4(%eax),%eax
    489e:	c6 40 05 00          	movb   $0x0,0x5(%eax)
}
    48a2:	5b                   	pop    %ebx
    48a3:	31 c0                	xor    %eax,%eax
    48a5:	5d                   	pop    %ebp
    48a6:	c3                   	ret    

000048a7 <cmd_log_self_go>:
{
    48a7:	55                   	push   %ebp
    48a8:	89 e5                	mov    %esp,%ebp
    48aa:	53                   	push   %ebx
    48ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
    48ae:	89 d8                	mov    %ebx,%eax
    48b0:	e8 a9 ff ff ff       	call   485e <shell_state_precheck>
    48b5:	84 c0                	test   %al,%al
    48b7:	74 0c                	je     48c5 <cmd_log_self_go+0x1e>
	return log_go(shell, shell->log_backend->backend, argc, argv);
    48b9:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_activate(backend, backend->cb->ctx);
    48bc:	8b 00                	mov    (%eax),%eax
	backend->cb->active = true;
    48be:	8b 40 04             	mov    0x4(%eax),%eax
    48c1:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
    48c5:	5b                   	pop    %ebx
    48c6:	31 c0                	xor    %eax,%eax
    48c8:	5d                   	pop    %ebp
    48c9:	c3                   	ret    

000048ca <cmd_log_self_status>:
{
    48ca:	55                   	push   %ebp
    48cb:	89 e5                	mov    %esp,%ebp
    48cd:	53                   	push   %ebx
    48ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
    48d1:	89 d8                	mov    %ebx,%eax
    48d3:	e8 86 ff ff ff       	call   485e <shell_state_precheck>
    48d8:	84 c0                	test   %al,%al
    48da:	74 14                	je     48f0 <cmd_log_self_status+0x26>
	log_status(shell, shell->log_backend->backend, argc, argv);
    48dc:	ff 75 10             	pushl  0x10(%ebp)
    48df:	ff 75 0c             	pushl  0xc(%ebp)
    48e2:	8b 43 1c             	mov    0x1c(%ebx),%eax
    48e5:	ff 30                	pushl  (%eax)
    48e7:	53                   	push   %ebx
    48e8:	e8 42 fc ff ff       	call   452f <log_status>
    48ed:	83 c4 10             	add    $0x10,%esp
}
    48f0:	31 c0                	xor    %eax,%eax
    48f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    48f5:	c9                   	leave  
    48f6:	c3                   	ret    

000048f7 <log_enable>:
{
    48f7:	55                   	push   %ebp
    48f8:	89 e5                	mov    %esp,%ebp
    48fa:	57                   	push   %edi
    48fb:	56                   	push   %esi
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
    48fc:	31 ff                	xor    %edi,%edi
	severity_level = severity_level_get(argv[1]);
    48fe:	8b 45 14             	mov    0x14(%ebp),%eax
{
    4901:	53                   	push   %ebx
	severity_level = severity_level_get(argv[1]);
    4902:	8b 58 04             	mov    0x4(%eax),%ebx
		if (strncmp(str, severity_lvls[i], 4) == 0) {
    4905:	6a 04                	push   $0x4
    4907:	ff 34 bd 8c 5d 02 00 	pushl  0x25d8c(,%edi,4)
    490e:	53                   	push   %ebx
    490f:	e8 82 5f 00 00       	call   a896 <strncmp>
    4914:	83 c4 0c             	add    $0xc,%esp
    4917:	89 c6                	mov    %eax,%esi
    4919:	85 c0                	test   %eax,%eax
    491b:	74 25                	je     4942 <log_enable+0x4b>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
    491d:	47                   	inc    %edi
    491e:	83 ff 05             	cmp    $0x5,%edi
    4921:	75 e2                	jne    4905 <log_enable+0xe>
		shell_error(shell, "Invalid severity: %s", argv[1]);
    4923:	8b 45 14             	mov    0x14(%ebp),%eax
    4926:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
    492b:	ff 70 04             	pushl  0x4(%eax)
    492e:	68 6d 6b 02 00       	push   $0x26b6d
    4933:	6a 02                	push   $0x2
    4935:	ff 75 08             	pushl  0x8(%ebp)
    4938:	e8 85 12 00 00       	call   5bc2 <shell_fprintf>
    493d:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
    4940:	eb 1b                	jmp    495d <log_enable+0x66>
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
    4942:	8b 45 10             	mov    0x10(%ebp),%eax
    4945:	57                   	push   %edi
    4946:	8b 55 0c             	mov    0xc(%ebp),%edx
    4949:	8d 48 fe             	lea    -0x2(%eax),%ecx
    494c:	8b 45 14             	mov    0x14(%ebp),%eax
    494f:	8d 58 08             	lea    0x8(%eax),%ebx
    4952:	8b 45 08             	mov    0x8(%ebp),%eax
    4955:	53                   	push   %ebx
    4956:	e8 cd fc ff ff       	call   4628 <filters_set>
    495b:	58                   	pop    %eax
    495c:	5a                   	pop    %edx
}
    495d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4960:	89 f0                	mov    %esi,%eax
    4962:	5b                   	pop    %ebx
    4963:	5e                   	pop    %esi
    4964:	5f                   	pop    %edi
    4965:	5d                   	pop    %ebp
    4966:	c3                   	ret    

00004967 <cmd_log_self_enable>:
{
    4967:	55                   	push   %ebp
    4968:	89 e5                	mov    %esp,%ebp
    496a:	53                   	push   %ebx
    496b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
    496e:	89 d8                	mov    %ebx,%eax
    4970:	e8 e9 fe ff ff       	call   485e <shell_state_precheck>
    4975:	88 c2                	mov    %al,%dl
    4977:	31 c0                	xor    %eax,%eax
    4979:	84 d2                	test   %dl,%dl
    497b:	74 14                	je     4991 <cmd_log_self_enable+0x2a>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    497d:	ff 75 10             	pushl  0x10(%ebp)
    4980:	ff 75 0c             	pushl  0xc(%ebp)
    4983:	8b 43 1c             	mov    0x1c(%ebx),%eax
    4986:	ff 30                	pushl  (%eax)
    4988:	53                   	push   %ebx
    4989:	e8 69 ff ff ff       	call   48f7 <log_enable>
    498e:	83 c4 10             	add    $0x10,%esp
}
    4991:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4994:	c9                   	leave  
    4995:	c3                   	ret    

00004996 <cmd_log_self_disable>:
{
    4996:	55                   	push   %ebp
    4997:	89 e5                	mov    %esp,%ebp
    4999:	53                   	push   %ebx
    499a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
    499d:	89 d8                	mov    %ebx,%eax
    499f:	e8 ba fe ff ff       	call   485e <shell_state_precheck>
    49a4:	88 c2                	mov    %al,%dl
    49a6:	31 c0                	xor    %eax,%eax
    49a8:	84 d2                	test   %dl,%dl
    49aa:	74 14                	je     49c0 <cmd_log_self_disable+0x2a>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    49ac:	ff 75 10             	pushl  0x10(%ebp)
    49af:	ff 75 0c             	pushl  0xc(%ebp)
    49b2:	8b 43 1c             	mov    0x1c(%ebx),%eax
    49b5:	ff 30                	pushl  (%eax)
    49b7:	53                   	push   %ebx
    49b8:	e8 62 fd ff ff       	call   471f <log_disable>
    49bd:	83 c4 10             	add    $0x10,%esp
}
    49c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    49c3:	c9                   	leave  
    49c4:	c3                   	ret    

000049c5 <shell_signal_handle>:

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    49c5:	c1 e2 04             	shl    $0x4,%edx
{
    49c8:	55                   	push   %ebp
    49c9:	89 e5                	mov    %esp,%ebp
    49cb:	57                   	push   %edi
    49cc:	56                   	push   %esi
    49cd:	89 cf                	mov    %ecx,%edi
    49cf:	53                   	push   %ebx
    49d0:	89 c3                	mov    %eax,%ebx
    49d2:	83 ec 08             	sub    $0x8,%esp
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    49d5:	8b 40 08             	mov    0x8(%eax),%eax
    49d8:	8d b4 10 64 02 00 00 	lea    0x264(%eax,%edx,1),%esi

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_INIT, k_poll_signal_init, struct k_poll_signal *, signal)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_RESET, k_poll_signal_reset, struct k_poll_signal *, signal)

K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_POLL_SIGNAL_CHECK, k_poll_signal_check, struct k_poll_signal *, signal, unsigned int *, signaled, int *, result)
    49df:	8d 45 f0             	lea    -0x10(%ebp),%eax
    49e2:	50                   	push   %eax
    49e3:	8d 45 ec             	lea    -0x14(%ebp),%eax
    49e6:	50                   	push   %eax
    49e7:	56                   	push   %esi
    49e8:	e8 90 02 02 00       	call   24c7d <z_impl_k_poll_signal_check>
    49ed:	83 c4 0c             	add    $0xc,%esp
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
    49f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    49f4:	74 0b                	je     4a01 <shell_signal_handle+0x3c>
 */
__syscall void k_poll_signal_reset(struct k_poll_signal *signal);

static inline void z_impl_k_poll_signal_reset(struct k_poll_signal *signal)
{
	signal->signaled = 0;
    49f6:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
		k_poll_signal_reset(signal);
		handler(shell);
    49fd:	53                   	push   %ebx
    49fe:	ff d7                	call   *%edi
    4a00:	58                   	pop    %eax
	}
}
    4a01:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4a04:	5b                   	pop    %ebx
    4a05:	5e                   	pop    %esi
    4a06:	5f                   	pop    %edi
    4a07:	5d                   	pop    %ebp
    4a08:	c3                   	ret    

00004a09 <kill_handler>:

static void kill_handler(const struct shell *shell)
{
    4a09:	55                   	push   %ebp
    4a0a:	89 e5                	mov    %esp,%ebp
    4a0c:	53                   	push   %ebx
    4a0d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (flag_processing_get(shell)) {
    4a10:	8b 43 08             	mov    0x8(%ebx),%eax
	shell->ctx->internal.flags.echo = val ? 1 : 0;
}

static inline bool flag_processing_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.processing == 1 ? true : false;
    4a13:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
    4a19:	a8 08                	test   $0x8,%al
    4a1b:	75 2b                	jne    4a48 <kill_handler+0x3f>
		shell_log_backend_disable(shell->log_backend);
    4a1d:	ff 73 1c             	pushl  0x1c(%ebx)
    4a20:	e8 a6 2d 00 00       	call   77cb <shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
    4a25:	8b 43 04             	mov    0x4(%ebx),%eax
    4a28:	8b 10                	mov    (%eax),%edx
    4a2a:	89 04 24             	mov    %eax,(%esp)
    4a2d:	ff 52 04             	call   *0x4(%edx)
    4a30:	5a                   	pop    %edx
	if (err != 0) {
    4a31:	85 c0                	test   %eax,%eax
    4a33:	75 13                	jne    4a48 <kill_handler+0x3f>
	shell_history_purge(shell->history);
    4a35:	ff 73 0c             	pushl  0xc(%ebx)
    4a38:	e8 21 2b 00 00       	call   755e <shell_history_purge>
    4a3d:	58                   	pop    %eax
	shell->ctx->state = SHELL_STATE_UNINITIALIZED;
    4a3e:	8b 43 08             	mov    0x8(%ebx),%eax
    4a41:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    4a48:	e8 55 f5 01 00       	call   23fa2 <z_impl_k_current_get>
	(void)instance_uninit(shell);
	k_thread_abort(k_current_get());
}
    4a4d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
    4a50:	89 45 08             	mov    %eax,0x8(%ebp)
    4a53:	c9                   	leave  
    4a54:	e9 06 f9 01 00       	jmp    2435f <z_impl_k_thread_abort>

00004a59 <shell_strlen>:
void shell_multiline_data_calc(struct shell_multiline_cons *cons,
				   u16_t buff_pos, u16_t buff_len);

static inline u16_t shell_strlen(const char *str)
{
	return str == NULL ? 0U : (u16_t)strlen(str);
    4a59:	85 c0                	test   %eax,%eax
    4a5b:	74 0c                	je     4a69 <shell_strlen+0x10>
{
    4a5d:	55                   	push   %ebp
    4a5e:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (u16_t)strlen(str);
    4a60:	50                   	push   %eax
    4a61:	e8 fd 5d 00 00       	call   a863 <strlen>
    4a66:	5a                   	pop    %edx
}
    4a67:	c9                   	leave  
    4a68:	c3                   	ret    
	return str == NULL ? 0U : (u16_t)strlen(str);
    4a69:	31 c0                	xor    %eax,%eax
}
    4a6b:	c3                   	ret    

00004a6c <shell_raw_fprintf>:
{
    4a6c:	55                   	push   %ebp
    4a6d:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
    4a6f:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
    4a72:	50                   	push   %eax
    4a73:	ff 75 0c             	pushl  0xc(%ebp)
    4a76:	ff 75 08             	pushl  0x8(%ebp)
    4a79:	e8 db 11 00 00       	call   5c59 <shell_fprintf_fmt>
    4a7e:	83 c4 0c             	add    $0xc,%esp
}
    4a81:	c9                   	leave  
    4a82:	c3                   	ret    

00004a83 <shell_internal_help_print>:
{
    4a83:	55                   	push   %ebp
    4a84:	89 e5                	mov    %esp,%ebp
    4a86:	53                   	push   %ebx
	shell_help_cmd_print(shell);
    4a87:	50                   	push   %eax
{
    4a88:	89 c3                	mov    %eax,%ebx
	shell_help_cmd_print(shell);
    4a8a:	e8 5d 25 00 00       	call   6fec <shell_help_cmd_print>
	shell_help_subcmd_print(shell);
    4a8f:	89 1c 24             	mov    %ebx,(%esp)
    4a92:	e8 3a 24 00 00       	call   6ed1 <shell_help_subcmd_print>
    4a97:	58                   	pop    %eax
}
    4a98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4a9b:	c9                   	leave  
    4a9c:	c3                   	ret    

00004a9d <state_set.constprop.23>:
static void state_set(const struct shell *shell, enum shell_state state)
    4a9d:	55                   	push   %ebp
	shell->ctx->state = state;
    4a9e:	8b 50 08             	mov    0x8(%eax),%edx
static void state_set(const struct shell *shell, enum shell_state state)
    4aa1:	89 e5                	mov    %esp,%ebp
	shell->ctx->state = state;
    4aa3:	c7 42 04 02 00 00 00 	movl   $0x2,0x4(%edx)
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    4aaa:	c6 42 42 00          	movb   $0x0,0x42(%edx)
	shell->ctx->cmd_buff_len = 0;
    4aae:	c7 42 3c 00 00 00 00 	movl   $0x0,0x3c(%edx)
		shell_print_prompt_and_cmd(shell);
    4ab5:	50                   	push   %eax
    4ab6:	e8 ab 1f 00 00       	call   6a66 <shell_print_prompt_and_cmd>
    4abb:	58                   	pop    %eax
}
    4abc:	c9                   	leave  
    4abd:	c3                   	ret    

00004abe <transport_evt_handler>:
{
    4abe:	55                   	push   %ebp
    4abf:	89 e5                	mov    %esp,%ebp
	signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?
    4ac1:	8b 45 0c             	mov    0xc(%ebp),%eax
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
    4ac4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    4ac8:	8b 50 08             	mov    0x8(%eax),%edx
    4acb:	8d 82 64 02 00 00    	lea    0x264(%edx),%eax
    4ad1:	74 06                	je     4ad9 <transport_evt_handler+0x1b>
    4ad3:	8d 82 94 02 00 00    	lea    0x294(%edx),%eax

K_SYSCALL_DECLARE2(K_SYSCALL_K_POLL_SIGNAL_RAISE, k_poll_signal_raise, int, struct k_poll_signal *, signal, int, result)
    4ad9:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
    4ae0:	89 45 08             	mov    %eax,0x8(%ebp)
}
    4ae3:	5d                   	pop    %ebp
    4ae4:	e9 ac 01 02 00       	jmp    24c95 <z_impl_k_poll_signal_raise>

00004ae9 <shell_log_process>:
{
    4ae9:	55                   	push   %ebp
    4aea:	89 e5                	mov    %esp,%ebp
    4aec:	57                   	push   %edi
    4aed:	56                   	push   %esi
    4aee:	53                   	push   %ebx
    4aef:	83 ec 08             	sub    $0x8,%esp
	int signaled = 0;
    4af2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
    4af9:	8b 5d 08             	mov    0x8(%ebp),%ebx
			shell_cmd_line_erase(shell);
    4afc:	53                   	push   %ebx
    4afd:	e8 27 1a 00 00       	call   6529 <shell_cmd_line_erase>
    4b02:	5a                   	pop    %edx
			processed = shell_log_backend_process(shell->log_backend);
    4b03:	ff 73 1c             	pushl  0x1c(%ebx)
    4b06:	e8 06 2d 00 00       	call   7811 <shell_log_backend_process>
    4b0b:	89 c7                	mov    %eax,%edi
		struct k_poll_signal *signal =
    4b0d:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_print_prompt_and_cmd(shell);
    4b10:	89 1c 24             	mov    %ebx,(%esp)
		struct k_poll_signal *signal =
    4b13:	8d b0 64 02 00 00    	lea    0x264(%eax),%esi
		shell_print_prompt_and_cmd(shell);
    4b19:	e8 48 1f 00 00       	call   6a66 <shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
    4b1e:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_print_prompt_and_cmd(shell);
    4b21:	59                   	pop    %ecx
		if (shell->ctx->cmd_buff_len) {
    4b22:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
    4b27:	74 08                	je     4b31 <shell_log_process+0x48>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
    4b29:	6a 0f                	push   $0xf
    4b2b:	e8 6a f3 01 00       	call   23e9a <z_impl_k_sleep>
    4b30:	58                   	pop    %eax
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_POLL_SIGNAL_CHECK, k_poll_signal_check, struct k_poll_signal *, signal, unsigned int *, signaled, int *, result)
    4b31:	8d 45 f0             	lea    -0x10(%ebp),%eax
    4b34:	50                   	push   %eax
    4b35:	8d 45 ec             	lea    -0x14(%ebp),%eax
    4b38:	50                   	push   %eax
    4b39:	56                   	push   %esi
    4b3a:	e8 3e 01 02 00       	call   24c7d <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
    4b3f:	89 f8                	mov    %edi,%eax
    4b41:	83 c4 0c             	add    $0xc,%esp
    4b44:	84 c0                	test   %al,%al
    4b46:	74 06                	je     4b4e <shell_log_process+0x65>
    4b48:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4b4c:	74 ae                	je     4afc <shell_log_process+0x13>
}
    4b4e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4b51:	5b                   	pop    %ebx
    4b52:	5e                   	pop    %esi
    4b53:	5f                   	pop    %edi
    4b54:	5d                   	pop    %ebp
    4b55:	c3                   	ret    

00004b56 <history_handle>:
{
    4b56:	55                   	push   %ebp
    4b57:	89 e5                	mov    %esp,%ebp
    4b59:	56                   	push   %esi
    4b5a:	53                   	push   %ebx
    4b5b:	89 d6                	mov    %edx,%esi
    4b5d:	53                   	push   %ebx
    4b5e:	89 c3                	mov    %eax,%ebx
	if (flag_history_exit_get(shell)) {
    4b60:	8b 40 08             	mov    0x8(%eax),%eax
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
}

static inline bool flag_history_exit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.history_exit == 1 ? true : false;
    4b63:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
    4b69:	80 e2 40             	and    $0x40,%dl
    4b6c:	74 1b                	je     4b89 <history_handle+0x33>
}

static inline void flag_history_exit_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    4b6e:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    4b75:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    4b78:	83 e2 bf             	and    $0xffffffbf,%edx
    4b7b:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
		shell_history_mode_exit(shell->history);
    4b82:	51                   	push   %ecx
    4b83:	e8 4c 29 00 00       	call   74d4 <shell_history_mode_exit>
    4b88:	59                   	pop    %ecx
	if (!shell_history_active(shell->history)) {
    4b89:	8b 43 0c             	mov    0xc(%ebx),%eax
    4b8c:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    4b90:	75 37                	jne    4bc9 <history_handle+0x73>
		if (up) {
    4b92:	89 f0                	mov    %esi,%eax
    4b94:	84 c0                	test   %al,%al
    4b96:	0f 84 ac 00 00 00    	je     4c48 <history_handle+0xf2>
			u16_t cmd_len = shell_strlen(shell->ctx->cmd_buff);
    4b9c:	8b 43 08             	mov    0x8(%ebx),%eax
    4b9f:	83 c0 42             	add    $0x42,%eax
    4ba2:	e8 b2 fe ff ff       	call   4a59 <shell_strlen>
			if (cmd_len) {
    4ba7:	66 85 c0             	test   %ax,%ax
    4baa:	8b 43 08             	mov    0x8(%ebx),%eax
    4bad:	74 13                	je     4bc2 <history_handle+0x6c>
				       shell->ctx->cmd_buff);
    4baf:	8d 50 42             	lea    0x42(%eax),%edx
				strcpy(shell->ctx->temp_buff,
    4bb2:	05 42 01 00 00       	add    $0x142,%eax
    4bb7:	52                   	push   %edx
    4bb8:	50                   	push   %eax
    4bb9:	e8 0d 5c 00 00       	call   a7cb <strcpy>
    4bbe:	58                   	pop    %eax
    4bbf:	5a                   	pop    %edx
    4bc0:	eb 07                	jmp    4bc9 <history_handle+0x73>
				shell->ctx->temp_buff[0] = '\0';
    4bc2:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
	history_mode = shell_history_get(shell->history, up,
    4bc9:	8d 45 f6             	lea    -0xa(%ebp),%eax
    4bcc:	50                   	push   %eax
					 shell->ctx->cmd_buff, &len);
    4bcd:	8b 43 08             	mov    0x8(%ebx),%eax
    4bd0:	83 c0 42             	add    $0x42,%eax
	history_mode = shell_history_get(shell->history, up,
    4bd3:	50                   	push   %eax
    4bd4:	89 f0                	mov    %esi,%eax
    4bd6:	0f b6 f0             	movzbl %al,%esi
    4bd9:	56                   	push   %esi
    4bda:	ff 73 0c             	pushl  0xc(%ebx)
    4bdd:	e8 01 29 00 00       	call   74e3 <shell_history_get>
    4be2:	83 c4 10             	add    $0x10,%esp
	if (!history_mode) {
    4be5:	84 c0                	test   %al,%al
    4be7:	75 24                	jne    4c0d <history_handle+0xb7>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    4be9:	8b 43 08             	mov    0x8(%ebx),%eax
    4bec:	8d 90 42 01 00 00    	lea    0x142(%eax),%edx
    4bf2:	83 c0 42             	add    $0x42,%eax
    4bf5:	52                   	push   %edx
    4bf6:	50                   	push   %eax
    4bf7:	e8 cf 5b 00 00       	call   a7cb <strcpy>
		len = shell_strlen(shell->ctx->cmd_buff);
    4bfc:	8b 43 08             	mov    0x8(%ebx),%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    4bff:	5a                   	pop    %edx
		len = shell_strlen(shell->ctx->cmd_buff);
    4c00:	83 c0 42             	add    $0x42,%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    4c03:	59                   	pop    %ecx
		len = shell_strlen(shell->ctx->cmd_buff);
    4c04:	e8 50 fe ff ff       	call   4a59 <shell_strlen>
    4c09:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	shell_op_cursor_home_move(shell);
    4c0d:	53                   	push   %ebx
    4c0e:	e8 86 18 00 00       	call   6499 <shell_op_cursor_home_move>
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
    4c13:	c7 04 24 6c 5e 02 00 	movl   $0x25e6c,(%esp)
    4c1a:	68 6a a5 02 00       	push   $0x2a56a
    4c1f:	ff 73 14             	pushl  0x14(%ebx)
    4c22:	e8 45 fe ff ff       	call   4a6c <shell_raw_fprintf>
    4c27:	83 c4 0c             	add    $0xc,%esp
	shell_print_cmd(shell);
    4c2a:	53                   	push   %ebx
    4c2b:	e8 4d 19 00 00       	call   657d <shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
    4c30:	8b 43 08             	mov    0x8(%ebx),%eax
    4c33:	66 8b 55 f6          	mov    -0xa(%ebp),%dx
    4c37:	66 89 50 3e          	mov    %dx,0x3e(%eax)
	shell->ctx->cmd_buff_len = len;
    4c3b:	66 89 50 3c          	mov    %dx,0x3c(%eax)
	shell_op_cond_next_line(shell);
    4c3f:	89 1c 24             	mov    %ebx,(%esp)
    4c42:	e8 54 16 00 00       	call   629b <shell_op_cond_next_line>
    4c47:	58                   	pop    %eax
}
    4c48:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4c4b:	5b                   	pop    %ebx
    4c4c:	5e                   	pop    %esi
    4c4d:	5d                   	pop    %ebp
    4c4e:	c3                   	ret    

00004c4f <execute>:
{
    4c4f:	55                   	push   %ebp
    4c50:	89 e5                	mov    %esp,%ebp
    4c52:	57                   	push   %edi
    4c53:	56                   	push   %esi
    4c54:	53                   	push   %ebx
    4c55:	89 c3                	mov    %eax,%ebx
    4c57:	83 ec 78             	sub    $0x78,%esp
	const struct shell_static_entry *p_static_entry = NULL;
    4c5a:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
	shell_op_cursor_end_move(shell);
    4c61:	50                   	push   %eax
    4c62:	e8 4d 18 00 00       	call   64b4 <shell_op_cursor_end_move>
	if (!shell_cursor_in_empty_line(shell)) {
    4c67:	89 1c 24             	mov    %ebx,(%esp)
    4c6a:	e8 f3 15 00 00       	call   6262 <shell_cursor_in_empty_line>
    4c6f:	5a                   	pop    %edx
    4c70:	84 c0                	test   %al,%al
    4c72:	75 0f                	jne    4c83 <execute+0x34>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    4c74:	68 b9 6d 02 00       	push   $0x26db9
    4c79:	ff 73 14             	pushl  0x14(%ebx)
    4c7c:	e8 eb fd ff ff       	call   4a6c <shell_raw_fprintf>
    4c81:	5e                   	pop    %esi
    4c82:	5f                   	pop    %edi
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    4c83:	6a 14                	push   $0x14
    4c85:	8b 43 08             	mov    0x8(%ebx),%eax
    4c88:	6a 00                	push   $0x0
    4c8a:	83 c0 0c             	add    $0xc,%eax
    4c8d:	50                   	push   %eax
    4c8e:	e8 0d 5d 00 00       	call   a9a0 <memset>
    4c93:	83 c4 0c             	add    $0xc,%esp
	shell_cmd_trim(shell);
    4c96:	53                   	push   %ebx
    4c97:	e8 5e 14 00 00       	call   60fa <shell_cmd_trim>
		    shell->ctx->cmd_buff_len);
    4c9c:	8b 43 08             	mov    0x8(%ebx),%eax
	history_put(shell, shell->ctx->cmd_buff,
    4c9f:	83 c0 42             	add    $0x42,%eax
    4ca2:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
	shell_history_put(shell->history, line, length);
    4ca6:	89 14 24             	mov    %edx,(%esp)
    4ca9:	50                   	push   %eax
    4caa:	ff 73 0c             	pushl  0xc(%ebx)
    4cad:	e8 c7 28 00 00       	call   7579 <shell_history_put>
    4cb2:	83 c4 0c             	add    $0xc,%esp
		shell_wildcard_prepare(shell);
    4cb5:	53                   	push   %ebx
    4cb6:	e8 d9 2c 00 00       	call   7994 <shell_wildcard_prepare>
	quote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,
    4cbb:	8b 43 08             	mov    0x8(%ebx),%eax
    4cbe:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
    4cc5:	83 c0 42             	add    $0x42,%eax
    4cc8:	50                   	push   %eax
    4cc9:	8d 45 c0             	lea    -0x40(%ebp),%eax
    4ccc:	50                   	push   %eax
    4ccd:	8d 45 94             	lea    -0x6c(%ebp),%eax
    4cd0:	50                   	push   %eax
    4cd1:	e8 aa 10 00 00       	call   5d80 <shell_make_argv>
    4cd6:	83 c4 10             	add    $0x10,%esp
	if (!argc) {
    4cd9:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
    4cdd:	74 18                	je     4cf7 <execute+0xa8>
	if (quote != 0) {
    4cdf:	84 c0                	test   %al,%al
    4ce1:	74 1e                	je     4d01 <execute+0xb2>
		shell_internal_fprintf(shell, SHELL_ERROR,
    4ce3:	0f be c0             	movsbl %al,%eax
    4ce6:	50                   	push   %eax
    4ce7:	68 18 6d 02 00       	push   $0x26d18
    4cec:	6a 02                	push   $0x2
    4cee:	53                   	push   %ebx
    4cef:	e8 56 1a 00 00       	call   674a <shell_internal_fprintf>
    4cf4:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
    4cf7:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
    4cfc:	e9 92 02 00 00       	jmp    4f93 <execute+0x344>
	help_entry.help = NULL;
    4d01:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
	size_t cmd_idx = 0;
    4d08:	31 f6                	xor    %esi,%esi
	bool wildcard_found = false;
    4d0a:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
	size_t cmd_with_handler_lvl = 0;
    4d0e:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
	size_t cmd_lvl = SHELL_CMD_ROOT_LVL;
    4d15:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%ebp)
	const struct shell_cmd_entry *p_cmd = NULL;
    4d1c:	31 ff                	xor    %edi,%edi
		if (cmd_lvl >= argc) {
    4d1e:	8b 45 8c             	mov    -0x74(%ebp),%eax
    4d21:	39 45 94             	cmp    %eax,-0x6c(%ebp)
    4d24:	0f 86 56 01 00 00    	jbe    4e80 <execute+0x231>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    4d2a:	85 c0                	test   %eax,%eax
    4d2c:	74 52                	je     4d80 <execute+0x131>
		    (!strcmp(argv[cmd_lvl], "-h") ||
    4d2e:	68 2c 6d 02 00       	push   $0x26d2c
    4d33:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
    4d37:	e8 3a 5b 00 00       	call   a876 <strcmp>
    4d3c:	5a                   	pop    %edx
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    4d3d:	85 c0                	test   %eax,%eax
		    (!strcmp(argv[cmd_lvl], "-h") ||
    4d3f:	59                   	pop    %ecx
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    4d40:	75 17                	jne    4d59 <execute+0x10a>
			if (help_entry.help) {
    4d42:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
    4d46:	74 2e                	je     4d76 <execute+0x127>
				shell->ctx->active_cmd = help_entry;
    4d48:	8b 45 88             	mov    -0x78(%ebp),%eax
    4d4b:	89 45 b0             	mov    %eax,-0x50(%ebp)
    4d4e:	8b 43 08             	mov    0x8(%ebx),%eax
    4d51:	8d 78 0c             	lea    0xc(%eax),%edi
    4d54:	e9 72 01 00 00       	jmp    4ecb <execute+0x27c>
		     !strcmp(argv[cmd_lvl], "--help"))) {
    4d59:	8b 45 8c             	mov    -0x74(%ebp),%eax
    4d5c:	68 2f 6d 02 00       	push   $0x26d2f
    4d61:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
    4d65:	e8 0c 5b 00 00       	call   a876 <strcmp>
    4d6a:	5a                   	pop    %edx
		    (!strcmp(argv[cmd_lvl], "-h") ||
    4d6b:	85 c0                	test   %eax,%eax
		     !strcmp(argv[cmd_lvl], "--help"))) {
    4d6d:	59                   	pop    %ecx
		    (!strcmp(argv[cmd_lvl], "-h") ||
    4d6e:	0f 85 f2 00 00 00    	jne    4e66 <execute+0x217>
    4d74:	eb cc                	jmp    4d42 <execute+0xf3>
			shell_internal_fprintf(shell, SHELL_ERROR,
    4d76:	68 36 6d 02 00       	push   $0x26d36
    4d7b:	e9 a1 00 00 00       	jmp    4e21 <execute+0x1d2>
		shell_cmd_get(p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,
    4d80:	8d 45 98             	lea    -0x68(%ebp),%eax
    4d83:	8d 56 01             	lea    0x1(%esi),%edx
    4d86:	50                   	push   %eax
    4d87:	8d 45 90             	lea    -0x70(%ebp),%eax
    4d8a:	50                   	push   %eax
    4d8b:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
    4d91:	56                   	push   %esi
    4d92:	ff 75 8c             	pushl  -0x74(%ebp)
    4d95:	57                   	push   %edi
    4d96:	e8 53 12 00 00       	call   5fee <shell_cmd_get>
		if ((cmd_idx == 0) || (p_static_entry == NULL)) {
    4d9b:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
		shell_cmd_get(p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,
    4da1:	83 c4 14             	add    $0x14,%esp
		if ((cmd_idx == 0) || (p_static_entry == NULL)) {
    4da4:	85 d2                	test   %edx,%edx
    4da6:	74 07                	je     4daf <execute+0x160>
    4da8:	8b 45 90             	mov    -0x70(%ebp),%eax
    4dab:	85 c0                	test   %eax,%eax
    4dad:	75 27                	jne    4dd6 <execute+0x187>
			if (cmd_lvl == 0) {
    4daf:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
    4db3:	0f 85 c7 00 00 00    	jne    4e80 <execute+0x231>
				shell_internal_fprintf(shell, SHELL_ERROR,
    4db9:	68 54 6d 02 00       	push   $0x26d54
    4dbe:	ff 75 c0             	pushl  -0x40(%ebp)
    4dc1:	68 48 88 02 00       	push   $0x28848
    4dc6:	6a 02                	push   $0x2
    4dc8:	53                   	push   %ebx
    4dc9:	e8 7c 19 00 00       	call   674a <shell_internal_fprintf>
    4dce:	83 c4 14             	add    $0x14,%esp
				return -ENOEXEC;
    4dd1:	e9 21 ff ff ff       	jmp    4cf7 <execute+0xa8>
		if (strcmp(argv[cmd_lvl], p_static_entry->syntax) == 0) {
    4dd6:	ff 30                	pushl  (%eax)
    4dd8:	8b 45 8c             	mov    -0x74(%ebp),%eax
    4ddb:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
    4de1:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
    4de5:	e8 8c 5a 00 00       	call   a876 <strcmp>
    4dea:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
    4df0:	59                   	pop    %ecx
    4df1:	85 c0                	test   %eax,%eax
    4df3:	5e                   	pop    %esi
    4df4:	74 07                	je     4dfd <execute+0x1ae>
				wildcard_found = true;
    4df6:	89 d6                	mov    %edx,%esi
    4df8:	e9 21 ff ff ff       	jmp    4d1e <execute+0xcf>
			if (p_static_entry->handler != NULL) {
    4dfd:	8b 45 90             	mov    -0x70(%ebp),%eax
    4e00:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    4e04:	74 40                	je     4e46 <execute+0x1f7>
				if (IS_ENABLED(CONFIG_SHELL_WILDCARD) &&
    4e06:	80 7d 87 00          	cmpb   $0x0,-0x79(%ebp)
    4e0a:	74 25                	je     4e31 <execute+0x1e2>
					shell_op_cursor_end_move(shell);
    4e0c:	53                   	push   %ebx
    4e0d:	e8 a2 16 00 00       	call   64b4 <shell_op_cursor_end_move>
					shell_op_cond_next_line(shell);
    4e12:	89 1c 24             	mov    %ebx,(%esp)
    4e15:	e8 81 14 00 00       	call   629b <shell_op_cond_next_line>
					shell_internal_fprintf(shell,
    4e1a:	c7 04 24 68 6d 02 00 	movl   $0x26d68,(%esp)
    4e21:	6a 02                	push   $0x2
    4e23:	53                   	push   %ebx
    4e24:	e8 21 19 00 00       	call   674a <shell_internal_fprintf>
    4e29:	83 c4 0c             	add    $0xc,%esp
					return -ENOEXEC;
    4e2c:	e9 c6 fe ff ff       	jmp    4cf7 <execute+0xa8>
				shell->ctx->active_cmd = *p_static_entry;
    4e31:	8b 4b 08             	mov    0x8(%ebx),%ecx
    4e34:	89 c6                	mov    %eax,%esi
    4e36:	8d 79 0c             	lea    0xc(%ecx),%edi
    4e39:	b9 05 00 00 00       	mov    $0x5,%ecx
    4e3e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    4e40:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
    4e43:	89 4d 80             	mov    %ecx,-0x80(%ebp)
			if (p_static_entry->help != NULL) {
    4e46:	8b 50 04             	mov    0x4(%eax),%edx
    4e49:	85 d2                	test   %edx,%edx
    4e4b:	74 0f                	je     4e5c <execute+0x20d>
				help_entry = *p_static_entry;
    4e4d:	8d 7d ac             	lea    -0x54(%ebp),%edi
    4e50:	b9 05 00 00 00       	mov    $0x5,%ecx
    4e55:	89 c6                	mov    %eax,%esi
    4e57:	89 55 88             	mov    %edx,-0x78(%ebp)
    4e5a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			cmd_lvl++;
    4e5c:	ff 45 8c             	incl   -0x74(%ebp)
			p_cmd = p_static_entry->subcmd;
    4e5f:	8b 78 08             	mov    0x8(%eax),%edi
			cmd_idx = 0;
    4e62:	31 d2                	xor    %edx,%edx
    4e64:	eb 90                	jmp    4df6 <execute+0x1a7>
			status = shell_wildcard_process(shell, p_cmd,
    4e66:	8b 45 8c             	mov    -0x74(%ebp),%eax
    4e69:	ff 74 85 c0          	pushl  -0x40(%ebp,%eax,4)
    4e6d:	57                   	push   %edi
    4e6e:	53                   	push   %ebx
    4e6f:	e8 8b 2b 00 00       	call   79ff <shell_wildcard_process>
    4e74:	83 c4 0c             	add    $0xc,%esp
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
    4e77:	83 f8 02             	cmp    $0x2,%eax
    4e7a:	0f 85 fc 00 00 00    	jne    4f7c <execute+0x32d>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
    4e80:	80 7d 87 00          	cmpb   $0x0,-0x79(%ebp)
    4e84:	74 24                	je     4eaa <execute+0x25b>
		shell_wildcard_finalize(shell);
    4e86:	53                   	push   %ebx
    4e87:	e8 df 2c 00 00       	call   7b6b <shell_wildcard_finalize>
				      shell->ctx->cmd_buff,
    4e8c:	8b 43 08             	mov    0x8(%ebx),%eax
		(void)shell_make_argv(&argc, &argv[0],
    4e8f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
				      shell->ctx->cmd_buff,
    4e96:	83 c0 42             	add    $0x42,%eax
		(void)shell_make_argv(&argc, &argv[0],
    4e99:	50                   	push   %eax
    4e9a:	8d 45 c0             	lea    -0x40(%ebp),%eax
    4e9d:	50                   	push   %eax
    4e9e:	8d 45 94             	lea    -0x6c(%ebp),%eax
    4ea1:	50                   	push   %eax
    4ea2:	e8 d9 0e 00 00       	call   5d80 <shell_make_argv>
    4ea7:	83 c4 10             	add    $0x10,%esp
	if (shell->ctx->active_cmd.handler == NULL) {
    4eaa:	8b 7b 08             	mov    0x8(%ebx),%edi
    4ead:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
    4eb1:	75 33                	jne    4ee6 <execute+0x297>
			if (help_entry->help == NULL) {
    4eb3:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
    4eb7:	0f 84 3a fe ff ff    	je     4cf7 <execute+0xa8>
			if (help_entry->help != shell->ctx->active_cmd.help) {
    4ebd:	8b 45 88             	mov    -0x78(%ebp),%eax
    4ec0:	3b 47 10             	cmp    0x10(%edi),%eax
    4ec3:	74 10                	je     4ed5 <execute+0x286>
				shell->ctx->active_cmd = *help_entry;
    4ec5:	89 45 b0             	mov    %eax,-0x50(%ebp)
    4ec8:	83 c7 0c             	add    $0xc,%edi
    4ecb:	8d 75 ac             	lea    -0x54(%ebp),%esi
    4ece:	b9 05 00 00 00       	mov    $0x5,%ecx
    4ed3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			shell_internal_help_print(shell);
    4ed5:	89 d8                	mov    %ebx,%eax
			return SHELL_CMD_HELP_PRINTED;
    4ed7:	be 01 00 00 00       	mov    $0x1,%esi
			shell_internal_help_print(shell);
    4edc:	e8 a2 fb ff ff       	call   4a83 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
    4ee1:	e9 ad 00 00 00       	jmp    4f93 <execute+0x344>
	if (shell->ctx->active_cmd.args.mandatory) {
    4ee6:	0f b6 47 1c          	movzbl 0x1c(%edi),%eax
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
    4eea:	8b 75 94             	mov    -0x6c(%ebp),%esi
    4eed:	2b 75 80             	sub    -0x80(%ebp),%esi
	if (shell->ctx->active_cmd.args.mandatory) {
    4ef0:	84 c0                	test   %al,%al
    4ef2:	74 2f                	je     4f23 <execute+0x2d4>
		u8_t opt = shell->ctx->active_cmd.args.optional;
    4ef4:	0f b6 57 1d          	movzbl 0x1d(%edi),%edx
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
    4ef8:	39 c6                	cmp    %eax,%esi
    4efa:	72 06                	jb     4f02 <execute+0x2b3>
    4efc:	01 d0                	add    %edx,%eax
	if (!arg_cnt_ok) {
    4efe:	39 c6                	cmp    %eax,%esi
    4f00:	76 21                	jbe    4f23 <execute+0x2d4>
		shell_internal_fprintf(shell, SHELL_ERROR,
    4f02:	ff 77 0c             	pushl  0xc(%edi)
		return -EINVAL;
    4f05:	be ea ff ff ff       	mov    $0xffffffea,%esi
		shell_internal_fprintf(shell, SHELL_ERROR,
    4f0a:	68 97 6d 02 00       	push   $0x26d97
    4f0f:	6a 02                	push   $0x2
    4f11:	53                   	push   %ebx
    4f12:	e8 33 18 00 00       	call   674a <shell_internal_fprintf>
    4f17:	83 c4 10             	add    $0x10,%esp
			shell_internal_help_print(shell);
    4f1a:	89 d8                	mov    %ebx,%eax
    4f1c:	e8 62 fb ff ff       	call   4a83 <shell_internal_help_print>
	if (!ret_val) {
    4f21:	eb 70                	jmp    4f93 <execute+0x344>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    4f23:	81 c7 f4 02 00 00    	add    $0x2f4,%edi
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    4f29:	57                   	push   %edi
    4f2a:	e8 ab e5 01 00       	call   234da <z_impl_k_mutex_unlock>
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
}

static inline void flag_cmd_ctx_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.cmd_ctx = val ? 1 : 0;
    4f2f:	8b 43 08             	mov    0x8(%ebx),%eax
    4f32:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    4f39:	80 ca 80             	or     $0x80,%dl
    4f3c:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
    4f43:	8b 4d 80             	mov    -0x80(%ebp),%ecx
    4f46:	8d 54 8d c0          	lea    -0x40(%ebp,%ecx,4),%edx
		ret_val = shell->ctx->active_cmd.handler(shell, argc, argv);
    4f4a:	89 14 24             	mov    %edx,(%esp)
    4f4d:	56                   	push   %esi
    4f4e:	53                   	push   %ebx
    4f4f:	ff 50 18             	call   *0x18(%eax)
    4f52:	89 c6                	mov    %eax,%esi
    4f54:	8b 43 08             	mov    0x8(%ebx),%eax
    4f57:	83 c4 0c             	add    $0xc,%esp
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    4f5a:	05 f4 02 00 00       	add    $0x2f4,%eax
    4f5f:	66 8b 90 6c ff ff ff 	mov    -0x94(%eax),%dx
    4f66:	80 e2 7f             	and    $0x7f,%dl
    4f69:	66 89 90 6c ff ff ff 	mov    %dx,-0x94(%eax)
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    4f70:	6a ff                	push   $0xffffffff
    4f72:	50                   	push   %eax
    4f73:	e8 6b e4 01 00       	call   233e3 <z_impl_k_mutex_lock>
    4f78:	58                   	pop    %eax
    4f79:	5a                   	pop    %edx
    4f7a:	eb 17                	jmp    4f93 <execute+0x344>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
    4f7c:	83 f8 03             	cmp    $0x3,%eax
    4f7f:	0f 84 fb fd ff ff    	je     4d80 <execute+0x131>
				++cmd_lvl;
    4f85:	ff 45 8c             	incl   -0x74(%ebp)
				continue;
    4f88:	89 f2                	mov    %esi,%edx
				wildcard_found = true;
    4f8a:	c6 45 87 01          	movb   $0x1,-0x79(%ebp)
				continue;
    4f8e:	e9 63 fe ff ff       	jmp    4df6 <execute+0x1a7>
}
    4f93:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4f96:	89 f0                	mov    %esi,%eax
    4f98:	5b                   	pop    %ebx
    4f99:	5e                   	pop    %esi
    4f9a:	5f                   	pop    %edi
    4f9b:	5d                   	pop    %ebp
    4f9c:	c3                   	ret    

00004f9d <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
    4f9d:	55                   	push   %ebp
    4f9e:	89 e5                	mov    %esp,%ebp
    4fa0:	57                   	push   %edi
    4fa1:	56                   	push   %esi
    4fa2:	53                   	push   %ebx
    4fa3:	81 ec b4 00 00 00    	sub    $0xb4,%esp
    4fa9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4fac:	8b 43 08             	mov    0x8(%ebx),%eax
    4faf:	f0 83 88 60 02 00 00 	lock orl $0x8,0x260(%eax)
    4fb6:	08 
	internal.flags.processing = 1;

	(void)atomic_or((atomic_t *)&shell->ctx->internal.value,
			internal.value);

	switch (shell->ctx->state) {
    4fb7:	8b 43 08             	mov    0x8(%ebx),%eax
    4fba:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
    4fbe:	0f 85 01 05 00 00    	jne    54c5 <shell_process+0x528>
	size_t count = 0;
    4fc4:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
    4fcb:	00 00 00 
		(void)shell->iface->api->read(shell->iface, &data,
    4fce:	8b 43 04             	mov    0x4(%ebx),%eax
    4fd1:	8d 8d 74 ff ff ff    	lea    -0x8c(%ebp),%ecx
    4fd7:	8b 10                	mov    (%eax),%edx
    4fd9:	51                   	push   %ecx
    4fda:	6a 01                	push   $0x1
    4fdc:	8d 8d 73 ff ff ff    	lea    -0x8d(%ebp),%ecx
    4fe2:	51                   	push   %ecx
    4fe3:	50                   	push   %eax
    4fe4:	ff 52 10             	call   *0x10(%edx)
    4fe7:	83 c4 10             	add    $0x10,%esp
		if (count == 0) {
    4fea:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
    4ff1:	0f 84 ce 04 00 00    	je     54c5 <shell_process+0x528>
		if (ascii_filter(data) != 0) {
    4ff7:	8a 95 73 ff ff ff    	mov    -0x8d(%ebp),%dl
	return (u8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    4ffd:	84 d2                	test   %dl,%dl
    4fff:	78 cd                	js     4fce <shell_process+0x31>
		switch (shell->ctx->receive_state) {
    5001:	8b 43 08             	mov    0x8(%ebx),%eax
    5004:	8b 78 08             	mov    0x8(%eax),%edi
    5007:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%ebp)
    500d:	83 ff 01             	cmp    $0x1,%edi
    5010:	0f 84 00 04 00 00    	je     5416 <shell_process+0x479>
    5016:	85 ff                	test   %edi,%edi
    5018:	74 0e                	je     5028 <shell_process+0x8b>
    501a:	83 ff 02             	cmp    $0x2,%edi
    501d:	0f 85 96 04 00 00    	jne    54b9 <shell_process+0x51c>
    5023:	e9 26 04 00 00       	jmp    544e <shell_process+0x4b1>
	if ((data != '\r') && (data != '\n')) {
    5028:	80 fa 0d             	cmp    $0xd,%dl
    502b:	74 0e                	je     503b <shell_process+0x9e>
    502d:	80 fa 0a             	cmp    $0xa,%dl
    5030:	74 09                	je     503b <shell_process+0x9e>
	return shell->ctx->internal.flags.last_nl;
}

static inline void flag_last_nl_set(const struct shell *shell, u8_t val)
{
	shell->ctx->internal.flags.last_nl = val;
    5032:	c6 80 61 02 00 00 00 	movb   $0x0,0x261(%eax)
		return false;
    5039:	eb 60                	jmp    509b <shell_process+0xfe>
	return shell->ctx->internal.flags.last_nl;
    503b:	8a 88 61 02 00 00    	mov    0x261(%eax),%cl
	if ((flag_last_nl_get(shell) == 0) ||
    5041:	84 c9                	test   %cl,%cl
    5043:	74 0a                	je     504f <shell_process+0xb2>
    5045:	8a 88 61 02 00 00    	mov    0x261(%eax),%cl
    504b:	38 ca                	cmp    %cl,%dl
    504d:	75 4c                	jne    509b <shell_process+0xfe>
	shell->ctx->internal.flags.last_nl = val;
    504f:	88 90 61 02 00 00    	mov    %dl,0x261(%eax)
				if (!shell->ctx->cmd_buff_len) {
    5055:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
    505a:	75 2c                	jne    5088 <shell_process+0xeb>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    505c:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    5063:	83 e2 bf             	and    $0xffffffbf,%edx
    5066:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell_history_mode_exit(shell->history);
    506d:	ff 73 0c             	pushl  0xc(%ebx)
    5070:	e8 5f 24 00 00       	call   74d4 <shell_history_mode_exit>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    5075:	c7 04 24 b9 6d 02 00 	movl   $0x26db9,(%esp)
    507c:	ff 73 14             	pushl  0x14(%ebx)
    507f:	e8 e8 f9 ff ff       	call   4a6c <shell_raw_fprintf>
    5084:	5e                   	pop    %esi
    5085:	5f                   	pop    %edi
    5086:	eb 07                	jmp    508f <shell_process+0xf2>
					(void)execute(shell);
    5088:	89 d8                	mov    %ebx,%eax
    508a:	e8 c0 fb ff ff       	call   4c4f <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
    508f:	89 d8                	mov    %ebx,%eax
    5091:	e8 07 fa ff ff       	call   4a9d <state_set.constprop.23>
				return;
    5096:	e9 2a 04 00 00       	jmp    54c5 <shell_process+0x528>
			switch (data) {
    509b:	80 fa 09             	cmp    $0x9,%dl
    509e:	74 37                	je     50d7 <shell_process+0x13a>
    50a0:	7f 16                	jg     50b8 <shell_process+0x11b>
    50a2:	84 d2                	test   %dl,%dl
    50a4:	0f 84 24 ff ff ff    	je     4fce <shell_process+0x31>
    50aa:	80 fa 08             	cmp    $0x8,%dl
    50ad:	0f 84 8b 01 00 00    	je     523e <shell_process+0x2a1>
    50b3:	e9 fb 01 00 00       	jmp    52b3 <shell_process+0x316>
    50b8:	80 fa 1b             	cmp    $0x1b,%dl
    50bb:	74 0e                	je     50cb <shell_process+0x12e>
    50bd:	80 fa 7f             	cmp    $0x7f,%dl
    50c0:	0f 84 9a 01 00 00    	je     5260 <shell_process+0x2c3>
    50c6:	e9 e8 01 00 00       	jmp    52b3 <shell_process+0x316>
	shell->ctx->receive_state = state;
    50cb:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
    50d2:	e9 f7 fe ff ff       	jmp    4fce <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    50d7:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
    50dd:	c1 ea 02             	shr    $0x2,%edx
				if (flag_echo_get(shell)) {
    50e0:	88 d1                	mov    %dl,%cl
    50e2:	80 e1 01             	and    $0x1,%cl
    50e5:	88 8d 50 ff ff ff    	mov    %cl,-0xb0(%ebp)
    50eb:	0f 84 dd fe ff ff    	je     4fce <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    50f1:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    50f8:	83 ca 40             	or     $0x40,%edx
    50fb:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	if (compl_space == 0) {
    5102:	66 81 78 3c ff 00    	cmpw   $0xff,0x3c(%eax)
    5108:	0f 84 c0 fe ff ff    	je     4fce <shell_process+0x31>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    510e:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
    5112:	52                   	push   %edx
    5113:	8d 50 42             	lea    0x42(%eax),%edx
    5116:	52                   	push   %edx
    5117:	05 42 01 00 00       	add    $0x142,%eax
    511c:	50                   	push   %eax
    511d:	e8 0f 58 00 00       	call   a931 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    5122:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    5125:	83 c4 0c             	add    $0xc,%esp
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
    5128:	05 42 01 00 00       	add    $0x142,%eax
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    512d:	0f b7 90 fc fe ff ff 	movzwl -0x104(%eax),%edx
    5134:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
    5138:	6a 0c                	push   $0xc
    513a:	50                   	push   %eax
    513b:	8d 45 c0             	lea    -0x40(%ebp),%eax
    513e:	50                   	push   %eax
    513f:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    5145:	50                   	push   %eax
    5146:	e8 35 0c 00 00       	call   5d80 <shell_make_argv>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    514b:	8b b5 78 ff ff ff    	mov    -0x88(%ebp),%esi
	(void)shell_make_argv(argc, argv, shell->ctx->temp_buff,
    5151:	83 c4 10             	add    $0x10,%esp
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    5154:	85 f6                	test   %esi,%esi
    5156:	0f 84 7e 03 00 00    	je     54da <shell_process+0x53d>
	int space = isspace((int)shell->ctx->cmd_buff[
    515c:	8b 43 08             	mov    0x8(%ebx),%eax
						shell->ctx->cmd_buff_pos - 1]);
    515f:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
	int space = isspace((int)shell->ctx->cmd_buff[
    5163:	0f be 44 10 41       	movsbl 0x41(%eax,%edx,1),%eax
    5168:	89 c2                	mov    %eax,%edx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    516a:	83 e8 09             	sub    $0x9,%eax
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    516d:	83 f8 04             	cmp    $0x4,%eax
    5170:	76 0f                	jbe    5181 <shell_process+0x1e4>
    5172:	80 fa 20             	cmp    $0x20,%dl
    5175:	74 0a                	je     5181 <shell_process+0x1e4>
    5177:	83 fe 01             	cmp    $0x1,%esi
    517a:	0f 84 58 03 00 00    	je     54d8 <shell_process+0x53b>
	search_argc = space ? *argc : *argc - 1;
    5180:	4e                   	dec    %esi
	if ((flag_last_nl_get(shell) == 0) ||
    5181:	31 d2                	xor    %edx,%edx
	const struct shell_static_entry *entry = NULL;
    5183:	31 ff                	xor    %edi,%edi
	const struct shell_cmd_entry *prev_cmd = NULL;
    5185:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
    518c:	00 00 00 
			if (shell_wildcard_character_exist(argv[*match_arg])) {
    518f:	ff 74 95 c0          	pushl  -0x40(%ebp,%edx,4)
    5193:	89 95 64 ff ff ff    	mov    %edx,-0x9c(%ebp)
    5199:	e8 b9 27 00 00       	call   7957 <shell_wildcard_character_exist>
    519e:	59                   	pop    %ecx
    519f:	84 c0                	test   %al,%al
    51a1:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
    51a7:	75 7a                	jne    5223 <shell_process+0x286>
		entry = find_cmd(prev_cmd, *match_arg, argv[*match_arg],
    51a9:	8b 7c 95 c0          	mov    -0x40(%ebp,%edx,4),%edi
	const struct shell_static_entry *entry = NULL;
    51ad:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
	size_t idx = 0;
    51b4:	31 c0                	xor    %eax,%eax
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
    51b6:	8d 48 01             	lea    0x1(%eax),%ecx
    51b9:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
    51bf:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%ebp)
    51c5:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
    51c8:	51                   	push   %ecx
    51c9:	8d 4d ac             	lea    -0x54(%ebp),%ecx
    51cc:	51                   	push   %ecx
    51cd:	50                   	push   %eax
    51ce:	52                   	push   %edx
    51cf:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    51d5:	e8 14 0e 00 00       	call   5fee <shell_cmd_get>
		if (entry && (strcmp(cmd_str, entry->syntax) == 0)) {
    51da:	8b 45 ac             	mov    -0x54(%ebp),%eax
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
    51dd:	83 c4 14             	add    $0x14,%esp
		if (entry && (strcmp(cmd_str, entry->syntax) == 0)) {
    51e0:	85 c0                	test   %eax,%eax
    51e2:	0f 84 e6 fd ff ff    	je     4fce <shell_process+0x31>
    51e8:	ff 30                	pushl  (%eax)
    51ea:	57                   	push   %edi
    51eb:	e8 86 56 00 00       	call   a876 <strcmp>
    51f0:	59                   	pop    %ecx
    51f1:	85 c0                	test   %eax,%eax
    51f3:	5a                   	pop    %edx
    51f4:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
    51fa:	75 16                	jne    5212 <shell_process+0x275>
			return entry;
    51fc:	8b 7d ac             	mov    -0x54(%ebp),%edi
		if (entry) {
    51ff:	85 ff                	test   %edi,%edi
    5201:	0f 84 c7 fd ff ff    	je     4fce <shell_process+0x31>
			prev_cmd = entry->subcmd;
    5207:	8b 47 08             	mov    0x8(%edi),%eax
    520a:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
    5210:	eb 11                	jmp    5223 <shell_process+0x286>
		shell_cmd_get(cmd, lvl, idx++, &entry, d_entry);
    5212:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
	} while (entry);
    5218:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
    521c:	75 98                	jne    51b6 <shell_process+0x219>
    521e:	e9 ab fd ff ff       	jmp    4fce <shell_process+0x31>
			(*match_arg)++;
    5223:	8d 42 01             	lea    0x1(%edx),%eax
    5226:	42                   	inc    %edx
	while (*match_arg < argc) {
    5227:	39 c6                	cmp    %eax,%esi
    5229:	0f 87 60 ff ff ff    	ja     518f <shell_process+0x1f2>
	if ((*cmd == NULL) && (search_argc != 0)) {
    522f:	89 c6                	mov    %eax,%esi
    5231:	85 ff                	test   %edi,%edi
    5233:	0f 85 a3 02 00 00    	jne    54dc <shell_process+0x53f>
    5239:	e9 90 fd ff ff       	jmp    4fce <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    523e:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
				if (flag_echo_get(shell)) {
    5244:	80 e2 04             	and    $0x4,%dl
    5247:	0f 84 81 fd ff ff    	je     4fce <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    524d:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    5254:	83 ca 40             	or     $0x40,%edx
    5257:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
					shell_op_char_backspace(shell);
    525e:	eb 2a                	jmp    528a <shell_process+0x2ed>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    5260:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
				if (flag_echo_get(shell)) {
    5266:	80 e2 04             	and    $0x4,%dl
    5269:	0f 84 5f fd ff ff    	je     4fce <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    526f:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    5276:	83 ca 40             	or     $0x40,%edx
    5279:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	return shell->ctx->internal.flags.mode_delete == 1 ? true : false;
    5280:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
					if (flag_mode_delete_get(shell)) {
    5286:	a8 20                	test   $0x20,%al
    5288:	74 1d                	je     52a7 <shell_process+0x30a>
						shell_op_char_backspace(shell);
    528a:	53                   	push   %ebx
    528b:	e8 a3 17 00 00       	call   6a33 <shell_op_char_backspace>
    5290:	eb 1b                	jmp    52ad <shell_process+0x310>
	shell->ctx->receive_state = state;
    5292:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    5299:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
				if (flag_echo_get(shell)) {
    529f:	a8 04                	test   $0x4,%al
    52a1:	0f 84 27 fd ff ff    	je     4fce <shell_process+0x31>
						shell_op_char_delete(shell);
    52a7:	53                   	push   %ebx
    52a8:	e8 34 17 00 00       	call   69e1 <shell_op_char_delete>
    52ad:	59                   	pop    %ecx
    52ae:	e9 1b fd ff ff       	jmp    4fce <shell_process+0x31>
		if (ascii_filter(data) != 0) {
    52b3:	0f be ca             	movsbl %dl,%ecx
	return (int)((((unsigned)c) >= ' ') &&
    52b6:	8d 71 e0             	lea    -0x20(%ecx),%esi
				if (isprint((int) data)) {
    52b9:	83 fe 5e             	cmp    $0x5e,%esi
    52bc:	77 1f                	ja     52dd <shell_process+0x340>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    52be:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    52c5:	83 ca 40             	or     $0x40,%edx
    52c8:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
					shell_op_char_insert(shell, data);
    52cf:	51                   	push   %ecx
    52d0:	53                   	push   %ebx
    52d1:	e8 72 16 00 00       	call   6948 <shell_op_char_insert>
		shell_op_cursor_move(shell, 1);
    52d6:	59                   	pop    %ecx
    52d7:	5e                   	pop    %esi
    52d8:	e9 f1 fc ff ff       	jmp    4fce <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    52dd:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
				} else if (flag_echo_get(shell)) {
    52e3:	a8 04                	test   $0x4,%al
    52e5:	0f 84 e3 fc ff ff    	je     4fce <shell_process+0x31>
	switch (data) {
    52eb:	4a                   	dec    %edx
    52ec:	80 fa 16             	cmp    $0x16,%dl
    52ef:	0f 87 d9 fc ff ff    	ja     4fce <shell_process+0x31>
    52f5:	0f b6 d2             	movzbl %dl,%edx
    52f8:	ff 24 95 a0 5d 02 00 	jmp    *0x25da0(,%edx,4)
	shell->ctx->receive_state = state;
    52ff:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_home_move(shell);
    5306:	53                   	push   %ebx
    5307:	e8 8d 11 00 00       	call   6499 <shell_op_cursor_home_move>
    530c:	eb 9f                	jmp    52ad <shell_process+0x310>
		shell_op_left_arrow(shell);
    530e:	53                   	push   %ebx
    530f:	e8 bc 11 00 00       	call   64d0 <shell_op_left_arrow>
    5314:	eb 97                	jmp    52ad <shell_process+0x310>
		shell_op_cursor_end_move(shell);
    5316:	53                   	push   %ebx
    5317:	e8 98 11 00 00       	call   64b4 <shell_op_cursor_end_move>
		if (!shell_cursor_in_empty_line(shell)) {
    531c:	89 1c 24             	mov    %ebx,(%esp)
    531f:	e8 3e 0f 00 00       	call   6262 <shell_cursor_in_empty_line>
    5324:	5a                   	pop    %edx
    5325:	84 c0                	test   %al,%al
    5327:	75 0f                	jne    5338 <shell_process+0x39b>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    5329:	68 b9 6d 02 00       	push   $0x26db9
    532e:	ff 73 14             	pushl  0x14(%ebx)
    5331:	e8 36 f7 ff ff       	call   4a6c <shell_raw_fprintf>
    5336:	5e                   	pop    %esi
    5337:	5f                   	pop    %edi
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    5338:	8b 53 08             	mov    0x8(%ebx),%edx
    533b:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    5342:	83 c8 40             	or     $0x40,%eax
    5345:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
		state_set(shell, SHELL_STATE_ACTIVE);
    534c:	89 d8                	mov    %ebx,%eax
    534e:	e8 4a f7 ff ff       	call   4a9d <state_set.constprop.23>
		break;
    5353:	e9 76 fc ff ff       	jmp    4fce <shell_process+0x31>
	shell->ctx->receive_state = state;
    5358:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_end_move(shell);
    535f:	53                   	push   %ebx
    5360:	e8 4f 11 00 00       	call   64b4 <shell_op_cursor_end_move>
    5365:	e9 43 ff ff ff       	jmp    52ad <shell_process+0x310>
		shell_op_right_arrow(shell);
    536a:	53                   	push   %ebx
    536b:	e8 7c 11 00 00       	call   64ec <shell_op_right_arrow>
    5370:	e9 38 ff ff ff       	jmp    52ad <shell_process+0x310>
		shell_op_delete_from_cursor(shell);
    5375:	53                   	push   %ebx
    5376:	e8 8f 11 00 00       	call   650a <shell_op_delete_from_cursor>
    537b:	e9 2d ff ff ff       	jmp    52ad <shell_process+0x310>
		SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    5380:	68 78 5e 02 00       	push   $0x25e78
    5385:	68 6a a5 02 00       	push   $0x2a56a
    538a:	ff 73 14             	pushl  0x14(%ebx)
    538d:	e8 da f6 ff ff       	call   4a6c <shell_raw_fprintf>
    5392:	83 c4 0c             	add    $0xc,%esp
		SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    5395:	68 70 5e 02 00       	push   $0x25e70
    539a:	68 6a a5 02 00       	push   $0x2a56a
    539f:	ff 73 14             	pushl  0x14(%ebx)
    53a2:	e8 c5 f6 ff ff       	call   4a6c <shell_raw_fprintf>
    53a7:	83 c4 0c             	add    $0xc,%esp
		shell_print_prompt_and_cmd(shell);
    53aa:	53                   	push   %ebx
    53ab:	e8 b6 16 00 00       	call   6a66 <shell_print_prompt_and_cmd>
    53b0:	e9 f8 fe ff ff       	jmp    52ad <shell_process+0x310>
		shell_op_cursor_home_move(shell);
    53b5:	53                   	push   %ebx
    53b6:	e8 de 10 00 00       	call   6499 <shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
    53bb:	8b 43 08             	mov    0x8(%ebx),%eax
    53be:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    53c5:	c6 40 42 00          	movb   $0x0,0x42(%eax)
    53c9:	83 ca 40             	or     $0x40,%edx
	shell->ctx->cmd_buff_len = 0;
    53cc:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
    53d3:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
    53da:	c7 04 24 6c 5e 02 00 	movl   $0x25e6c,(%esp)
    53e1:	68 6a a5 02 00       	push   $0x2a56a
    53e6:	ff 73 14             	pushl  0x14(%ebx)
    53e9:	e8 7e f6 ff ff       	call   4a6c <shell_raw_fprintf>
    53ee:	83 c4 0c             	add    $0xc,%esp
    53f1:	e9 d8 fb ff ff       	jmp    4fce <shell_process+0x31>
		shell_op_word_remove(shell);
    53f6:	53                   	push   %ebx
    53f7:	e8 68 13 00 00       	call   6764 <shell_op_word_remove>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
    53fc:	8b 53 08             	mov    0x8(%ebx),%edx
    53ff:	59                   	pop    %ecx
    5400:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    5407:	83 c8 40             	or     $0x40,%eax
    540a:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
    5411:	e9 b8 fb ff ff       	jmp    4fce <shell_process+0x31>
			if (data == '[') {
    5416:	80 fa 5b             	cmp    $0x5b,%dl
    5419:	75 0c                	jne    5427 <shell_process+0x48a>
	shell->ctx->receive_state = state;
    541b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
    5422:	e9 a7 fb ff ff       	jmp    4fce <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    5427:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
			} else if (flag_echo_get(shell)) {
    542d:	a8 04                	test   $0x4,%al
    542f:	74 18                	je     5449 <shell_process+0x4ac>
	if (data == SHELL_VT100_ASCII_ALT_B) {
    5431:	80 fa 62             	cmp    $0x62,%dl
    5434:	75 04                	jne    543a <shell_process+0x49d>
		shell_op_cursor_word_move(shell, -1);
    5436:	6a ff                	push   $0xffffffff
    5438:	eb 07                	jmp    5441 <shell_process+0x4a4>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
    543a:	80 fa 66             	cmp    $0x66,%dl
    543d:	75 0a                	jne    5449 <shell_process+0x4ac>
		shell_op_cursor_word_move(shell, 1);
    543f:	6a 01                	push   $0x1
    5441:	53                   	push   %ebx
    5442:	e8 8c 0f 00 00       	call   63d3 <shell_op_cursor_word_move>
    5447:	58                   	pop    %eax
    5448:	5a                   	pop    %edx
	shell->ctx->receive_state = state;
    5449:	8b 43 08             	mov    0x8(%ebx),%eax
    544c:	eb 6b                	jmp    54b9 <shell_process+0x51c>
    544e:	8b 88 60 02 00 00    	mov    0x260(%eax),%ecx
    5454:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			if (!flag_echo_get(shell)) {
    545b:	80 e1 04             	and    $0x4,%cl
    545e:	74 65                	je     54c5 <shell_process+0x528>
			switch (data) {
    5460:	83 ea 31             	sub    $0x31,%edx
    5463:	80 fa 1b             	cmp    $0x1b,%dl
    5466:	0f 87 62 fb ff ff    	ja     4fce <shell_process+0x31>
    546c:	0f b6 d2             	movzbl %dl,%edx
    546f:	ff 24 95 fc 5d 02 00 	jmp    *0x25dfc(,%edx,4)
				history_handle(shell, true);
    5476:	ba 01 00 00 00       	mov    $0x1,%edx
    547b:	eb 02                	jmp    547f <shell_process+0x4e2>
				history_handle(shell, false);
    547d:	31 d2                	xor    %edx,%edx
    547f:	89 d8                	mov    %ebx,%eax
    5481:	e8 d0 f6 ff ff       	call   4b56 <history_handle>
				break;
    5486:	e9 43 fb ff ff       	jmp    4fce <shell_process+0x31>
	shell->ctx->receive_state = state;
    548b:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
    5492:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
    5498:	66 8b 88 60 02 00 00 	mov    0x260(%eax),%cx
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
    549f:	83 e2 01             	and    $0x1,%edx
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
    54a2:	83 e1 fe             	and    $0xfffffffe,%ecx
				flag_insert_mode_set(shell, !status);
    54a5:	83 f2 01             	xor    $0x1,%edx
    54a8:	83 e2 01             	and    $0x1,%edx
    54ab:	09 ca                	or     %ecx,%edx
    54ad:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
    54b4:	e9 15 fb ff ff       	jmp    4fce <shell_process+0x31>
	shell->ctx->receive_state = state;
    54b9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    54c0:	e9 09 fb ff ff       	jmp    4fce <shell_process+0x31>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    54c5:	8b 43 08             	mov    0x8(%ebx),%eax
    54c8:	f0 83 a0 60 02 00 00 	lock andl $0xfffffff7,0x260(%eax)
    54cf:	f7 

	internal.value = 0xFFFFFFFF;
	internal.flags.processing = 0;
	(void)atomic_and((atomic_t *)&shell->ctx->internal.value,
			 internal.value);
}
    54d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    54d3:	5b                   	pop    %ebx
    54d4:	5e                   	pop    %esi
    54d5:	5f                   	pop    %edi
    54d6:	5d                   	pop    %ebp
    54d7:	c3                   	ret    
		*complete_arg_idx = SHELL_CMD_ROOT_LVL;
    54d8:	31 f6                	xor    %esi,%esi
		*cmd = NULL;
    54da:	31 ff                	xor    %edi,%edi
	find_completion_candidates(cmd, argv[arg_idx], &first, &cnt, &longest);
    54dc:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
    54e0:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
    54e6:	e8 6e f5 ff ff       	call   4a59 <shell_strlen>
    54eb:	0f b7 c0             	movzwl %ax,%eax
    54ee:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
	*cnt = 0;
    54f4:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
    54fb:	00 00 00 
	size_t first = 0;
    54fe:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
    5505:	00 00 00 
	*longest = 0U;
    5508:	66 c7 85 58 ff ff ff 	movw   $0x0,-0xa8(%ebp)
    550f:	00 00 
	bool found = false;
    5511:	c6 85 54 ff ff ff 00 	movb   $0x0,-0xac(%ebp)
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    5518:	31 c0                	xor    %eax,%eax
    551a:	85 ff                	test   %edi,%edi
    551c:	0f 95 c0             	setne  %al
    551f:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
    5525:	b8 00 00 00 00       	mov    $0x0,%eax
    552a:	74 03                	je     552f <shell_process+0x592>
    552c:	8b 47 08             	mov    0x8(%edi),%eax
    552f:	8d 55 ac             	lea    -0x54(%ebp),%edx
    5532:	52                   	push   %edx
    5533:	8d 55 98             	lea    -0x68(%ebp),%edx
    5536:	52                   	push   %edx
    5537:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    553d:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    5543:	50                   	push   %eax
    5544:	e8 a5 0a 00 00       	call   5fee <shell_cmd_get>
		if (!candidate) {
    5549:	8b 45 98             	mov    -0x68(%ebp),%eax
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    554c:	83 c4 14             	add    $0x14,%esp
		if (!candidate) {
    554f:	85 c0                	test   %eax,%eax
    5551:	74 6b                	je     55be <shell_process+0x621>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    5553:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
    5559:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
    555f:	ff 30                	pushl  (%eax)
    5561:	e8 30 53 00 00       	call   a896 <strncmp>
    5566:	83 c4 0c             	add    $0xc,%esp
		if (is_completion_candidate(candidate->syntax, incompl_cmd,
    5569:	85 c0                	test   %eax,%eax
    556b:	75 46                	jne    55b3 <shell_process+0x616>
			size_t slen = strlen(candidate->syntax);
    556d:	8b 45 98             	mov    -0x68(%ebp),%eax
    5570:	ff 30                	pushl  (%eax)
    5572:	e8 ec 52 00 00       	call   a863 <strlen>
    5577:	5a                   	pop    %edx
			*longest = (slen > *longest) ? slen : *longest;
    5578:	0f b7 95 58 ff ff ff 	movzwl -0xa8(%ebp),%edx
    557f:	39 c2                	cmp    %eax,%edx
    5581:	73 02                	jae    5585 <shell_process+0x5e8>
    5583:	89 c2                	mov    %eax,%edx
			(*cnt)++;
    5585:	ff 85 64 ff ff ff    	incl   -0x9c(%ebp)
			*longest = (slen > *longest) ? slen : *longest;
    558b:	66 89 95 58 ff ff ff 	mov    %dx,-0xa8(%ebp)
			if (!found) {
    5592:	80 bd 54 ff ff ff 00 	cmpb   $0x0,-0xac(%ebp)
    5599:	75 18                	jne    55b3 <shell_process+0x616>
				*first_idx = idx;
    559b:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    55a1:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			found = true;
    55a7:	8a 85 50 ff ff ff    	mov    -0xb0(%ebp),%al
    55ad:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
		idx++;
    55b3:	ff 85 6c ff ff ff    	incl   -0x94(%ebp)
    55b9:	e9 5a ff ff ff       	jmp    5518 <shell_process+0x57b>
	if (cnt == 1) {
    55be:	83 bd 64 ff ff ff 01 	cmpl   $0x1,-0x9c(%ebp)
    55c5:	0f 85 be 00 00 00    	jne    5689 <shell_process+0x6ec>
	u16_t arg_len = shell_strlen(arg);
    55cb:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
    55cf:	e8 85 f4 ff ff       	call   4a59 <shell_strlen>
    55d4:	0f b7 f0             	movzwl %ax,%esi
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    55d7:	8b 43 08             	mov    0x8(%ebx),%eax
    55da:	83 c0 0c             	add    $0xc,%eax
    55dd:	85 ff                	test   %edi,%edi
    55df:	74 03                	je     55e4 <shell_process+0x647>
    55e1:	8b 7f 08             	mov    0x8(%edi),%edi
    55e4:	50                   	push   %eax
    55e5:	8d 45 ac             	lea    -0x54(%ebp),%eax
    55e8:	50                   	push   %eax
    55e9:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
    55ef:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    55f5:	57                   	push   %edi
    55f6:	e8 f3 09 00 00       	call   5fee <shell_cmd_get>
	cmd_len = shell_strlen(match->syntax);
    55fb:	8b 45 ac             	mov    -0x54(%ebp),%eax
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    55fe:	83 c4 14             	add    $0x14,%esp
	cmd_len = shell_strlen(match->syntax);
    5601:	8b 00                	mov    (%eax),%eax
    5603:	e8 51 f4 ff ff       	call   4a59 <shell_strlen>
	if (cmd_len != arg_len) {
    5608:	66 39 c6             	cmp    %ax,%si
    560b:	74 15                	je     5622 <shell_process+0x685>
					   cmd_len - arg_len);
    560d:	29 f0                	sub    %esi,%eax
		shell_op_completion_insert(shell,
    560f:	0f b7 c0             	movzwl %ax,%eax
    5612:	50                   	push   %eax
    5613:	8b 45 ac             	mov    -0x54(%ebp),%eax
    5616:	03 30                	add    (%eax),%esi
    5618:	56                   	push   %esi
    5619:	53                   	push   %ebx
    561a:	e8 af 13 00 00       	call   69ce <shell_op_completion_insert>
    561f:	83 c4 0c             	add    $0xc,%esp
	if (!isspace((int) shell->ctx->cmd_buff[
    5622:	8b 43 08             	mov    0x8(%ebx),%eax
					shell->ctx->cmd_buff_pos])) {
    5625:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
	if (!isspace((int) shell->ctx->cmd_buff[
    5629:	0f be 54 10 42       	movsbl 0x42(%eax,%edx,1),%edx
    562e:	89 d1                	mov    %edx,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    5630:	83 ea 09             	sub    $0x9,%edx
    5633:	83 fa 04             	cmp    $0x4,%edx
    5636:	76 44                	jbe    567c <shell_process+0x6df>
    5638:	80 f9 20             	cmp    $0x20,%cl
    563b:	74 3f                	je     567c <shell_process+0x6df>
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
    563d:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
		if (flag_insert_mode_get(shell)) {
    5643:	80 e2 01             	and    $0x1,%dl
    5646:	74 2d                	je     5675 <shell_process+0x6d8>
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
    5648:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    564f:	83 e2 fe             	and    $0xfffffffe,%edx
    5652:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
			shell_op_char_insert(shell, ' ');
    5659:	6a 20                	push   $0x20
    565b:	53                   	push   %ebx
    565c:	e8 e7 12 00 00       	call   6948 <shell_op_char_insert>
    5661:	8b 53 08             	mov    0x8(%ebx),%edx
    5664:	5f                   	pop    %edi
    5665:	58                   	pop    %eax
    5666:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    566d:	83 c8 01             	or     $0x1,%eax
    5670:	e9 95 fd ff ff       	jmp    540a <shell_process+0x46d>
			shell_op_char_insert(shell, ' ');
    5675:	6a 20                	push   $0x20
    5677:	e9 54 fc ff ff       	jmp    52d0 <shell_process+0x333>
		shell_op_cursor_move(shell, 1);
    567c:	6a 01                	push   $0x1
    567e:	53                   	push   %ebx
    567f:	e8 c9 0c 00 00       	call   634d <shell_op_cursor_move>
    5684:	e9 4d fc ff ff       	jmp    52d6 <shell_process+0x339>
	} else if (cnt > 1) {
    5689:	0f 86 3f f9 ff ff    	jbe    4fce <shell_process+0x31>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    568f:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
    5693:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t str_len = shell_strlen(str);
    5699:	e8 bb f3 ff ff       	call   4a59 <shell_strlen>
    569e:	0f b7 c0             	movzwl %ax,%eax
    56a1:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		shell->ctx->vt100_ctx.printed_cmd = 0;
    56a7:	8b 43 08             	mov    0x8(%ebx),%eax
    56aa:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
    56b0:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    56b6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
    56bc:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
    56c2:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    56c8:	8b 43 08             	mov    0x8(%ebx),%eax
    56cb:	31 d2                	xor    %edx,%edx
    56cd:	83 c0 0c             	add    $0xc,%eax
    56d0:	85 ff                	test   %edi,%edi
    56d2:	74 03                	je     56d7 <shell_process+0x73a>
    56d4:	8b 57 08             	mov    0x8(%edi),%edx
    56d7:	50                   	push   %eax
    56d8:	8d 45 ac             	lea    -0x54(%ebp),%eax
    56db:	50                   	push   %eax
    56dc:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
    56e2:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    56e8:	52                   	push   %edx
    56e9:	e8 00 09 00 00       	call   5fee <shell_cmd_get>
    56ee:	83 c4 14             	add    $0x14,%esp
		idx++;
    56f1:	ff 85 54 ff ff ff    	incl   -0xac(%ebp)
		if (str && match->syntax &&
    56f7:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
    56fe:	75 1d                	jne    571d <shell_process+0x780>
		tab_item_print(shell, match->syntax, longest);
    5700:	8b 45 ac             	mov    -0x54(%ebp),%eax
    5703:	8b 00                	mov    (%eax),%eax
    5705:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
	if (option == NULL) {
    570b:	85 c0                	test   %eax,%eax
    570d:	75 32                	jne    5741 <shell_process+0x7a4>
		shell->ctx->vt100_ctx.printed_cmd = 0;
    570f:	8b 43 08             	mov    0x8(%ebx),%eax
    5712:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
		return;
    5718:	e9 fe 00 00 00       	jmp    581b <shell_process+0x87e>
		if (str && match->syntax &&
    571d:	8b 45 ac             	mov    -0x54(%ebp),%eax
    5720:	8b 00                	mov    (%eax),%eax
    5722:	85 c0                	test   %eax,%eax
    5724:	74 da                	je     5700 <shell_process+0x763>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    5726:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
    572c:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
    5732:	50                   	push   %eax
    5733:	e8 5e 51 00 00       	call   a896 <strncmp>
    5738:	83 c4 0c             	add    $0xc,%esp
		if (str && match->syntax &&
    573b:	85 c0                	test   %eax,%eax
    573d:	74 c1                	je     5700 <shell_process+0x763>
    573f:	eb 87                	jmp    56c8 <shell_process+0x72b>
	longest_option += shell_strlen(tab);
    5741:	b8 97 86 02 00       	mov    $0x28697,%eax
    5746:	e8 0e f3 ff ff       	call   4a59 <shell_strlen>
    574b:	03 85 58 ff ff ff    	add    -0xa8(%ebp),%eax
    5751:	66 89 85 50 ff ff ff 	mov    %ax,-0xb0(%ebp)
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
    5758:	8b 43 08             	mov    0x8(%ebx),%eax
    575b:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
    575f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			- shell_strlen(tab)) / longest_option;
    5765:	b8 97 86 02 00       	mov    $0x28697,%eax
    576a:	e8 ea f2 ff ff       	call   4a59 <shell_strlen>
    576f:	66 89 85 42 ff ff ff 	mov    %ax,-0xbe(%ebp)
	diff = longest_option - shell_strlen(option);
    5776:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    577c:	e8 d8 f2 ff ff       	call   4a59 <shell_strlen>
    5781:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
    5787:	29 c1                	sub    %eax,%ecx
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0) {
    5789:	8b 43 08             	mov    0x8(%ebx),%eax
	diff = longest_option - shell_strlen(option);
    578c:	66 89 8d 40 ff ff ff 	mov    %cx,-0xc0(%ebp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0) {
    5793:	8b 48 38             	mov    0x38(%eax),%ecx
    5796:	8d 51 01             	lea    0x1(%ecx),%edx
    5799:	66 89 50 38          	mov    %dx,0x38(%eax)
			- shell_strlen(tab)) / longest_option;
    579d:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
    57a3:	0f b7 85 42 ff ff ff 	movzwl -0xbe(%ebp),%eax
    57aa:	29 c2                	sub    %eax,%edx
    57ac:	89 d0                	mov    %edx,%eax
    57ae:	0f b7 95 50 ff ff ff 	movzwl -0xb0(%ebp),%edx
    57b5:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
    57bb:	99                   	cltd   
    57bc:	f7 bd 50 ff ff ff    	idivl  -0xb0(%ebp)
    57c2:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0) {
    57c8:	31 d2                	xor    %edx,%edx
    57ca:	89 c8                	mov    %ecx,%eax
    57cc:	66 f7 b5 50 ff ff ff 	divw   -0xb0(%ebp)
    57d3:	66 85 d2             	test   %dx,%dx
    57d6:	75 1d                	jne    57f5 <shell_process+0x858>
		shell_internal_fprintf(shell, SHELL_OPTION, "\n%s%s", tab,
    57d8:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    57de:	68 97 86 02 00       	push   $0x28697
    57e3:	68 b2 6d 02 00       	push   $0x26db2
    57e8:	6a 07                	push   $0x7
    57ea:	53                   	push   %ebx
    57eb:	e8 5a 0f 00 00       	call   674a <shell_internal_fprintf>
    57f0:	83 c4 14             	add    $0x14,%esp
    57f3:	eb 16                	jmp    580b <shell_process+0x86e>
		shell_internal_fprintf(shell, SHELL_OPTION, "%s", option);
    57f5:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    57fb:	68 6a a5 02 00       	push   $0x2a56a
    5800:	6a 07                	push   $0x7
    5802:	53                   	push   %ebx
    5803:	e8 42 0f 00 00       	call   674a <shell_internal_fprintf>
    5808:	83 c4 10             	add    $0x10,%esp
	shell_op_cursor_horiz_move(shell, diff);
    580b:	0f b7 85 40 ff ff ff 	movzwl -0xc0(%ebp),%eax
    5812:	50                   	push   %eax
    5813:	53                   	push   %ebx
    5814:	e8 1a 0a 00 00       	call   6233 <shell_op_cursor_horiz_move>
    5819:	58                   	pop    %eax
    581a:	5a                   	pop    %edx
	while (cnt) {
    581b:	ff 8d 4c ff ff ff    	decl   -0xb4(%ebp)
    5821:	0f 85 a1 fe ff ff    	jne    56c8 <shell_process+0x72b>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    5827:	68 b9 6d 02 00       	push   $0x26db9
    582c:	ff 73 14             	pushl  0x14(%ebx)
    582f:	e8 38 f2 ff ff       	call   4a6c <shell_raw_fprintf>
    5834:	58                   	pop    %eax
    5835:	5a                   	pop    %edx
	shell_print_prompt_and_cmd(shell);
    5836:	53                   	push   %ebx
    5837:	e8 2a 12 00 00       	call   6a66 <shell_print_prompt_and_cmd>
	u16_t arg_len = shell_strlen(arg);
    583c:	8b 44 b5 c0          	mov    -0x40(%ebp,%esi,4),%eax
	shell_print_prompt_and_cmd(shell);
    5840:	59                   	pop    %ecx
	u16_t arg_len = shell_strlen(arg);
    5841:	e8 13 f2 ff ff       	call   4a59 <shell_strlen>
    5846:	66 89 85 6c ff ff ff 	mov    %ax,-0x94(%ebp)
	u16_t common = common_beginning_find(cmd, &completion,
    584d:	0f b7 c0             	movzwl %ax,%eax
    5850:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
	size_t idx = first + 1;
    5856:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
    585c:	8d 48 01             	lea    0x1(%eax),%ecx
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    585f:	31 c0                	xor    %eax,%eax
    5861:	85 ff                	test   %edi,%edi
    5863:	74 03                	je     5868 <shell_process+0x8cb>
    5865:	8b 47 08             	mov    0x8(%edi),%eax
    5868:	8d 55 98             	lea    -0x68(%ebp),%edx
    586b:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%ebp)
    5871:	52                   	push   %edx
    5872:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
    5878:	52                   	push   %edx
	u16_t common = UINT16_MAX;
    5879:	83 ce ff             	or     $0xffffffff,%esi
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    587c:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
    5882:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    5888:	50                   	push   %eax
    5889:	e8 60 07 00 00       	call   5fee <shell_cmd_get>
	*str = match->syntax;
    588e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    5894:	83 c4 14             	add    $0x14,%esp
	*str = match->syntax;
    5897:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
    589d:	8b 00                	mov    (%eax),%eax
    589f:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    58a5:	8d 41 01             	lea    0x1(%ecx),%eax
    58a8:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
    58ae:	31 c0                	xor    %eax,%eax
    58b0:	85 ff                	test   %edi,%edi
    58b2:	74 03                	je     58b7 <shell_process+0x91a>
    58b4:	8b 47 08             	mov    0x8(%edi),%eax
    58b7:	8d 55 ac             	lea    -0x54(%ebp),%edx
    58ba:	52                   	push   %edx
    58bb:	8d 55 80             	lea    -0x80(%ebp),%edx
    58be:	52                   	push   %edx
    58bf:	51                   	push   %ecx
    58c0:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    58c6:	50                   	push   %eax
    58c7:	e8 22 07 00 00       	call   5fee <shell_cmd_get>
		if (match2 == NULL) {
    58cc:	8b 45 80             	mov    -0x80(%ebp),%eax
		shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    58cf:	83 c4 14             	add    $0x14,%esp
		if (match2 == NULL) {
    58d2:	85 c0                	test   %eax,%eax
    58d4:	74 5e                	je     5934 <shell_process+0x997>
		curr_common = str_common(match->syntax, match2->syntax,
    58d6:	8b 08                	mov    (%eax),%ecx
    58d8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    58de:	8b 00                	mov    (%eax),%eax
    58e0:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
	size_t common = 0;
    58e6:	31 c0                	xor    %eax,%eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    58e8:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
    58ee:	8a 14 02             	mov    (%edx,%eax,1),%dl
    58f1:	38 14 01             	cmp    %dl,(%ecx,%eax,1)
    58f4:	75 0c                	jne    5902 <shell_process+0x965>
    58f6:	84 d2                	test   %dl,%dl
    58f8:	74 08                	je     5902 <shell_process+0x965>
		common++;
    58fa:	40                   	inc    %eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    58fb:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5900:	75 e6                	jne    58e8 <shell_process+0x94b>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
    5902:	39 85 5c ff ff ff    	cmp    %eax,-0xa4(%ebp)
    5908:	7e 12                	jle    591c <shell_process+0x97f>
    590a:	66 83 bd 6c ff ff ff 	cmpw   $0x0,-0x94(%ebp)
    5911:	00 
    5912:	74 08                	je     591c <shell_process+0x97f>
	shell_cmd_get(cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
    5914:	8b 8d 60 ff ff ff    	mov    -0xa0(%ebp),%ecx
    591a:	eb 89                	jmp    58a5 <shell_process+0x908>
			common = (curr_common < common) ? curr_common : common;
    591c:	0f b7 f6             	movzwl %si,%esi
			--cnt;
    591f:	ff 8d 64 ff ff ff    	decl   -0x9c(%ebp)
			common = (curr_common < common) ? curr_common : common;
    5925:	39 c6                	cmp    %eax,%esi
    5927:	7e 02                	jle    592b <shell_process+0x98e>
    5929:	89 c6                	mov    %eax,%esi
	while (cnt > 1) {
    592b:	83 bd 64 ff ff ff 01 	cmpl   $0x1,-0x9c(%ebp)
    5932:	75 e0                	jne    5914 <shell_process+0x977>
	if (common) {
    5934:	66 85 f6             	test   %si,%si
    5937:	0f 84 91 f6 ff ff    	je     4fce <shell_process+0x31>
					   common - arg_len);
    593d:	2b b5 6c ff ff ff    	sub    -0x94(%ebp),%esi
		shell_op_completion_insert(shell, &completion[arg_len],
    5943:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    594a:	0f b7 f6             	movzwl %si,%esi
    594d:	03 85 58 ff ff ff    	add    -0xa8(%ebp),%eax
    5953:	56                   	push   %esi
    5954:	50                   	push   %eax
    5955:	53                   	push   %ebx
    5956:	e8 73 10 00 00       	call   69ce <shell_op_completion_insert>
    595b:	e9 8e fa ff ff       	jmp    53ee <shell_process+0x451>

00005960 <shell_init>:
{
    5960:	55                   	push   %ebp
    5961:	89 e5                	mov    %esp,%ebp
    5963:	57                   	push   %edi
    5964:	56                   	push   %esi
    5965:	53                   	push   %ebx
    5966:	8b 5d 08             	mov    0x8(%ebp),%ebx
    5969:	8b 75 14             	mov    0x14(%ebp),%esi
	int err = shell->iface->api->init(shell->iface, p_config,
    596c:	8b 43 04             	mov    0x4(%ebx),%eax
    596f:	8b 10                	mov    (%eax),%edx
    5971:	53                   	push   %ebx
    5972:	68 be 4a 00 00       	push   $0x4abe
    5977:	ff 75 0c             	pushl  0xc(%ebp)
    597a:	50                   	push   %eax
    597b:	ff 12                	call   *(%edx)
    597d:	83 c4 10             	add    $0x10,%esp
    5980:	89 c7                	mov    %eax,%edi
	if (err != 0) {
    5982:	85 c0                	test   %eax,%eax
    5984:	0f 85 d9 00 00 00    	jne    5a63 <shell_init+0x103>
	memset(shell->ctx, 0, sizeof(*shell->ctx));
    598a:	68 14 03 00 00       	push   $0x314
    598f:	6a 00                	push   $0x0
    5991:	ff 73 08             	pushl  0x8(%ebx)
    5994:	e8 07 50 00 00       	call   a9a0 <memset>
	shell->ctx->prompt = shell->default_prompt;
    5999:	8b 43 08             	mov    0x8(%ebx),%eax
	memset(shell->ctx, 0, sizeof(*shell->ctx));
    599c:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->prompt = shell->default_prompt;
    599f:	8b 13                	mov    (%ebx),%edx
    59a1:	89 10                	mov    %edx,(%eax)
	shell_history_init(shell->history);
    59a3:	ff 73 0c             	pushl  0xc(%ebx)
    59a6:	e8 7b 1c 00 00       	call   7626 <shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
    59ab:	8b 43 08             	mov    0x8(%ebx),%eax
    59ae:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
    59b3:	89 04 24             	mov    %eax,(%esp)
    59b6:	e8 fe d9 01 00       	call   233b9 <z_impl_k_mutex_init>
    59bb:	58                   	pop    %eax
		shell->stats->log_lost_cnt = 0;
    59bc:	8b 43 18             	mov    0x18(%ebx),%eax
    59bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
    59c5:	8b 43 08             	mov    0x8(%ebx),%eax
    59c8:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
	shell->ctx->state = SHELL_STATE_INITIALIZED;
    59cf:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    59d6:	83 ca 10             	or     $0x10,%edx
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    59d9:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
    59e0:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->internal.flags.echo = val ? 1 : 0;
    59e7:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    59ee:	83 ca 04             	or     $0x4,%edx
    59f1:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
    59f8:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    59ff:	83 ca 20             	or     $0x20,%edx
    5a02:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
	shell->ctx->vt100_ctx.cons.name_len = shell_strlen(shell->ctx->prompt);
    5a09:	8b 00                	mov    (%eax),%eax
    5a0b:	e8 49 f0 ff ff       	call   4a59 <shell_strlen>
    5a10:	8b 53 08             	mov    0x8(%ebx),%edx
    5a13:	88 42 2c             	mov    %al,0x2c(%edx)
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
    5a16:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    5a1d:	83 c8 02             	or     $0x2,%eax
    5a20:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
    5a27:	6a 00                	push   $0x0
    5a29:	6a 00                	push   $0x0
	k_tid_t tid = k_thread_create(shell->thread,
    5a2b:	89 f0                	mov    %esi,%eax
    5a2d:	6a 0e                	push   $0xe
    5a2f:	ff 75 18             	pushl  0x18(%ebp)
    5a32:	0f b6 f0             	movzbl %al,%esi
    5a35:	56                   	push   %esi
    5a36:	53                   	push   %ebx
    5a37:	68 a9 5a 00 00       	push   $0x5aa9
    5a3c:	68 00 08 00 00       	push   $0x800
    5a41:	ff 73 2c             	pushl  0x2c(%ebx)
    5a44:	ff 73 28             	pushl  0x28(%ebx)
    5a47:	e8 d0 e7 01 00       	call   2421c <z_impl_k_thread_create>
	shell->ctx->tid = tid;
    5a4c:	8b 53 08             	mov    0x8(%ebx),%edx
    5a4f:	83 c4 28             	add    $0x28,%esp
    5a52:	89 82 10 03 00 00    	mov    %eax,0x310(%edx)
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
    5a58:	ff 73 24             	pushl  0x24(%ebx)
    5a5b:	50                   	push   %eax
    5a5c:	e8 3e e7 01 00       	call   2419f <z_impl_k_thread_name_set>
    5a61:	5a                   	pop    %edx
    5a62:	59                   	pop    %ecx
}
    5a63:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5a66:	89 f8                	mov    %edi,%eax
    5a68:	5b                   	pop    %ebx
    5a69:	5e                   	pop    %esi
    5a6a:	5f                   	pop    %edi
    5a6b:	5d                   	pop    %ebp
    5a6c:	c3                   	ret    

00005a6d <shell_start>:
{
    5a6d:	55                   	push   %ebp
    5a6e:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
    5a73:	89 e5                	mov    %esp,%ebp
    5a75:	53                   	push   %ebx
    5a76:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (shell->ctx->state != SHELL_STATE_INITIALIZED) {
    5a79:	8b 53 08             	mov    0x8(%ebx),%edx
    5a7c:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    5a80:	75 22                	jne    5aa4 <shell_start+0x37>
		shell_vt100_color_set(shell, SHELL_NORMAL);
    5a82:	6a 00                	push   $0x0
    5a84:	53                   	push   %ebx
    5a85:	e8 a3 0b 00 00       	call   662d <shell_vt100_color_set>
    5a8a:	58                   	pop    %eax
    5a8b:	5a                   	pop    %edx
	shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
    5a8c:	68 b8 6d 02 00       	push   $0x26db8
    5a91:	ff 73 14             	pushl  0x14(%ebx)
    5a94:	e8 d3 ef ff ff       	call   4a6c <shell_raw_fprintf>
    5a99:	59                   	pop    %ecx
    5a9a:	58                   	pop    %eax
	state_set(shell, SHELL_STATE_ACTIVE);
    5a9b:	89 d8                	mov    %ebx,%eax
    5a9d:	e8 fb ef ff ff       	call   4a9d <state_set.constprop.23>
	return 0;
    5aa2:	31 c0                	xor    %eax,%eax
}
    5aa4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5aa7:	c9                   	leave  
    5aa8:	c3                   	ret    

00005aa9 <shell_thread>:
{
    5aa9:	55                   	push   %ebp
    5aaa:	89 e5                	mov    %esp,%ebp
    5aac:	57                   	push   %edi
    5aad:	56                   	push   %esi
    5aae:	bf a4 02 00 00       	mov    $0x2a4,%edi
    5ab3:	53                   	push   %ebx
    5ab4:	be 64 02 00 00       	mov    $0x264,%esi
    5ab9:	8b 5d 08             	mov    0x8(%ebp),%ebx
		k_poll_signal_init(&shell->ctx->signals[i]);
    5abc:	8b 43 08             	mov    0x8(%ebx),%eax
    5abf:	01 f0                	add    %esi,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_POLL_SIGNAL_INIT, k_poll_signal_init, struct k_poll_signal *, signal)
    5ac1:	50                   	push   %eax
    5ac2:	e8 a2 f1 01 00       	call   24c69 <z_impl_k_poll_signal_init>
				  &shell->ctx->signals[i]);
    5ac7:	8b 43 08             	mov    0x8(%ebx),%eax
    5aca:	8d 14 30             	lea    (%eax,%esi,1),%edx
		k_poll_event_init(&shell->ctx->events[i],
    5acd:	01 f8                	add    %edi,%eax
    5acf:	89 14 24             	mov    %edx,(%esp)
    5ad2:	6a 00                	push   $0x0
    5ad4:	6a 01                	push   $0x1
    5ad6:	83 c6 10             	add    $0x10,%esi
    5ad9:	50                   	push   %eax
    5ada:	83 c7 14             	add    $0x14,%edi
    5add:	e8 c0 ef 01 00       	call   24aa2 <k_poll_event_init>
    5ae2:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    5ae5:	81 fe a4 02 00 00    	cmp    $0x2a4,%esi
    5aeb:	75 cf                	jne    5abc <shell_thread+0x13>
	err = shell->iface->api->enable(shell->iface, false);
    5aed:	8b 43 04             	mov    0x4(%ebx),%eax
    5af0:	8b 10                	mov    (%eax),%edx
    5af2:	6a 00                	push   $0x0
    5af4:	50                   	push   %eax
    5af5:	ff 52 08             	call   *0x8(%edx)
    5af8:	59                   	pop    %ecx
    5af9:	5e                   	pop    %esi
	if (err != 0) {
    5afa:	85 c0                	test   %eax,%eax
    5afc:	0f 85 b8 00 00 00    	jne    5bba <shell_thread+0x111>
	if (log_backend && IS_ENABLED(CONFIG_LOG)) {
    5b02:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    5b06:	74 0f                	je     5b17 <shell_thread+0x6e>
		shell_log_backend_enable(shell->log_backend, (void *)shell,
    5b08:	ff 75 10             	pushl  0x10(%ebp)
    5b0b:	53                   	push   %ebx
    5b0c:	ff 73 1c             	pushl  0x1c(%ebx)
    5b0f:	e8 7e 1c 00 00       	call   7792 <shell_log_backend_enable>
    5b14:	83 c4 0c             	add    $0xc,%esp
	err = shell_start(shell);
    5b17:	53                   	push   %ebx
    5b18:	e8 50 ff ff ff       	call   5a6d <shell_start>
    5b1d:	5a                   	pop    %edx
	if (err != 0) {
    5b1e:	85 c0                	test   %eax,%eax
    5b20:	0f 85 94 00 00 00    	jne    5bba <shell_thread+0x111>
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    5b26:	6a ff                	push   $0xffffffff
    5b28:	6a 03                	push   $0x3
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
    5b2a:	8b 43 08             	mov    0x8(%ebx),%eax
    5b2d:	05 a4 02 00 00       	add    $0x2a4,%eax
    5b32:	50                   	push   %eax
    5b33:	e8 ab ef 01 00       	call   24ae3 <z_impl_k_poll>
    5b38:	83 c4 0c             	add    $0xc,%esp
    5b3b:	89 c6                	mov    %eax,%esi
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    5b3d:	6a ff                	push   $0xffffffff
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    5b3f:	8b 43 08             	mov    0x8(%ebx),%eax
    5b42:	05 f4 02 00 00       	add    $0x2f4,%eax
    5b47:	50                   	push   %eax
    5b48:	e8 96 d8 01 00       	call   233e3 <z_impl_k_mutex_lock>
    5b4d:	59                   	pop    %ecx
		if (err != 0) {
    5b4e:	85 f6                	test   %esi,%esi
    5b50:	5f                   	pop    %edi
    5b51:	74 13                	je     5b66 <shell_thread+0xbd>
			shell_internal_fprintf(shell, SHELL_ERROR,
    5b53:	56                   	push   %esi
    5b54:	68 bb 6d 02 00       	push   $0x26dbb
    5b59:	6a 02                	push   $0x2
    5b5b:	53                   	push   %ebx
    5b5c:	e8 e9 0b 00 00       	call   674a <shell_internal_fprintf>
    5b61:	83 c4 10             	add    $0x10,%esp
			return;
    5b64:	eb 54                	jmp    5bba <shell_thread+0x111>
		if (shell->iface->api->update) {
    5b66:	8b 53 04             	mov    0x4(%ebx),%edx
    5b69:	8b 02                	mov    (%edx),%eax
    5b6b:	8b 40 14             	mov    0x14(%eax),%eax
    5b6e:	85 c0                	test   %eax,%eax
    5b70:	74 04                	je     5b76 <shell_thread+0xcd>
			shell->iface->api->update(shell->iface);
    5b72:	52                   	push   %edx
    5b73:	ff d0                	call   *%eax
    5b75:	5a                   	pop    %edx
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    5b76:	b9 09 4a 00 00       	mov    $0x4a09,%ecx
    5b7b:	ba 02 00 00 00       	mov    $0x2,%edx
    5b80:	89 d8                	mov    %ebx,%eax
    5b82:	e8 3e ee ff ff       	call   49c5 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    5b87:	b9 9d 4f 00 00       	mov    $0x4f9d,%ecx
    5b8c:	31 d2                	xor    %edx,%edx
    5b8e:	89 d8                	mov    %ebx,%eax
    5b90:	e8 30 ee ff ff       	call   49c5 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
    5b95:	b9 e9 4a 00 00       	mov    $0x4ae9,%ecx
    5b9a:	ba 01 00 00 00       	mov    $0x1,%edx
    5b9f:	89 d8                	mov    %ebx,%eax
    5ba1:	e8 1f ee ff ff       	call   49c5 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    5ba6:	8b 43 08             	mov    0x8(%ebx),%eax
    5ba9:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    5bae:	50                   	push   %eax
    5baf:	e8 26 d9 01 00       	call   234da <z_impl_k_mutex_unlock>
    5bb4:	58                   	pop    %eax
    5bb5:	e9 6c ff ff ff       	jmp    5b26 <shell_thread+0x7d>
}
    5bba:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5bbd:	5b                   	pop    %ebx
    5bbe:	5e                   	pop    %esi
    5bbf:	5f                   	pop    %edi
    5bc0:	5d                   	pop    %ebp
    5bc1:	c3                   	ret    

00005bc2 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
    5bc2:	55                   	push   %ebp
    5bc3:	89 e5                	mov    %esp,%ebp
    5bc5:	53                   	push   %ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    5bc6:	6a ff                	push   $0xffffffff
    5bc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args = { 0 };

	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    5bcb:	8b 43 08             	mov    0x8(%ebx),%eax
    5bce:	05 f4 02 00 00       	add    $0x2f4,%eax
    5bd3:	50                   	push   %eax
    5bd4:	e8 0a d8 01 00       	call   233e3 <z_impl_k_mutex_lock>
    5bd9:	58                   	pop    %eax
	if (!flag_cmd_ctx_get(shell)) {
    5bda:	8b 43 08             	mov    0x8(%ebx),%eax
    5bdd:	5a                   	pop    %edx
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
    5bde:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
    5be4:	84 c0                	test   %al,%al
    5be6:	78 07                	js     5bef <shell_fprintf+0x2d>
		shell_cmd_line_erase(shell);
    5be8:	53                   	push   %ebx
    5be9:	e8 3b 09 00 00       	call   6529 <shell_cmd_line_erase>
    5bee:	59                   	pop    %ecx
	}

	va_start(args, fmt);
    5bef:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
    5bf2:	50                   	push   %eax
    5bf3:	ff 75 10             	pushl  0x10(%ebp)
    5bf6:	ff 75 0c             	pushl  0xc(%ebp)
    5bf9:	53                   	push   %ebx
    5bfa:	e8 d9 0a 00 00       	call   66d8 <shell_internal_vfprintf>
	va_end(args);

	if (!flag_cmd_ctx_get(shell)) {
    5bff:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
    5c02:	83 c4 10             	add    $0x10,%esp
    5c05:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
	if (!flag_cmd_ctx_get(shell)) {
    5c0b:	84 c0                	test   %al,%al
    5c0d:	78 07                	js     5c16 <shell_fprintf+0x54>
		shell_print_prompt_and_cmd(shell);
    5c0f:	53                   	push   %ebx
    5c10:	e8 51 0e 00 00       	call   6a66 <shell_print_prompt_and_cmd>
    5c15:	5a                   	pop    %edx

void shell_spaces_trim(char *str);

static inline void transport_buffer_flush(const struct shell *shell)
{
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
    5c16:	ff 73 14             	pushl  0x14(%ebx)
    5c19:	e8 16 00 00 00       	call   5c34 <shell_fprintf_buffer_flush>
	}
	transport_buffer_flush(shell);
	k_mutex_unlock(&shell->ctx->wr_mtx);
    5c1e:	8b 43 08             	mov    0x8(%ebx),%eax
    5c21:	05 f4 02 00 00       	add    $0x2f4,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    5c26:	89 04 24             	mov    %eax,(%esp)
    5c29:	e8 ac d8 01 00       	call   234da <z_impl_k_mutex_unlock>
    5c2e:	58                   	pop    %eax
}
    5c2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c32:	c9                   	leave  
    5c33:	c3                   	ret    

00005c34 <shell_fprintf_buffer_flush>:
	}
}


void shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
    5c34:	55                   	push   %ebp
    5c35:	89 e5                	mov    %esp,%ebp
    5c37:	53                   	push   %ebx
    5c38:	8b 5d 08             	mov    0x8(%ebp),%ebx
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
    5c3b:	8b 43 10             	mov    0x10(%ebx),%eax
    5c3e:	ff 30                	pushl  (%eax)
    5c40:	ff 33                	pushl  (%ebx)
    5c42:	ff 73 0c             	pushl  0xc(%ebx)
    5c45:	ff 53 08             	call   *0x8(%ebx)
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    5c48:	8b 43 10             	mov    0x10(%ebx),%eax
    5c4b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
    5c51:	83 c4 0c             	add    $0xc,%esp
}
    5c54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c57:	c9                   	leave  
    5c58:	c3                   	ret    

00005c59 <shell_fprintf_fmt>:
{
    5c59:	55                   	push   %ebp
    5c5a:	89 e5                	mov    %esp,%ebp
    5c5c:	53                   	push   %ebx
	(void)_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
    5c5d:	ff 75 10             	pushl  0x10(%ebp)
    5c60:	ff 75 0c             	pushl  0xc(%ebp)
{
    5c63:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void)_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
    5c66:	53                   	push   %ebx
    5c67:	68 8e 5c 00 00       	push   $0x5c8e
    5c6c:	e8 04 4f 00 00       	call   ab75 <_prf>
	if (sh_fprintf->ctrl_blk->autoflush) {
    5c71:	8b 43 10             	mov    0x10(%ebx),%eax
	(void)_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
    5c74:	83 c4 10             	add    $0x10,%esp
	if (sh_fprintf->ctrl_blk->autoflush) {
    5c77:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
    5c7b:	74 0c                	je     5c89 <shell_fprintf_fmt+0x30>
		shell_fprintf_buffer_flush(sh_fprintf);
    5c7d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    5c80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c83:	c9                   	leave  
		shell_fprintf_buffer_flush(sh_fprintf);
    5c84:	e9 ab ff ff ff       	jmp    5c34 <shell_fprintf_buffer_flush>
}
    5c89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5c8c:	c9                   	leave  
    5c8d:	c3                   	ret    

00005c8e <out_func>:
{
    5c8e:	55                   	push   %ebp
    5c8f:	89 e5                	mov    %esp,%ebp
    5c91:	56                   	push   %esi
    5c92:	53                   	push   %ebx
    5c93:	8b 75 0c             	mov    0xc(%ebp),%esi
    5c96:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
    5c99:	8b 46 0c             	mov    0xc(%esi),%eax
    5c9c:	83 78 10 02          	cmpl   $0x2,0x10(%eax)
    5ca0:	75 0f                	jne    5cb1 <out_func+0x23>
    5ca2:	83 fb 0a             	cmp    $0xa,%ebx
    5ca5:	75 0a                	jne    5cb1 <out_func+0x23>
		(void)out_func('\r', ctx);
    5ca7:	56                   	push   %esi
    5ca8:	6a 0d                	push   $0xd
    5caa:	e8 df ff ff ff       	call   5c8e <out_func>
    5caf:	5a                   	pop    %edx
    5cb0:	59                   	pop    %ecx
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (u8_t)c;
    5cb1:	8b 46 10             	mov    0x10(%esi),%eax
    5cb4:	8b 16                	mov    (%esi),%edx
    5cb6:	8b 00                	mov    (%eax),%eax
    5cb8:	88 1c 02             	mov    %bl,(%edx,%eax,1)
	sh_fprintf->ctrl_blk->buffer_cnt++;
    5cbb:	8b 56 10             	mov    0x10(%esi),%edx
    5cbe:	8b 02                	mov    (%edx),%eax
    5cc0:	40                   	inc    %eax
    5cc1:	89 02                	mov    %eax,(%edx)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
    5cc3:	3b 46 04             	cmp    0x4(%esi),%eax
    5cc6:	75 07                	jne    5ccf <out_func+0x41>
		shell_fprintf_buffer_flush(sh_fprintf);
    5cc8:	56                   	push   %esi
    5cc9:	e8 66 ff ff ff       	call   5c34 <shell_fprintf_buffer_flush>
    5cce:	58                   	pop    %eax
}
    5ccf:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5cd2:	31 c0                	xor    %eax,%eax
    5cd4:	5b                   	pop    %ebx
    5cd5:	5e                   	pop    %esi
    5cd6:	5d                   	pop    %ebp
    5cd7:	c3                   	ret    

00005cd8 <shell_strlen>:
	return str == NULL ? 0U : (u16_t)strlen(str);
    5cd8:	85 c0                	test   %eax,%eax
    5cda:	74 0c                	je     5ce8 <shell_strlen+0x10>
{
    5cdc:	55                   	push   %ebp
    5cdd:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (u16_t)strlen(str);
    5cdf:	50                   	push   %eax
    5ce0:	e8 7e 4b 00 00       	call   a863 <strlen>
    5ce5:	5a                   	pop    %edx
}
    5ce6:	c9                   	leave  
    5ce7:	c3                   	ret    
	return str == NULL ? 0U : (u16_t)strlen(str);
    5ce8:	31 c0                	xor    %eax,%eax
}
    5cea:	c3                   	ret    

00005ceb <column_span_with_buffer_offsets_get>:
}

s32_t column_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
					  u16_t offset1,
					  u16_t offset2)
{
    5ceb:	55                   	push   %ebp
    5cec:	89 e5                	mov    %esp,%ebp
    5cee:	56                   	push   %esi
    5cef:	53                   	push   %ebx
    5cf0:	8b 45 08             	mov    0x8(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    5cf3:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
    5cf7:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return col_num_with_buffer_offset_get(cons, offset2)
    5cfb:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    5cff:	01 f0                	add    %esi,%eax
    5d01:	99                   	cltd   
    5d02:	f7 fb                	idiv   %ebx
    5d04:	89 d1                	mov    %edx,%ecx
			- col_num_with_buffer_offset_get(cons, offset1);
    5d06:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    5d0a:	8d 04 32             	lea    (%edx,%esi,1),%eax
    5d0d:	99                   	cltd   
    5d0e:	f7 fb                	idiv   %ebx
}
    5d10:	5b                   	pop    %ebx
			- col_num_with_buffer_offset_get(cons, offset1);
    5d11:	89 c8                	mov    %ecx,%eax
}
    5d13:	5e                   	pop    %esi
			- col_num_with_buffer_offset_get(cons, offset1);
    5d14:	29 d0                	sub    %edx,%eax
}
    5d16:	5d                   	pop    %ebp
    5d17:	c3                   	ret    

00005d18 <row_span_with_buffer_offsets_get>:

s32_t row_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
				       u16_t offset1,
				       u16_t offset2)
{
    5d18:	55                   	push   %ebp
    5d19:	89 e5                	mov    %esp,%ebp
    5d1b:	56                   	push   %esi
    5d1c:	53                   	push   %ebx
    5d1d:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    5d20:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
    5d24:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return line_num_with_buffer_offset_get(cons, offset2)
    5d28:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    5d2c:	01 f0                	add    %esi,%eax
    5d2e:	99                   	cltd   
    5d2f:	f7 fb                	idiv   %ebx
		- line_num_with_buffer_offset_get(cons, offset1);
    5d31:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    5d35:	89 c1                	mov    %eax,%ecx
    5d37:	8d 04 32             	lea    (%edx,%esi,1),%eax
    5d3a:	99                   	cltd   
    5d3b:	f7 fb                	idiv   %ebx
}
    5d3d:	5b                   	pop    %ebx
		- line_num_with_buffer_offset_get(cons, offset1);
    5d3e:	29 c1                	sub    %eax,%ecx
}
    5d40:	5e                   	pop    %esi
		- line_num_with_buffer_offset_get(cons, offset1);
    5d41:	89 c8                	mov    %ecx,%eax
}
    5d43:	5d                   	pop    %ebp
    5d44:	c3                   	ret    

00005d45 <shell_multiline_data_calc>:

void shell_multiline_data_calc(struct shell_multiline_cons *cons,
			       u16_t buff_pos, u16_t buff_len)
{
    5d45:	55                   	push   %ebp
    5d46:	89 e5                	mov    %esp,%ebp
    5d48:	56                   	push   %esi
    5d49:	53                   	push   %ebx
    5d4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    5d4d:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
    5d51:	0f b6 71 0c          	movzbl 0xc(%ecx),%esi
    5d55:	0f b7 59 0a          	movzwl 0xa(%ecx),%ebx
    5d59:	01 f0                	add    %esi,%eax
    5d5b:	99                   	cltd   
    5d5c:	f7 fb                	idiv   %ebx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    5d5e:	40                   	inc    %eax
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    5d5f:	42                   	inc    %edx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    5d60:	66 89 41 04          	mov    %ax,0x4(%ecx)
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    5d64:	66 89 11             	mov    %dx,(%ecx)

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    5d67:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
    5d6b:	01 f0                	add    %esi,%eax
    5d6d:	99                   	cltd   
    5d6e:	f7 fb                	idiv   %ebx
    5d70:	40                   	inc    %eax
    5d71:	66 89 41 06          	mov    %ax,0x6(%ecx)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    5d75:	8d 42 01             	lea    0x1(%edx),%eax
    5d78:	66 89 41 02          	mov    %ax,0x2(%ecx)
}
    5d7c:	5b                   	pop    %ebx
    5d7d:	5e                   	pop    %esi
    5d7e:	5d                   	pop    %ebp
    5d7f:	c3                   	ret    

00005d80 <shell_make_argv>:
	return quote;
}


char shell_make_argv(size_t *argc, char **argv, char *cmd, u8_t max_argc)
{
    5d80:	55                   	push   %ebp
    5d81:	89 e5                	mov    %esp,%ebp
    5d83:	57                   	push   %edi
    5d84:	56                   	push   %esi
    5d85:	53                   	push   %ebx
    5d86:	50                   	push   %eax
	char quote = 0;
    5d87:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
{
    5d8b:	8a 45 14             	mov    0x14(%ebp),%al
    5d8e:	8b 5d 10             	mov    0x10(%ebp),%ebx
    5d91:	88 45 f1             	mov    %al,-0xf(%ebp)
	char c;

	*argc = 0;
    5d94:	8b 45 08             	mov    0x8(%ebp),%eax
    5d97:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	do {
		c = *cmd;
    5d9d:	8a 03                	mov    (%ebx),%al
		if (c == '\0') {
    5d9f:	84 c0                	test   %al,%al
    5da1:	0f 84 c1 01 00 00    	je     5f68 <shell_make_argv+0x1e8>
    5da7:	0f be d0             	movsbl %al,%edx
    5daa:	83 ea 09             	sub    $0x9,%edx
			break;
		}

		if (isspace((int) c)) {
    5dad:	83 fa 04             	cmp    $0x4,%edx
    5db0:	76 04                	jbe    5db6 <shell_make_argv+0x36>
    5db2:	3c 20                	cmp    $0x20,%al
    5db4:	75 09                	jne    5dbf <shell_make_argv+0x3f>
			*cmd++ = '\0';
    5db6:	c6 03 00             	movb   $0x0,(%ebx)
    5db9:	43                   	inc    %ebx
			continue;
    5dba:	e9 9a 01 00 00       	jmp    5f59 <shell_make_argv+0x1d9>
		}

		argv[(*argc)++] = cmd;
    5dbf:	8b 45 08             	mov    0x8(%ebp),%eax
    5dc2:	8b 7d 08             	mov    0x8(%ebp),%edi
	char quote = 0;
    5dc5:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
		argv[(*argc)++] = cmd;
    5dc9:	8b 00                	mov    (%eax),%eax
    5dcb:	8d 50 01             	lea    0x1(%eax),%edx
    5dce:	89 17                	mov    %edx,(%edi)
    5dd0:	8b 7d 0c             	mov    0xc(%ebp),%edi
    5dd3:	89 1c 87             	mov    %ebx,(%edi,%eax,4)
		c = *cmd;
    5dd6:	8a 13                	mov    (%ebx),%dl
		if (c == '\0') {
    5dd8:	84 d2                	test   %dl,%dl
    5dda:	0f 84 79 01 00 00    	je     5f59 <shell_make_argv+0x1d9>
		if (!quote) {
    5de0:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    5de4:	75 3e                	jne    5e24 <shell_make_argv+0xa4>
			switch (c) {
    5de6:	80 fa 27             	cmp    $0x27,%dl
    5de9:	74 18                	je     5e03 <shell_make_argv+0x83>
    5deb:	80 fa 5c             	cmp    $0x5c,%dl
    5dee:	74 07                	je     5df7 <shell_make_argv+0x77>
    5df0:	80 fa 22             	cmp    $0x22,%dl
    5df3:	75 2f                	jne    5e24 <shell_make_argv+0xa4>
    5df5:	eb 0c                	jmp    5e03 <shell_make_argv+0x83>
						shell_strlen(cmd));
    5df7:	89 d8                	mov    %ebx,%eax
				memmove(cmd, cmd + 1,
    5df9:	8d 7b 01             	lea    0x1(%ebx),%edi
						shell_strlen(cmd));
    5dfc:	e8 d7 fe ff ff       	call   5cd8 <shell_strlen>
    5e01:	eb 71                	jmp    5e74 <shell_make_argv+0xf4>
						shell_strlen(cmd));
    5e03:	89 d8                	mov    %ebx,%eax
    5e05:	88 55 f3             	mov    %dl,-0xd(%ebp)
    5e08:	e8 cb fe ff ff       	call   5cd8 <shell_strlen>
				memmove(cmd, cmd + 1,
    5e0d:	89 df                	mov    %ebx,%edi
    5e0f:	0f b7 c0             	movzwl %ax,%eax
    5e12:	50                   	push   %eax
    5e13:	8d 43 01             	lea    0x1(%ebx),%eax
    5e16:	50                   	push   %eax
    5e17:	53                   	push   %ebx
    5e18:	e8 db 4a 00 00       	call   a8f8 <memmove>
    5e1d:	83 c4 0c             	add    $0xc,%esp
				memmove(cmd, cmd + 1,
    5e20:	89 fb                	mov    %edi,%ebx
    5e22:	eb b2                	jmp    5dd6 <shell_make_argv+0x56>
		if (quote == c) {
    5e24:	0f be 4d f3          	movsbl -0xd(%ebp),%ecx
    5e28:	0f b6 c2             	movzbl %dl,%eax
    5e2b:	39 c1                	cmp    %eax,%ecx
    5e2d:	75 20                	jne    5e4f <shell_make_argv+0xcf>
			memmove(cmd, cmd + 1, shell_strlen(cmd));
    5e2f:	89 d8                	mov    %ebx,%eax
    5e31:	89 df                	mov    %ebx,%edi
    5e33:	e8 a0 fe ff ff       	call   5cd8 <shell_strlen>
    5e38:	0f b7 c0             	movzwl %ax,%eax
    5e3b:	50                   	push   %eax
    5e3c:	8d 43 01             	lea    0x1(%ebx),%eax
    5e3f:	50                   	push   %eax
    5e40:	53                   	push   %ebx
    5e41:	e8 b2 4a 00 00       	call   a8f8 <memmove>
    5e46:	83 c4 0c             	add    $0xc,%esp
			quote = 0;
    5e49:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    5e4d:	eb d1                	jmp    5e20 <shell_make_argv+0xa0>
		if (quote && c == '\\') {
    5e4f:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    5e53:	0f 84 e5 00 00 00    	je     5f3e <shell_make_argv+0x1be>
    5e59:	80 fa 5c             	cmp    $0x5c,%dl
    5e5c:	0f 85 dc 00 00 00    	jne    5f3e <shell_make_argv+0x1be>
			char t = *(cmd + 1);
    5e62:	8a 43 01             	mov    0x1(%ebx),%al
			if (t == quote) {
    5e65:	8d 7b 01             	lea    0x1(%ebx),%edi
    5e68:	38 45 f3             	cmp    %al,-0xd(%ebp)
    5e6b:	75 17                	jne    5e84 <shell_make_argv+0x104>
						shell_strlen(cmd));
    5e6d:	89 d8                	mov    %ebx,%eax
    5e6f:	e8 64 fe ff ff       	call   5cd8 <shell_strlen>
				memmove(cmd, cmd + 1,
    5e74:	0f b7 c0             	movzwl %ax,%eax
    5e77:	50                   	push   %eax
    5e78:	57                   	push   %edi
    5e79:	53                   	push   %ebx
    5e7a:	e8 79 4a 00 00       	call   a8f8 <memmove>
    5e7f:	83 c4 0c             	add    $0xc,%esp
				continue;
    5e82:	eb 9c                	jmp    5e20 <shell_make_argv+0xa0>
			if (t == '0') {
    5e84:	3c 30                	cmp    $0x30,%al
    5e86:	75 2c                	jne    5eb4 <shell_make_argv+0x134>
    5e88:	b9 02 00 00 00       	mov    $0x2,%ecx
				u8_t v = 0U;
    5e8d:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
    5e8f:	8a 04 0b             	mov    (%ebx,%ecx,1),%al
    5e92:	88 4d f2             	mov    %cl,-0xe(%ebp)
					if (t >= '0' && t <= '7') {
    5e95:	8d 50 d0             	lea    -0x30(%eax),%edx
    5e98:	80 fa 07             	cmp    $0x7,%dl
    5e9b:	77 11                	ja     5eae <shell_make_argv+0x12e>
						v = (v << 3) | (t - '0');
    5e9d:	c1 e6 03             	shl    $0x3,%esi
    5ea0:	41                   	inc    %ecx
    5ea1:	09 d6                	or     %edx,%esi
				for (i = 2U; i < (2 + 3); i++) {
    5ea3:	83 f9 05             	cmp    $0x5,%ecx
    5ea6:	75 e7                	jne    5e8f <shell_make_argv+0x10f>
    5ea8:	c6 45 f2 05          	movb   $0x5,-0xe(%ebp)
    5eac:	eb 65                	jmp    5f13 <shell_make_argv+0x193>
				if (i > 2) {
    5eae:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
    5eb2:	75 5f                	jne    5f13 <shell_make_argv+0x193>
			if (t == 'x') {
    5eb4:	3c 78                	cmp    $0x78,%al
    5eb6:	0f 85 95 00 00 00    	jne    5f51 <shell_make_argv+0x1d1>
    5ebc:	ba 02 00 00 00       	mov    $0x2,%edx
				u8_t v = 0U;
    5ec1:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
    5ec3:	8a 04 13             	mov    (%ebx,%edx,1),%al
    5ec6:	88 55 f2             	mov    %dl,-0xe(%ebp)
					if (t >= '0' && t <= '9') {
    5ec9:	8d 48 d0             	lea    -0x30(%eax),%ecx
    5ecc:	80 f9 09             	cmp    $0x9,%cl
    5ecf:	77 07                	ja     5ed8 <shell_make_argv+0x158>
						v = (v << 4) | (t - '0');
    5ed1:	c1 e6 04             	shl    $0x4,%esi
    5ed4:	09 ce                	or     %ecx,%esi
    5ed6:	eb 20                	jmp    5ef8 <shell_make_argv+0x178>
					} else if ((t >= 'a') &&
    5ed8:	8d 48 9f             	lea    -0x61(%eax),%ecx
    5edb:	80 f9 05             	cmp    $0x5,%cl
    5ede:	77 08                	ja     5ee8 <shell_make_argv+0x168>
						v = (v << 4) | (t - 'a' + 10);
    5ee0:	c1 e6 04             	shl    $0x4,%esi
    5ee3:	83 e8 57             	sub    $0x57,%eax
    5ee6:	eb 0e                	jmp    5ef6 <shell_make_argv+0x176>
					} else if ((t >= 'A') && (t <= 'F')) {
    5ee8:	8d 48 bf             	lea    -0x41(%eax),%ecx
    5eeb:	80 f9 05             	cmp    $0x5,%cl
    5eee:	77 18                	ja     5f08 <shell_make_argv+0x188>
						v = (v << 4) | (t - 'A' + 10);
    5ef0:	c1 e6 04             	shl    $0x4,%esi
    5ef3:	83 e8 37             	sub    $0x37,%eax
    5ef6:	09 c6                	or     %eax,%esi
				for (i = 2U; i < (2 + 2); i++) {
    5ef8:	83 fa 03             	cmp    $0x3,%edx
    5efb:	74 07                	je     5f04 <shell_make_argv+0x184>
    5efd:	ba 03 00 00 00       	mov    $0x3,%edx
    5f02:	eb bf                	jmp    5ec3 <shell_make_argv+0x143>
    5f04:	b2 04                	mov    $0x4,%dl
    5f06:	eb 08                	jmp    5f10 <shell_make_argv+0x190>
				if (i > 2) {
    5f08:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
    5f0c:	74 43                	je     5f51 <shell_make_argv+0x1d1>
    5f0e:	b2 03                	mov    $0x3,%dl
    5f10:	88 55 f2             	mov    %dl,-0xe(%ebp)
						shell_strlen(cmd) - (i - 2));
    5f13:	89 d8                	mov    %ebx,%eax
    5f15:	e8 be fd ff ff       	call   5cd8 <shell_strlen>
    5f1a:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
    5f1e:	0f b7 c0             	movzwl %ax,%eax
    5f21:	83 c0 02             	add    $0x2,%eax
    5f24:	29 d0                	sub    %edx,%eax
					memmove(cmd, cmd + (i - 1),
    5f26:	50                   	push   %eax
    5f27:	8d 44 13 ff          	lea    -0x1(%ebx,%edx,1),%eax
    5f2b:	50                   	push   %eax
    5f2c:	53                   	push   %ebx
    5f2d:	e8 c6 49 00 00       	call   a8f8 <memmove>
					*cmd++ = v;
    5f32:	89 f0                	mov    %esi,%eax
					memmove(cmd, cmd + (i - 1),
    5f34:	83 c4 0c             	add    $0xc,%esp
					*cmd++ = v;
    5f37:	88 03                	mov    %al,(%ebx)
					continue;
    5f39:	e9 e2 fe ff ff       	jmp    5e20 <shell_make_argv+0xa0>
		if (!quote && isspace((int) c)) {
    5f3e:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    5f42:	75 0d                	jne    5f51 <shell_make_argv+0x1d1>
    5f44:	8d 50 f7             	lea    -0x9(%eax),%edx
    5f47:	83 fa 04             	cmp    $0x4,%edx
    5f4a:	76 0d                	jbe    5f59 <shell_make_argv+0x1d9>
    5f4c:	83 f8 20             	cmp    $0x20,%eax
    5f4f:	74 08                	je     5f59 <shell_make_argv+0x1d9>
		cmd += 1;
    5f51:	8d 7b 01             	lea    0x1(%ebx),%edi
    5f54:	e9 c7 fe ff ff       	jmp    5e20 <shell_make_argv+0xa0>
		quote = make_argv(&cmd, c);
	} while (*argc < max_argc);
    5f59:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    5f5d:	8b 7d 08             	mov    0x8(%ebp),%edi
    5f60:	39 07                	cmp    %eax,(%edi)
    5f62:	0f 82 35 fe ff ff    	jb     5d9d <shell_make_argv+0x1d>

	argv[*argc] = 0;
    5f68:	8b 45 08             	mov    0x8(%ebp),%eax
    5f6b:	8b 7d 0c             	mov    0xc(%ebp),%edi
    5f6e:	8b 00                	mov    (%eax),%eax
    5f70:	c7 04 87 00 00 00 00 	movl   $0x0,(%edi,%eax,4)

	return quote;
}
    5f77:	8a 45 f3             	mov    -0xd(%ebp),%al
    5f7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5f7d:	5b                   	pop    %ebx
    5f7e:	5e                   	pop    %esi
    5f7f:	5f                   	pop    %edi
    5f80:	5d                   	pop    %ebp
    5f81:	c3                   	ret    

00005f82 <shell_pattern_remove>:

void shell_pattern_remove(char *buff, u16_t *buff_len, const char *pattern)
{
    5f82:	55                   	push   %ebp
    5f83:	89 e5                	mov    %esp,%ebp
    5f85:	57                   	push   %edi
    5f86:	56                   	push   %esi
    5f87:	53                   	push   %ebx
    5f88:	50                   	push   %eax
    5f89:	8b 5d 10             	mov    0x10(%ebp),%ebx
    5f8c:	8b 55 08             	mov    0x8(%ebp),%edx
	char *pattern_addr = strstr(buff, pattern);
    5f8f:	53                   	push   %ebx
    5f90:	89 55 f0             	mov    %edx,-0x10(%ebp)
    5f93:	52                   	push   %edx
{
    5f94:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char *pattern_addr = strstr(buff, pattern);
    5f97:	e8 d5 47 00 00       	call   a771 <strstr>
    5f9c:	5a                   	pop    %edx
    5f9d:	89 c6                	mov    %eax,%esi
	u16_t shift;
	u16_t pattern_len = shell_strlen(pattern);
    5f9f:	89 d8                	mov    %ebx,%eax
	char *pattern_addr = strstr(buff, pattern);
    5fa1:	59                   	pop    %ecx
	u16_t pattern_len = shell_strlen(pattern);
    5fa2:	e8 31 fd ff ff       	call   5cd8 <shell_strlen>

	if (!pattern_addr) {
    5fa7:	85 f6                	test   %esi,%esi
    5fa9:	74 3b                	je     5fe6 <shell_pattern_remove+0x64>
		return;
	}

	if (pattern_addr > buff) {
    5fab:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5fae:	89 c3                	mov    %eax,%ebx
    5fb0:	39 f2                	cmp    %esi,%edx
    5fb2:	73 08                	jae    5fbc <shell_pattern_remove+0x3a>
		if (*(pattern_addr - 1) == ' ') {
    5fb4:	80 7e ff 20          	cmpb   $0x20,-0x1(%esi)
    5fb8:	75 02                	jne    5fbc <shell_pattern_remove+0x3a>
			pattern_len++; /* space needs to be removed as well */
    5fba:	43                   	inc    %ebx
			pattern_addr--; /* set pointer to space */
    5fbb:	4e                   	dec    %esi
		}
	}

	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    5fbc:	89 f0                	mov    %esi,%eax
    5fbe:	e8 15 fd ff ff       	call   5cd8 <shell_strlen>
	*buff_len -= pattern_len;
    5fc3:	66 29 1f             	sub    %bx,(%edi)
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    5fc6:	29 d8                	sub    %ebx,%eax
    5fc8:	40                   	inc    %eax

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    5fc9:	89 75 08             	mov    %esi,0x8(%ebp)
    5fcc:	0f b7 db             	movzwl %bx,%ebx
    5fcf:	01 f3                	add    %esi,%ebx
    5fd1:	0f b7 c0             	movzwl %ax,%eax
    5fd4:	89 5d 0c             	mov    %ebx,0xc(%ebp)
    5fd7:	89 45 10             	mov    %eax,0x10(%ebp)
}
    5fda:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5fdd:	5b                   	pop    %ebx
    5fde:	5e                   	pop    %esi
    5fdf:	5f                   	pop    %edi
    5fe0:	5d                   	pop    %ebp
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    5fe1:	e9 12 49 00 00       	jmp    a8f8 <memmove>
}
    5fe6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5fe9:	5b                   	pop    %ebx
    5fea:	5e                   	pop    %esi
    5feb:	5f                   	pop    %edi
    5fec:	5d                   	pop    %ebp
    5fed:	c3                   	ret    

00005fee <shell_cmd_get>:
}

void shell_cmd_get(const struct shell_cmd_entry *command, size_t lvl,
		   size_t idx, const struct shell_static_entry **entry,
		   struct shell_static_entry *d_entry)
{
    5fee:	55                   	push   %ebp
    5fef:	89 e5                	mov    %esp,%ebp
    5ff1:	56                   	push   %esi
    5ff2:	53                   	push   %ebx
    5ff3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    5ff6:	8b 45 10             	mov    0x10(%ebp),%eax
    5ff9:	8b 5d 14             	mov    0x14(%ebp),%ebx
    5ffc:	8b 75 18             	mov    0x18(%ebp),%esi
	__ASSERT_NO_MSG(entry != NULL);
	__ASSERT_NO_MSG(d_entry != NULL);

	if (lvl == SHELL_CMD_ROOT_LVL) {
    5fff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    6003:	75 1d                	jne    6022 <shell_cmd_get+0x34>
	return ((u8_t *)__shell_root_cmds_end -
    6005:	ba cc 52 02 00       	mov    $0x252cc,%edx
    600a:	81 ea 94 52 02 00    	sub    $0x25294,%edx
			(u8_t *)__shell_root_cmds_start)/
    6010:	c1 ea 03             	shr    $0x3,%edx
		if (idx < shell_root_cmd_count()) {
    6013:	39 d0                	cmp    %edx,%eax
    6015:	73 0f                	jae    6026 <shell_cmd_get+0x38>
			const struct shell_cmd_entry *cmd;

			cmd = shell_root_cmd_get(idx);
			*entry = cmd->u.entry;
    6017:	8b 04 c5 98 52 02 00 	mov    0x25298(,%eax,8),%eax
    601e:	89 03                	mov    %eax,(%ebx)
    6020:	eb 34                	jmp    6056 <shell_cmd_get+0x68>
			*entry = NULL;
		}
		return;
	}

	if (command == NULL) {
    6022:	85 c9                	test   %ecx,%ecx
    6024:	75 08                	jne    602e <shell_cmd_get+0x40>
			*entry = NULL;
    6026:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    602c:	eb 28                	jmp    6056 <shell_cmd_get+0x68>
		*entry = NULL;
		return;
	}

	if (command->is_dynamic) {
    602e:	8b 51 04             	mov    0x4(%ecx),%edx
    6031:	80 39 00             	cmpb   $0x0,(%ecx)
    6034:	74 11                	je     6047 <shell_cmd_get+0x59>
		command->u.dynamic_get(idx, d_entry);
    6036:	56                   	push   %esi
    6037:	50                   	push   %eax
    6038:	ff d2                	call   *%edx
    603a:	58                   	pop    %eax
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
    603b:	83 3e 00             	cmpl   $0x0,(%esi)
		command->u.dynamic_get(idx, d_entry);
    603e:	5a                   	pop    %edx
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
    603f:	75 02                	jne    6043 <shell_cmd_get+0x55>
    6041:	31 f6                	xor    %esi,%esi
    6043:	89 33                	mov    %esi,(%ebx)
    6045:	eb 0f                	jmp    6056 <shell_cmd_get+0x68>
	} else {
		*entry = (command->u.entry[idx].syntax != NULL) ?
    6047:	6b c0 14             	imul   $0x14,%eax,%eax
    604a:	01 d0                	add    %edx,%eax
    604c:	8b 10                	mov    (%eax),%edx
				&command->u.entry[idx] : NULL;
    604e:	85 d2                	test   %edx,%edx
    6050:	74 02                	je     6054 <shell_cmd_get+0x66>
    6052:	89 c2                	mov    %eax,%edx
		*entry = (command->u.entry[idx].syntax != NULL) ?
    6054:	89 13                	mov    %edx,(%ebx)
	}
}
    6056:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6059:	5b                   	pop    %ebx
    605a:	5e                   	pop    %esi
    605b:	5d                   	pop    %ebp
    605c:	c3                   	ret    

0000605d <shell_spaces_trim>:

	return 0;
}

void shell_spaces_trim(char *str)
{
    605d:	55                   	push   %ebp
    605e:	89 e5                	mov    %esp,%ebp
    6060:	57                   	push   %edi
    6061:	56                   	push   %esi
    6062:	53                   	push   %ebx
    6063:	83 ec 0c             	sub    $0xc,%esp
    6066:	8b 75 08             	mov    0x8(%ebp),%esi
	u16_t len = shell_strlen(str);
    6069:	89 f0                	mov    %esi,%eax
    606b:	e8 68 fc ff ff       	call   5cd8 <shell_strlen>
	u16_t shift = 0U;

	if (!str) {
    6070:	85 f6                	test   %esi,%esi
	u16_t len = shell_strlen(str);
    6072:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	if (!str) {
    6076:	74 7a                	je     60f2 <shell_spaces_trim+0x95>
		return;
	}

	for (u16_t i = 0; i < len - 1; i++) {
    6078:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	u16_t shift = 0U;
    607e:	31 db                	xor    %ebx,%ebx
	for (u16_t i = 0; i < len - 1; i++) {
    6080:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    6084:	0f b7 7d f2          	movzwl -0xe(%ebp),%edi
    6088:	89 45 ec             	mov    %eax,-0x14(%ebp)
    608b:	48                   	dec    %eax
    608c:	39 c7                	cmp    %eax,%edi
    608e:	7d 62                	jge    60f2 <shell_spaces_trim+0x95>
		if (isspace((int)str[i])) {
    6090:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
    6094:	66 ff 45 f2          	incw   -0xe(%ebp)
    6098:	89 d0                	mov    %edx,%eax
    609a:	83 ea 09             	sub    $0x9,%edx
    609d:	83 fa 04             	cmp    $0x4,%edx
    60a0:	76 04                	jbe    60a6 <shell_spaces_trim+0x49>
    60a2:	3c 20                	cmp    $0x20,%al
    60a4:	75 da                	jne    6080 <shell_spaces_trim+0x23>
			for (u16_t j = i + 1; j < len; j++) {
    60a6:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    60aa:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
    60ae:	76 d0                	jbe    6080 <shell_spaces_trim+0x23>
				if (isspace((int)str[j])) {
    60b0:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
    60b3:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    60b6:	0f be 0c 06          	movsbl (%esi,%eax,1),%ecx
    60ba:	89 ca                	mov    %ecx,%edx
    60bc:	83 e9 09             	sub    $0x9,%ecx
    60bf:	40                   	inc    %eax
    60c0:	83 f9 04             	cmp    $0x4,%ecx
    60c3:	76 05                	jbe    60ca <shell_spaces_trim+0x6d>
    60c5:	80 fa 20             	cmp    $0x20,%dl
    60c8:	75 03                	jne    60cd <shell_spaces_trim+0x70>
					shift++;
    60ca:	43                   	inc    %ebx
					continue;
    60cb:	eb dd                	jmp    60aa <shell_spaces_trim+0x4d>
				}

				if (shift > 0) {
    60cd:	66 85 db             	test   %bx,%bx
    60d0:	74 ae                	je     6080 <shell_spaces_trim+0x23>
					/* +1 for EOS */
					memmove(&str[i + 1],
						&str[j],
						len - shift + 1);
    60d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60d5:	0f b7 d3             	movzwl %bx,%edx
    60d8:	40                   	inc    %eax
    60d9:	29 d0                	sub    %edx,%eax
					memmove(&str[i + 1],
    60db:	50                   	push   %eax
    60dc:	8d 44 3e 01          	lea    0x1(%esi,%edi,1),%eax
    60e0:	ff 75 e8             	pushl  -0x18(%ebp)
    60e3:	50                   	push   %eax
    60e4:	e8 0f 48 00 00       	call   a8f8 <memmove>
					len -= shift;
    60e9:	66 29 5d f0          	sub    %bx,-0x10(%ebp)
					memmove(&str[i + 1],
    60ed:	83 c4 0c             	add    $0xc,%esp
					len -= shift;
    60f0:	eb 8c                	jmp    607e <shell_spaces_trim+0x21>

				break;
			}
		}
	}
}
    60f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    60f5:	5b                   	pop    %ebx
    60f6:	5e                   	pop    %esi
    60f7:	5f                   	pop    %edi
    60f8:	5d                   	pop    %ebp
    60f9:	c3                   	ret    

000060fa <shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void shell_cmd_trim(const struct shell *shell)
{
    60fa:	55                   	push   %ebp
    60fb:	89 e5                	mov    %esp,%ebp
    60fd:	57                   	push   %edi
    60fe:	56                   	push   %esi
    60ff:	53                   	push   %ebx
    6100:	83 ec 08             	sub    $0x8,%esp
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    6103:	8b 45 08             	mov    0x8(%ebp),%eax
    6106:	8b 58 08             	mov    0x8(%eax),%ebx
	if (buff[0] == '\0') {
    6109:	8d 43 42             	lea    0x42(%ebx),%eax
    610c:	80 7b 42 00          	cmpb   $0x0,0x42(%ebx)
    6110:	74 76                	je     6188 <shell_cmd_trim+0x8e>
	while (isspace((int) buff[*buff_len - 1])) {
    6112:	0f b7 7b 3c          	movzwl 0x3c(%ebx),%edi
    6116:	89 fa                	mov    %edi,%edx
    6118:	0f be 74 38 ff       	movsbl -0x1(%eax,%edi,1),%esi
    611d:	89 f1                	mov    %esi,%ecx
    611f:	83 ee 09             	sub    $0x9,%esi
    6122:	83 fe 04             	cmp    $0x4,%esi
    6125:	77 10                	ja     6137 <shell_cmd_trim+0x3d>
		*buff_len -= 1;
    6127:	4a                   	dec    %edx
		if (*buff_len == 0) {
    6128:	66 85 d2             	test   %dx,%dx
		*buff_len -= 1;
    612b:	66 89 53 3c          	mov    %dx,0x3c(%ebx)
		if (*buff_len == 0) {
    612f:	75 e1                	jne    6112 <shell_cmd_trim+0x18>
			buff[0] = '\0';
    6131:	c6 43 42 00          	movb   $0x0,0x42(%ebx)
			return;
    6135:	eb 51                	jmp    6188 <shell_cmd_trim+0x8e>
	while (isspace((int) buff[*buff_len - 1])) {
    6137:	80 f9 20             	cmp    $0x20,%cl
    613a:	74 eb                	je     6127 <shell_cmd_trim+0x2d>
	buff[*buff_len] = '\0';
    613c:	c6 44 3b 42 00       	movb   $0x0,0x42(%ebx,%edi,1)
	u16_t i = 0U;
    6141:	31 f6                	xor    %esi,%esi
	while (isspace((int) buff[i++]))
    6143:	0f b7 ce             	movzwl %si,%ecx
    6146:	8d 7e 01             	lea    0x1(%esi),%edi
    6149:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    614c:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    6150:	89 cf                	mov    %ecx,%edi
    6152:	01 c7                	add    %eax,%edi
    6154:	0f be 0f             	movsbl (%edi),%ecx
    6157:	89 ca                	mov    %ecx,%edx
    6159:	83 e9 09             	sub    $0x9,%ecx
    615c:	83 f9 04             	cmp    $0x4,%ecx
    615f:	77 06                	ja     6167 <shell_cmd_trim+0x6d>
    6161:	66 8b 75 f2          	mov    -0xe(%ebp),%si
    6165:	eb dc                	jmp    6143 <shell_cmd_trim+0x49>
    6167:	80 fa 20             	cmp    $0x20,%dl
    616a:	74 f5                	je     6161 <shell_cmd_trim+0x67>
	if (--i > 0) {
    616c:	66 85 f6             	test   %si,%si
    616f:	74 17                	je     6188 <shell_cmd_trim+0x8e>
		memmove(buff, buff + i, (*buff_len + 1) - i); /* +1 for '\0' */
    6171:	0f b7 53 3c          	movzwl 0x3c(%ebx),%edx
    6175:	42                   	inc    %edx
    6176:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6179:	52                   	push   %edx
    617a:	57                   	push   %edi
    617b:	50                   	push   %eax
    617c:	e8 77 47 00 00       	call   a8f8 <memmove>
		*buff_len = *buff_len - i;
    6181:	66 29 73 3c          	sub    %si,0x3c(%ebx)
		memmove(buff, buff + i, (*buff_len + 1) - i); /* +1 for '\0' */
    6185:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    6188:	8b 45 08             	mov    0x8(%ebp),%eax
    618b:	8b 40 08             	mov    0x8(%eax),%eax
    618e:	8b 50 3c             	mov    0x3c(%eax),%edx
    6191:	66 89 50 3e          	mov    %dx,0x3e(%eax)
}
    6195:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6198:	5b                   	pop    %ebx
    6199:	5e                   	pop    %esi
    619a:	5f                   	pop    %edi
    619b:	5d                   	pop    %ebp
    619c:	c3                   	ret    

0000619d <shell_raw_fprintf>:
{
    619d:	55                   	push   %ebp
    619e:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
    61a0:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
    61a3:	50                   	push   %eax
    61a4:	ff 75 0c             	pushl  0xc(%ebp)
    61a7:	ff 75 08             	pushl  0x8(%ebp)
    61aa:	e8 aa fa ff ff       	call   5c59 <shell_fprintf_fmt>
    61af:	83 c4 0c             	add    $0xc,%esp
}
    61b2:	c9                   	leave  
    61b3:	c3                   	ret    

000061b4 <clear_eos.isra.5>:
static inline void clear_eos(const struct shell *shell)
    61b4:	55                   	push   %ebp
    61b5:	89 e5                	mov    %esp,%ebp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
    61b7:	68 80 5e 02 00       	push   $0x25e80
    61bc:	68 6a a5 02 00       	push   $0x2a56a
    61c1:	50                   	push   %eax
    61c2:	e8 d6 ff ff ff       	call   619d <shell_raw_fprintf>
    61c7:	83 c4 0c             	add    $0xc,%esp
}
    61ca:	c9                   	leave  
    61cb:	c3                   	ret    

000061cc <full_line_cmd.isra.7>:
}

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
    61cc:	55                   	push   %ebp
    61cd:	89 e5                	mov    %esp,%ebp
    61cf:	56                   	push   %esi
    61d0:	53                   	push   %ebx
    61d1:	89 c6                	mov    %eax,%esi
{
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
    61d3:	8b 00                	mov    (%eax),%eax
    61d5:	0f b7 58 3c          	movzwl 0x3c(%eax),%ebx
    61d9:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (u16_t)strlen(str);
    61db:	85 c0                	test   %eax,%eax
    61dd:	74 09                	je     61e8 <full_line_cmd.isra.7+0x1c>
    61df:	50                   	push   %eax
    61e0:	e8 7e 46 00 00       	call   a863 <strlen>
    61e5:	5a                   	pop    %edx
    61e6:	eb 02                	jmp    61ea <full_line_cmd.isra.7+0x1e>
    61e8:	31 c0                	xor    %eax,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0);
    61ea:	8b 16                	mov    (%esi),%edx
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
    61ec:	0f b7 c0             	movzwl %ax,%eax
    61ef:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0);
    61f1:	0f b7 4a 2a          	movzwl 0x2a(%edx),%ecx
    61f5:	99                   	cltd   
    61f6:	f7 f9                	idiv   %ecx
    61f8:	85 d2                	test   %edx,%edx
    61fa:	0f 94 c0             	sete   %al
}
    61fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6200:	5b                   	pop    %ebx
    6201:	5e                   	pop    %esi
    6202:	5d                   	pop    %ebp
    6203:	c3                   	ret    

00006204 <shell_op_cursor_vert_move>:
{
    6204:	55                   	push   %ebp
    6205:	89 e5                	mov    %esp,%ebp
    6207:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
    620a:	85 c0                	test   %eax,%eax
    620c:	74 23                	je     6231 <shell_op_cursor_vert_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
    620e:	0f 9e c2             	setle  %dl
    6211:	0f b6 d2             	movzbl %dl,%edx
    6214:	83 c2 41             	add    $0x41,%edx
    6217:	52                   	push   %edx
    6218:	99                   	cltd   
    6219:	31 d0                	xor    %edx,%eax
    621b:	29 d0                	sub    %edx,%eax
    621d:	50                   	push   %eax
    621e:	8b 45 08             	mov    0x8(%ebp),%eax
    6221:	68 d2 6d 02 00       	push   $0x26dd2
    6226:	ff 70 14             	pushl  0x14(%eax)
    6229:	e8 6f ff ff ff       	call   619d <shell_raw_fprintf>
    622e:	83 c4 10             	add    $0x10,%esp
}
    6231:	c9                   	leave  
    6232:	c3                   	ret    

00006233 <shell_op_cursor_horiz_move>:
{
    6233:	55                   	push   %ebp
    6234:	89 e5                	mov    %esp,%ebp
    6236:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
    6239:	85 c0                	test   %eax,%eax
    623b:	74 23                	je     6260 <shell_op_cursor_horiz_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
    623d:	0f 9e c2             	setle  %dl
    6240:	0f b6 d2             	movzbl %dl,%edx
    6243:	83 c2 43             	add    $0x43,%edx
    6246:	52                   	push   %edx
    6247:	99                   	cltd   
    6248:	31 d0                	xor    %edx,%eax
    624a:	29 d0                	sub    %edx,%eax
    624c:	50                   	push   %eax
    624d:	8b 45 08             	mov    0x8(%ebp),%eax
    6250:	68 d2 6d 02 00       	push   $0x26dd2
    6255:	ff 70 14             	pushl  0x14(%eax)
    6258:	e8 40 ff ff ff       	call   619d <shell_raw_fprintf>
    625d:	83 c4 10             	add    $0x10,%esp
}
    6260:	c9                   	leave  
    6261:	c3                   	ret    

00006262 <shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool shell_cursor_in_empty_line(const struct shell *shell)
{
    6262:	55                   	push   %ebp
    6263:	89 e5                	mov    %esp,%ebp
    6265:	56                   	push   %esi
    6266:	53                   	push   %ebx
    6267:	8b 75 08             	mov    0x8(%ebp),%esi
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
    626a:	8b 46 08             	mov    0x8(%esi),%eax
    626d:	8b 10                	mov    (%eax),%edx
    626f:	0f b7 58 3e          	movzwl 0x3e(%eax),%ebx
    6273:	31 c0                	xor    %eax,%eax
    6275:	85 d2                	test   %edx,%edx
    6277:	74 07                	je     6280 <shell_cursor_in_empty_line+0x1e>
    6279:	52                   	push   %edx
    627a:	e8 e4 45 00 00       	call   a863 <strlen>
    627f:	5a                   	pop    %edx
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0);
    6280:	8b 56 08             	mov    0x8(%esi),%edx
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
    6283:	0f b7 c0             	movzwl %ax,%eax
    6286:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0);
    6288:	0f b7 4a 2a          	movzwl 0x2a(%edx),%ecx
    628c:	99                   	cltd   
    628d:	f7 f9                	idiv   %ecx
    628f:	85 d2                	test   %edx,%edx
    6291:	0f 94 c0             	sete   %al
}
    6294:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6297:	5b                   	pop    %ebx
    6298:	5e                   	pop    %esi
    6299:	5d                   	pop    %ebp
    629a:	c3                   	ret    

0000629b <shell_op_cond_next_line>:

void shell_op_cond_next_line(const struct shell *shell)
{
    629b:	55                   	push   %ebp
    629c:	89 e5                	mov    %esp,%ebp
    629e:	53                   	push   %ebx
    629f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    62a2:	53                   	push   %ebx
    62a3:	e8 ba ff ff ff       	call   6262 <shell_cursor_in_empty_line>
    62a8:	59                   	pop    %ecx
    62a9:	84 c0                	test   %al,%al
    62ab:	74 11                	je     62be <shell_op_cond_next_line+0x23>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    62ad:	68 b9 6d 02 00       	push   $0x26db9
    62b2:	ff 73 14             	pushl  0x14(%ebx)
    62b5:	e8 e3 fe ff ff       	call   619d <shell_raw_fprintf>
    62ba:	58                   	pop    %eax
    62bb:	5a                   	pop    %edx
    62bc:	eb 0c                	jmp    62ca <shell_op_cond_next_line+0x2f>
    62be:	8d 43 08             	lea    0x8(%ebx),%eax
    62c1:	e8 06 ff ff ff       	call   61cc <full_line_cmd.isra.7>
    62c6:	84 c0                	test   %al,%al
    62c8:	75 e3                	jne    62ad <shell_op_cond_next_line+0x12>
		cursor_next_line_move(shell);
	}
}
    62ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    62cd:	c9                   	leave  
    62ce:	c3                   	ret    

000062cf <shell_op_cursor_position_synchronize>:

void shell_op_cursor_position_synchronize(const struct shell *shell)
{
    62cf:	55                   	push   %ebp
    62d0:	89 e5                	mov    %esp,%ebp
    62d2:	57                   	push   %edi
    62d3:	56                   	push   %esi
    62d4:	53                   	push   %ebx
    62d5:	51                   	push   %ecx
    62d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    62d9:	8b 73 08             	mov    0x8(%ebx),%esi
	bool last_line;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    62dc:	0f b7 46 3c          	movzwl 0x3c(%esi),%eax
    62e0:	50                   	push   %eax
    62e1:	0f b7 46 3e          	movzwl 0x3e(%esi),%eax
    62e5:	50                   	push   %eax
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    62e6:	8d 46 20             	lea    0x20(%esi),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    62e9:	50                   	push   %eax
    62ea:	e8 56 fa ff ff       	call   5d45 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
    62ef:	66 8b 46 26          	mov    0x26(%esi),%ax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    62f3:	83 c4 0c             	add    $0xc,%esp
	last_line = (cons->cur_y == cons->cur_y_end);
    62f6:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
    62fa:	8d 43 08             	lea    0x8(%ebx),%eax
	last_line = (cons->cur_y == cons->cur_y_end);
    62fd:	66 8b 7e 24          	mov    0x24(%esi),%di
	if (full_line_cmd(shell)) {
    6301:	e8 c6 fe ff ff       	call   61cc <full_line_cmd.isra.7>
    6306:	84 c0                	test   %al,%al
    6308:	74 0f                	je     6319 <shell_op_cursor_position_synchronize+0x4a>
    630a:	68 b9 6d 02 00       	push   $0x26db9
    630f:	ff 73 14             	pushl  0x14(%ebx)
    6312:	e8 86 fe ff ff       	call   619d <shell_raw_fprintf>
    6317:	58                   	pop    %eax
    6318:	5a                   	pop    %edx
		cursor_next_line_move(shell);
	}

	if (last_line) {
    6319:	66 3b 7d f2          	cmp    -0xe(%ebp),%di
    631d:	74 13                	je     6332 <shell_op_cursor_position_synchronize+0x63>
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
    631f:	0f b7 4e 24          	movzwl 0x24(%esi),%ecx
    6323:	0f b7 46 26          	movzwl 0x26(%esi),%eax
    6327:	29 c8                	sub    %ecx,%eax
    6329:	50                   	push   %eax
    632a:	53                   	push   %ebx
    632b:	e8 d4 fe ff ff       	call   6204 <shell_op_cursor_vert_move>
    6330:	59                   	pop    %ecx
    6331:	5f                   	pop    %edi
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
    6332:	0f b7 56 22          	movzwl 0x22(%esi),%edx
		shell_op_cursor_horiz_move(shell, cons->cur_x -
    6336:	0f b7 46 20          	movzwl 0x20(%esi),%eax
    633a:	29 d0                	sub    %edx,%eax
    633c:	50                   	push   %eax
    633d:	53                   	push   %ebx
    633e:	e8 f0 fe ff ff       	call   6233 <shell_op_cursor_horiz_move>
    6343:	58                   	pop    %eax
    6344:	5a                   	pop    %edx
	}
}
    6345:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6348:	5b                   	pop    %ebx
    6349:	5e                   	pop    %esi
    634a:	5f                   	pop    %edi
    634b:	5d                   	pop    %ebp
    634c:	c3                   	ret    

0000634d <shell_op_cursor_move>:

void shell_op_cursor_move(const struct shell *shell, s16_t val)
{
    634d:	55                   	push   %ebp
    634e:	89 e5                	mov    %esp,%ebp
    6350:	57                   	push   %edi
    6351:	56                   	push   %esi
    6352:	53                   	push   %ebx
    6353:	50                   	push   %eax
    6354:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    6357:	8b 43 08             	mov    0x8(%ebx),%eax
    635a:	83 c0 20             	add    $0x20,%eax
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
	s32_t row_span;
	s32_t col_span;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    635d:	0f b7 48 1c          	movzwl 0x1c(%eax),%ecx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
    6361:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    6365:	51                   	push   %ecx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
    6366:	89 d6                	mov    %edx,%esi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    6368:	52                   	push   %edx
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
    6369:	03 75 0c             	add    0xc(%ebp),%esi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    636c:	50                   	push   %eax
    636d:	e8 d3 f9 ff ff       	call   5d45 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
    6372:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    6375:	83 c4 0c             	add    $0xc,%esp
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
    6378:	0f b7 d6             	movzwl %si,%edx
    637b:	0f b7 48 3e          	movzwl 0x3e(%eax),%ecx
    637f:	52                   	push   %edx
    6380:	83 c0 20             	add    $0x20,%eax
    6383:	51                   	push   %ecx
    6384:	89 55 f0             	mov    %edx,-0x10(%ebp)
    6387:	50                   	push   %eax
    6388:	e8 8b f9 ff ff       	call   5d18 <row_span_with_buffer_offsets_get>
    638d:	83 c4 0c             	add    $0xc,%esp
    6390:	89 c7                	mov    %eax,%edi
						    new_pos);
	col_span = column_span_with_buffer_offsets_get(
						    &shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
    6392:	8b 43 08             	mov    0x8(%ebx),%eax
	col_span = column_span_with_buffer_offsets_get(
    6395:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6398:	52                   	push   %edx
    6399:	83 c0 20             	add    $0x20,%eax
    639c:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
    63a0:	52                   	push   %edx
    63a1:	50                   	push   %eax
    63a2:	e8 44 f9 ff ff       	call   5ceb <column_span_with_buffer_offsets_get>
    63a7:	83 c4 0c             	add    $0xc,%esp
    63aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
						    new_pos);

	shell_op_cursor_vert_move(shell, -row_span);
    63ad:	f7 df                	neg    %edi
    63af:	57                   	push   %edi
    63b0:	53                   	push   %ebx
    63b1:	e8 4e fe ff ff       	call   6204 <shell_op_cursor_vert_move>
    63b6:	5a                   	pop    %edx
	shell_op_cursor_horiz_move(shell, col_span);
    63b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
	shell_op_cursor_vert_move(shell, -row_span);
    63ba:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, col_span);
    63bb:	50                   	push   %eax
    63bc:	53                   	push   %ebx
    63bd:	e8 71 fe ff ff       	call   6233 <shell_op_cursor_horiz_move>
    63c2:	5f                   	pop    %edi
    63c3:	58                   	pop    %eax
	shell->ctx->cmd_buff_pos = new_pos;
    63c4:	8b 43 08             	mov    0x8(%ebx),%eax
    63c7:	66 89 70 3e          	mov    %si,0x3e(%eax)
}
    63cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
    63ce:	5b                   	pop    %ebx
    63cf:	5e                   	pop    %esi
    63d0:	5f                   	pop    %edi
    63d1:	5d                   	pop    %ebp
    63d2:	c3                   	ret    

000063d3 <shell_op_cursor_word_move>:

	return ret;
}

void shell_op_cursor_word_move(const struct shell *shell, s16_t val)
{
    63d3:	55                   	push   %ebp
    63d4:	89 e5                	mov    %esp,%ebp
    63d6:	57                   	push   %edi
    63d7:	56                   	push   %esi
    63d8:	be 01 00 00 00       	mov    $0x1,%esi
    63dd:	53                   	push   %ebx
    63de:	83 ec 10             	sub    $0x10,%esp
    63e1:	8b 45 0c             	mov    0xc(%ebp),%eax
	s16_t shift;
	s16_t sign;

	if (val < 0) {
    63e4:	66 85 c0             	test   %ax,%ax
{
    63e7:	89 c3                	mov    %eax,%ebx
	if (val < 0) {
    63e9:	79 05                	jns    63f0 <shell_op_cursor_word_move+0x1d>
		val = -val;
    63eb:	f7 db                	neg    %ebx
		sign = -1;
    63ed:	83 ce ff             	or     $0xffffffff,%esi
		if (((idx == 0) && (sign < 0)) ||
    63f0:	89 f0                	mov    %esi,%eax
    63f2:	66 c1 e8 0f          	shr    $0xf,%ax
    63f6:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	} else {
		sign = 1;
	}

	while (val--) {
    63fa:	4b                   	dec    %ebx
    63fb:	66 83 fb ff          	cmp    $0xffff,%bx
    63ff:	0f 84 8c 00 00 00    	je     6491 <shell_op_cursor_word_move+0xbe>
		shift = shift_calc(shell->ctx->cmd_buff,
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
    6405:	8b 45 08             	mov    0x8(%ebp),%eax
		if (((idx == 0) && (sign < 0)) ||
    6408:	8a 55 e6             	mov    -0x1a(%ebp),%dl
    640b:	88 55 e9             	mov    %dl,-0x17(%ebp)
				   shell->ctx->cmd_buff_len, sign);
    640e:	8b 40 08             	mov    0x8(%eax),%eax
		shift = shift_calc(shell->ctx->cmd_buff,
    6411:	83 c0 42             	add    $0x42,%eax
				   shell->ctx->cmd_buff_len, sign);
    6414:	8b 78 fa             	mov    -0x6(%eax),%edi
    6417:	66 89 7d f0          	mov    %di,-0x10(%ebp)
				   shell->ctx->cmd_buff_pos,
    641b:	66 8b 78 fc          	mov    -0x4(%eax),%di
    641f:	66 89 7d f2          	mov    %di,-0xe(%ebp)
		shift = shift_calc(shell->ctx->cmd_buff,
    6423:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6426:	89 f8                	mov    %edi,%eax
	bool found = false;
    6428:	31 ff                	xor    %edi,%edi
		idx = pos + ret * sign;
    642a:	89 c1                	mov    %eax,%ecx
    642c:	66 2b 4d f2          	sub    -0xe(%ebp),%cx
		if (((idx == 0) && (sign < 0)) ||
    6430:	66 85 c0             	test   %ax,%ax
    6433:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
    6437:	75 06                	jne    643f <shell_op_cursor_word_move+0x6c>
    6439:	80 7d e9 00          	cmpb   $0x0,-0x17(%ebp)
    643d:	75 3e                	jne    647d <shell_op_cursor_word_move+0xaa>
    643f:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
    6443:	75 05                	jne    644a <shell_op_cursor_word_move+0x77>
    6445:	66 85 f6             	test   %si,%si
    6448:	7f 33                	jg     647d <shell_op_cursor_word_move+0xaa>
		if (isalnum((int)str[idx]) != 0) {
    644a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    644d:	0f b7 d0             	movzwl %ax,%edx
    6450:	0f be 14 11          	movsbl (%ecx,%edx,1),%edx
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    6454:	88 d1                	mov    %dl,%cl
    6456:	83 c9 20             	or     $0x20,%ecx
    6459:	0f be c9             	movsbl %cl,%ecx
    645c:	83 e9 61             	sub    $0x61,%ecx
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
    645f:	83 f9 19             	cmp    $0x19,%ecx
    6462:	76 10                	jbe    6474 <shell_op_cursor_word_move+0xa1>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    6464:	83 ea 30             	sub    $0x30,%edx
	return (int)(isalpha(chr) || isdigit(chr));
    6467:	83 fa 09             	cmp    $0x9,%edx
    646a:	76 08                	jbe    6474 <shell_op_cursor_word_move+0xa1>
			if (found) {
    646c:	89 fa                	mov    %edi,%edx
    646e:	84 d2                	test   %dl,%dl
    6470:	74 07                	je     6479 <shell_op_cursor_word_move+0xa6>
    6472:	eb 09                	jmp    647d <shell_op_cursor_word_move+0xaa>
			found = true;
    6474:	bf 01 00 00 00       	mov    $0x1,%edi
		ret++;
    6479:	01 f0                	add    %esi,%eax
    647b:	eb ad                	jmp    642a <shell_op_cursor_word_move+0x57>
		shell_op_cursor_move(shell, sign * shift);
    647d:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
    6481:	50                   	push   %eax
    6482:	ff 75 08             	pushl  0x8(%ebp)
    6485:	e8 c3 fe ff ff       	call   634d <shell_op_cursor_move>
    648a:	58                   	pop    %eax
    648b:	5a                   	pop    %edx
    648c:	e9 69 ff ff ff       	jmp    63fa <shell_op_cursor_word_move+0x27>
	}
}
    6491:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6494:	5b                   	pop    %ebx
    6495:	5e                   	pop    %esi
    6496:	5f                   	pop    %edi
    6497:	5d                   	pop    %ebp
    6498:	c3                   	ret    

00006499 <shell_op_cursor_home_move>:
	clear_eos(shell);
	cursor_restore(shell);
}

void shell_op_cursor_home_move(const struct shell *shell)
{
    6499:	55                   	push   %ebp
    649a:	89 e5                	mov    %esp,%ebp
    649c:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
    649f:	8b 42 08             	mov    0x8(%edx),%eax
    64a2:	66 8b 40 3e          	mov    0x3e(%eax),%ax
    64a6:	f7 d8                	neg    %eax
    64a8:	98                   	cwtl   
    64a9:	50                   	push   %eax
    64aa:	52                   	push   %edx
    64ab:	e8 9d fe ff ff       	call   634d <shell_op_cursor_move>
    64b0:	58                   	pop    %eax
    64b1:	5a                   	pop    %edx
}
    64b2:	c9                   	leave  
    64b3:	c3                   	ret    

000064b4 <shell_op_cursor_end_move>:

void shell_op_cursor_end_move(const struct shell *shell)
{
    64b4:	55                   	push   %ebp
    64b5:	89 e5                	mov    %esp,%ebp
    64b7:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
    64ba:	8b 4a 08             	mov    0x8(%edx),%ecx
    64bd:	8b 41 3c             	mov    0x3c(%ecx),%eax
    64c0:	66 2b 41 3e          	sub    0x3e(%ecx),%ax
    64c4:	98                   	cwtl   
    64c5:	50                   	push   %eax
    64c6:	52                   	push   %edx
    64c7:	e8 81 fe ff ff       	call   634d <shell_op_cursor_move>
    64cc:	58                   	pop    %eax
    64cd:	5a                   	pop    %edx
						shell->ctx->cmd_buff_pos);
}
    64ce:	c9                   	leave  
    64cf:	c3                   	ret    

000064d0 <shell_op_left_arrow>:


void shell_op_left_arrow(const struct shell *shell)
{
    64d0:	55                   	push   %ebp
    64d1:	89 e5                	mov    %esp,%ebp
    64d3:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos > 0) {
    64d6:	8b 50 08             	mov    0x8(%eax),%edx
    64d9:	66 83 7a 3e 00       	cmpw   $0x0,0x3e(%edx)
    64de:	74 0a                	je     64ea <shell_op_left_arrow+0x1a>
		shell_op_cursor_move(shell, -1);
    64e0:	6a ff                	push   $0xffffffff
    64e2:	50                   	push   %eax
    64e3:	e8 65 fe ff ff       	call   634d <shell_op_cursor_move>
    64e8:	58                   	pop    %eax
    64e9:	5a                   	pop    %edx
	}
}
    64ea:	c9                   	leave  
    64eb:	c3                   	ret    

000064ec <shell_op_right_arrow>:

void shell_op_right_arrow(const struct shell *shell)
{
    64ec:	55                   	push   %ebp
    64ed:	89 e5                	mov    %esp,%ebp
    64ef:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
    64f2:	8b 50 08             	mov    0x8(%eax),%edx
    64f5:	8b 4a 3c             	mov    0x3c(%edx),%ecx
    64f8:	66 39 4a 3e          	cmp    %cx,0x3e(%edx)
    64fc:	73 0a                	jae    6508 <shell_op_right_arrow+0x1c>
		shell_op_cursor_move(shell, 1);
    64fe:	6a 01                	push   $0x1
    6500:	50                   	push   %eax
    6501:	e8 47 fe ff ff       	call   634d <shell_op_cursor_move>
    6506:	58                   	pop    %eax
    6507:	5a                   	pop    %edx
	}
}
    6508:	c9                   	leave  
    6509:	c3                   	ret    

0000650a <shell_op_delete_from_cursor>:
	--shell->ctx->cmd_buff_len;
	reprint_from_cursor(shell, --diff, true);
}

void shell_op_delete_from_cursor(const struct shell *shell)
{
    650a:	55                   	push   %ebp
    650b:	89 e5                	mov    %esp,%ebp
    650d:	8b 4d 08             	mov    0x8(%ebp),%ecx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
    6510:	8b 51 08             	mov    0x8(%ecx),%edx
    6513:	0f b7 42 3e          	movzwl 0x3e(%edx),%eax
    6517:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
    651b:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)

	clear_eos(shell);
    6520:	8b 41 14             	mov    0x14(%ecx),%eax
}
    6523:	5d                   	pop    %ebp
	clear_eos(shell);
    6524:	e9 8b fc ff ff       	jmp    61b4 <clear_eos.isra.5>

00006529 <shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void shell_cmd_line_erase(const struct shell *shell)
{
    6529:	55                   	push   %ebp
    652a:	89 e5                	mov    %esp,%ebp
    652c:	53                   	push   %ebx
    652d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
				  shell->ctx->cmd_buff_pos,
				  shell->ctx->cmd_buff_len);
    6530:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    6533:	83 c0 20             	add    $0x20,%eax
    6536:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
    653a:	52                   	push   %edx
    653b:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
    653f:	52                   	push   %edx
    6540:	50                   	push   %eax
    6541:	e8 ff f7 ff ff       	call   5d45 <shell_multiline_data_calc>
	shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    6546:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    6549:	83 c4 0c             	add    $0xc,%esp
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    654c:	0f b7 50 20          	movzwl 0x20(%eax),%edx
	shell_op_cursor_horiz_move(shell,
    6550:	b8 01 00 00 00       	mov    $0x1,%eax
    6555:	29 d0                	sub    %edx,%eax
    6557:	50                   	push   %eax
    6558:	53                   	push   %ebx
    6559:	e8 d5 fc ff ff       	call   6233 <shell_op_cursor_horiz_move>
    655e:	58                   	pop    %eax
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
    655f:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell,
    6562:	5a                   	pop    %edx
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
    6563:	0f b7 40 24          	movzwl 0x24(%eax),%eax
    6567:	48                   	dec    %eax
    6568:	50                   	push   %eax
    6569:	53                   	push   %ebx
    656a:	e8 95 fc ff ff       	call   6204 <shell_op_cursor_vert_move>
    656f:	59                   	pop    %ecx
    6570:	58                   	pop    %eax

	clear_eos(shell);
    6571:	8b 43 14             	mov    0x14(%ebx),%eax
}
    6574:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6577:	c9                   	leave  
	clear_eos(shell);
    6578:	e9 37 fc ff ff       	jmp    61b4 <clear_eos.isra.5>

0000657d <shell_print_cmd>:
{
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void shell_print_cmd(const struct shell *shell)
{
    657d:	55                   	push   %ebp
    657e:	89 e5                	mov    %esp,%ebp
    6580:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
    6583:	8b 42 08             	mov    0x8(%edx),%eax
    6586:	83 c0 42             	add    $0x42,%eax
    6589:	50                   	push   %eax
    658a:	68 6a a5 02 00       	push   $0x2a56a
    658f:	ff 72 14             	pushl  0x14(%edx)
    6592:	e8 06 fc ff ff       	call   619d <shell_raw_fprintf>
    6597:	83 c4 0c             	add    $0xc,%esp
}
    659a:	c9                   	leave  
    659b:	c3                   	ret    

0000659c <shell_write>:
	}
}

void shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
    659c:	55                   	push   %ebp
    659d:	89 e5                	mov    %esp,%ebp
    659f:	57                   	push   %edi
    65a0:	56                   	push   %esi
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
    65a1:	31 f6                	xor    %esi,%esi
{
    65a3:	53                   	push   %ebx
    65a4:	50                   	push   %eax
    65a5:	8b 7d 08             	mov    0x8(%ebp),%edi
    65a8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t tmp_cnt;

	while (length) {
    65ab:	85 db                	test   %ebx,%ebx
    65ad:	74 71                	je     6620 <shell_write+0x84>
		int err = shell->iface->api->write(shell->iface,
    65af:	8b 47 04             	mov    0x4(%edi),%eax
    65b2:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    65b5:	8b 10                	mov    (%eax),%edx
    65b7:	51                   	push   %ecx
    65b8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    65bb:	53                   	push   %ebx
    65bc:	01 f1                	add    %esi,%ecx
    65be:	51                   	push   %ecx
    65bf:	50                   	push   %eax
    65c0:	ff 52 0c             	call   *0xc(%edx)
				&((const u8_t *) data)[offset], length,
				&tmp_cnt);
		(void)err;
		__ASSERT_NO_MSG(err == 0);
		__ASSERT_NO_MSG(length >= tmp_cnt);
		offset += tmp_cnt;
    65c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
		int err = shell->iface->api->write(shell->iface,
    65c6:	83 c4 10             	add    $0x10,%esp
		offset += tmp_cnt;
    65c9:	01 c6                	add    %eax,%esi
		length -= tmp_cnt;
    65cb:	29 c3                	sub    %eax,%ebx
		if (tmp_cnt == 0 &&
    65cd:	85 c0                	test   %eax,%eax
    65cf:	75 da                	jne    65ab <shell_write+0xf>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
    65d1:	8b 47 08             	mov    0x8(%edi),%eax
    65d4:	8b 50 04             	mov    0x4(%eax),%edx
		if (tmp_cnt == 0 &&
    65d7:	83 fa 03             	cmp    $0x3,%edx
    65da:	74 cf                	je     65ab <shell_write+0xf>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
    65dc:	83 fa 02             	cmp    $0x2,%edx
    65df:	77 21                	ja     6602 <shell_write+0x66>
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    65e1:	6a ff                	push   $0xffffffff
		k_poll(&shell->ctx->events[SHELL_SIGNAL_TXDONE], 1, K_FOREVER);
    65e3:	05 e0 02 00 00       	add    $0x2e0,%eax
    65e8:	6a 01                	push   $0x1
    65ea:	50                   	push   %eax
    65eb:	e8 f3 e4 01 00       	call   24ae3 <z_impl_k_poll>
    65f0:	8b 47 08             	mov    0x8(%edi),%eax
    65f3:	83 c4 0c             	add    $0xc,%esp
    65f6:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%eax)
    65fd:	00 00 00 
    6600:	eb a9                	jmp    65ab <shell_write+0xf>
	return shell->ctx->internal.flags.tx_rdy == 1 ? true : false;
    6602:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
		while (!flag_tx_rdy_get(shell)) {
    6608:	80 e2 10             	and    $0x10,%dl
    660b:	74 f5                	je     6602 <shell_write+0x66>
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
    660d:	66 8b 90 60 02 00 00 	mov    0x260(%eax),%dx
    6614:	83 e2 ef             	and    $0xffffffef,%edx
    6617:	66 89 90 60 02 00 00 	mov    %dx,0x260(%eax)
    661e:	eb 8b                	jmp    65ab <shell_write+0xf>
			shell_pend_on_txdone(shell);
		}
	}
}
    6620:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6623:	5b                   	pop    %ebx
    6624:	5e                   	pop    %esi
    6625:	5f                   	pop    %edi
    6626:	5d                   	pop    %ebp
    6627:	c3                   	ret    

00006628 <shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void shell_print_stream(const void *user_ctx, const char *data,
			size_t data_len)
{
	shell_write((const struct shell *) user_ctx, data, data_len);
    6628:	e9 6f ff ff ff       	jmp    659c <shell_write>

0000662d <shell_vt100_color_set>:

}

void shell_vt100_color_set(const struct shell *shell,
			   enum shell_vt100_color color)
{
    662d:	55                   	push   %ebp
    662e:	89 e5                	mov    %esp,%ebp
    6630:	83 ec 08             	sub    $0x8,%esp
    6633:	8b 55 08             	mov    0x8(%ebp),%edx
    6636:	8b 45 0c             	mov    0xc(%ebp),%eax

	if (shell->ctx->vt100_ctx.col.col == color) {
    6639:	8b 4a 08             	mov    0x8(%edx),%ecx
    663c:	39 41 30             	cmp    %eax,0x30(%ecx)
    663f:	74 3a                	je     667b <shell_vt100_color_set+0x4e>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
    6641:	89 41 30             	mov    %eax,0x30(%ecx)

	if (color != SHELL_NORMAL) {
    6644:	8b 52 14             	mov    0x14(%edx),%edx
    6647:	85 c0                	test   %eax,%eax
    6649:	74 1d                	je     6668 <shell_vt100_color_set+0x3b>

		u8_t cmd[] = SHELL_VT100_COLOR(color - 1);
    664b:	83 c0 2f             	add    $0x2f,%eax
    664e:	c7 45 f8 1b 5b 31 3b 	movl   $0x3b315b1b,-0x8(%ebp)
    6655:	88 45 fd             	mov    %al,-0x3(%ebp)

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    6658:	8d 45 f8             	lea    -0x8(%ebp),%eax
		u8_t cmd[] = SHELL_VT100_COLOR(color - 1);
    665b:	c6 45 fc 33          	movb   $0x33,-0x4(%ebp)
    665f:	66 c7 45 fe 6d 00    	movw   $0x6d,-0x2(%ebp)
		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    6665:	50                   	push   %eax
    6666:	eb 05                	jmp    666d <shell_vt100_color_set+0x40>
	} else {
		static const u8_t cmd[] = SHELL_VT100_MODESOFF;

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    6668:	68 7c 5e 02 00       	push   $0x25e7c
    666d:	68 6a a5 02 00       	push   $0x2a56a
    6672:	52                   	push   %edx
    6673:	e8 25 fb ff ff       	call   619d <shell_raw_fprintf>
    6678:	83 c4 0c             	add    $0xc,%esp
	}
}
    667b:	c9                   	leave  
    667c:	c3                   	ret    

0000667d <shell_vt100_colors_restore>:

void shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
    667d:	55                   	push   %ebp
    667e:	89 e5                	mov    %esp,%ebp
    6680:	56                   	push   %esi
    6681:	53                   	push   %ebx
    6682:	83 ec 08             	sub    $0x8,%esp
    6685:	8b 75 0c             	mov    0xc(%ebp),%esi
    6688:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_vt100_color_set(shell, color->col);
    668b:	ff 36                	pushl  (%esi)
    668d:	53                   	push   %ebx
    668e:	e8 9a ff ff ff       	call   662d <shell_vt100_color_set>
    6693:	5a                   	pop    %edx
	vt100_bgcolor_set(shell, color->bgcol);
    6694:	8b 46 04             	mov    0x4(%esi),%eax
	shell_vt100_color_set(shell, color->col);
    6697:	59                   	pop    %ecx
	if ((bgcolor == SHELL_NORMAL) ||
    6698:	85 c0                	test   %eax,%eax
    669a:	74 35                	je     66d1 <shell_vt100_colors_restore+0x54>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
    669c:	8b 53 08             	mov    0x8(%ebx),%edx
	if ((bgcolor == SHELL_NORMAL) ||
    669f:	3b 42 34             	cmp    0x34(%edx),%eax
    66a2:	74 2d                	je     66d1 <shell_vt100_colors_restore+0x54>
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
    66a4:	89 42 34             	mov    %eax,0x34(%edx)
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
    66a7:	8d 48 2f             	lea    0x2f(%eax),%ecx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    66aa:	8d 45 f2             	lea    -0xe(%ebp),%eax
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
    66ad:	66 c7 45 f2 1b 5b    	movw   $0x5b1b,-0xe(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    66b3:	50                   	push   %eax
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
    66b4:	c6 45 f4 34          	movb   $0x34,-0xc(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    66b8:	68 6a a5 02 00       	push   $0x2a56a
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
    66bd:	88 4d f5             	mov    %cl,-0xb(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    66c0:	ff 73 14             	pushl  0x14(%ebx)
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
    66c3:	66 c7 45 f6 6d 00    	movw   $0x6d,-0xa(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
    66c9:	e8 cf fa ff ff       	call   619d <shell_raw_fprintf>
    66ce:	83 c4 0c             	add    $0xc,%esp
}
    66d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    66d4:	5b                   	pop    %ebx
    66d5:	5e                   	pop    %esi
    66d6:	5d                   	pop    %ebp
    66d7:	c3                   	ret    

000066d8 <shell_internal_vfprintf>:

void shell_internal_vfprintf(const struct shell *shell,
			     enum shell_vt100_color color, const char *fmt,
			     va_list args)
{
    66d8:	55                   	push   %ebp
    66d9:	89 e5                	mov    %esp,%ebp
    66db:	57                   	push   %edi
    66dc:	56                   	push   %esi
    66dd:	53                   	push   %ebx
    66de:	83 ec 08             	sub    $0x8,%esp
    66e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    66e4:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
    66e7:	8b 43 08             	mov    0x8(%ebx),%eax
    66ea:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
    66f0:	80 e2 02             	and    $0x2,%dl
    66f3:	74 3c                	je     6731 <shell_internal_vfprintf+0x59>
	    shell->ctx->internal.flags.use_colors &&
    66f5:	39 78 30             	cmp    %edi,0x30(%eax)
    66f8:	74 37                	je     6731 <shell_internal_vfprintf+0x59>
			   enum shell_vt100_color color);

static inline void shell_vt100_colors_store(const struct shell *shell,
					    struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
    66fa:	6a 08                	push   $0x8
    66fc:	83 c0 30             	add    $0x30,%eax
    66ff:	50                   	push   %eax
    6700:	8d 75 ec             	lea    -0x14(%ebp),%esi
    6703:	56                   	push   %esi
    6704:	e8 28 42 00 00       	call   a931 <memcpy>
    6709:	83 c4 0c             	add    $0xc,%esp
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		shell_vt100_colors_store(shell, &col);
		shell_vt100_color_set(shell, color);
    670c:	57                   	push   %edi
    670d:	53                   	push   %ebx
    670e:	e8 1a ff ff ff       	call   662d <shell_vt100_color_set>
    6713:	58                   	pop    %eax
    6714:	5a                   	pop    %edx

		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    6715:	ff 75 14             	pushl  0x14(%ebp)
    6718:	ff 75 10             	pushl  0x10(%ebp)
    671b:	ff 73 14             	pushl  0x14(%ebx)
    671e:	e8 36 f5 ff ff       	call   5c59 <shell_fprintf_fmt>
    6723:	83 c4 0c             	add    $0xc,%esp

		shell_vt100_colors_restore(shell, &col);
    6726:	56                   	push   %esi
    6727:	53                   	push   %ebx
    6728:	e8 50 ff ff ff       	call   667d <shell_vt100_colors_restore>
    672d:	59                   	pop    %ecx
    672e:	5b                   	pop    %ebx
	    (color != shell->ctx->vt100_ctx.col.col)) {
    672f:	eb 11                	jmp    6742 <shell_internal_vfprintf+0x6a>
	} else {
		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    6731:	ff 75 14             	pushl  0x14(%ebp)
    6734:	ff 75 10             	pushl  0x10(%ebp)
    6737:	ff 73 14             	pushl  0x14(%ebx)
    673a:	e8 1a f5 ff ff       	call   5c59 <shell_fprintf_fmt>
    673f:	83 c4 0c             	add    $0xc,%esp
	}
}
    6742:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6745:	5b                   	pop    %ebx
    6746:	5e                   	pop    %esi
    6747:	5f                   	pop    %edi
    6748:	5d                   	pop    %ebp
    6749:	c3                   	ret    

0000674a <shell_internal_fprintf>:

void shell_internal_fprintf(const struct shell *shell,
			    enum shell_vt100_color color,
			    const char *fmt, ...)
{
    674a:	55                   	push   %ebp
    674b:	89 e5                	mov    %esp,%ebp
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args = { 0 };

	va_start(args, fmt);
    674d:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
    6750:	50                   	push   %eax
    6751:	ff 75 10             	pushl  0x10(%ebp)
    6754:	ff 75 0c             	pushl  0xc(%ebp)
    6757:	ff 75 08             	pushl  0x8(%ebp)
    675a:	e8 79 ff ff ff       	call   66d8 <shell_internal_vfprintf>
    675f:	83 c4 10             	add    $0x10,%esp
	va_end(args);
}
    6762:	c9                   	leave  
    6763:	c3                   	ret    

00006764 <shell_op_word_remove>:
{
    6764:	55                   	push   %ebp
    6765:	89 e5                	mov    %esp,%ebp
    6767:	57                   	push   %edi
    6768:	56                   	push   %esi
    6769:	8b 75 08             	mov    0x8(%ebp),%esi
    676c:	53                   	push   %ebx
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    676d:	8b 46 08             	mov    0x8(%esi),%eax
    6770:	0f b7 48 3e          	movzwl 0x3e(%eax),%ecx
	if ((shell->ctx->cmd_buff_len == 0) ||
    6774:	0f b7 50 3c          	movzwl 0x3c(%eax),%edx
    6778:	66 85 c9             	test   %cx,%cx
    677b:	0f 84 a9 00 00 00    	je     682a <shell_op_word_remove+0xc6>
    6781:	66 85 d2             	test   %dx,%dx
    6784:	0f 84 a0 00 00 00    	je     682a <shell_op_word_remove+0xc6>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    678a:	8d 4c 08 41          	lea    0x41(%eax,%ecx,1),%ecx
	char *str_start = &shell->ctx->cmd_buff[0];
    678e:	8d 78 42             	lea    0x42(%eax),%edi
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    6791:	89 c8                	mov    %ecx,%eax
    6793:	89 cb                	mov    %ecx,%ebx
    6795:	29 c3                	sub    %eax,%ebx
	while ((str >= str_start) && (*str == ' ')) {
    6797:	39 f8                	cmp    %edi,%eax
    6799:	72 13                	jb     67ae <shell_op_word_remove+0x4a>
    679b:	80 38 20             	cmpb   $0x20,(%eax)
    679e:	75 09                	jne    67a9 <shell_op_word_remove+0x45>
		--str;
    67a0:	48                   	dec    %eax
    67a1:	eb f0                	jmp    6793 <shell_op_word_remove+0x2f>
		--str;
    67a3:	48                   	dec    %eax
		++chars_to_delete;
    67a4:	43                   	inc    %ebx
	while ((str >= str_start) && (*str != ' ')) {
    67a5:	39 c7                	cmp    %eax,%edi
    67a7:	77 05                	ja     67ae <shell_op_word_remove+0x4a>
    67a9:	80 38 20             	cmpb   $0x20,(%eax)
    67ac:	75 f5                	jne    67a3 <shell_op_word_remove+0x3f>
		shell->ctx->cmd_buff_len - chars_to_delete);
    67ae:	0f b7 cb             	movzwl %bx,%ecx
    67b1:	29 ca                	sub    %ecx,%edx
	memmove(str + 1, str + 1 + chars_to_delete,
    67b3:	8d 78 01             	lea    0x1(%eax),%edi
    67b6:	52                   	push   %edx
    67b7:	8d 44 08 01          	lea    0x1(%eax,%ecx,1),%eax
    67bb:	50                   	push   %eax
    67bc:	57                   	push   %edi
    67bd:	e8 36 41 00 00       	call   a8f8 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
    67c2:	8b 56 08             	mov    0x8(%esi),%edx
	memmove(str + 1, str + 1 + chars_to_delete,
    67c5:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_len -= chars_to_delete;
    67c8:	8b 42 3c             	mov    0x3c(%edx),%eax
    67cb:	29 d8                	sub    %ebx,%eax
    67cd:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell_op_cursor_move(shell, -chars_to_delete);
    67d1:	f7 db                	neg    %ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    67d3:	0f b7 c0             	movzwl %ax,%eax
	shell_op_cursor_move(shell, -chars_to_delete);
    67d6:	0f bf db             	movswl %bx,%ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    67d9:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)
	shell_op_cursor_move(shell, -chars_to_delete);
    67de:	53                   	push   %ebx
    67df:	56                   	push   %esi
    67e0:	e8 68 fb ff ff       	call   634d <shell_op_cursor_move>
    67e5:	58                   	pop    %eax
    67e6:	5a                   	pop    %edx
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
    67e7:	68 dc 6d 02 00       	push   $0x26ddc
    67ec:	68 6a a5 02 00       	push   $0x2a56a
    67f1:	ff 76 14             	pushl  0x14(%esi)
    67f4:	e8 a4 f9 ff ff       	call   619d <shell_raw_fprintf>
    67f9:	83 c4 0c             	add    $0xc,%esp
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
    67fc:	57                   	push   %edi
    67fd:	68 6a a5 02 00       	push   $0x2a56a
    6802:	6a 00                	push   $0x0
    6804:	56                   	push   %esi
    6805:	e8 40 ff ff ff       	call   674a <shell_internal_fprintf>
    680a:	83 c4 10             	add    $0x10,%esp
	clear_eos(shell);
    680d:	8b 46 14             	mov    0x14(%esi),%eax
    6810:	e8 9f f9 ff ff       	call   61b4 <clear_eos.isra.5>
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
    6815:	68 d9 6d 02 00       	push   $0x26dd9
    681a:	68 6a a5 02 00       	push   $0x2a56a
    681f:	ff 76 14             	pushl  0x14(%esi)
    6822:	e8 76 f9 ff ff       	call   619d <shell_raw_fprintf>
    6827:	83 c4 0c             	add    $0xc,%esp
}
    682a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    682d:	5b                   	pop    %ebx
    682e:	5e                   	pop    %esi
    682f:	5f                   	pop    %edi
    6830:	5d                   	pop    %ebp
    6831:	c3                   	ret    

00006832 <reprint_from_cursor>:
{
    6832:	55                   	push   %ebp
	if (data_removed) {
    6833:	84 c9                	test   %cl,%cl
{
    6835:	89 e5                	mov    %esp,%ebp
    6837:	57                   	push   %edi
    6838:	56                   	push   %esi
    6839:	89 cf                	mov    %ecx,%edi
    683b:	53                   	push   %ebx
    683c:	89 d6                	mov    %edx,%esi
    683e:	89 c3                	mov    %eax,%ebx
	if (data_removed) {
    6840:	74 08                	je     684a <reprint_from_cursor+0x18>
		clear_eos(shell);
    6842:	8b 40 14             	mov    0x14(%eax),%eax
    6845:	e8 6a f9 ff ff       	call   61b4 <clear_eos.isra.5>
		      &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    684a:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
    684d:	0f b7 50 3e          	movzwl 0x3e(%eax),%edx
    6851:	8d 44 10 42          	lea    0x42(%eax,%edx,1),%eax
    6855:	50                   	push   %eax
    6856:	68 6a a5 02 00       	push   $0x2a56a
    685b:	6a 00                	push   $0x0
    685d:	53                   	push   %ebx
    685e:	e8 e7 fe ff ff       	call   674a <shell_internal_fprintf>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    6863:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
    6866:	83 c4 10             	add    $0x10,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    6869:	8b 50 3c             	mov    0x3c(%eax),%edx
    686c:	66 89 50 3e          	mov    %dx,0x3e(%eax)
	if (full_line_cmd(shell)) {
    6870:	8d 43 08             	lea    0x8(%ebx),%eax
    6873:	e8 54 f9 ff ff       	call   61cc <full_line_cmd.isra.7>
    6878:	84 c0                	test   %al,%al
    687a:	74 1a                	je     6896 <reprint_from_cursor+0x64>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
    687c:	66 85 f6             	test   %si,%si
    687f:	75 06                	jne    6887 <reprint_from_cursor+0x55>
    6881:	89 f8                	mov    %edi,%eax
    6883:	84 c0                	test   %al,%al
    6885:	75 0f                	jne    6896 <reprint_from_cursor+0x64>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    6887:	68 b9 6d 02 00       	push   $0x26db9
    688c:	ff 73 14             	pushl  0x14(%ebx)
    688f:	e8 09 f9 ff ff       	call   619d <shell_raw_fprintf>
    6894:	59                   	pop    %ecx
    6895:	5f                   	pop    %edi
	shell_op_cursor_move(shell, -diff);
    6896:	f7 de                	neg    %esi
    6898:	0f bf f6             	movswl %si,%esi
    689b:	56                   	push   %esi
    689c:	53                   	push   %ebx
    689d:	e8 ab fa ff ff       	call   634d <shell_op_cursor_move>
    68a2:	58                   	pop    %eax
    68a3:	5a                   	pop    %edx
}
    68a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    68a7:	5b                   	pop    %ebx
    68a8:	5e                   	pop    %esi
    68a9:	5f                   	pop    %edi
    68aa:	5d                   	pop    %ebp
    68ab:	c3                   	ret    

000068ac <data_insert>:
{
    68ac:	55                   	push   %ebp
    68ad:	89 e5                	mov    %esp,%ebp
    68af:	57                   	push   %edi
    68b0:	56                   	push   %esi
    68b1:	53                   	push   %ebx
    68b2:	83 ec 0c             	sub    $0xc,%esp
    68b5:	89 55 ec             	mov    %edx,-0x14(%ebp)
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    68b8:	8b 70 08             	mov    0x8(%eax),%esi
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    68bb:	0f b7 d1             	movzwl %cx,%edx
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    68be:	0f b7 5e 3c          	movzwl 0x3c(%esi),%ebx
    68c2:	89 df                	mov    %ebx,%edi
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    68c4:	01 d3                	add    %edx,%ebx
    68c6:	89 55 f0             	mov    %edx,-0x10(%ebp)
    68c9:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
    68cf:	7f 6f                	jg     6940 <data_insert+0x94>
    68d1:	89 c3                	mov    %eax,%ebx
    68d3:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    68d6:	0f b7 46 3e          	movzwl 0x3e(%esi),%eax
    68da:	29 c7                	sub    %eax,%edi
	memmove(curr_pos + len, curr_pos, after);
    68dc:	0f b7 ff             	movzwl %di,%edi
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    68df:	8d 74 06 42          	lea    0x42(%esi,%eax,1),%esi
	memmove(curr_pos + len, curr_pos, after);
    68e3:	57                   	push   %edi
    68e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68e7:	56                   	push   %esi
    68e8:	01 f0                	add    %esi,%eax
    68ea:	50                   	push   %eax
    68eb:	e8 08 40 00 00       	call   a8f8 <memmove>
    68f0:	83 c4 0c             	add    $0xc,%esp
	memcpy(curr_pos, data, len);
    68f3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    68f6:	ff 75 f0             	pushl  -0x10(%ebp)
    68f9:	52                   	push   %edx
    68fa:	56                   	push   %esi
    68fb:	e8 31 40 00 00       	call   a931 <memcpy>
	shell->ctx->cmd_buff_len += len;
    6900:	8b 53 08             	mov    0x8(%ebx),%edx
    6903:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6906:	89 c8                	mov    %ecx,%eax
	memcpy(curr_pos, data, len);
    6908:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_len += len;
    690b:	03 42 3c             	add    0x3c(%edx),%eax
    690e:	66 89 42 3c          	mov    %ax,0x3c(%edx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    6912:	0f b7 c0             	movzwl %ax,%eax
    6915:	c6 44 02 42 00       	movb   $0x0,0x42(%edx,%eax,1)
	if (!flag_echo_get(shell)) {
    691a:	8b 43 08             	mov    0x8(%ebx),%eax
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    691d:	8b 90 60 02 00 00    	mov    0x260(%eax),%edx
    6923:	80 e2 04             	and    $0x4,%dl
    6926:	75 06                	jne    692e <data_insert+0x82>
		shell->ctx->cmd_buff_pos += len;
    6928:	66 01 48 3e          	add    %cx,0x3e(%eax)
		return;
    692c:	eb 12                	jmp    6940 <data_insert+0x94>
}
    692e:	8d 65 f4             	lea    -0xc(%ebp),%esp
	reprint_from_cursor(shell, after, false);
    6931:	89 d8                	mov    %ebx,%eax
    6933:	89 fa                	mov    %edi,%edx
    6935:	31 c9                	xor    %ecx,%ecx
}
    6937:	5b                   	pop    %ebx
    6938:	5e                   	pop    %esi
    6939:	5f                   	pop    %edi
    693a:	5d                   	pop    %ebp
	reprint_from_cursor(shell, after, false);
    693b:	e9 f2 fe ff ff       	jmp    6832 <reprint_from_cursor>
}
    6940:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6943:	5b                   	pop    %ebx
    6944:	5e                   	pop    %esi
    6945:	5f                   	pop    %edi
    6946:	5d                   	pop    %ebp
    6947:	c3                   	ret    

00006948 <shell_op_char_insert>:
{
    6948:	55                   	push   %ebp
    6949:	89 e5                	mov    %esp,%ebp
    694b:	56                   	push   %esi
    694c:	53                   	push   %ebx
    694d:	53                   	push   %ebx
    694e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    6951:	8b 45 0c             	mov    0xc(%ebp),%eax
    6954:	88 45 f4             	mov    %al,-0xc(%ebp)
	if (shell->ctx->internal.flags.insert_mode &&
    6957:	8b 4b 08             	mov    0x8(%ebx),%ecx
    695a:	8b 91 60 02 00 00    	mov    0x260(%ecx),%edx
    6960:	80 e2 01             	and    $0x1,%dl
    6963:	74 53                	je     69b8 <shell_op_char_insert+0x70>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
    6965:	0f b7 51 3e          	movzwl 0x3e(%ecx),%edx
	if (shell->ctx->internal.flags.insert_mode &&
    6969:	66 39 51 3c          	cmp    %dx,0x3c(%ecx)
    696d:	74 49                	je     69b8 <shell_op_char_insert+0x70>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    696f:	8d 72 01             	lea    0x1(%edx),%esi
    6972:	66 89 71 3e          	mov    %si,0x3e(%ecx)
    6976:	88 44 11 42          	mov    %al,0x42(%ecx,%edx,1)
	if (!flag_echo_get(shell)) {
    697a:	8b 53 08             	mov    0x8(%ebx),%edx
    697d:	8b 92 60 02 00 00    	mov    0x260(%edx),%edx
    6983:	80 e2 04             	and    $0x4,%dl
    6986:	74 3f                	je     69c7 <shell_op_char_insert+0x7f>
		char_replace(shell, data);
    6988:	0f be c0             	movsbl %al,%eax
	shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    698b:	50                   	push   %eax
    698c:	68 d6 6d 02 00       	push   $0x26dd6
    6991:	ff 73 14             	pushl  0x14(%ebx)
    6994:	e8 04 f8 ff ff       	call   619d <shell_raw_fprintf>
    6999:	83 c4 0c             	add    $0xc,%esp
	if (shell_cursor_in_empty_line(shell)) {
    699c:	53                   	push   %ebx
    699d:	e8 c0 f8 ff ff       	call   6262 <shell_cursor_in_empty_line>
    69a2:	59                   	pop    %ecx
    69a3:	84 c0                	test   %al,%al
    69a5:	74 20                	je     69c7 <shell_op_char_insert+0x7f>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    69a7:	68 b9 6d 02 00       	push   $0x26db9
    69ac:	ff 73 14             	pushl  0x14(%ebx)
    69af:	e8 e9 f7 ff ff       	call   619d <shell_raw_fprintf>
    69b4:	58                   	pop    %eax
    69b5:	5a                   	pop    %edx
    69b6:	eb 0f                	jmp    69c7 <shell_op_char_insert+0x7f>
		data_insert(shell, &data, 1);
    69b8:	b9 01 00 00 00       	mov    $0x1,%ecx
    69bd:	8d 55 f4             	lea    -0xc(%ebp),%edx
    69c0:	89 d8                	mov    %ebx,%eax
    69c2:	e8 e5 fe ff ff       	call   68ac <data_insert>
}
    69c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    69ca:	5b                   	pop    %ebx
    69cb:	5e                   	pop    %esi
    69cc:	5d                   	pop    %ebp
    69cd:	c3                   	ret    

000069ce <shell_op_completion_insert>:
{
    69ce:	55                   	push   %ebp
    69cf:	89 e5                	mov    %esp,%ebp
	data_insert(shell, compl, compl_len);
    69d1:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
    69d5:	8b 55 0c             	mov    0xc(%ebp),%edx
    69d8:	8b 45 08             	mov    0x8(%ebp),%eax
}
    69db:	5d                   	pop    %ebp
	data_insert(shell, compl, compl_len);
    69dc:	e9 cb fe ff ff       	jmp    68ac <data_insert>

000069e1 <shell_op_char_delete>:
{
    69e1:	55                   	push   %ebp
    69e2:	89 e5                	mov    %esp,%ebp
    69e4:	56                   	push   %esi
    69e5:	53                   	push   %ebx
    69e6:	8b 75 08             	mov    0x8(%ebp),%esi
	u16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    69e9:	8b 56 08             	mov    0x8(%esi),%edx
    69ec:	0f b7 42 3e          	movzwl 0x3e(%edx),%eax
	if (diff == 0) {
    69f0:	8b 5a 3c             	mov    0x3c(%edx),%ebx
    69f3:	66 29 c3             	sub    %ax,%bx
    69f6:	74 34                	je     6a2c <shell_op_char_delete+0x4b>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    69f8:	8d 44 02 42          	lea    0x42(%edx,%eax,1),%eax
	memmove(str, str + 1, diff);
    69fc:	0f b7 d3             	movzwl %bx,%edx
    69ff:	52                   	push   %edx
    6a00:	8d 50 01             	lea    0x1(%eax),%edx
    6a03:	52                   	push   %edx
    6a04:	50                   	push   %eax
    6a05:	e8 ee 3e 00 00       	call   a8f8 <memmove>
	--shell->ctx->cmd_buff_len;
    6a0a:	8b 46 08             	mov    0x8(%esi),%eax
	memmove(str, str + 1, diff);
    6a0d:	83 c4 0c             	add    $0xc,%esp
	reprint_from_cursor(shell, --diff, true);
    6a10:	8d 53 ff             	lea    -0x1(%ebx),%edx
    6a13:	b9 01 00 00 00       	mov    $0x1,%ecx
	--shell->ctx->cmd_buff_len;
    6a18:	66 ff 48 3c          	decw   0x3c(%eax)
}
    6a1c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6a1f:	5b                   	pop    %ebx
	reprint_from_cursor(shell, --diff, true);
    6a20:	89 f0                	mov    %esi,%eax
    6a22:	0f b7 d2             	movzwl %dx,%edx
}
    6a25:	5e                   	pop    %esi
    6a26:	5d                   	pop    %ebp
	reprint_from_cursor(shell, --diff, true);
    6a27:	e9 06 fe ff ff       	jmp    6832 <reprint_from_cursor>
}
    6a2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6a2f:	5b                   	pop    %ebx
    6a30:	5e                   	pop    %esi
    6a31:	5d                   	pop    %ebp
    6a32:	c3                   	ret    

00006a33 <shell_op_char_backspace>:
{
    6a33:	55                   	push   %ebp
    6a34:	89 e5                	mov    %esp,%ebp
    6a36:	53                   	push   %ebx
    6a37:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->ctx->cmd_buff_len == 0) ||
    6a3a:	8b 43 08             	mov    0x8(%ebx),%eax
    6a3d:	66 83 78 3c 00       	cmpw   $0x0,0x3c(%eax)
    6a42:	74 1d                	je     6a61 <shell_op_char_backspace+0x2e>
    6a44:	66 83 78 3e 00       	cmpw   $0x0,0x3e(%eax)
    6a49:	74 16                	je     6a61 <shell_op_char_backspace+0x2e>
	shell_op_cursor_move(shell, -1);
    6a4b:	6a ff                	push   $0xffffffff
    6a4d:	53                   	push   %ebx
    6a4e:	e8 fa f8 ff ff       	call   634d <shell_op_cursor_move>
    6a53:	58                   	pop    %eax
	shell_op_char_delete(shell);
    6a54:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    6a57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell_op_cursor_move(shell, -1);
    6a5a:	5a                   	pop    %edx
}
    6a5b:	c9                   	leave  
	shell_op_char_delete(shell);
    6a5c:	e9 80 ff ff ff       	jmp    69e1 <shell_op_char_delete>
}
    6a61:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6a64:	c9                   	leave  
    6a65:	c3                   	ret    

00006a66 <shell_print_prompt_and_cmd>:
{
    6a66:	55                   	push   %ebp
    6a67:	89 e5                	mov    %esp,%ebp
    6a69:	53                   	push   %ebx
    6a6a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    6a6d:	8b 43 08             	mov    0x8(%ebx),%eax
    6a70:	ff 30                	pushl  (%eax)
    6a72:	68 6a a5 02 00       	push   $0x2a56a
    6a77:	6a 03                	push   $0x3
    6a79:	53                   	push   %ebx
    6a7a:	e8 cb fc ff ff       	call   674a <shell_internal_fprintf>
	if (flag_echo_get(shell)) {
    6a7f:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    6a82:	83 c4 10             	add    $0x10,%esp
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    6a85:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
	if (flag_echo_get(shell)) {
    6a8b:	a8 04                	test   $0x4,%al
    6a8d:	74 13                	je     6aa2 <shell_print_prompt_and_cmd+0x3c>
		shell_print_cmd(shell);
    6a8f:	53                   	push   %ebx
    6a90:	e8 e8 fa ff ff       	call   657d <shell_print_cmd>
		shell_op_cursor_position_synchronize(shell);
    6a95:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    6a98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_print_cmd(shell);
    6a9b:	58                   	pop    %eax
}
    6a9c:	c9                   	leave  
		shell_op_cursor_position_synchronize(shell);
    6a9d:	e9 2d f8 ff ff       	jmp    62cf <shell_op_cursor_position_synchronize>
}
    6aa2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6aa5:	c9                   	leave  
    6aa6:	c3                   	ret    

00006aa7 <z_impl_uart_irq_tx_disable>:
static inline void z_impl_uart_irq_tx_disable(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_tx_disable) {
    6aa7:	8b 50 04             	mov    0x4(%eax),%edx
    6aaa:	8b 52 20             	mov    0x20(%edx),%edx
    6aad:	85 d2                	test   %edx,%edx
    6aaf:	74 09                	je     6aba <z_impl_uart_irq_tx_disable+0x13>
{
    6ab1:	55                   	push   %ebp
    6ab2:	89 e5                	mov    %esp,%ebp
		api->irq_tx_disable(dev);
    6ab4:	50                   	push   %eax
    6ab5:	ff d2                	call   *%edx
    6ab7:	58                   	pop    %eax
	}
}
    6ab8:	c9                   	leave  
    6ab9:	c3                   	ret    
    6aba:	c3                   	ret    

00006abb <uninit>:
}

static int uninit(const struct shell_transport *transport)
{
	return 0;
}
    6abb:	31 c0                	xor    %eax,%eax
    6abd:	c3                   	ret    

00006abe <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
    6abe:	55                   	push   %ebp
    6abf:	89 e5                	mov    %esp,%ebp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    6ac1:	8b 45 08             	mov    0x8(%ebp),%eax
{
    6ac4:	8b 55 0c             	mov    0xc(%ebp),%edx

	if (blocking_tx) {
    6ac7:	84 d2                	test   %dl,%dl
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    6ac9:	8b 40 04             	mov    0x4(%eax),%eax
    6acc:	8b 00                	mov    (%eax),%eax
    6ace:	88 50 10             	mov    %dl,0x10(%eax)
	if (blocking_tx) {
    6ad1:	74 07                	je     6ada <enable+0x1c>

K_SYSCALL_DECLARE2(K_SYSCALL_UART_CONFIG_GET, uart_config_get, int, struct device *, dev, struct uart_config *, cfg)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_ENABLE, uart_irq_tx_enable, struct device *, dev)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_DISABLE, uart_irq_tx_disable, struct device *, dev)
    6ad3:	8b 00                	mov    (%eax),%eax
    6ad5:	e8 cd ff ff ff       	call   6aa7 <z_impl_uart_irq_tx_disable>
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
#endif
	}

	return 0;
}
    6ada:	31 c0                	xor    %eax,%eax
    6adc:	5d                   	pop    %ebp
    6add:	c3                   	ret    

00006ade <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
    6ade:	55                   	push   %ebp
    6adf:	89 e5                	mov    %esp,%ebp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    6ae1:	ff 75 10             	pushl  0x10(%ebp)
    6ae4:	ff 75 0c             	pushl  0xc(%ebp)
    6ae7:	8b 45 08             	mov    0x8(%ebp),%eax
    6aea:	8b 40 04             	mov    0x4(%eax),%eax
    6aed:	ff 70 0c             	pushl  0xc(%eax)
    6af0:	e8 dd c2 ff ff       	call   2dd2 <ring_buf_get>
    6af5:	8b 55 14             	mov    0x14(%ebp),%edx
    6af8:	83 c4 0c             	add    $0xc,%esp
    6afb:	89 02                	mov    %eax,(%edx)

	return 0;
}
    6afd:	31 c0                	xor    %eax,%eax
    6aff:	c9                   	leave  
    6b00:	c3                   	ret    

00006b01 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(struct device *arg)
{
    6b01:	55                   	push   %ebp
    6b02:	89 e5                	mov    %esp,%ebp
    6b04:	68 df 6d 02 00       	push   $0x26ddf
    6b09:	e8 7f c1 01 00       	call   22c8d <z_impl_device_get_binding>
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	u32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	shell_init(&shell_uart, dev, true, log_backend, level);
    6b0e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    6b15:	6a 01                	push   $0x1
    6b17:	6a 01                	push   $0x1
    6b19:	50                   	push   %eax
    6b1a:	68 00 54 02 00       	push   $0x25400
    6b1f:	e8 3c ee ff ff       	call   5960 <shell_init>
    6b24:	83 c4 14             	add    $0x14,%esp

	return 0;
}
    6b27:	31 c0                	xor    %eax,%eax
    6b29:	c9                   	leave  
    6b2a:	c3                   	ret    

00006b2b <init>:
{
    6b2b:	55                   	push   %ebp
    6b2c:	89 e5                	mov    %esp,%ebp
    6b2e:	53                   	push   %ebx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    6b2f:	8b 45 08             	mov    0x8(%ebp),%eax
{
    6b32:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	sh_uart->ctrl_blk->handler = evt_handler;
    6b35:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    6b38:	8b 50 04             	mov    0x4(%eax),%edx
	sh_uart->ctrl_blk->dev = (struct device *)config;
    6b3b:	8b 02                	mov    (%edx),%eax
	sh_uart->ctrl_blk->handler = evt_handler;
    6b3d:	89 48 04             	mov    %ecx,0x4(%eax)
	sh_uart->ctrl_blk->context = context;
    6b40:	8b 4d 14             	mov    0x14(%ebp),%ecx
	sh_uart->ctrl_blk->dev = (struct device *)config;
    6b43:	89 18                	mov    %ebx,(%eax)
	sh_uart->ctrl_blk->context = context;
    6b45:	89 48 08             	mov    %ecx,0x8(%eax)
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
    6b48:	8b 43 04             	mov    0x4(%ebx),%eax
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    6b4b:	85 c0                	test   %eax,%eax
    6b4d:	74 13                	je     6b62 <init+0x37>
    6b4f:	8b 40 48             	mov    0x48(%eax),%eax
    6b52:	85 c0                	test   %eax,%eax
    6b54:	74 0c                	je     6b62 <init+0x37>
		api->irq_callback_set(dev, cb, user_data);
    6b56:	52                   	push   %edx
    6b57:	68 01 6c 00 00       	push   $0x6c01
    6b5c:	53                   	push   %ebx
    6b5d:	ff d0                	call   *%eax
    6b5f:	83 c4 0c             	add    $0xc,%esp
	if (api->irq_rx_enable) {
    6b62:	8b 43 04             	mov    0x4(%ebx),%eax
    6b65:	8b 40 28             	mov    0x28(%eax),%eax
    6b68:	85 c0                	test   %eax,%eax
    6b6a:	74 04                	je     6b70 <init+0x45>
		api->irq_rx_enable(dev);
    6b6c:	53                   	push   %ebx
    6b6d:	ff d0                	call   *%eax
    6b6f:	58                   	pop    %eax
}
    6b70:	31 c0                	xor    %eax,%eax
    6b72:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6b75:	c9                   	leave  
    6b76:	c3                   	ret    

00006b77 <write>:
{
    6b77:	55                   	push   %ebp
    6b78:	89 e5                	mov    %esp,%ebp
    6b7a:	57                   	push   %edi
    6b7b:	56                   	push   %esi
    6b7c:	53                   	push   %ebx
    6b7d:	50                   	push   %eax
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    6b7e:	8b 45 08             	mov    0x8(%ebp),%eax
{
    6b81:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    6b84:	8b 7d 10             	mov    0x10(%ebp),%edi
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    6b87:	8b 70 04             	mov    0x4(%eax),%esi
		!sh_uart->ctrl_blk->blocking_tx) {
    6b8a:	8b 06                	mov    (%esi),%eax
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    6b8c:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
    6b90:	74 08                	je     6b9a <write+0x23>
    6b92:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
    6b95:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b98:	eb 34                	jmp    6bce <write+0x57>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
    6b9a:	57                   	push   %edi
    6b9b:	53                   	push   %ebx
    6b9c:	ff 76 08             	pushl  0x8(%esi)
    6b9f:	e8 55 c1 ff ff       	call   2cf9 <ring_buf_put>
    6ba4:	8b 4d 14             	mov    0x14(%ebp),%ecx
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6ba7:	8b 16                	mov    (%esi),%edx
    6ba9:	83 c4 0c             	add    $0xc,%esp
    6bac:	89 01                	mov    %eax,(%ecx)
    6bae:	b8 01 00 00 00       	mov    $0x1,%eax
    6bb3:	87 42 0c             	xchg   %eax,0xc(%edx)
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
    6bb6:	85 c0                	test   %eax,%eax
    6bb8:	75 3d                	jne    6bf7 <write+0x80>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
    6bba:	8b 06                	mov    (%esi),%eax
    6bbc:	8b 10                	mov    (%eax),%edx
	if (api->irq_tx_enable) {
    6bbe:	8b 42 04             	mov    0x4(%edx),%eax
    6bc1:	8b 40 1c             	mov    0x1c(%eax),%eax
    6bc4:	85 c0                	test   %eax,%eax
    6bc6:	74 2f                	je     6bf7 <write+0x80>
		api->irq_tx_enable(dev);
    6bc8:	52                   	push   %edx
    6bc9:	ff d0                	call   *%eax
    6bcb:	58                   	pop    %eax
    6bcc:	eb 29                	jmp    6bf7 <write+0x80>
    6bce:	8b 06                	mov    (%esi),%eax
		for (size_t i = 0; i < length; i++) {
    6bd0:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
    6bd3:	74 13                	je     6be8 <write+0x71>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    6bd5:	8b 00                	mov    (%eax),%eax
	api->poll_out(dev, out_char);
    6bd7:	43                   	inc    %ebx
    6bd8:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
    6bdc:	8b 50 04             	mov    0x4(%eax),%edx
    6bdf:	51                   	push   %ecx
    6be0:	50                   	push   %eax
    6be1:	ff 52 04             	call   *0x4(%edx)
    6be4:	59                   	pop    %ecx
    6be5:	58                   	pop    %eax
    6be6:	eb e6                	jmp    6bce <write+0x57>
		*cnt = length;
    6be8:	8b 4d 14             	mov    0x14(%ebp),%ecx
    6beb:	89 39                	mov    %edi,(%ecx)
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    6bed:	ff 70 08             	pushl  0x8(%eax)
    6bf0:	6a 01                	push   $0x1
    6bf2:	ff 50 04             	call   *0x4(%eax)
    6bf5:	58                   	pop    %eax
    6bf6:	5a                   	pop    %edx
}
    6bf7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6bfa:	31 c0                	xor    %eax,%eax
    6bfc:	5b                   	pop    %ebx
    6bfd:	5e                   	pop    %esi
    6bfe:	5f                   	pop    %edi
    6bff:	5d                   	pop    %ebp
    6c00:	c3                   	ret    

00006c01 <uart_callback>:
{
    6c01:	55                   	push   %ebp
    6c02:	89 e5                	mov    %esp,%ebp
    6c04:	57                   	push   %edi
    6c05:	56                   	push   %esi
    6c06:	53                   	push   %ebx
    6c07:	83 ec 10             	sub    $0x10,%esp
    6c0a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct device *dev = sh_uart->ctrl_blk->dev;
    6c0d:	8b 03                	mov    (%ebx),%eax
    6c0f:	8b 30                	mov    (%eax),%esi
	if (api->irq_update) {
    6c11:	8b 46 04             	mov    0x4(%esi),%eax
    6c14:	8b 40 44             	mov    0x44(%eax),%eax
    6c17:	85 c0                	test   %eax,%eax
    6c19:	74 04                	je     6c1f <uart_callback+0x1e>
		return api->irq_update(dev);
    6c1b:	56                   	push   %esi
    6c1c:	ff d0                	call   *%eax
    6c1e:	5f                   	pop    %edi
	if (api->irq_rx_ready) {
    6c1f:	8b 46 04             	mov    0x4(%esi),%eax
    6c22:	8b 40 34             	mov    0x34(%eax),%eax
    6c25:	85 c0                	test   %eax,%eax
    6c27:	0f 84 bd 00 00 00    	je     6cea <uart_callback+0xe9>
		return api->irq_rx_ready(dev);
    6c2d:	56                   	push   %esi
    6c2e:	ff d0                	call   *%eax
    6c30:	59                   	pop    %ecx
	if (uart_irq_rx_ready(dev)) {
    6c31:	85 c0                	test   %eax,%eax
    6c33:	0f 84 b1 00 00 00    	je     6cea <uart_callback+0xe9>
	bool new_data = false;
    6c39:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
					 sh_uart->rx_ringbuf->size);
    6c3d:	8b 43 0c             	mov    0xc(%ebx),%eax
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
    6c40:	8d 55 f0             	lea    -0x10(%ebp),%edx
    6c43:	ff 70 10             	pushl  0x10(%eax)
    6c46:	52                   	push   %edx
    6c47:	50                   	push   %eax
    6c48:	e8 2b c0 ff ff       	call   2c78 <ring_buf_put_claim>
    6c4d:	83 c4 0c             	add    $0xc,%esp
    6c50:	89 c7                	mov    %eax,%edi
		if (len) {
    6c52:	85 c0                	test   %eax,%eax
    6c54:	74 3f                	je     6c95 <uart_callback+0x94>
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
    6c56:	8b 03                	mov    (%ebx),%eax
	return 0;
    6c58:	31 d2                	xor    %edx,%edx
    6c5a:	8b 08                	mov    (%eax),%ecx
	if (api->fifo_read) {
    6c5c:	8b 41 04             	mov    0x4(%ecx),%eax
    6c5f:	8b 40 18             	mov    0x18(%eax),%eax
    6c62:	85 c0                	test   %eax,%eax
    6c64:	74 14                	je     6c7a <uart_callback+0x79>
		return api->fifo_read(dev, rx_data, size);
    6c66:	57                   	push   %edi
    6c67:	ff 75 f0             	pushl  -0x10(%ebp)
    6c6a:	51                   	push   %ecx
    6c6b:	ff d0                	call   *%eax
    6c6d:	83 c4 0c             	add    $0xc,%esp
    6c70:	89 c2                	mov    %eax,%edx
			if (rd_len) {
    6c72:	85 c0                	test   %eax,%eax
    6c74:	74 04                	je     6c7a <uart_callback+0x79>
				new_data = true;
    6c76:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
			ring_buf_put_finish(sh_uart->rx_ringbuf, rd_len);
    6c7a:	52                   	push   %edx
    6c7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    6c7e:	ff 73 0c             	pushl  0xc(%ebx)
    6c81:	e8 3c c0 ff ff       	call   2cc2 <ring_buf_put_finish>
    6c86:	58                   	pop    %eax
    6c87:	5a                   	pop    %edx
	} while (rd_len && (rd_len == len));
    6c88:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6c8b:	85 d2                	test   %edx,%edx
    6c8d:	74 49                	je     6cd8 <uart_callback+0xd7>
    6c8f:	39 d7                	cmp    %edx,%edi
    6c91:	74 aa                	je     6c3d <uart_callback+0x3c>
    6c93:	eb 43                	jmp    6cd8 <uart_callback+0xd7>
			LOG_WRN("RX ring buffer full.");
    6c95:	f6 05 f8 a8 40 00 06 	testb  $0x6,0x40a8f8
    6c9c:	74 20                	je     6cbe <uart_callback+0xbd>
    6c9e:	b8 74 52 02 00       	mov    $0x25274,%eax
    6ca3:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    6ca8:	c1 e8 03             	shr    $0x3,%eax
    6cab:	c1 e0 06             	shl    $0x6,%eax
    6cae:	83 c8 02             	or     $0x2,%eax
    6cb1:	50                   	push   %eax
    6cb2:	68 e6 6d 02 00       	push   $0x26de6
    6cb7:	e8 ce c7 ff ff       	call   348a <log_0>
    6cbc:	59                   	pop    %ecx
    6cbd:	5f                   	pop    %edi
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
    6cbe:	8b 03                	mov    (%ebx),%eax
    6cc0:	8b 10                	mov    (%eax),%edx
	if (api->fifo_read) {
    6cc2:	8b 42 04             	mov    0x4(%edx),%eax
    6cc5:	8b 40 18             	mov    0x18(%eax),%eax
    6cc8:	85 c0                	test   %eax,%eax
    6cca:	74 0c                	je     6cd8 <uart_callback+0xd7>
		return api->fifo_read(dev, rx_data, size);
    6ccc:	6a 01                	push   $0x1
    6cce:	8d 4d ef             	lea    -0x11(%ebp),%ecx
    6cd1:	51                   	push   %ecx
    6cd2:	52                   	push   %edx
    6cd3:	ff d0                	call   *%eax
    6cd5:	83 c4 0c             	add    $0xc,%esp
	if (new_data) {
    6cd8:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
    6cdc:	74 0c                	je     6cea <uart_callback+0xe9>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
    6cde:	8b 03                	mov    (%ebx),%eax
    6ce0:	ff 70 08             	pushl  0x8(%eax)
    6ce3:	6a 00                	push   $0x0
    6ce5:	ff 50 04             	call   *0x4(%eax)
    6ce8:	58                   	pop    %eax
    6ce9:	5a                   	pop    %edx
	if (api->irq_tx_ready) {
    6cea:	8b 46 04             	mov    0x4(%esi),%eax
    6ced:	8b 40 24             	mov    0x24(%eax),%eax
    6cf0:	85 c0                	test   %eax,%eax
    6cf2:	74 64                	je     6d58 <uart_callback+0x157>
		return api->irq_tx_ready(dev);
    6cf4:	56                   	push   %esi
    6cf5:	ff d0                	call   *%eax
    6cf7:	5f                   	pop    %edi
	if (uart_irq_tx_ready(dev)) {
    6cf8:	85 c0                	test   %eax,%eax
    6cfa:	74 5c                	je     6d58 <uart_callback+0x157>
	struct device *dev = sh_uart->ctrl_blk->dev;
    6cfc:	8b 03                	mov    (%ebx),%eax
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
    6cfe:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct device *dev = sh_uart->ctrl_blk->dev;
    6d01:	8b 30                	mov    (%eax),%esi
				 sh_uart->tx_ringbuf->size);
    6d03:	8b 43 08             	mov    0x8(%ebx),%eax
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
    6d06:	ff 70 10             	pushl  0x10(%eax)
    6d09:	52                   	push   %edx
    6d0a:	50                   	push   %eax
    6d0b:	e8 38 c0 ff ff       	call   2d48 <ring_buf_get_claim>
    6d10:	83 c4 0c             	add    $0xc,%esp
	if (len) {
    6d13:	85 c0                	test   %eax,%eax
    6d15:	74 25                	je     6d3c <uart_callback+0x13b>
	if (api->fifo_fill) {
    6d17:	8b 56 04             	mov    0x4(%esi),%edx
    6d1a:	8b 4a 14             	mov    0x14(%edx),%ecx
	return 0;
    6d1d:	31 d2                	xor    %edx,%edx
	if (api->fifo_fill) {
    6d1f:	85 c9                	test   %ecx,%ecx
    6d21:	74 0c                	je     6d2f <uart_callback+0x12e>
		return api->fifo_fill(dev, tx_data, size);
    6d23:	50                   	push   %eax
    6d24:	ff 75 f0             	pushl  -0x10(%ebp)
    6d27:	56                   	push   %esi
    6d28:	ff d1                	call   *%ecx
    6d2a:	83 c4 0c             	add    $0xc,%esp
    6d2d:	89 c2                	mov    %eax,%edx
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
    6d2f:	52                   	push   %edx
    6d30:	ff 73 08             	pushl  0x8(%ebx)
    6d33:	e8 60 c0 ff ff       	call   2d98 <ring_buf_get_finish>
    6d38:	59                   	pop    %ecx
    6d39:	5e                   	pop    %esi
		__ASSERT_NO_MSG(err == 0);
    6d3a:	eb 10                	jmp    6d4c <uart_callback+0x14b>
    6d3c:	89 f0                	mov    %esi,%eax
    6d3e:	e8 64 fd ff ff       	call   6aa7 <z_impl_uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
    6d43:	8b 03                	mov    (%ebx),%eax
    6d45:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    6d4c:	8b 03                	mov    (%ebx),%eax
    6d4e:	ff 70 08             	pushl  0x8(%eax)
    6d51:	6a 01                	push   $0x1
    6d53:	ff 50 04             	call   *0x4(%eax)
    6d56:	58                   	pop    %eax
    6d57:	5a                   	pop    %edx
}
    6d58:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6d5b:	5b                   	pop    %ebx
    6d5c:	5e                   	pop    %esi
    6d5d:	5f                   	pop    %edi
    6d5e:	5d                   	pop    %ebp
    6d5f:	c3                   	ret    

00006d60 <shell_raw_fprintf>:
{
    6d60:	55                   	push   %ebp
    6d61:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
    6d63:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
    6d66:	50                   	push   %eax
    6d67:	ff 75 0c             	pushl  0xc(%ebp)
    6d6a:	ff 75 08             	pushl  0x8(%ebp)
    6d6d:	e8 e7 ee ff ff       	call   5c59 <shell_fprintf_fmt>
    6d72:	83 c4 0c             	add    $0xc,%esp
}
    6d75:	c9                   	leave  
    6d76:	c3                   	ret    

00006d77 <formatted_text_print.constprop.2>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
    6d77:	85 d2                	test   %edx,%edx
    6d79:	0f 84 51 01 00 00    	je     6ed0 <formatted_text_print.constprop.2+0x159>
static void formatted_text_print(const struct shell *shell, const char *str,
    6d7f:	55                   	push   %ebp
    6d80:	89 e5                	mov    %esp,%ebp
    6d82:	57                   	push   %edi
    6d83:	56                   	push   %esi
	if (str == NULL) {
    6d84:	31 f6                	xor    %esi,%esi
static void formatted_text_print(const struct shell *shell, const char *str,
    6d86:	53                   	push   %ebx
    6d87:	89 c3                	mov    %eax,%ebx
    6d89:	83 ec 10             	sub    $0x10,%esp
    6d8c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    6d8f:	89 55 f0             	mov    %edx,-0x10(%ebp)
		shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
    6d92:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d95:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
    6d99:	89 c1                	mov    %eax,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    6d9b:	83 e8 09             	sub    $0x9,%eax
    6d9e:	83 f8 04             	cmp    $0x4,%eax
    6da1:	77 03                	ja     6da6 <formatted_text_print.constprop.2+0x2f>
		++offset;
    6da3:	46                   	inc    %esi
    6da4:	eb ec                	jmp    6d92 <formatted_text_print.constprop.2+0x1b>
	while (isspace((int) *(str + offset))) {
    6da6:	80 f9 20             	cmp    $0x20,%cl
    6da9:	74 f8                	je     6da3 <formatted_text_print.constprop.2+0x2c>
    6dab:	ff 75 f0             	pushl  -0x10(%ebp)
    6dae:	e8 b0 3a 00 00       	call   a863 <strlen>
		size_t idx = 0;

		length = shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    6db3:	8b 53 08             	mov    0x8(%ebx),%edx
    6db6:	0f b7 7a 2a          	movzwl 0x2a(%edx),%edi
    6dba:	89 fa                	mov    %edi,%edx
    6dbc:	89 7d e8             	mov    %edi,-0x18(%ebp)
		length = shell_strlen(str) - offset;
    6dbf:	0f b7 c0             	movzwl %ax,%eax
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    6dc2:	2b 55 ec             	sub    -0x14(%ebp),%edx
		length = shell_strlen(str) - offset;
    6dc5:	29 f0                	sub    %esi,%eax
			for (idx = 0; idx < length; idx++) {
    6dc7:	31 ff                	xor    %edi,%edi
    6dc9:	59                   	pop    %ecx
		if (length <=
    6dca:	39 d0                	cmp    %edx,%eax
    6dcc:	76 0d                	jbe    6ddb <formatted_text_print.constprop.2+0x64>
    6dce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dd1:	01 f0                	add    %esi,%eax
    6dd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    6dd6:	e9 89 00 00 00       	jmp    6e64 <formatted_text_print.constprop.2+0xed>
    6ddb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6dde:	01 f1                	add    %esi,%ecx
			for (idx = 0; idx < length; idx++) {
    6de0:	39 f8                	cmp    %edi,%eax
    6de2:	74 4a                	je     6e2e <formatted_text_print.constprop.2+0xb7>
				if (*(str + offset + idx) == '\n') {
    6de4:	8d 14 3e             	lea    (%esi,%edi,1),%edx
    6de7:	80 3c 39 0a          	cmpb   $0xa,(%ecx,%edi,1)
    6deb:	89 55 e8             	mov    %edx,-0x18(%ebp)
    6dee:	75 3b                	jne    6e2b <formatted_text_print.constprop.2+0xb4>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
    6df0:	ff 73 14             	pushl  0x14(%ebx)
    6df3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    6df6:	e8 39 ee ff ff       	call   5c34 <shell_fprintf_buffer_flush>
					transport_buffer_flush(shell);
					shell_write(shell, str + offset, idx);
    6dfb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    6dfe:	89 3c 24             	mov    %edi,(%esp)
    6e01:	51                   	push   %ecx
    6e02:	53                   	push   %ebx
    6e03:	e8 94 f7 ff ff       	call   659c <shell_write>
    6e08:	83 c4 0c             	add    $0xc,%esp
					offset += idx + 1;
    6e0b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    6e0e:	46                   	inc    %esi
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
    6e0f:	68 b9 6d 02 00       	push   $0x26db9
    6e14:	ff 73 14             	pushl  0x14(%ebx)
    6e17:	e8 44 ff ff ff       	call   6d60 <shell_raw_fprintf>
    6e1c:	5f                   	pop    %edi
    6e1d:	58                   	pop    %eax
					cursor_next_line_move(shell);
					shell_op_cursor_horiz_move(shell,
    6e1e:	ff 75 ec             	pushl  -0x14(%ebp)
    6e21:	53                   	push   %ebx
    6e22:	e8 0c f4 ff ff       	call   6233 <shell_op_cursor_horiz_move>
    6e27:	58                   	pop    %eax
    6e28:	5a                   	pop    %edx
							terminal_offset);
					break;
    6e29:	eb 03                	jmp    6e2e <formatted_text_print.constprop.2+0xb7>
			for (idx = 0; idx < length; idx++) {
    6e2b:	47                   	inc    %edi
    6e2c:	eb b2                	jmp    6de0 <formatted_text_print.constprop.2+0x69>
				}
			}

			/* String will fit in one line. */
			shell_raw_fprintf(shell->fprintf_ctx, str + offset);
    6e2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6e31:	01 f2                	add    %esi,%edx
    6e33:	52                   	push   %edx
    6e34:	ff 73 14             	pushl  0x14(%ebx)
    6e37:	e8 24 ff ff ff       	call   6d60 <shell_raw_fprintf>
    6e3c:	58                   	pop    %eax
    6e3d:	5a                   	pop    %edx
    6e3e:	68 b9 6d 02 00       	push   $0x26db9
    6e43:	ff 73 14             	pushl  0x14(%ebx)
    6e46:	e8 15 ff ff ff       	call   6d60 <shell_raw_fprintf>
    6e4b:	59                   	pop    %ecx
    6e4c:	5b                   	pop    %ebx
		cursor_next_line_move(shell);
		shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	cursor_next_line_move(shell);
}
    6e4d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6e50:	5b                   	pop    %ebx
    6e51:	5e                   	pop    %esi
    6e52:	5f                   	pop    %edi
    6e53:	5d                   	pop    %ebp
    6e54:	c3                   	ret    
			if (isspace((int) (*(str + offset + idx)))) {
    6e55:	3c 20                	cmp    $0x20,%al
    6e57:	74 1c                	je     6e75 <formatted_text_print.constprop.2+0xfe>
			if ((idx + terminal_offset) >=
    6e59:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e5c:	01 f8                	add    %edi,%eax
    6e5e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6e61:	76 1a                	jbe    6e7d <formatted_text_print.constprop.2+0x106>
			++idx;
    6e63:	47                   	inc    %edi
			if (isspace((int) (*(str + offset + idx)))) {
    6e64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6e67:	0f be 0c 38          	movsbl (%eax,%edi,1),%ecx
    6e6b:	89 c8                	mov    %ecx,%eax
    6e6d:	83 e9 09             	sub    $0x9,%ecx
    6e70:	83 f9 04             	cmp    $0x4,%ecx
    6e73:	77 e0                	ja     6e55 <formatted_text_print.constprop.2+0xde>
				if (*(str + offset + idx) == '\n') {
    6e75:	3c 0a                	cmp    $0xa,%al
    6e77:	74 06                	je     6e7f <formatted_text_print.constprop.2+0x108>
    6e79:	89 fa                	mov    %edi,%edx
    6e7b:	eb dc                	jmp    6e59 <formatted_text_print.constprop.2+0xe2>
			if ((idx + terminal_offset) >=
    6e7d:	89 d7                	mov    %edx,%edi
    6e7f:	ff 73 14             	pushl  0x14(%ebx)
    6e82:	e8 ad ed ff ff       	call   5c34 <shell_fprintf_buffer_flush>
		shell_write(shell, str + offset, length);
    6e87:	89 3c 24             	mov    %edi,(%esp)
    6e8a:	ff 75 e4             	pushl  -0x1c(%ebp)
		offset += length;
    6e8d:	01 fe                	add    %edi,%esi
		shell_write(shell, str + offset, length);
    6e8f:	53                   	push   %ebx
    6e90:	e8 07 f7 ff ff       	call   659c <shell_write>
    6e95:	83 c4 0c             	add    $0xc,%esp
		while (isspace((int) (*(str + offset)))) {
    6e98:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e9b:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
    6e9f:	89 c1                	mov    %eax,%ecx
    6ea1:	83 e8 09             	sub    $0x9,%eax
    6ea4:	83 f8 04             	cmp    $0x4,%eax
    6ea7:	77 03                	ja     6eac <formatted_text_print.constprop.2+0x135>
			++offset;
    6ea9:	46                   	inc    %esi
    6eaa:	eb ec                	jmp    6e98 <formatted_text_print.constprop.2+0x121>
		while (isspace((int) (*(str + offset)))) {
    6eac:	80 f9 20             	cmp    $0x20,%cl
    6eaf:	74 f8                	je     6ea9 <formatted_text_print.constprop.2+0x132>
    6eb1:	68 b9 6d 02 00       	push   $0x26db9
    6eb6:	ff 73 14             	pushl  0x14(%ebx)
    6eb9:	e8 a2 fe ff ff       	call   6d60 <shell_raw_fprintf>
    6ebe:	58                   	pop    %eax
    6ebf:	5a                   	pop    %edx
		shell_op_cursor_horiz_move(shell, terminal_offset);
    6ec0:	ff 75 ec             	pushl  -0x14(%ebp)
    6ec3:	53                   	push   %ebx
    6ec4:	e8 6a f3 ff ff       	call   6233 <shell_op_cursor_horiz_move>
    6ec9:	59                   	pop    %ecx
    6eca:	5f                   	pop    %edi
    6ecb:	e9 db fe ff ff       	jmp    6dab <formatted_text_print.constprop.2+0x34>
    6ed0:	c3                   	ret    

00006ed1 <shell_help_subcmd_print>:

/* Function is printing command help, its subcommands name and subcommands
 * help string.
 */
void shell_help_subcmd_print(const struct shell *shell)
{
    6ed1:	55                   	push   %ebp
    6ed2:	89 e5                	mov    %esp,%ebp
    6ed4:	57                   	push   %edi
    6ed5:	56                   	push   %esi
    6ed6:	53                   	push   %ebx
    6ed7:	83 ec 24             	sub    $0x24,%esp
	const struct shell_static_entry *entry = NULL;
    6eda:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
{
    6ee1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_static_entry static_entry;
	u16_t longest_syntax = 0;
	size_t cmd_idx = 0;

	/* Checking if there are any subcommands available. */
	if (!shell->ctx->active_cmd.subcmd) {
    6ee4:	8b 43 08             	mov    0x8(%ebx),%eax
    6ee7:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
    6eeb:	0f 84 f3 00 00 00    	je     6fe4 <shell_help_subcmd_print+0x113>
	size_t cmd_idx = 0;
    6ef1:	31 ff                	xor    %edi,%edi
	u16_t longest_syntax = 0;
    6ef3:	31 f6                	xor    %esi,%esi
		return;
	}

	/* Searching for the longest subcommand to print. */
	do {
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
    6ef5:	8d 47 01             	lea    0x1(%edi),%eax
    6ef8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    6efb:	8d 45 e0             	lea    -0x20(%ebp),%eax
    6efe:	50                   	push   %eax
    6eff:	8d 45 dc             	lea    -0x24(%ebp),%eax
    6f02:	50                   	push   %eax
    6f03:	8b 43 08             	mov    0x8(%ebx),%eax
    6f06:	57                   	push   %edi
    6f07:	6a 01                	push   $0x1
    6f09:	ff 70 14             	pushl  0x14(%eax)
    6f0c:	e8 dd f0 ff ff       	call   5fee <shell_cmd_get>
			      !SHELL_CMD_ROOT_LVL,
			      cmd_idx++, &entry, &static_entry);

		if (!entry) {
    6f11:	8b 45 dc             	mov    -0x24(%ebp),%eax
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
    6f14:	83 c4 14             	add    $0x14,%esp
		if (!entry) {
    6f17:	85 c0                	test   %eax,%eax
    6f19:	74 1c                	je     6f37 <shell_help_subcmd_print+0x66>
			break;
		}

		u16_t len = shell_strlen(entry->syntax);
    6f1b:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (u16_t)strlen(str);
    6f1d:	85 c0                	test   %eax,%eax
    6f1f:	74 0e                	je     6f2f <shell_help_subcmd_print+0x5e>
    6f21:	50                   	push   %eax
    6f22:	e8 3c 39 00 00       	call   a863 <strlen>

		longest_syntax = longest_syntax > len ? longest_syntax : len;
    6f27:	66 39 c6             	cmp    %ax,%si
    6f2a:	5a                   	pop    %edx
    6f2b:	73 02                	jae    6f2f <shell_help_subcmd_print+0x5e>
    6f2d:	89 c6                	mov    %eax,%esi
	} while (cmd_idx != 0); /* too many commands */
    6f2f:	47                   	inc    %edi
    6f30:	74 0f                	je     6f41 <shell_help_subcmd_print+0x70>
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
    6f32:	8b 7d d8             	mov    -0x28(%ebp),%edi
    6f35:	eb be                	jmp    6ef5 <shell_help_subcmd_print+0x24>

	if (cmd_idx == 1) {
    6f37:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
    6f3b:	0f 84 a3 00 00 00    	je     6fe4 <shell_help_subcmd_print+0x113>
		return;
	}

	shell_internal_fprintf(shell, SHELL_NORMAL, "Subcommands:\n");
    6f41:	68 28 6e 02 00       	push   $0x26e28
    6f46:	6a 00                	push   $0x0
    6f48:	53                   	push   %ebx
    6f49:	e8 fc f7 ff ff       	call   674a <shell_internal_fprintf>
    6f4e:	83 c4 0c             	add    $0xc,%esp

	/* Printing subcommands and help string (if exists). */
	cmd_idx = 0;
    6f51:	31 c0                	xor    %eax,%eax

	while (true) {
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
    6f53:	8d 50 01             	lea    0x1(%eax),%edx
    6f56:	89 55 d8             	mov    %edx,-0x28(%ebp)
    6f59:	8d 55 e0             	lea    -0x20(%ebp),%edx
    6f5c:	52                   	push   %edx
    6f5d:	8d 55 dc             	lea    -0x24(%ebp),%edx
    6f60:	52                   	push   %edx
    6f61:	50                   	push   %eax
    6f62:	8b 43 08             	mov    0x8(%ebx),%eax
    6f65:	6a 01                	push   $0x1
    6f67:	ff 70 14             	pushl  0x14(%eax)
    6f6a:	e8 7f f0 ff ff       	call   5fee <shell_cmd_get>
			      !SHELL_CMD_ROOT_LVL,
			      cmd_idx++, &entry, &static_entry);

		if (entry == NULL) {
    6f6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
		shell_cmd_get(shell->ctx->active_cmd.subcmd,
    6f72:	83 c4 14             	add    $0x14,%esp
		if (entry == NULL) {
    6f75:	85 c0                	test   %eax,%eax
    6f77:	74 6b                	je     6fe4 <shell_help_subcmd_print+0x113>
			break;
		}

		help_item_print(shell, entry->syntax, longest_syntax,
    6f79:	8b 08                	mov    (%eax),%ecx
    6f7b:	8b 78 04             	mov    0x4(%eax),%edi
    6f7e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    6f81:	68 40 6e 02 00       	push   $0x26e40
    6f86:	e8 d8 38 00 00       	call   a863 <strlen>
    6f8b:	59                   	pop    %ecx
	if (item_name == NULL) {
    6f8c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    6f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (item_name == NULL) {
    6f92:	85 c9                	test   %ecx,%ecx
    6f94:	75 05                	jne    6f9b <shell_help_subcmd_print+0xca>
    6f96:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6f99:	eb b8                	jmp    6f53 <shell_help_subcmd_print+0x82>
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
    6f9b:	68 40 6e 02 00       	push   $0x26e40
    6fa0:	51                   	push   %ecx
		help_item_print(shell, entry->syntax, longest_syntax,
    6fa1:	0f b7 ce             	movzwl %si,%ecx
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
    6fa4:	51                   	push   %ecx
    6fa5:	68 40 6e 02 00       	push   $0x26e40
    6faa:	68 36 6e 02 00       	push   $0x26e36
    6faf:	6a 00                	push   $0x0
    6fb1:	53                   	push   %ebx
    6fb2:	e8 93 f7 ff ff       	call   674a <shell_internal_fprintf>
    6fb7:	83 c4 1c             	add    $0x1c,%esp
	if (item_help == NULL) {
    6fba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6fbd:	85 ff                	test   %edi,%edi
    6fbf:	75 11                	jne    6fd2 <shell_help_subcmd_print+0x101>
    6fc1:	68 b9 6d 02 00       	push   $0x26db9
    6fc6:	ff 73 14             	pushl  0x14(%ebx)
    6fc9:	e8 92 fd ff ff       	call   6d60 <shell_raw_fprintf>
    6fce:	58                   	pop    %eax
    6fcf:	5a                   	pop    %edx
    6fd0:	eb c4                	jmp    6f96 <shell_help_subcmd_print+0xc5>
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    6fd2:	8d 4c 46 01          	lea    0x1(%esi,%eax,2),%ecx
	formatted_text_print(shell, item_help, offset, false);
    6fd6:	89 fa                	mov    %edi,%edx
    6fd8:	0f b7 c9             	movzwl %cx,%ecx
    6fdb:	89 d8                	mov    %ebx,%eax
    6fdd:	e8 95 fd ff ff       	call   6d77 <formatted_text_print.constprop.2>
    6fe2:	eb b2                	jmp    6f96 <shell_help_subcmd_print+0xc5>
				entry->help);
	}
}
    6fe4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6fe7:	5b                   	pop    %ebx
    6fe8:	5e                   	pop    %esi
    6fe9:	5f                   	pop    %edi
    6fea:	5d                   	pop    %ebp
    6feb:	c3                   	ret    

00006fec <shell_help_cmd_print>:

void shell_help_cmd_print(const struct shell *shell)
{
    6fec:	55                   	push   %ebp
    6fed:	89 e5                	mov    %esp,%ebp
    6fef:	56                   	push   %esi
    6ff0:	53                   	push   %ebx
    6ff1:	31 db                	xor    %ebx,%ebx
    6ff3:	8b 75 08             	mov    0x8(%ebp),%esi
	static const char cmd_sep[] = " - ";	/* commands separator */

	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
    6ff6:	8b 46 08             	mov    0x8(%esi),%eax
    6ff9:	8b 40 0c             	mov    0xc(%eax),%eax
    6ffc:	85 c0                	test   %eax,%eax
    6ffe:	74 09                	je     7009 <shell_help_cmd_print+0x1d>
    7000:	50                   	push   %eax
    7001:	e8 5d 38 00 00       	call   a863 <strlen>
    7006:	5a                   	pop    %edx
    7007:	89 c3                	mov    %eax,%ebx
    7009:	68 e4 5e 02 00       	push   $0x25ee4
    700e:	e8 50 38 00 00       	call   a863 <strlen>
							  shell_strlen(cmd_sep);

	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
    7013:	c7 04 24 e4 5e 02 00 	movl   $0x25ee4,(%esp)
	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
    701a:	01 c3                	add    %eax,%ebx
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
    701c:	8b 46 08             	mov    0x8(%esi),%eax
    701f:	ff 70 0c             	pushl  0xc(%eax)
    7022:	68 b3 6d 02 00       	push   $0x26db3
    7027:	6a 00                	push   $0x0
    7029:	56                   	push   %esi
    702a:	e8 1b f7 ff ff       	call   674a <shell_internal_fprintf>
			       shell->ctx->active_cmd.syntax, cmd_sep);

	formatted_text_print(shell, shell->ctx->active_cmd.help,
    702f:	8b 46 08             	mov    0x8(%esi),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
    7032:	83 c4 14             	add    $0x14,%esp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
    7035:	0f b7 cb             	movzwl %bx,%ecx
    7038:	8b 50 10             	mov    0x10(%eax),%edx
			     field_width, false);
}
    703b:	8d 65 f8             	lea    -0x8(%ebp),%esp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
    703e:	89 f0                	mov    %esi,%eax
}
    7040:	5b                   	pop    %ebx
    7041:	5e                   	pop    %esi
    7042:	5d                   	pop    %ebp
	formatted_text_print(shell, shell->ctx->active_cmd.help,
    7043:	e9 2f fd ff ff       	jmp    6d77 <formatted_text_print.constprop.2>

00007048 <cmd_bacskpace_mode_backspace>:
	return 0;
}

static int cmd_bacskpace_mode_backspace(const struct shell *shell, size_t argc,
					char **argv)
{
    7048:	55                   	push   %ebp
    7049:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
    704b:	8b 45 08             	mov    0x8(%ebp),%eax
    704e:	8b 50 08             	mov    0x8(%eax),%edx
    7051:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    7058:	83 e0 df             	and    $0xffffffdf,%eax
    705b:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, false);

	return 0;
}
    7062:	31 c0                	xor    %eax,%eax
    7064:	5d                   	pop    %ebp
    7065:	c3                   	ret    

00007066 <cmd_bacskpace_mode_delete>:

static int cmd_bacskpace_mode_delete(const struct shell *shell, size_t argc,
				      char **argv)
{
    7066:	55                   	push   %ebp
    7067:	89 e5                	mov    %esp,%ebp
    7069:	8b 45 08             	mov    0x8(%ebp),%eax
    706c:	8b 50 08             	mov    0x8(%eax),%edx
    706f:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    7076:	83 c8 20             	or     $0x20,%eax
    7079:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, true);

	return 0;
}
    7080:	31 c0                	xor    %eax,%eax
    7082:	5d                   	pop    %ebp
    7083:	c3                   	ret    

00007084 <cmd_colors_off>:

static int cmd_colors_off(const struct shell *shell, size_t argc, char **argv)
{
    7084:	55                   	push   %ebp
    7085:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
    7087:	8b 45 08             	mov    0x8(%ebp),%eax
    708a:	8b 50 08             	mov    0x8(%eax),%edx
    708d:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    7094:	83 e0 fd             	and    $0xfffffffd,%eax
    7097:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, false);

	return 0;
}
    709e:	31 c0                	xor    %eax,%eax
    70a0:	5d                   	pop    %ebp
    70a1:	c3                   	ret    

000070a2 <cmd_colors_on>:

static int cmd_colors_on(const struct shell *shell, size_t argc, char **argv)
{
    70a2:	55                   	push   %ebp
    70a3:	89 e5                	mov    %esp,%ebp
    70a5:	8b 45 08             	mov    0x8(%ebp),%eax
    70a8:	8b 50 08             	mov    0x8(%eax),%edx
    70ab:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    70b2:	83 c8 02             	or     $0x2,%eax
    70b5:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, true);

	return 0;
}
    70bc:	31 c0                	xor    %eax,%eax
    70be:	5d                   	pop    %ebp
    70bf:	c3                   	ret    

000070c0 <cmd_echo_off>:

static int cmd_echo_off(const struct shell *shell, size_t argc, char **argv)
{
    70c0:	55                   	push   %ebp
    70c1:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.echo = val ? 1 : 0;
    70c3:	8b 45 08             	mov    0x8(%ebp),%eax
    70c6:	8b 50 08             	mov    0x8(%eax),%edx
    70c9:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    70d0:	83 e0 fb             	and    $0xfffffffb,%eax
    70d3:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, false);

	return 0;
}
    70da:	31 c0                	xor    %eax,%eax
    70dc:	5d                   	pop    %ebp
    70dd:	c3                   	ret    

000070de <cmd_echo_on>:

static int cmd_echo_on(const struct shell *shell, size_t argc, char **argv)
{
    70de:	55                   	push   %ebp
    70df:	89 e5                	mov    %esp,%ebp
    70e1:	8b 45 08             	mov    0x8(%ebp),%eax
    70e4:	8b 50 08             	mov    0x8(%eax),%edx
    70e7:	66 8b 82 60 02 00 00 	mov    0x260(%edx),%ax
    70ee:	83 c8 04             	or     $0x4,%eax
    70f1:	66 89 82 60 02 00 00 	mov    %ax,0x260(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, true);

	return 0;
}
    70f8:	31 c0                	xor    %eax,%eax
    70fa:	5d                   	pop    %ebp
    70fb:	c3                   	ret    

000070fc <cmd_shell_stats_reset>:
	return 0;
}

static int cmd_shell_stats_reset(const struct shell *shell,
				 size_t argc, char **argv)
{
    70fc:	55                   	push   %ebp
    70fd:	89 e5                	mov    %esp,%ebp
	if (!IS_ENABLED(CONFIG_SHELL_STATS)) {
		shell_error(shell, "Command not supported.");
		return -ENOEXEC;
	}

	shell->stats->log_lost_cnt = 0;
    70ff:	8b 45 08             	mov    0x8(%ebp),%eax
    7102:	8b 40 18             	mov    0x18(%eax),%eax
    7105:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	return 0;
}
    710b:	31 c0                	xor    %eax,%eax
    710d:	5d                   	pop    %ebp
    710e:	c3                   	ret    

0000710f <shell_raw_fprintf>:
{
    710f:	55                   	push   %ebp
    7110:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
    7112:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
    7115:	50                   	push   %eax
    7116:	ff 75 0c             	pushl  0xc(%ebp)
    7119:	ff 75 08             	pushl  0x8(%ebp)
    711c:	e8 38 eb ff ff       	call   5c59 <shell_fprintf_fmt>
    7121:	83 c4 0c             	add    $0xc,%esp
}
    7124:	c9                   	leave  
    7125:	c3                   	ret    

00007126 <cmd_clear>:
{
    7126:	55                   	push   %ebp
    7127:	89 e5                	mov    %esp,%ebp
    7129:	53                   	push   %ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    712a:	68 00 5f 02 00       	push   $0x25f00
{
    712f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    7132:	68 6a a5 02 00       	push   $0x2a56a
    7137:	ff 73 14             	pushl  0x14(%ebx)
    713a:	e8 d0 ff ff ff       	call   710f <shell_raw_fprintf>
    713f:	83 c4 0c             	add    $0xc,%esp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    7142:	68 f8 5e 02 00       	push   $0x25ef8
    7147:	68 6a a5 02 00       	push   $0x2a56a
    714c:	ff 73 14             	pushl  0x14(%ebx)
    714f:	e8 bb ff ff ff       	call   710f <shell_raw_fprintf>
    7154:	83 c4 0c             	add    $0xc,%esp
}
    7157:	31 c0                	xor    %eax,%eax
    7159:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    715c:	c9                   	leave  
    715d:	c3                   	ret    

0000715e <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
    715e:	55                   	push   %ebp
    715f:	89 e5                	mov    %esp,%ebp
    7161:	53                   	push   %ebx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    7162:	68 e8 5e 02 00       	push   $0x25ee8
{
    7167:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    716a:	68 6a a5 02 00       	push   $0x2a56a
    716f:	ff 73 14             	pushl  0x14(%ebx)
    7172:	e8 98 ff ff ff       	call   710f <shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid =  SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    7177:	8b 43 08             	mov    0x8(%ebx),%eax
    717a:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    7181:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
    7184:	31 c0                	xor    %eax,%eax
    7186:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7189:	c9                   	leave  
    718a:	c3                   	ret    

0000718b <cmd_shell_stats_show>:
{
    718b:	55                   	push   %ebp
    718c:	89 e5                	mov    %esp,%ebp
    718e:	8b 45 08             	mov    0x8(%ebp),%eax
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
    7191:	8b 50 18             	mov    0x18(%eax),%edx
    7194:	ff 32                	pushl  (%edx)
    7196:	68 43 6e 02 00       	push   $0x26e43
    719b:	6a 00                	push   $0x0
    719d:	50                   	push   %eax
    719e:	e8 1f ea ff ff       	call   5bc2 <shell_fprintf>
    71a3:	83 c4 10             	add    $0x10,%esp
}
    71a6:	31 c0                	xor    %eax,%eax
    71a8:	c9                   	leave  
    71a9:	c3                   	ret    

000071aa <cmd_help>:
{
    71aa:	55                   	push   %ebp
    71ab:	89 e5                	mov    %esp,%ebp
    71ad:	53                   	push   %ebx
	shell_print(shell,
    71ae:	68 52 6e 02 00       	push   $0x26e52
{
    71b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_print(shell,
    71b6:	6a 00                	push   $0x0
    71b8:	53                   	push   %ebx
    71b9:	e8 04 ea ff ff       	call   5bc2 <shell_fprintf>
    71be:	83 c4 0c             	add    $0xc,%esp
	shell_print(shell,
    71c1:	68 41 6f 02 00       	push   $0x26f41
    71c6:	6a 00                	push   $0x0
    71c8:	53                   	push   %ebx
    71c9:	e8 f4 e9 ff ff       	call   5bc2 <shell_fprintf>
    71ce:	83 c4 0c             	add    $0xc,%esp
}
    71d1:	31 c0                	xor    %eax,%eax
    71d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    71d6:	c9                   	leave  
    71d7:	c3                   	ret    

000071d8 <cmd_history>:
{
    71d8:	55                   	push   %ebp
    71d9:	89 e5                	mov    %esp,%ebp
    71db:	57                   	push   %edi
    71dc:	56                   	push   %esi
	size_t i = 0;
    71dd:	31 ff                	xor    %edi,%edi
{
    71df:	53                   	push   %ebx
    71e0:	50                   	push   %eax
    71e1:	8b 75 08             	mov    0x8(%ebp),%esi
		shell_history_get(shell->history, true,
    71e4:	8d 45 f2             	lea    -0xe(%ebp),%eax
    71e7:	50                   	push   %eax
				  shell->ctx->temp_buff, &len);
    71e8:	8b 46 08             	mov    0x8(%esi),%eax
    71eb:	05 42 01 00 00       	add    $0x142,%eax
		shell_history_get(shell->history, true,
    71f0:	50                   	push   %eax
    71f1:	6a 01                	push   $0x1
    71f3:	ff 76 0c             	pushl  0xc(%esi)
    71f6:	e8 e8 02 00 00       	call   74e3 <shell_history_get>
    71fb:	83 c4 10             	add    $0x10,%esp
		if (len) {
    71fe:	8b 46 08             	mov    0x8(%esi),%eax
    7201:	66 83 7d f2 00       	cmpw   $0x0,-0xe(%ebp)
    7206:	74 1e                	je     7226 <cmd_history+0x4e>
			shell_print(shell, "[%3d] %s",
    7208:	05 42 01 00 00       	add    $0x142,%eax
    720d:	8d 5f 01             	lea    0x1(%edi),%ebx
    7210:	50                   	push   %eax
    7211:	57                   	push   %edi
    7212:	89 df                	mov    %ebx,%edi
    7214:	68 f9 6f 02 00       	push   $0x26ff9
    7219:	6a 00                	push   $0x0
    721b:	56                   	push   %esi
    721c:	e8 a1 e9 ff ff       	call   5bc2 <shell_fprintf>
    7221:	83 c4 14             	add    $0x14,%esp
		shell_history_get(shell->history, true,
    7224:	eb be                	jmp    71e4 <cmd_history+0xc>
	shell->ctx->temp_buff[0] = '\0';
    7226:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
}
    722d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7230:	31 c0                	xor    %eax,%eax
    7232:	5b                   	pop    %ebx
    7233:	5e                   	pop    %esi
    7234:	5f                   	pop    %edi
    7235:	5d                   	pop    %ebp
    7236:	c3                   	ret    

00007237 <cmd_echo>:
{
    7237:	55                   	push   %ebp
    7238:	89 e5                	mov    %esp,%ebp
    723a:	8b 45 08             	mov    0x8(%ebp),%eax
    723d:	8b 55 10             	mov    0x10(%ebp),%edx
	if (argc == 2) {
    7240:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    7244:	75 21                	jne    7267 <cmd_echo+0x30>
		shell_error(shell, "%s:%s%s", argv[0],
    7246:	ff 72 04             	pushl  0x4(%edx)
    7249:	68 07 70 02 00       	push   $0x27007
    724e:	ff 32                	pushl  (%edx)
    7250:	68 1c 70 02 00       	push   $0x2701c
    7255:	6a 02                	push   $0x2
    7257:	50                   	push   %eax
    7258:	e8 65 e9 ff ff       	call   5bc2 <shell_fprintf>
    725d:	83 c4 18             	add    $0x18,%esp
    7260:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    7265:	eb 2b                	jmp    7292 <cmd_echo+0x5b>
	shell_print(shell, "Echo status: %s",
    7267:	8b 50 08             	mov    0x8(%eax),%edx
	return shell->ctx->internal.flags.echo == 1 ? true : false;
    726a:	8b 8a 60 02 00 00    	mov    0x260(%edx),%ecx
    7270:	ba 7e 90 02 00       	mov    $0x2907e,%edx
    7275:	80 e1 04             	and    $0x4,%cl
    7278:	75 05                	jne    727f <cmd_echo+0x48>
    727a:	ba 03 70 02 00       	mov    $0x27003,%edx
    727f:	52                   	push   %edx
    7280:	68 25 70 02 00       	push   $0x27025
    7285:	6a 00                	push   $0x0
    7287:	50                   	push   %eax
    7288:	e8 35 e9 ff ff       	call   5bc2 <shell_fprintf>
    728d:	83 c4 10             	add    $0x10,%esp
	return 0;
    7290:	31 c0                	xor    %eax,%eax
}
    7292:	c9                   	leave  
    7293:	c3                   	ret    

00007294 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
    7294:	55                   	push   %ebp
    7295:	89 e5                	mov    %esp,%ebp
    7297:	57                   	push   %edi
    7298:	56                   	push   %esi
    7299:	53                   	push   %ebx
    729a:	83 ec 0c             	sub    $0xc,%esp
    729d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    72a0:	8b 45 10             	mov    0x10(%ebp),%eax
	if (!IS_ENABLED(CONFIG_SHELL_CMDS_RESIZE)) {
		shell_error(shell, "Command not supported.");
		return -ENOEXEC;
	}

	if (argc != 1) {
    72a3:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    72a7:	74 24                	je     72cd <cmd_resize+0x39>
		shell_error(shell, "%s:%s%s", argv[0],
    72a9:	ff 70 04             	pushl  0x4(%eax)
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
    72ac:	be ea ff ff ff       	mov    $0xffffffea,%esi
		shell_error(shell, "%s:%s%s", argv[0],
    72b1:	68 07 70 02 00       	push   $0x27007
    72b6:	ff 30                	pushl  (%eax)
    72b8:	68 1c 70 02 00       	push   $0x2701c
    72bd:	6a 02                	push   $0x2
    72bf:	53                   	push   %ebx
    72c0:	e8 fd e8 ff ff       	call   5bc2 <shell_fprintf>
    72c5:	83 c4 18             	add    $0x18,%esp
		return -EINVAL;
    72c8:	e9 b3 01 00 00       	jmp    7480 <cmd_resize+0x1ec>
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
    72cd:	68 73 70 02 00       	push   $0x27073
    72d2:	68 6a a5 02 00       	push   $0x2a56a
    72d7:	ff 73 14             	pushl  0x14(%ebx)
    72da:	e8 30 fe ff ff       	call   710f <shell_raw_fprintf>
    72df:	83 c4 0c             	add    $0xc,%esp
	shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
    72e2:	68 06 ff ff ff       	push   $0xffffff06
    72e7:	53                   	push   %ebx
    72e8:	e8 17 ef ff ff       	call   6204 <shell_op_cursor_vert_move>
    72ed:	5a                   	pop    %edx
    72ee:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
    72ef:	68 fa 00 00 00       	push   $0xfa
    72f4:	53                   	push   %ebx
    72f5:	e8 39 ef ff ff       	call   6233 <shell_op_cursor_horiz_move>
    72fa:	5e                   	pop    %esi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    72fb:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
    72fe:	5f                   	pop    %edi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    72ff:	05 42 01 00 00       	add    $0x142,%eax
    7304:	68 00 01 00 00       	push   $0x100
	char c = 0;
    7309:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    730d:	6a 00                	push   $0x0
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
    730f:	bf e8 03 00 00       	mov    $0x3e8,%edi
    7314:	50                   	push   %eax
    7315:	e8 86 36 00 00       	call   a9a0 <memset>
    731a:	83 c4 0c             	add    $0xc,%esp
	u16_t buff_idx = 0U;
    731d:	31 f6                	xor    %esi,%esi
	shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
    731f:	68 f0 5e 02 00       	push   $0x25ef0
    7324:	ff 73 14             	pushl  0x14(%ebx)
    7327:	e8 e3 fd ff ff       	call   710f <shell_raw_fprintf>
    732c:	58                   	pop    %eax
    732d:	5a                   	pop    %edx
    732e:	ff 73 14             	pushl  0x14(%ebx)
    7331:	e8 fe e8 ff ff       	call   5c34 <shell_fprintf_buffer_flush>
    7336:	59                   	pop    %ecx
			(void)shell->iface->api->read(shell->iface, &c,
    7337:	8b 43 04             	mov    0x4(%ebx),%eax
    733a:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    733d:	8b 10                	mov    (%eax),%edx
    733f:	51                   	push   %ecx
    7340:	6a 01                	push   $0x1
    7342:	8d 4d ef             	lea    -0x11(%ebp),%ecx
    7345:	51                   	push   %ecx
    7346:	50                   	push   %eax
    7347:	ff 52 10             	call   *0x10(%edx)
    734a:	83 c4 10             	add    $0x10,%esp
			if (cnt == 0) {
    734d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7351:	75 14                	jne    7367 <cmd_resize+0xd3>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_BUSY_WAIT, k_busy_wait, u32_t, usec_to_wait)
    7353:	68 e8 03 00 00       	push   $0x3e8
    7358:	e8 fb cd 01 00       	call   24158 <z_impl_k_busy_wait>
	for (u16_t i = 0; i < 1000; i++) {
    735d:	66 4f                	dec    %di
    735f:	58                   	pop    %eax
    7360:	75 d5                	jne    7337 <cmd_resize+0xa3>
    7362:	e9 dc 00 00 00       	jmp    7443 <cmd_resize+0x1af>
			if ((c != SHELL_VT100_ASCII_ESC) &&
    7367:	8a 55 ef             	mov    -0x11(%ebp),%dl
    736a:	8b 43 08             	mov    0x8(%ebx),%eax
    736d:	80 fa 1b             	cmp    $0x1b,%dl
    7370:	0f 84 b1 00 00 00    	je     7427 <cmd_resize+0x193>
    7376:	80 b8 42 01 00 00 1b 	cmpb   $0x1b,0x142(%eax)
    737d:	75 b8                	jne    7337 <cmd_resize+0xa3>
			if (c == 'R') { /* End of response from the terminal. */
    737f:	80 fa 52             	cmp    $0x52,%dl
    7382:	0f 85 9f 00 00 00    	jne    7427 <cmd_resize+0x193>
				shell->ctx->temp_buff[buff_idx] = '\0';
    7388:	0f b7 f6             	movzwl %si,%esi
				if (shell->ctx->temp_buff[1] != '[') {
    738b:	31 ff                	xor    %edi,%edi
	*y = 0U;
    738d:	31 d2                	xor    %edx,%edx
				shell->ctx->temp_buff[buff_idx] = '\0';
    738f:	c6 84 30 42 01 00 00 	movb   $0x0,0x142(%eax,%esi,1)
    7396:	00 
				if (shell->ctx->temp_buff[1] != '[') {
    7397:	80 b8 43 01 00 00 5b 	cmpb   $0x5b,0x143(%eax)
    739e:	0f 85 98 00 00 00    	jne    743c <cmd_resize+0x1a8>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    73a4:	66 0f be 8c 38 44 01 	movsbw 0x144(%eax,%edi,1),%cx
    73ab:	00 00 
    73ad:	8d 77 03             	lea    0x3(%edi),%esi
    73b0:	80 f9 3b             	cmp    $0x3b,%cl
    73b3:	74 12                	je     73c7 <cmd_resize+0x133>
					*y = *y * 10 +
    73b5:	6b d2 0a             	imul   $0xa,%edx,%edx
    73b8:	47                   	inc    %edi
    73b9:	8d 54 0a d0          	lea    -0x30(%edx,%ecx,1),%edx
					if (buff_idx >=
    73bd:	81 ff fe 00 00 00    	cmp    $0xfe,%edi
    73c3:	75 df                	jne    73a4 <cmd_resize+0x110>
    73c5:	eb 7c                	jmp    7443 <cmd_resize+0x1af>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    73c7:	66 81 fe 00 01       	cmp    $0x100,%si
    73cc:	74 75                	je     7443 <cmd_resize+0x1af>
    73ce:	0f b7 ce             	movzwl %si,%ecx
    73d1:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
    73d4:	89 7d e8             	mov    %edi,-0x18(%ebp)
	*x = 0U;
    73d7:	31 ff                	xor    %edi,%edi
				while (shell->ctx->temp_buff[buff_idx]
    73d9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    73dc:	66 0f be 89 42 01 00 	movsbw 0x142(%ecx),%cx
    73e3:	00 
    73e4:	84 c9                	test   %cl,%cl
    73e6:	74 14                	je     73fc <cmd_resize+0x168>
					*x = *x * 10 +
    73e8:	6b ff 0a             	imul   $0xa,%edi,%edi
					(shell->ctx->temp_buff[buff_idx++] -
    73eb:	46                   	inc    %esi
    73ec:	ff 45 e8             	incl   -0x18(%ebp)
					if (buff_idx >=
    73ef:	66 81 fe ff 00       	cmp    $0xff,%si
					*x = *x * 10 +
    73f4:	8d 7c 0f d0          	lea    -0x30(%edi,%ecx,1),%edi
					if (buff_idx >=
    73f8:	76 df                	jbe    73d9 <cmd_resize+0x145>
    73fa:	eb 47                	jmp    7443 <cmd_resize+0x1af>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    73fc:	66 81 ff fa 00       	cmp    $0xfa,%di
				shell->ctx->temp_buff[0] = 0;
    7401:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    7408:	76 05                	jbe    740f <cmd_resize+0x17b>
    740a:	bf fa 00 00 00       	mov    $0xfa,%edi
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    740f:	66 81 fa fa 00       	cmp    $0xfa,%dx
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    7414:	66 89 78 2a          	mov    %di,0x2a(%eax)
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    7418:	76 05                	jbe    741f <cmd_resize+0x18b>
    741a:	ba fa 00 00 00       	mov    $0xfa,%edx
    741f:	66 89 50 28          	mov    %dx,0x28(%eax)
	int ret_val = 0;
    7423:	31 f6                	xor    %esi,%esi
    7425:	eb 21                	jmp    7448 <cmd_resize+0x1b4>
			shell->ctx->temp_buff[buff_idx] = c;
    7427:	0f b7 ce             	movzwl %si,%ecx
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    742a:	46                   	inc    %esi
    742b:	66 83 fe 09          	cmp    $0x9,%si
			shell->ctx->temp_buff[buff_idx] = c;
    742f:	88 94 08 42 01 00 00 	mov    %dl,0x142(%eax,%ecx,1)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    7436:	0f 86 fb fe ff ff    	jbe    7337 <cmd_resize+0xa3>
				shell->ctx->temp_buff[0] = 0;
    743c:	c6 80 42 01 00 00 00 	movb   $0x0,0x142(%eax)
		ret_val = -ENOTSUP;
    7443:	be dd ff ff ff       	mov    $0xffffffdd,%esi
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
    7448:	68 70 70 02 00       	push   $0x27070
    744d:	68 6a a5 02 00       	push   $0x2a56a
    7452:	ff 73 14             	pushl  0x14(%ebx)
    7455:	e8 b5 fc ff ff       	call   710f <shell_raw_fprintf>
    745a:	83 c4 0c             	add    $0xc,%esp
	}

	err = terminal_size_get(shell);
	if (err != 0) {
    745d:	85 f6                	test   %esi,%esi
    745f:	74 1f                	je     7480 <cmd_resize+0x1ec>
		shell->ctx->vt100_ctx.cons.terminal_wid =
				SHELL_DEFAULT_TERMINAL_WIDTH;
		shell->ctx->vt100_ctx.cons.terminal_hei =
    7461:	8b 43 08             	mov    0x8(%ebx),%eax
				SHELL_DEFAULT_TERMINAL_HEIGHT;
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    7464:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
		shell->ctx->vt100_ctx.cons.terminal_hei =
    7469:	c7 40 28 18 00 50 00 	movl   $0x500018,0x28(%eax)
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    7470:	68 36 70 02 00       	push   $0x27036
    7475:	6a 04                	push   $0x4
    7477:	53                   	push   %ebx
    7478:	e8 45 e7 ff ff       	call   5bc2 <shell_fprintf>
    747d:	83 c4 0c             	add    $0xc,%esp
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
    7480:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7483:	89 f0                	mov    %esi,%eax
    7485:	5b                   	pop    %ebx
    7486:	5e                   	pop    %esi
    7487:	5f                   	pop    %edi
    7488:	5d                   	pop    %ebp
    7489:	c3                   	ret    

0000748a <remove_from_tail>:
	item->data[len] = '\0';
	sys_dlist_prepend(&history->list, &item->dnode);
}

static void remove_from_tail(struct shell_history *history)
{
    748a:	55                   	push   %ebp
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;

	l_item = sys_dlist_peek_tail(&history->list);
    748b:	8d 50 04             	lea    0x4(%eax),%edx
{
    748e:	89 e5                	mov    %esp,%ebp
    7490:	53                   	push   %ebx
    7491:	51                   	push   %ecx
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    7492:	39 50 04             	cmp    %edx,0x4(%eax)
    7495:	74 2f                	je     74c6 <remove_from_tail+0x3c>
    7497:	8b 50 08             	mov    0x8(%eax),%edx
	l_item = sys_dlist_peek_tail(&history->list);
    749a:	89 55 f8             	mov    %edx,-0x8(%ebp)
	node->prev->next = node->next;
    749d:	8b 5a 04             	mov    0x4(%edx),%ebx
    74a0:	8b 0a                	mov    (%edx),%ecx
    74a2:	89 0b                	mov    %ecx,(%ebx)
	node->next->prev = node->prev;
    74a4:	89 59 04             	mov    %ebx,0x4(%ecx)
	node->next = NULL;
    74a7:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	node->prev = NULL;
    74ad:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	sys_dlist_remove(l_item);

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
	k_mem_slab_free(history->mem_slab, (void **)&l_item);
    74b4:	8d 55 f8             	lea    -0x8(%ebp),%edx
    74b7:	52                   	push   %edx
    74b8:	ff 30                	pushl  (%eax)
    74ba:	e8 74 ba 01 00       	call   22f33 <k_mem_slab_free>
}
    74bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	k_mem_slab_free(history->mem_slab, (void **)&l_item);
    74c2:	58                   	pop    %eax
    74c3:	5a                   	pop    %edx
}
    74c4:	c9                   	leave  
    74c5:	c3                   	ret    
	l_item = sys_dlist_peek_tail(&history->list);
    74c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	node->prev->next = node->next;
    74cd:	a1 04 00 00 00       	mov    0x4,%eax
    74d2:	0f 0b                	ud2    

000074d4 <shell_history_mode_exit>:
{
    74d4:	55                   	push   %ebp
    74d5:	89 e5                	mov    %esp,%ebp
	history->current = NULL;
    74d7:	8b 45 08             	mov    0x8(%ebp),%eax
    74da:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    74e1:	5d                   	pop    %ebp
    74e2:	c3                   	ret    

000074e3 <shell_history_get>:
{
    74e3:	55                   	push   %ebp
    74e4:	89 e5                	mov    %esp,%ebp
    74e6:	57                   	push   %edi
    74e7:	56                   	push   %esi
    74e8:	8b 45 08             	mov    0x8(%ebp),%eax
    74eb:	53                   	push   %ebx
    74ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    74ef:	8b 75 10             	mov    0x10(%ebp),%esi
	return list->head == list;
    74f2:	8b 58 04             	mov    0x4(%eax),%ebx
	if (sys_dlist_is_empty(&history->list)) {
    74f5:	8d 50 04             	lea    0x4(%eax),%edx
{
    74f8:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (sys_dlist_is_empty(&history->list)) {
    74fb:	39 d3                	cmp    %edx,%ebx
    74fd:	75 09                	jne    7508 <shell_history_get+0x25>
		*len = 0;
    74ff:	66 c7 07 00 00       	movw   $0x0,(%edi)
		return false;
    7504:	31 c0                	xor    %eax,%eax
    7506:	eb 4e                	jmp    7556 <shell_history_get+0x73>
	if (!up) { /* button down */
    7508:	8b 50 0c             	mov    0xc(%eax),%edx
    750b:	84 c9                	test   %cl,%cl
    750d:	75 16                	jne    7525 <shell_history_get+0x42>
		if (history->current == NULL) {
    750f:	85 d2                	test   %edx,%edx
    7511:	74 ec                	je     74ff <shell_history_get+0x1c>
	return (node == list->head) ? NULL : node->prev;
    7513:	39 d3                	cmp    %edx,%ebx
    7515:	75 09                	jne    7520 <shell_history_get+0x3d>
	history->current = l_item;
    7517:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	if (h_item) {
    751e:	eb df                	jmp    74ff <shell_history_get+0x1c>
    7520:	8b 5a 04             	mov    0x4(%edx),%ebx
    7523:	eb 0b                	jmp    7530 <shell_history_get+0x4d>
		sys_dlist_peek_head_not_empty(&history->list) :
    7525:	85 d2                	test   %edx,%edx
    7527:	74 07                	je     7530 <shell_history_get+0x4d>
	return (node == list->tail) ? NULL : node->next;
    7529:	39 50 08             	cmp    %edx,0x8(%eax)
    752c:	74 e9                	je     7517 <shell_history_get+0x34>
    752e:	8b 1a                	mov    (%edx),%ebx
	history->current = l_item;
    7530:	89 58 0c             	mov    %ebx,0xc(%eax)
	if (h_item) {
    7533:	85 db                	test   %ebx,%ebx
    7535:	74 c8                	je     74ff <shell_history_get+0x1c>
		memcpy(dst, h_item->data, h_item->len);
    7537:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    753b:	50                   	push   %eax
    753c:	8d 43 0a             	lea    0xa(%ebx),%eax
    753f:	50                   	push   %eax
    7540:	56                   	push   %esi
    7541:	e8 eb 33 00 00       	call   a931 <memcpy>
		*len = h_item->len;
    7546:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
		memcpy(dst, h_item->data, h_item->len);
    754a:	83 c4 0c             	add    $0xc,%esp
		*len = h_item->len;
    754d:	66 89 07             	mov    %ax,(%edi)
		dst[*len] = '\0';
    7550:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
		return true;
    7554:	b0 01                	mov    $0x1,%al
}
    7556:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7559:	5b                   	pop    %ebx
    755a:	5e                   	pop    %esi
    755b:	5f                   	pop    %edi
    755c:	5d                   	pop    %ebp
    755d:	c3                   	ret    

0000755e <shell_history_purge>:

void shell_history_purge(struct shell_history *history)
{
    755e:	55                   	push   %ebp
    755f:	89 e5                	mov    %esp,%ebp
    7561:	53                   	push   %ebx
    7562:	8b 5d 08             	mov    0x8(%ebp),%ebx
	while (!sys_dlist_is_empty(&history->list)) {
    7565:	8d 43 04             	lea    0x4(%ebx),%eax
    7568:	39 43 04             	cmp    %eax,0x4(%ebx)
    756b:	74 09                	je     7576 <shell_history_purge+0x18>
		remove_from_tail(history);
    756d:	89 d8                	mov    %ebx,%eax
    756f:	e8 16 ff ff ff       	call   748a <remove_from_tail>
    7574:	eb ef                	jmp    7565 <shell_history_purge+0x7>
	}
}
    7576:	5b                   	pop    %ebx
    7577:	5d                   	pop    %ebp
    7578:	c3                   	ret    

00007579 <shell_history_put>:

void shell_history_put(struct shell_history *history, u8_t *line, size_t len)
{
    7579:	55                   	push   %ebp
    757a:	89 e5                	mov    %esp,%ebp
    757c:	57                   	push   %edi
    757d:	56                   	push   %esi
    757e:	53                   	push   %ebx
    757f:	83 ec 08             	sub    $0x8,%esp
    7582:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7585:	8b 75 10             	mov    0x10(%ebp),%esi
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;

	shell_history_mode_exit(history);

	if (len == 0) {
    7588:	85 f6                	test   %esi,%esi
	history->current = NULL;
    758a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	if (len == 0) {
    7591:	0f 84 87 00 00 00    	je     761e <shell_history_put+0xa5>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
    7597:	8d 7b 04             	lea    0x4(%ebx),%edi
	return list->head == list;
    759a:	8b 43 04             	mov    0x4(%ebx),%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
    759d:	39 c7                	cmp    %eax,%edi
    759f:	75 09                	jne    75aa <shell_history_put+0x31>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    75a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (h_item &&
    75a8:	eb 27                	jmp    75d1 <shell_history_put+0x58>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    75aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (h_item &&
    75ad:	85 c0                	test   %eax,%eax
    75af:	74 20                	je     75d1 <shell_history_put+0x58>
	   (h_item->len == len) &&
    75b1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
	if (h_item &&
    75b5:	39 f2                	cmp    %esi,%edx
    75b7:	75 18                	jne    75d1 <shell_history_put+0x58>
	   (strncmp(h_item->data, line, CONFIG_SHELL_CMD_BUFF_SIZE) == 0)) {
    75b9:	68 00 01 00 00       	push   $0x100
    75be:	83 c0 0a             	add    $0xa,%eax
    75c1:	ff 75 0c             	pushl  0xc(%ebp)
    75c4:	50                   	push   %eax
    75c5:	e8 cc 32 00 00       	call   a896 <strncmp>
    75ca:	83 c4 0c             	add    $0xc,%esp
	   (h_item->len == len) &&
    75cd:	85 c0                	test   %eax,%eax
    75cf:	74 4d                	je     761e <shell_history_put+0xa5>
		/* Same command as before, do not store */
		return;
	}

	while (k_mem_slab_alloc(history->mem_slab, (void **)&h_item, K_NO_WAIT)
    75d1:	6a 00                	push   $0x0
    75d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
    75d6:	50                   	push   %eax
    75d7:	ff 33                	pushl  (%ebx)
    75d9:	e8 ef b8 01 00       	call   22ecd <k_mem_slab_alloc>
    75de:	83 c4 0c             	add    $0xc,%esp
    75e1:	85 c0                	test   %eax,%eax
    75e3:	74 09                	je     75ee <shell_history_put+0x75>
			!= 0) {
		/* if no space remove the oldest entry. */
		remove_from_tail(history);
    75e5:	89 d8                	mov    %ebx,%eax
    75e7:	e8 9e fe ff ff       	call   748a <remove_from_tail>
    75ec:	eb e3                	jmp    75d1 <shell_history_put+0x58>
	}

	add_to_head(history, h_item, line, len);
    75ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
	memcpy(item->data, src, len);
    75f1:	89 55 ec             	mov    %edx,-0x14(%ebp)
	item->len = len;
    75f4:	66 89 72 08          	mov    %si,0x8(%edx)
	memcpy(item->data, src, len);
    75f8:	56                   	push   %esi
    75f9:	ff 75 0c             	pushl  0xc(%ebp)
    75fc:	8d 42 0a             	lea    0xa(%edx),%eax
    75ff:	50                   	push   %eax
    7600:	e8 2c 33 00 00       	call   a931 <memcpy>
	item->data[len] = '\0';
    7605:	8b 55 ec             	mov    -0x14(%ebp),%edx
	memcpy(item->data, src, len);
    7608:	83 c4 0c             	add    $0xc,%esp
	item->data[len] = '\0';
    760b:	c6 44 32 0a 00       	movb   $0x0,0xa(%edx,%esi,1)
	node->next = list->head;
    7610:	8b 43 04             	mov    0x4(%ebx),%eax
	node->prev = list;
    7613:	89 7a 04             	mov    %edi,0x4(%edx)
	node->next = list->head;
    7616:	89 02                	mov    %eax,(%edx)
	list->head->prev = node;
    7618:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
    761b:	89 53 04             	mov    %edx,0x4(%ebx)
}
    761e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7621:	5b                   	pop    %ebx
    7622:	5e                   	pop    %esi
    7623:	5f                   	pop    %edi
    7624:	5d                   	pop    %ebp
    7625:	c3                   	ret    

00007626 <shell_history_init>:

void shell_history_init(struct shell_history *history)
{
    7626:	55                   	push   %ebp
    7627:	89 e5                	mov    %esp,%ebp
    7629:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dlist_init(&history->list);
    762c:	8d 50 04             	lea    0x4(%eax),%edx
	history->current = NULL;
    762f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
    7636:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail = (sys_dnode_t *)list;
    7639:	89 50 08             	mov    %edx,0x8(%eax)
}
    763c:	5d                   	pop    %ebp
    763d:	c3                   	ret    

0000763e <put>:

	return true;
}

static void put(const struct log_backend *const backend, struct log_msg *msg)
{
    763e:	55                   	push   %ebp
    763f:	89 e5                	mov    %esp,%ebp
    7641:	57                   	push   %edi
    7642:	56                   	push   %esi
    7643:	53                   	push   %ebx
    7644:	83 ec 18             	sub    $0x18,%esp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    7647:	8b 45 08             	mov    0x8(%ebp),%eax
{
    764a:	8b 75 0c             	mov    0xc(%ebp),%esi
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    764d:	8b 40 04             	mov    0x4(%eax),%eax
    7650:	8b 18                	mov    (%eax),%ebx
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			shell->ctx->internal.flags.use_colors;
    7652:	8b 43 08             	mov    0x8(%ebx),%eax
    7655:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
	struct k_poll_signal *signal;

	log_msg_get(msg);
    765b:	56                   	push   %esi
			shell->ctx->internal.flags.use_colors;
    765c:	d1 e8                	shr    %eax
    765e:	89 c7                	mov    %eax,%edi
	log_msg_get(msg);
    7660:	e8 91 c3 ff ff       	call   39f6 <log_msg_get>
    7665:	58                   	pop    %eax

	switch (shell->log_backend->control_block->state) {
    7666:	8b 43 1c             	mov    0x1c(%ebx),%eax
			shell->ctx->internal.flags.use_colors;
    7669:	83 e7 01             	and    $0x1,%edi
	switch (shell->log_backend->control_block->state) {
    766c:	8b 40 0c             	mov    0xc(%eax),%eax
    766f:	8b 40 04             	mov    0x4(%eax),%eax
    7672:	83 f8 01             	cmp    $0x1,%eax
    7675:	74 2f                	je     76a6 <put+0x68>
    7677:	83 f8 03             	cmp    $0x3,%eax
    767a:	0f 85 c7 00 00 00    	jne    7747 <put+0x109>
			k_poll_signal_raise(signal, 0);
		}

		break;
	case SHELL_LOG_BACKEND_PANIC:
		shell_cmd_line_erase(shell);
    7680:	53                   	push   %ebx
    7681:	e8 a3 ee ff ff       	call   6529 <shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
    7686:	8b 43 1c             	mov    0x1c(%ebx),%eax
    7689:	8b 50 08             	mov    0x8(%eax),%edx
		flags |= LOG_OUTPUT_FLAG_COLORS;
    768c:	89 f8                	mov    %edi,%eax
    768e:	83 e0 01             	and    $0x1,%eax
    7691:	83 c0 0e             	add    $0xe,%eax
	log_output_msg_process(log_output, msg, flags);
    7694:	89 04 24             	mov    %eax,(%esp)
    7697:	56                   	push   %esi
    7698:	52                   	push   %edx
    7699:	e8 ae cb ff ff       	call   424c <log_output_msg_process>
    769e:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
    76a1:	e9 a1 00 00 00       	jmp    7747 <put+0x109>
		msg_to_fifo(shell, msg);
    76a6:	89 75 e0             	mov    %esi,-0x20(%ebp)
	struct shell_log_backend_msg t_msg = {
    76a9:	89 75 e4             	mov    %esi,-0x1c(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    76ac:	e8 41 d2 01 00       	call   248f2 <z_impl_k_uptime_get_32>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_PUT, k_msgq_put, int, struct k_msgq *, q, void *, data, s32_t, timeout)
    76b1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    76b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
			 shell->log_backend->timeout);
    76b7:	8b 43 1c             	mov    0x1c(%ebx),%eax
    76ba:	ff 70 10             	pushl  0x10(%eax)
    76bd:	52                   	push   %edx
    76be:	ff 70 04             	pushl  0x4(%eax)
    76c1:	e8 20 bb 01 00       	call   231e6 <z_impl_k_msgq_put>
    76c6:	83 c4 0c             	add    $0xc,%esp
	switch (err) {
    76c9:	83 f8 b0             	cmp    $0xffffffb0,%eax
    76cc:	74 05                	je     76d3 <put+0x95>
    76ce:	83 f8 f5             	cmp    $0xfffffff5,%eax
    76d1:	75 60                	jne    7733 <put+0xf5>
	struct k_msgq *msgq = shell->log_backend->msgq;
    76d3:	8b 43 1c             	mov    0x1c(%ebx),%eax
    76d6:	8b 70 04             	mov    0x4(%eax),%esi
	u32_t timeout = shell->log_backend->timeout;
    76d9:	8b 40 10             	mov    0x10(%eax),%eax
    76dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    76df:	e8 0e d2 01 00       	call   248f2 <z_impl_k_uptime_get_32>
    76e4:	89 c7                	mov    %eax,%edi
K_SYSCALL_DECLARE2(K_SYSCALL_K_MSGQ_PEEK, k_msgq_peek, int, struct k_msgq *, q, void *, data)
    76e6:	8d 55 ec             	lea    -0x14(%ebp),%edx
    76e9:	52                   	push   %edx
    76ea:	56                   	push   %esi
    76eb:	e8 95 bc 01 00       	call   23385 <z_impl_k_msgq_peek>
    76f0:	5a                   	pop    %edx
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
    76f1:	85 c0                	test   %eax,%eax
    76f3:	59                   	pop    %ecx
    76f4:	75 29                	jne    771f <put+0xe1>
    76f6:	89 f8                	mov    %edi,%eax
    76f8:	2b 45 f0             	sub    -0x10(%ebp),%eax
    76fb:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    76fe:	73 1f                	jae    771f <put+0xe1>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_GET, k_msgq_get, int, struct k_msgq *, q, void *, data, s32_t, timeout)
    7700:	6a 00                	push   $0x0
    7702:	8d 55 ec             	lea    -0x14(%ebp),%edx
    7705:	52                   	push   %edx
    7706:	56                   	push   %esi
    7707:	e8 9f bb 01 00       	call   232ab <z_impl_k_msgq_get>
    770c:	83 c4 0c             	add    $0xc,%esp
			log_msg_put(msg.msg);
    770f:	ff 75 ec             	pushl  -0x14(%ebp)
    7712:	e8 42 c4 ff ff       	call   3b59 <log_msg_put>
    7717:	58                   	pop    %eax
				shell->stats->log_lost_cnt++;
    7718:	8b 43 18             	mov    0x18(%ebx),%eax
    771b:	ff 00                	incl   (%eax)
    771d:	eb c7                	jmp    76e6 <put+0xa8>
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_PUT, k_msgq_put, int, struct k_msgq *, q, void *, data, s32_t, timeout)
    771f:	6a 00                	push   $0x0
    7721:	8d 45 e0             	lea    -0x20(%ebp),%eax
    7724:	50                   	push   %eax
		err = k_msgq_put(shell->log_backend->msgq, &msg, K_NO_WAIT);
    7725:	8b 43 1c             	mov    0x1c(%ebx),%eax
    7728:	ff 70 04             	pushl  0x4(%eax)
    772b:	e8 b6 ba 01 00       	call   231e6 <z_impl_k_msgq_put>
    7730:	83 c4 0c             	add    $0xc,%esp
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
    7733:	8b 43 08             	mov    0x8(%ebx),%eax
K_SYSCALL_DECLARE2(K_SYSCALL_K_POLL_SIGNAL_RAISE, k_poll_signal_raise, int, struct k_poll_signal *, signal, int, result)
    7736:	6a 00                	push   $0x0
    7738:	05 74 02 00 00       	add    $0x274,%eax
    773d:	50                   	push   %eax
    773e:	e8 52 d5 01 00       	call   24c95 <z_impl_k_poll_signal_raise>
    7743:	5a                   	pop    %edx
    7744:	59                   	pop    %ecx
    7745:	eb 07                	jmp    774e <put+0x110>
	case SHELL_LOG_BACKEND_DISABLED:
		/* fall through */
		/* no break */
	default:
		/* Discard message. */
		log_msg_put(msg);
    7747:	56                   	push   %esi
    7748:	e8 0c c4 ff ff       	call   3b59 <log_msg_put>
    774d:	58                   	pop    %eax
	}
}
    774e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7751:	5b                   	pop    %ebx
    7752:	5e                   	pop    %esi
    7753:	5f                   	pop    %edi
    7754:	5d                   	pop    %ebp
    7755:	c3                   	ret    

00007756 <dropped>:
		shell_log_backend_disable(shell->log_backend);
	}
}

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
    7756:	55                   	push   %ebp
    7757:	89 e5                	mov    %esp,%ebp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    7759:	8b 45 08             	mov    0x8(%ebp),%eax
{
    775c:	8b 55 0c             	mov    0xc(%ebp),%edx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    775f:	8b 40 04             	mov    0x4(%eax),%eax
    7762:	8b 00                	mov    (%eax),%eax
	const struct shell_log_backend *log_backend = shell->log_backend;
    7764:	8b 48 1c             	mov    0x1c(%eax),%ecx
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    7767:	8b 40 18             	mov    0x18(%eax),%eax
    776a:	f0 01 10             	lock add %edx,(%eax)
    776d:	8b 41 0c             	mov    0xc(%ecx),%eax
    7770:	f0 01 10             	lock add %edx,(%eax)

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
    7773:	5d                   	pop    %ebp
    7774:	c3                   	ret    

00007775 <shell_log_backend_output_func>:
{
    7775:	55                   	push   %ebp
    7776:	89 e5                	mov    %esp,%ebp
    7778:	53                   	push   %ebx
    7779:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	shell_print_stream(ctx, data, length);
    777c:	53                   	push   %ebx
    777d:	ff 75 08             	pushl  0x8(%ebp)
    7780:	ff 75 10             	pushl  0x10(%ebp)
    7783:	e8 a0 ee ff ff       	call   6628 <shell_print_stream>
}
    7788:	89 d8                	mov    %ebx,%eax
	shell_print_stream(ctx, data, length);
    778a:	83 c4 0c             	add    $0xc,%esp
}
    778d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7790:	c9                   	leave  
    7791:	c3                   	ret    

00007792 <shell_log_backend_enable>:
{
    7792:	55                   	push   %ebp
    7793:	89 e5                	mov    %esp,%ebp
    7795:	56                   	push   %esi
    7796:	53                   	push   %ebx
		log_backend_enable(backend->backend, ctx, init_log_level);
    7797:	ff 75 10             	pushl  0x10(%ebp)
{
    779a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    779d:	8b 75 0c             	mov    0xc(%ebp),%esi
		log_backend_enable(backend->backend, ctx, init_log_level);
    77a0:	56                   	push   %esi
    77a1:	ff 33                	pushl  (%ebx)
    77a3:	e8 f0 be ff ff       	call   3698 <log_backend_enable>
		log_output_ctx_set(backend->log_output, ctx);
    77a8:	8b 43 08             	mov    0x8(%ebx),%eax
    77ab:	8b 40 04             	mov    0x4(%eax),%eax
		log_backend_enable(backend->backend, ctx, init_log_level);
    77ae:	83 c4 0c             	add    $0xc,%esp
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
    77b1:	89 70 04             	mov    %esi,0x4(%eax)
	backend->control_block->dropped_cnt = 0;
    77b4:	8b 43 0c             	mov    0xc(%ebx),%eax
    77b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
    77bd:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
}
    77c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    77c7:	5b                   	pop    %ebx
    77c8:	5e                   	pop    %esi
    77c9:	5d                   	pop    %ebp
    77ca:	c3                   	ret    

000077cb <shell_log_backend_disable>:
{
    77cb:	55                   	push   %ebp
    77cc:	89 e5                	mov    %esp,%ebp
    77ce:	53                   	push   %ebx
    77cf:	83 ec 08             	sub    $0x8,%esp
    77d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
K_SYSCALL_DECLARE3(K_SYSCALL_K_MSGQ_GET, k_msgq_get, int, struct k_msgq *, q, void *, data, s32_t, timeout)
    77d5:	6a 00                	push   $0x0
    77d7:	8d 45 f4             	lea    -0xc(%ebp),%eax
    77da:	50                   	push   %eax
    77db:	ff 73 04             	pushl  0x4(%ebx)
    77de:	e8 c8 ba 01 00       	call   232ab <z_impl_k_msgq_get>
    77e3:	83 c4 0c             	add    $0xc,%esp
	return (err == 0) ? msg.msg : NULL;
    77e6:	85 c0                	test   %eax,%eax
    77e8:	75 10                	jne    77fa <shell_log_backend_disable+0x2f>
    77ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
	while ((msg = msg_from_fifo(backend)) != NULL) {
    77ed:	85 c0                	test   %eax,%eax
    77ef:	74 09                	je     77fa <shell_log_backend_disable+0x2f>
		log_msg_put(msg);
    77f1:	50                   	push   %eax
    77f2:	e8 62 c3 ff ff       	call   3b59 <log_msg_put>
    77f7:	5a                   	pop    %edx
    77f8:	eb db                	jmp    77d5 <shell_log_backend_disable+0xa>
	log_backend_disable(backend->backend);
    77fa:	ff 33                	pushl  (%ebx)
    77fc:	e8 ec bf ff ff       	call   37ed <log_backend_disable>
    7801:	58                   	pop    %eax
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    7802:	8b 43 0c             	mov    0xc(%ebx),%eax
}
    7805:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    7808:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
}
    780f:	c9                   	leave  
    7810:	c3                   	ret    

00007811 <shell_log_backend_process>:
{
    7811:	55                   	push   %ebp
    7812:	89 e5                	mov    %esp,%ebp
    7814:	57                   	push   %edi
    7815:	56                   	push   %esi
    7816:	53                   	push   %ebx
    7817:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    781a:	83 ec 0c             	sub    $0xc,%esp
    781d:	8b 55 08             	mov    0x8(%ebp),%edx
			(const struct shell *)backend->backend->cb->ctx;
    7820:	8b 02                	mov    (%edx),%eax
	const struct shell *shell =
    7822:	8b 40 04             	mov    0x4(%eax),%eax
    7825:	8b 18                	mov    (%eax),%ebx
			shell->ctx->internal.flags.use_colors;
    7827:	8b 43 08             	mov    0x8(%ebx),%eax
    782a:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
    7830:	6a 00                	push   $0x0
    7832:	d1 e8                	shr    %eax
    7834:	51                   	push   %ecx
    7835:	ff 72 04             	pushl  0x4(%edx)
    7838:	83 e0 01             	and    $0x1,%eax
    783b:	88 45 e8             	mov    %al,-0x18(%ebp)
    783e:	e8 68 ba 01 00       	call   232ab <z_impl_k_msgq_get>
    7843:	83 c4 0c             	add    $0xc,%esp
	return (err == 0) ? msg.msg : NULL;
    7846:	8b 55 08             	mov    0x8(%ebp),%edx
    7849:	85 c0                	test   %eax,%eax
    784b:	74 04                	je     7851 <shell_log_backend_process+0x40>
		return false;
    784d:	31 c0                	xor    %eax,%eax
    784f:	eb 7f                	jmp    78d0 <shell_log_backend_process+0xbf>
	return (err == 0) ? msg.msg : NULL;
    7851:	8b 7d ec             	mov    -0x14(%ebp),%edi
	if (!msg) {
    7854:	89 c6                	mov    %eax,%esi
		return false;
    7856:	31 c0                	xor    %eax,%eax
	if (!msg) {
    7858:	85 ff                	test   %edi,%edi
    785a:	74 74                	je     78d0 <shell_log_backend_process+0xbf>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    785c:	8b 42 0c             	mov    0xc(%edx),%eax
    785f:	87 30                	xchg   %esi,(%eax)
	if (dropped) {
    7861:	85 f6                	test   %esi,%esi
    7863:	74 48                	je     78ad <shell_log_backend_process+0x9c>
		if (colors) {
    7865:	80 7d e8 00          	cmpb   $0x0,-0x18(%ebp)
    7869:	74 25                	je     7890 <shell_log_backend_process+0x7f>
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
    786b:	8b 43 08             	mov    0x8(%ebx),%eax
    786e:	6a 08                	push   $0x8
    7870:	83 c0 30             	add    $0x30,%eax
    7873:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    7876:	50                   	push   %eax
    7877:	89 55 08             	mov    %edx,0x8(%ebp)
    787a:	51                   	push   %ecx
    787b:	e8 b1 30 00 00       	call   a931 <memcpy>
    7880:	83 c4 0c             	add    $0xc,%esp
			shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
    7883:	6a 02                	push   $0x2
    7885:	53                   	push   %ebx
    7886:	e8 a2 ed ff ff       	call   662d <shell_vt100_color_set>
    788b:	58                   	pop    %eax
    788c:	5a                   	pop    %edx
    788d:	8b 55 08             	mov    0x8(%ebp),%edx
		log_output_dropped_process(backend->log_output, dropped);
    7890:	56                   	push   %esi
    7891:	ff 72 08             	pushl  0x8(%edx)
    7894:	e8 f5 ca ff ff       	call   438e <log_output_dropped_process>
    7899:	5e                   	pop    %esi
    789a:	58                   	pop    %eax
		if (colors) {
    789b:	80 7d e8 00          	cmpb   $0x0,-0x18(%ebp)
    789f:	74 0c                	je     78ad <shell_log_backend_process+0x9c>
			shell_vt100_colors_restore(shell, &col);
    78a1:	8d 45 ec             	lea    -0x14(%ebp),%eax
    78a4:	50                   	push   %eax
    78a5:	53                   	push   %ebx
    78a6:	e8 d2 ed ff ff       	call   667d <shell_vt100_colors_restore>
    78ab:	5a                   	pop    %edx
    78ac:	59                   	pop    %ecx
	msg_process(shell->log_backend->log_output, msg, colors);
    78ad:	8b 43 1c             	mov    0x1c(%ebx),%eax
    78b0:	8b 50 08             	mov    0x8(%eax),%edx
		flags |= LOG_OUTPUT_FLAG_COLORS;
    78b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78b6:	83 e0 01             	and    $0x1,%eax
    78b9:	83 c0 0e             	add    $0xe,%eax
	log_output_msg_process(log_output, msg, flags);
    78bc:	50                   	push   %eax
    78bd:	57                   	push   %edi
    78be:	52                   	push   %edx
    78bf:	e8 88 c9 ff ff       	call   424c <log_output_msg_process>
    78c4:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
    78c7:	57                   	push   %edi
    78c8:	e8 8c c2 ff ff       	call   3b59 <log_msg_put>
    78cd:	58                   	pop    %eax
	return true;
    78ce:	b0 01                	mov    $0x1,%al
}
    78d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    78d3:	5b                   	pop    %ebx
    78d4:	5e                   	pop    %esi
    78d5:	5f                   	pop    %edi
    78d6:	5d                   	pop    %ebp
    78d7:	c3                   	ret    

000078d8 <panic>:
{
    78d8:	55                   	push   %ebp
    78d9:	89 e5                	mov    %esp,%ebp
    78db:	53                   	push   %ebx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    78dc:	8b 45 08             	mov    0x8(%ebp),%eax
    78df:	8b 40 04             	mov    0x4(%eax),%eax
    78e2:	8b 18                	mov    (%eax),%ebx
	err = shell->iface->api->enable(shell->iface, true);
    78e4:	8b 43 04             	mov    0x4(%ebx),%eax
    78e7:	8b 10                	mov    (%eax),%edx
    78e9:	6a 01                	push   $0x1
    78eb:	50                   	push   %eax
    78ec:	ff 52 08             	call   *0x8(%edx)
    78ef:	59                   	pop    %ecx
	if (err == 0) {
    78f0:	85 c0                	test   %eax,%eax
	err = shell->iface->api->enable(shell->iface, true);
    78f2:	5a                   	pop    %edx
	if (err == 0) {
    78f3:	8b 43 1c             	mov    0x1c(%ebx),%eax
    78f6:	75 4e                	jne    7946 <panic+0x6e>
		shell->log_backend->control_block->state =
    78f8:	8b 40 0c             	mov    0xc(%eax),%eax
    78fb:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
						  shell->ctx->cmd_buff_len);
    7902:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    7905:	83 c0 20             	add    $0x20,%eax
    7908:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
    790c:	52                   	push   %edx
    790d:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
    7911:	52                   	push   %edx
    7912:	50                   	push   %eax
    7913:	e8 2d e4 ff ff       	call   5d45 <shell_multiline_data_calc>
    7918:	83 c4 0c             	add    $0xc,%esp
		shell_op_cursor_vert_move(shell, -1);
    791b:	6a ff                	push   $0xffffffff
    791d:	53                   	push   %ebx
    791e:	e8 e1 e8 ff ff       	call   6204 <shell_op_cursor_vert_move>
    7923:	59                   	pop    %ecx
    7924:	58                   	pop    %eax
					   -shell->ctx->vt100_ctx.cons.cur_x);
    7925:	8b 43 08             	mov    0x8(%ebx),%eax
    7928:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		shell_op_cursor_horiz_move(shell,
    792c:	f7 d8                	neg    %eax
    792e:	50                   	push   %eax
    792f:	53                   	push   %ebx
    7930:	e8 fe e8 ff ff       	call   6233 <shell_op_cursor_horiz_move>
    7935:	58                   	pop    %eax
    7936:	5a                   	pop    %edx
		while (shell_log_backend_process(shell->log_backend)) {
    7937:	ff 73 1c             	pushl  0x1c(%ebx)
    793a:	e8 d2 fe ff ff       	call   7811 <shell_log_backend_process>
    793f:	5a                   	pop    %edx
    7940:	84 c0                	test   %al,%al
    7942:	75 f3                	jne    7937 <panic+0x5f>
    7944:	eb 0c                	jmp    7952 <panic+0x7a>
}
    7946:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_log_backend_disable(shell->log_backend);
    7949:	89 45 08             	mov    %eax,0x8(%ebp)
}
    794c:	c9                   	leave  
		shell_log_backend_disable(shell->log_backend);
    794d:	e9 79 fe ff ff       	jmp    77cb <shell_log_backend_disable>
}
    7952:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7955:	c9                   	leave  
    7956:	c3                   	ret    

00007957 <shell_wildcard_character_exist>:

	return ret_val;
}

bool shell_wildcard_character_exist(const char *str)
{
    7957:	55                   	push   %ebp
    7958:	89 e5                	mov    %esp,%ebp
    795a:	56                   	push   %esi
    795b:	53                   	push   %ebx
    795c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return str == NULL ? 0U : (u16_t)strlen(str);
    795f:	85 db                	test   %ebx,%ebx
    7961:	75 04                	jne    7967 <shell_wildcard_character_exist+0x10>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
    7963:	31 c0                	xor    %eax,%eax
    7965:	eb 26                	jmp    798d <shell_wildcard_character_exist+0x36>
    7967:	53                   	push   %ebx
    7968:	e8 f6 2e 00 00       	call   a863 <strlen>
    796d:	5a                   	pop    %edx
	for (size_t i = 0; i < str_len; i++) {
    796e:	31 d2                	xor    %edx,%edx
    7970:	0f b7 f0             	movzwl %ax,%esi
    7973:	39 f2                	cmp    %esi,%edx
    7975:	73 ec                	jae    7963 <shell_wildcard_character_exist+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
    7977:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
    797a:	80 f9 3f             	cmp    $0x3f,%cl
    797d:	0f 94 c0             	sete   %al
    7980:	80 f9 2a             	cmp    $0x2a,%cl
    7983:	0f 94 c1             	sete   %cl
    7986:	08 c8                	or     %cl,%al
    7988:	75 03                	jne    798d <shell_wildcard_character_exist+0x36>
	for (size_t i = 0; i < str_len; i++) {
    798a:	42                   	inc    %edx
    798b:	eb e6                	jmp    7973 <shell_wildcard_character_exist+0x1c>
}
    798d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7990:	5b                   	pop    %ebx
    7991:	5e                   	pop    %esi
    7992:	5d                   	pop    %ebp
    7993:	c3                   	ret    

00007994 <shell_wildcard_prepare>:

void shell_wildcard_prepare(const struct shell *shell)
{
    7994:	55                   	push   %ebp
    7995:	89 e5                	mov    %esp,%ebp
    7997:	53                   	push   %ebx
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    7998:	68 00 01 00 00       	push   $0x100
{
    799d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    79a0:	6a 00                	push   $0x0
    79a2:	8b 43 08             	mov    0x8(%ebx),%eax
    79a5:	05 42 01 00 00       	add    $0x142,%eax
    79aa:	50                   	push   %eax
    79ab:	e8 f0 2f 00 00       	call   a9a0 <memset>
	memcpy(shell->ctx->temp_buff,
			shell->ctx->cmd_buff,
			shell->ctx->cmd_buff_len);
    79b0:	8b 43 08             	mov    0x8(%ebx),%eax
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    79b3:	83 c4 0c             	add    $0xc,%esp
	memcpy(shell->ctx->temp_buff,
    79b6:	0f b7 50 3c          	movzwl 0x3c(%eax),%edx
    79ba:	52                   	push   %edx
			shell->ctx->cmd_buff,
    79bb:	8d 50 42             	lea    0x42(%eax),%edx
	memcpy(shell->ctx->temp_buff,
    79be:	52                   	push   %edx
    79bf:	05 42 01 00 00       	add    $0x142,%eax
    79c4:	50                   	push   %eax
    79c5:	e8 67 2f 00 00       	call   a931 <memcpy>
    79ca:	83 c4 0c             	add    $0xc,%esp

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	shell_spaces_trim(shell->ctx->temp_buff);
    79cd:	8b 43 08             	mov    0x8(%ebx),%eax
    79d0:	05 42 01 00 00       	add    $0x142,%eax
    79d5:	50                   	push   %eax
    79d6:	e8 82 e6 ff ff       	call   605d <shell_spaces_trim>
    79db:	8b 53 08             	mov    0x8(%ebx),%edx
    79de:	59                   	pop    %ecx
    79df:	81 c2 42 01 00 00    	add    $0x142,%edx
    79e5:	74 09                	je     79f0 <shell_wildcard_prepare+0x5c>
    79e7:	52                   	push   %edx
    79e8:	e8 76 2e 00 00       	call   a863 <strlen>
    79ed:	5a                   	pop    %edx
    79ee:	eb 02                	jmp    79f2 <shell_wildcard_prepare+0x5e>
    79f0:	31 c0                	xor    %eax,%eax

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
    79f2:	8b 53 08             	mov    0x8(%ebx),%edx
    79f5:	40                   	inc    %eax
}
    79f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
    79f9:	66 89 42 40          	mov    %ax,0x40(%edx)
}
    79fd:	c9                   	leave  
    79fe:	c3                   	ret    

000079ff <shell_wildcard_process>:


enum shell_wildcard_status shell_wildcard_process(const struct shell *shell,
					      const struct shell_cmd_entry *cmd,
					      const char *pattern)
{
    79ff:	55                   	push   %ebp
    7a00:	89 e5                	mov    %esp,%ebp
    7a02:	57                   	push   %edi
    7a03:	56                   	push   %esi
    7a04:	53                   	push   %ebx
    7a05:	83 ec 24             	sub    $0x24,%esp
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
    7a08:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    7a0c:	75 0a                	jne    7a18 <shell_wildcard_process+0x19>
		return ret_val;
    7a0e:	bb 03 00 00 00       	mov    $0x3,%ebx
    7a13:	e9 49 01 00 00       	jmp    7b61 <shell_wildcard_process+0x162>
	}

	if (!shell_wildcard_character_exist(pattern)) {
    7a18:	ff 75 10             	pushl  0x10(%ebp)
    7a1b:	e8 37 ff ff ff       	call   7957 <shell_wildcard_character_exist>
    7a20:	5a                   	pop    %edx
    7a21:	84 c0                	test   %al,%al
    7a23:	74 e9                	je     7a0e <shell_wildcard_process+0xf>
    7a25:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	size_t cnt = 0;
    7a2c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    7a33:	bb 02 00 00 00       	mov    $0x2,%ebx
    7a38:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (cmd->is_dynamic) {
    7a3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7a3e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7a41:	f7 da                	neg    %edx
    7a43:	8b 40 04             	mov    0x4(%eax),%eax
    7a46:	80 39 00             	cmpb   $0x0,(%ecx)
    7a49:	74 0f                	je     7a5a <shell_wildcard_process+0x5b>
		cmd->u.dynamic_get(idx, d_entry);
    7a4b:	8d 75 e0             	lea    -0x20(%ebp),%esi
    7a4e:	56                   	push   %esi
    7a4f:	52                   	push   %edx
    7a50:	ff d0                	call   *%eax
    7a52:	5f                   	pop    %edi
    7a53:	58                   	pop    %eax
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
    7a54:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    7a58:	eb 09                	jmp    7a63 <shell_wildcard_process+0x64>
		*entry = (cmd->u.entry[idx].syntax != NULL) ?
    7a5a:	6b 75 d4 ec          	imul   $0xffffffec,-0x2c(%ebp),%esi
    7a5e:	01 c6                	add    %eax,%esi
				&cmd->u.entry[idx] : NULL;
    7a60:	83 3e 00             	cmpl   $0x0,(%esi)
    7a63:	74 68                	je     7acd <shell_wildcard_process+0xce>
		if (fnmatch(pattern, p_static_entry->syntax, 0) == 0) {
    7a65:	6a 00                	push   $0x0
    7a67:	ff 36                	pushl  (%esi)
    7a69:	ff 75 10             	pushl  0x10(%ebp)
    7a6c:	e8 1b b7 ff ff       	call   318c <fnmatch>
    7a71:	83 c4 0c             	add    $0xc,%esp
    7a74:	85 c0                	test   %eax,%eax
    7a76:	0f 85 cd 00 00 00    	jne    7b49 <shell_wildcard_process+0x14a>
			ret_val = command_add(shell->ctx->temp_buff,
    7a7c:	8b 06                	mov    (%esi),%eax
    7a7e:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
    7a84:	89 45 dc             	mov    %eax,-0x24(%ebp)
					      &shell->ctx->cmd_tmp_buff_len,
    7a87:	8b 45 08             	mov    0x8(%ebp),%eax
    7a8a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    7a8e:	8b 58 08             	mov    0x8(%eax),%ebx
    7a91:	74 0d                	je     7aa0 <shell_wildcard_process+0xa1>
    7a93:	ff 75 dc             	pushl  -0x24(%ebp)
    7a96:	e8 c8 2d 00 00       	call   a863 <strlen>
    7a9b:	5e                   	pop    %esi
    7a9c:	66 89 45 da          	mov    %ax,-0x26(%ebp)
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
    7aa0:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
    7aa4:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
    7aa8:	8d 44 30 01          	lea    0x1(%eax,%esi,1),%eax
    7aac:	3d 00 01 00 00       	cmp    $0x100,%eax
    7ab1:	7e 41                	jle    7af4 <shell_wildcard_process+0xf5>
				shell_internal_fprintf(shell,
    7ab3:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
    7ab6:	bb 01 00 00 00       	mov    $0x1,%ebx
				shell_internal_fprintf(shell,
    7abb:	68 44 74 02 00       	push   $0x27444
    7ac0:	6a 04                	push   $0x4
    7ac2:	ff 75 08             	pushl  0x8(%ebp)
    7ac5:	e8 80 ec ff ff       	call   674a <shell_internal_fprintf>
    7aca:	83 c4 10             	add    $0x10,%esp
	if (cnt > 0) {
    7acd:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    7ad1:	0f 84 8a 00 00 00    	je     7b61 <shell_wildcard_process+0x162>
				     &shell->ctx->cmd_tmp_buff_len, pattern);
    7ad7:	8b 45 08             	mov    0x8(%ebp),%eax
    7ada:	8b 40 08             	mov    0x8(%eax),%eax
		shell_pattern_remove(shell->ctx->temp_buff,
    7add:	ff 75 10             	pushl  0x10(%ebp)
    7ae0:	8d 50 40             	lea    0x40(%eax),%edx
    7ae3:	05 42 01 00 00       	add    $0x142,%eax
    7ae8:	52                   	push   %edx
    7ae9:	50                   	push   %eax
    7aea:	e8 93 e4 ff ff       	call   5f82 <shell_pattern_remove>
    7aef:	83 c4 0c             	add    $0xc,%esp
	 * possible. Next it will continue to search for next wildcard pattern
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
    7af2:	eb 6d                	jmp    7b61 <shell_wildcard_process+0x162>
	completion_addr = strstr(buff, pattern);
    7af4:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
    7af7:	8d 83 42 01 00 00    	lea    0x142(%ebx),%eax
	completion_addr = strstr(buff, pattern);
    7afd:	50                   	push   %eax
    7afe:	e8 6e 2c 00 00       	call   a771 <strstr>
    7b03:	5a                   	pop    %edx
    7b04:	89 c7                	mov    %eax,%edi
    7b06:	59                   	pop    %ecx
	if (!completion_addr) {
    7b07:	85 c0                	test   %eax,%eax
    7b09:	74 4c                	je     7b57 <shell_wildcard_process+0x158>
    7b0b:	50                   	push   %eax
    7b0c:	e8 52 2d 00 00       	call   a863 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
    7b11:	0f b7 c0             	movzwl %ax,%eax
    7b14:	40                   	inc    %eax
    7b15:	89 04 24             	mov    %eax,(%esp)
    7b18:	57                   	push   %edi
    7b19:	8d 44 37 01          	lea    0x1(%edi,%esi,1),%eax
    7b1d:	50                   	push   %eax
    7b1e:	e8 d5 2d 00 00       	call   a8f8 <memmove>
    7b23:	83 c4 0c             	add    $0xc,%esp
	memcpy(completion_addr, cmd, cmd_len);
    7b26:	56                   	push   %esi
    7b27:	ff 75 dc             	pushl  -0x24(%ebp)
    7b2a:	57                   	push   %edi
    7b2b:	e8 01 2e 00 00       	call   a931 <memcpy>
	completion_addr[cmd_len] = ' ';
    7b30:	c6 04 37 20          	movb   $0x20,(%edi,%esi,1)
	*buff_len += cmd_len + 1; /* + 1 for space */
    7b34:	66 8b 45 da          	mov    -0x26(%ebp),%ax
    7b38:	66 03 43 40          	add    0x40(%ebx),%ax
			cnt++;
    7b3c:	ff 45 d0             	incl   -0x30(%ebp)
	*buff_len += cmd_len + 1; /* + 1 for space */
    7b3f:	40                   	inc    %eax
	memcpy(completion_addr, cmd, cmd_len);
    7b40:	83 c4 0c             	add    $0xc,%esp
	*buff_len += cmd_len + 1; /* + 1 for space */
    7b43:	66 89 43 40          	mov    %ax,0x40(%ebx)
			ret_val = command_add(shell->ctx->temp_buff,
    7b47:	31 db                	xor    %ebx,%ebx
	} while (cmd_idx);
    7b49:	ff 4d d4             	decl   -0x2c(%ebp)
    7b4c:	0f 85 e6 fe ff ff    	jne    7a38 <shell_wildcard_process+0x39>
    7b52:	e9 76 ff ff ff       	jmp    7acd <shell_wildcard_process+0xce>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    7b57:	bb 02 00 00 00       	mov    $0x2,%ebx
    7b5c:	e9 6c ff ff ff       	jmp    7acd <shell_wildcard_process+0xce>
}
    7b61:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7b64:	89 d8                	mov    %ebx,%eax
    7b66:	5b                   	pop    %ebx
    7b67:	5e                   	pop    %esi
    7b68:	5f                   	pop    %edi
    7b69:	5d                   	pop    %ebp
    7b6a:	c3                   	ret    

00007b6b <shell_wildcard_finalize>:

void shell_wildcard_finalize(const struct shell *shell)
{
    7b6b:	55                   	push   %ebp
    7b6c:	89 e5                	mov    %esp,%ebp
    7b6e:	53                   	push   %ebx
    7b6f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memcpy(shell->ctx->cmd_buff,
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
    7b72:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
    7b75:	0f b7 50 40          	movzwl 0x40(%eax),%edx
    7b79:	52                   	push   %edx
	       shell->ctx->temp_buff,
    7b7a:	8d 90 42 01 00 00    	lea    0x142(%eax),%edx
	memcpy(shell->ctx->cmd_buff,
    7b80:	52                   	push   %edx
    7b81:	83 c0 42             	add    $0x42,%eax
    7b84:	50                   	push   %eax
    7b85:	e8 a7 2d 00 00       	call   a931 <memcpy>
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    7b8a:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
    7b8d:	83 c4 0c             	add    $0xc,%esp
}
    7b90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    7b93:	8b 50 40             	mov    0x40(%eax),%edx
    7b96:	66 89 50 3c          	mov    %dx,0x3c(%eax)
}
    7b9a:	c9                   	leave  
    7b9b:	c3                   	ret    

00007b9c <append_u8>:

#define BASIC_HEADER_SIZE	4

static inline bool append_u8(struct coap_packet *cpkt, u8_t data)
{
	if (!cpkt) {
    7b9c:	85 c0                	test   %eax,%eax
    7b9e:	74 28                	je     7bc8 <append_u8+0x2c>
{
    7ba0:	55                   	push   %ebp
    7ba1:	89 c1                	mov    %eax,%ecx
    7ba3:	89 e5                	mov    %esp,%ebp
    7ba5:	57                   	push   %edi
    7ba6:	56                   	push   %esi
    7ba7:	53                   	push   %ebx
		return false;
	}

	if (cpkt->max_len - cpkt->offset < 1) {
    7ba8:	0f b7 70 04          	movzwl 0x4(%eax),%esi
    7bac:	0f b7 78 06          	movzwl 0x6(%eax),%edi
    7bb0:	29 f7                	sub    %esi,%edi
		return false;
    7bb2:	31 c0                	xor    %eax,%eax
	if (cpkt->max_len - cpkt->offset < 1) {
    7bb4:	89 f3                	mov    %esi,%ebx
    7bb6:	85 ff                	test   %edi,%edi
    7bb8:	7e 11                	jle    7bcb <append_u8+0x2f>
		return false;
	}

	cpkt->data[cpkt->offset++] = data;
    7bba:	8b 01                	mov    (%ecx),%eax
    7bbc:	43                   	inc    %ebx
    7bbd:	66 89 59 04          	mov    %bx,0x4(%ecx)
    7bc1:	88 14 30             	mov    %dl,(%eax,%esi,1)

	return true;
    7bc4:	b0 01                	mov    $0x1,%al
    7bc6:	eb 03                	jmp    7bcb <append_u8+0x2f>
		return false;
    7bc8:	31 c0                	xor    %eax,%eax
}
    7bca:	c3                   	ret    
    7bcb:	5b                   	pop    %ebx
    7bcc:	5e                   	pop    %esi
    7bcd:	5f                   	pop    %edi
    7bce:	5d                   	pop    %ebp
    7bcf:	c3                   	ret    

00007bd0 <append_be16>:

static inline bool append_be16(struct coap_packet *cpkt, u16_t data)
{
	if (!cpkt) {
    7bd0:	85 c0                	test   %eax,%eax
    7bd2:	74 37                	je     7c0b <append_be16+0x3b>
{
    7bd4:	55                   	push   %ebp
    7bd5:	89 c1                	mov    %eax,%ecx
    7bd7:	89 e5                	mov    %esp,%ebp
    7bd9:	57                   	push   %edi
    7bda:	56                   	push   %esi
    7bdb:	53                   	push   %ebx
		return false;
	}

	if (cpkt->max_len - cpkt->offset < 2) {
    7bdc:	0f b7 70 04          	movzwl 0x4(%eax),%esi
    7be0:	0f b7 78 06          	movzwl 0x6(%eax),%edi
    7be4:	29 f7                	sub    %esi,%edi
		return false;
    7be6:	31 c0                	xor    %eax,%eax
	if (cpkt->max_len - cpkt->offset < 2) {
    7be8:	89 f3                	mov    %esi,%ebx
    7bea:	4f                   	dec    %edi
    7beb:	7e 21                	jle    7c0e <append_be16+0x3e>
		return false;
	}

	cpkt->data[cpkt->offset++] = data >> 8;
    7bed:	8b 01                	mov    (%ecx),%eax
    7bef:	43                   	inc    %ebx
    7bf0:	66 89 59 04          	mov    %bx,0x4(%ecx)
    7bf4:	88 34 30             	mov    %dh,(%eax,%esi,1)
	cpkt->data[cpkt->offset++] = (u8_t) data;
    7bf7:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    7bfb:	8b 19                	mov    (%ecx),%ebx
    7bfd:	8d 70 01             	lea    0x1(%eax),%esi
    7c00:	66 89 71 04          	mov    %si,0x4(%ecx)
    7c04:	88 14 03             	mov    %dl,(%ebx,%eax,1)

	return true;
    7c07:	b0 01                	mov    $0x1,%al
    7c09:	eb 03                	jmp    7c0e <append_be16+0x3e>
		return false;
    7c0b:	31 c0                	xor    %eax,%eax
}
    7c0d:	c3                   	ret    
    7c0e:	5b                   	pop    %ebx
    7c0f:	5e                   	pop    %esi
    7c10:	5f                   	pop    %edi
    7c11:	5d                   	pop    %ebp
    7c12:	c3                   	ret    

00007c13 <decode_delta>:
	return max_len - offset;
}

static int decode_delta(u8_t *data, u16_t offset, u16_t *pos, u16_t max_len,
			u16_t opt, u16_t *opt_ext, u16_t *hdr_len)
{
    7c13:	55                   	push   %ebp
    7c14:	89 e5                	mov    %esp,%ebp
    7c16:	57                   	push   %edi
    7c17:	56                   	push   %esi
    7c18:	8b 75 0c             	mov    0xc(%ebp),%esi
    7c1b:	53                   	push   %ebx
	int ret = 0;

	if (opt == COAP_OPTION_EXT_13) {
    7c1c:	66 83 fe 0d          	cmp    $0xd,%si
{
    7c20:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (opt == COAP_OPTION_EXT_13) {
    7c23:	75 31                	jne    7c56 <decode_delta+0x43>
		u8_t val;

		*hdr_len = 1U;
    7c25:	8b 75 14             	mov    0x14(%ebp),%esi

		ret = read_u8(data, offset, pos, max_len, &val);
    7c28:	0f b7 da             	movzwl %dx,%ebx
		*hdr_len = 1U;
    7c2b:	66 c7 06 01 00       	movw   $0x1,(%esi)
		ret = read_u8(data, offset, pos, max_len, &val);
    7c30:	0f b7 f7             	movzwl %di,%esi
	if (max_len - offset < 1) {
    7c33:	89 f7                	mov    %esi,%edi
    7c35:	29 df                	sub    %ebx,%edi
    7c37:	85 ff                	test   %edi,%edi
    7c39:	7f 07                	jg     7c42 <decode_delta+0x2f>
		if (ret < 0) {
			return -EINVAL;
    7c3b:	be ea ff ff ff       	mov    $0xffffffea,%esi
    7c40:	eb 64                	jmp    7ca6 <decode_delta+0x93>
	*value = data[offset++];
    7c42:	42                   	inc    %edx
    7c43:	0f b6 1c 18          	movzbl (%eax,%ebx,1),%ebx
	*pos = offset;
    7c47:	66 89 11             	mov    %dx,(%ecx)
	return max_len - offset;
    7c4a:	0f b7 d2             	movzwl %dx,%edx
		if (ret < 0) {
    7c4d:	29 d6                	sub    %edx,%esi
    7c4f:	78 ea                	js     7c3b <decode_delta+0x28>
		}

		opt = val + COAP_OPTION_EXT_13;
    7c51:	83 c3 0d             	add    $0xd,%ebx
    7c54:	eb 4a                	jmp    7ca0 <decode_delta+0x8d>
	} else if (opt == COAP_OPTION_EXT_14) {
    7c56:	66 83 fe 0e          	cmp    $0xe,%si
    7c5a:	75 3a                	jne    7c96 <decode_delta+0x83>
		u16_t val;

		*hdr_len = 2U;
    7c5c:	8b 75 14             	mov    0x14(%ebp),%esi

		ret = read_be16(data, offset, pos, max_len, &val);
    7c5f:	0f b7 da             	movzwl %dx,%ebx
		*hdr_len = 2U;
    7c62:	66 c7 06 02 00       	movw   $0x2,(%esi)
		ret = read_be16(data, offset, pos, max_len, &val);
    7c67:	0f b7 f7             	movzwl %di,%esi
	if (max_len - offset < 2) {
    7c6a:	89 f7                	mov    %esi,%edi
    7c6c:	29 df                	sub    %ebx,%edi
    7c6e:	4f                   	dec    %edi
    7c6f:	7e ca                	jle    7c3b <decode_delta+0x28>
	*value |= data[offset++];
    7c71:	8d 7a 02             	lea    0x2(%edx),%edi
	*value = data[offset++] << 8;
    7c74:	42                   	inc    %edx
	*value |= data[offset++];
    7c75:	0f b7 d2             	movzwl %dx,%edx
	*value = data[offset++] << 8;
    7c78:	0f b6 1c 18          	movzbl (%eax,%ebx,1),%ebx
	*value |= data[offset++];
    7c7c:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
	*value = data[offset++] << 8;
    7c80:	c1 e3 08             	shl    $0x8,%ebx
	*pos = offset;
    7c83:	66 89 39             	mov    %di,(%ecx)
	return max_len - offset;
    7c86:	0f b7 ff             	movzwl %di,%edi
	*value |= data[offset++];
    7c89:	09 c3                	or     %eax,%ebx
		if (ret < 0) {
    7c8b:	29 fe                	sub    %edi,%esi
    7c8d:	78 ac                	js     7c3b <decode_delta+0x28>
			return -EINVAL;
		}

		opt = val + COAP_OPTION_EXT_269;
    7c8f:	66 81 c3 0d 01       	add    $0x10d,%bx
    7c94:	eb 0a                	jmp    7ca0 <decode_delta+0x8d>
	} else if (opt == COAP_OPTION_EXT_15) {
    7c96:	66 83 fe 0f          	cmp    $0xf,%si
    7c9a:	74 9f                	je     7c3b <decode_delta+0x28>
    7c9c:	89 f3                	mov    %esi,%ebx
	int ret = 0;
    7c9e:	31 f6                	xor    %esi,%esi
		return -EINVAL;
	}

	*opt_ext = opt;
    7ca0:	8b 55 10             	mov    0x10(%ebp),%edx
    7ca3:	66 89 1a             	mov    %bx,(%edx)

	return ret;
}
    7ca6:	5b                   	pop    %ebx
    7ca7:	89 f0                	mov    %esi,%eax
    7ca9:	5e                   	pop    %esi
    7caa:	5f                   	pop    %edi
    7cab:	5d                   	pop    %ebp
    7cac:	c3                   	ret    

00007cad <update_descriptive_block>:
	return val;
}

static int update_descriptive_block(struct coap_block_context *ctx,
				    int block, int size)
{
    7cad:	55                   	push   %ebp
    7cae:	89 e5                	mov    %esp,%ebp
    7cb0:	57                   	push   %edi
    7cb1:	56                   	push   %esi
    7cb2:	89 ce                	mov    %ecx,%esi
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
    7cb4:	89 d1                	mov    %edx,%ecx
{
    7cb6:	53                   	push   %ebx
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
    7cb7:	83 e1 07             	and    $0x7,%ecx
{
    7cba:	89 c3                	mov    %eax,%ebx
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
    7cbc:	89 d0                	mov    %edx,%eax
    7cbe:	83 c1 04             	add    $0x4,%ecx
    7cc1:	c1 f8 04             	sar    $0x4,%eax
    7cc4:	d3 e0                	shl    %cl,%eax

	if (block == -ENOENT) {
    7cc6:	83 fa fe             	cmp    $0xfffffffe,%edx
    7cc9:	74 51                	je     7d1c <update_descriptive_block+0x6f>
    7ccb:	89 c1                	mov    %eax,%ecx
		return 0;
	}

	if (size && ctx->total_size && ctx->total_size != size) {
    7ccd:	85 f6                	test   %esi,%esi
    7ccf:	74 0f                	je     7ce0 <update_descriptive_block+0x33>
    7cd1:	8b 3b                	mov    (%ebx),%edi
    7cd3:	85 ff                	test   %edi,%edi
    7cd5:	74 09                	je     7ce0 <update_descriptive_block+0x33>
		return -EINVAL;
    7cd7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (size && ctx->total_size && ctx->total_size != size) {
    7cdc:	39 f7                	cmp    %esi,%edi
    7cde:	75 3e                	jne    7d1e <update_descriptive_block+0x71>
	}

	if (ctx->current > 0 && GET_BLOCK_SIZE(block) > ctx->block_size) {
    7ce0:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    7ce4:	74 0f                	je     7cf5 <update_descriptive_block+0x48>
    7ce6:	89 d7                	mov    %edx,%edi
		return -EINVAL;
    7ce8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (ctx->current > 0 && GET_BLOCK_SIZE(block) > ctx->block_size) {
    7ced:	83 e7 07             	and    $0x7,%edi
    7cf0:	3b 7b 08             	cmp    0x8(%ebx),%edi
    7cf3:	77 29                	ja     7d1e <update_descriptive_block+0x71>
		return -EINVAL;
	}

	if (ctx->total_size && new_current > ctx->total_size) {
    7cf5:	8b 3b                	mov    (%ebx),%edi
    7cf7:	85 ff                	test   %edi,%edi
    7cf9:	74 09                	je     7d04 <update_descriptive_block+0x57>
		return -EINVAL;
    7cfb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (ctx->total_size && new_current > ctx->total_size) {
    7d00:	39 cf                	cmp    %ecx,%edi
    7d02:	72 1a                	jb     7d1e <update_descriptive_block+0x71>
		return -EINVAL;
	}

	if (size) {
    7d04:	85 f6                	test   %esi,%esi
    7d06:	74 02                	je     7d0a <update_descriptive_block+0x5d>
		ctx->total_size = size;
    7d08:	89 33                	mov    %esi,(%ebx)
	}
	ctx->current = new_current;
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
    7d0a:	83 e2 07             	and    $0x7,%edx
    7d0d:	8b 43 08             	mov    0x8(%ebx),%eax
	ctx->current = new_current;
    7d10:	89 4b 04             	mov    %ecx,0x4(%ebx)
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
    7d13:	39 d0                	cmp    %edx,%eax
    7d15:	76 02                	jbe    7d19 <update_descriptive_block+0x6c>
    7d17:	89 d0                	mov    %edx,%eax
    7d19:	89 43 08             	mov    %eax,0x8(%ebx)
		return 0;
    7d1c:	31 c0                	xor    %eax,%eax

	return 0;
}
    7d1e:	5b                   	pop    %ebx
    7d1f:	5e                   	pop    %esi
    7d20:	5f                   	pop    %edi
    7d21:	5d                   	pop    %ebp
    7d22:	c3                   	ret    

00007d23 <append>:
{
    7d23:	55                   	push   %ebp
    7d24:	89 e5                	mov    %esp,%ebp
    7d26:	57                   	push   %edi
    7d27:	56                   	push   %esi
    7d28:	53                   	push   %ebx
    7d29:	89 c3                	mov    %eax,%ebx
    7d2b:	83 ec 08             	sub    $0x8,%esp
	if (!cpkt || !data) {
    7d2e:	85 c0                	test   %eax,%eax
{
    7d30:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if (!cpkt || !data) {
    7d33:	0f 94 c0             	sete   %al
    7d36:	85 d2                	test   %edx,%edx
    7d38:	0f 94 c2             	sete   %dl
    7d3b:	08 d0                	or     %dl,%al
    7d3d:	75 31                	jne    7d70 <append+0x4d>
	if (cpkt->max_len - cpkt->offset < len) {
    7d3f:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
    7d43:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
    7d47:	0f b7 f1             	movzwl %cx,%esi
    7d4a:	29 d7                	sub    %edx,%edi
    7d4c:	89 55 ec             	mov    %edx,-0x14(%ebp)
    7d4f:	39 fe                	cmp    %edi,%esi
    7d51:	7f 1f                	jg     7d72 <append+0x4f>
	memcpy(cpkt->data + cpkt->offset, data, len);
    7d53:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d56:	56                   	push   %esi
    7d57:	8b 55 f0             	mov    -0x10(%ebp),%edx
    7d5a:	03 03                	add    (%ebx),%eax
    7d5c:	52                   	push   %edx
    7d5d:	89 cf                	mov    %ecx,%edi
    7d5f:	50                   	push   %eax
    7d60:	e8 cc 2b 00 00       	call   a931 <memcpy>
    7d65:	83 c4 0c             	add    $0xc,%esp
	return true;
    7d68:	b0 01                	mov    $0x1,%al
	cpkt->offset += len;
    7d6a:	66 01 7b 04          	add    %di,0x4(%ebx)
	return true;
    7d6e:	eb 02                	jmp    7d72 <append+0x4f>
		return false;
    7d70:	31 c0                	xor    %eax,%eax
}
    7d72:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7d75:	5b                   	pop    %ebx
    7d76:	5e                   	pop    %esi
    7d77:	5f                   	pop    %edi
    7d78:	5d                   	pop    %ebp
    7d79:	c3                   	ret    

00007d7a <parse_option>:
{
    7d7a:	55                   	push   %ebp
    7d7b:	89 e5                	mov    %esp,%ebp
    7d7d:	57                   	push   %edi
    7d7e:	56                   	push   %esi
    7d7f:	53                   	push   %ebx
    7d80:	83 ec 14             	sub    $0x14,%esp
    7d83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	r = read_u8(data, offset, pos, max_len, &opt);
    7d86:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    7d8a:	0f b7 da             	movzwl %dx,%ebx
    7d8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (max_len - offset < 1) {
    7d90:	29 d8                	sub    %ebx,%eax
{
    7d92:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (max_len - offset < 1) {
    7d95:	85 c0                	test   %eax,%eax
    7d97:	0f 8e 23 01 00 00    	jle    7ec0 <parse_option+0x146>
	*value = data[offset++];
    7d9d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    7da0:	8d 42 01             	lea    0x1(%edx),%eax
    7da3:	8a 14 1e             	mov    (%esi,%ebx,1),%dl
	*pos = offset;
    7da6:	66 89 01             	mov    %ax,(%ecx)
	if (r < 0) {
    7da9:	8b 75 e8             	mov    -0x18(%ebp),%esi
	return max_len - offset;
    7dac:	0f b7 c0             	movzwl %ax,%eax
	if (r < 0) {
    7daf:	29 c6                	sub    %eax,%esi
    7db1:	89 f0                	mov    %esi,%eax
    7db3:	0f 88 62 01 00 00    	js     7f1b <parse_option+0x1a1>
	*opt_len += 1;
    7db9:	66 ff 07             	incw   (%edi)
	if (opt == COAP_MARKER) {
    7dbc:	80 fa ff             	cmp    $0xff,%dl
    7dbf:	75 0f                	jne    7dd0 <parse_option+0x56>
		return r > 0 ? 0 : -EINVAL;
    7dc1:	85 f6                	test   %esi,%esi
    7dc3:	0f 84 f7 00 00 00    	je     7ec0 <parse_option+0x146>
    7dc9:	31 c0                	xor    %eax,%eax
    7dcb:	e9 4b 01 00 00       	jmp    7f1b <parse_option+0x1a1>
	return (opt & 0xF0) >> 4;
    7dd0:	88 d3                	mov    %dl,%bl
	len = option_header_get_len(opt);
    7dd2:	83 e2 0f             	and    $0xf,%edx
	return (opt & 0xF0) >> 4;
    7dd5:	c0 eb 04             	shr    $0x4,%bl
	len = option_header_get_len(opt);
    7dd8:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
	delta = option_header_get_delta(opt);
    7ddc:	0f b6 f3             	movzbl %bl,%esi
    7ddf:	66 89 75 f0          	mov    %si,-0x10(%ebp)
	if (r == 0 && delta > COAP_OPTION_NO_EXT) {
    7de3:	85 c0                	test   %eax,%eax
    7de5:	75 0a                	jne    7df1 <parse_option+0x77>
    7de7:	66 83 fe 0c          	cmp    $0xc,%si
    7deb:	0f 87 cf 00 00 00    	ja     7ec0 <parse_option+0x146>
    7df1:	89 ce                	mov    %ecx,%esi
	if (delta > COAP_OPTION_NO_EXT) {
    7df3:	80 fb 0c             	cmp    $0xc,%bl
    7df6:	76 3b                	jbe    7e33 <parse_option+0xb9>
		r = decode_delta(data, *pos, pos, max_len,
    7df8:	8d 45 ee             	lea    -0x12(%ebp),%eax
    7dfb:	0f b7 11             	movzwl (%ecx),%edx
    7dfe:	50                   	push   %eax
    7dff:	8d 45 f0             	lea    -0x10(%ebp),%eax
    7e02:	50                   	push   %eax
    7e03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e06:	0f b6 db             	movzbl %bl,%ebx
    7e09:	53                   	push   %ebx
    7e0a:	ff 75 e8             	pushl  -0x18(%ebp)
    7e0d:	e8 01 fe ff ff       	call   7c13 <decode_delta>
    7e12:	83 c4 10             	add    $0x10,%esp
		if ((r < 0) || (r == 0 && len > COAP_OPTION_NO_EXT)) {
    7e15:	85 c0                	test   %eax,%eax
    7e17:	0f 88 a3 00 00 00    	js     7ec0 <parse_option+0x146>
    7e1d:	66 83 7d f2 0c       	cmpw   $0xc,-0xe(%ebp)
    7e22:	76 08                	jbe    7e2c <parse_option+0xb2>
    7e24:	85 c0                	test   %eax,%eax
    7e26:	0f 84 94 00 00 00    	je     7ec0 <parse_option+0x146>
		*opt_len += hdr_len;
    7e2c:	66 8b 55 ee          	mov    -0x12(%ebp),%dx
    7e30:	66 01 17             	add    %dx,(%edi)
	if (len > COAP_OPTION_NO_EXT) {
    7e33:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
    7e37:	66 83 f9 0c          	cmp    $0xc,%cx
    7e3b:	76 27                	jbe    7e64 <parse_option+0xea>
		r = decode_delta(data, *pos, pos, max_len,
    7e3d:	8d 45 ee             	lea    -0x12(%ebp),%eax
    7e40:	0f b7 16             	movzwl (%esi),%edx
    7e43:	50                   	push   %eax
    7e44:	8d 45 f2             	lea    -0xe(%ebp),%eax
    7e47:	50                   	push   %eax
    7e48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e4b:	51                   	push   %ecx
    7e4c:	89 f1                	mov    %esi,%ecx
    7e4e:	ff 75 e8             	pushl  -0x18(%ebp)
    7e51:	e8 bd fd ff ff       	call   7c13 <decode_delta>
    7e56:	83 c4 10             	add    $0x10,%esp
		if (r < 0) {
    7e59:	85 c0                	test   %eax,%eax
    7e5b:	78 63                	js     7ec0 <parse_option+0x146>
		*opt_len += hdr_len;
    7e5d:	66 8b 55 ee          	mov    -0x12(%ebp),%dx
    7e61:	66 01 17             	add    %dx,(%edi)
	*opt_delta += delta;
    7e64:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7e67:	8b 55 f0             	mov    -0x10(%ebp),%edx
	*opt_len += len;
    7e6a:	0f b7 5d f2          	movzwl -0xe(%ebp),%ebx
	*opt_delta += delta;
    7e6e:	66 01 11             	add    %dx,(%ecx)
	*opt_len += len;
    7e71:	66 01 1f             	add    %bx,(%edi)
	if (r == 0) {
    7e74:	85 c0                	test   %eax,%eax
    7e76:	75 0b                	jne    7e83 <parse_option+0x109>
		if (len == 0) {
    7e78:	66 85 db             	test   %bx,%bx
    7e7b:	0f 84 48 ff ff ff    	je     7dc9 <parse_option+0x4f>
    7e81:	eb 3d                	jmp    7ec0 <parse_option+0x146>
	if (option) {
    7e83:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    7e87:	0f 84 80 00 00 00    	je     7f0d <parse_option+0x193>
		if (len > sizeof(option->value)) {
    7e8d:	66 83 fb 0c          	cmp    $0xc,%bx
    7e91:	76 34                	jbe    7ec7 <parse_option+0x14d>
			NET_ERR("%u is > sizeof(coap_option->value)(%zu)!",
    7e93:	f6 05 68 a8 40 00 07 	testb  $0x7,0x40a868
    7e9a:	74 24                	je     7ec0 <parse_option+0x146>
    7e9c:	b8 54 51 02 00       	mov    $0x25154,%eax
    7ea1:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    7ea6:	c1 e8 03             	shr    $0x3,%eax
    7ea9:	c1 e0 06             	shl    $0x6,%eax
    7eac:	83 c8 01             	or     $0x1,%eax
    7eaf:	50                   	push   %eax
    7eb0:	6a 0c                	push   $0xc
    7eb2:	53                   	push   %ebx
    7eb3:	68 96 74 02 00       	push   $0x27496
    7eb8:	e8 2c b6 ff ff       	call   34e9 <log_2>
    7ebd:	83 c4 10             	add    $0x10,%esp
			return -EINVAL;
    7ec0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    7ec5:	eb 54                	jmp    7f1b <parse_option+0x1a1>
		option->delta = *opt_delta;
    7ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7eca:	8b 7d 14             	mov    0x14(%ebp),%edi
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
    7ecd:	0f b7 cb             	movzwl %bx,%ecx
		option->delta = *opt_delta;
    7ed0:	66 8b 00             	mov    (%eax),%ax
		option->len = len;
    7ed3:	88 5f 02             	mov    %bl,0x2(%edi)
		option->delta = *opt_delta;
    7ed6:	66 89 07             	mov    %ax,(%edi)
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
    7ed9:	8d 57 03             	lea    0x3(%edi),%edx
    7edc:	0f b7 06             	movzwl (%esi),%eax
	if (max_len - offset < len) {
    7edf:	8b 7d e8             	mov    -0x18(%ebp),%edi
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
    7ee2:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
	if (max_len - offset < len) {
    7ee6:	29 c7                	sub    %eax,%edi
    7ee8:	39 f9                	cmp    %edi,%ecx
    7eea:	7f d4                	jg     7ec0 <parse_option+0x146>
	memcpy(value, data + offset, len);
    7eec:	03 45 e4             	add    -0x1c(%ebp),%eax
    7eef:	51                   	push   %ecx
    7ef0:	50                   	push   %eax
    7ef1:	52                   	push   %edx
    7ef2:	e8 3a 2a 00 00       	call   a931 <memcpy>
	offset += len;
    7ef7:	66 03 5d e2          	add    -0x1e(%ebp),%bx
		if (r < 0) {
    7efb:	8b 45 e8             	mov    -0x18(%ebp),%eax
	*pos = offset;
    7efe:	66 89 1e             	mov    %bx,(%esi)
	memcpy(value, data + offset, len);
    7f01:	83 c4 0c             	add    $0xc,%esp
	return max_len - offset;
    7f04:	0f b7 db             	movzwl %bx,%ebx
		if (r < 0) {
    7f07:	29 d8                	sub    %ebx,%eax
    7f09:	79 10                	jns    7f1b <parse_option+0x1a1>
    7f0b:	eb b3                	jmp    7ec0 <parse_option+0x146>
		*pos += len;
    7f0d:	66 03 1e             	add    (%esi),%bx
		r = max_len - *pos;
    7f10:	8b 45 e8             	mov    -0x18(%ebp),%eax
		*pos += len;
    7f13:	66 89 1e             	mov    %bx,(%esi)
		r = max_len - *pos;
    7f16:	0f b7 db             	movzwl %bx,%ebx
    7f19:	29 d8                	sub    %ebx,%eax
}
    7f1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7f1e:	5b                   	pop    %ebx
    7f1f:	5e                   	pop    %esi
    7f20:	5f                   	pop    %edi
    7f21:	5d                   	pop    %ebp
    7f22:	c3                   	ret    

00007f23 <coap_packet_init>:
{
    7f23:	55                   	push   %ebp
    7f24:	89 e5                	mov    %esp,%ebp
    7f26:	57                   	push   %edi
    7f27:	56                   	push   %esi
    7f28:	53                   	push   %ebx
    7f29:	83 ec 10             	sub    $0x10,%esp
    7f2c:	8b 45 14             	mov    0x14(%ebp),%eax
    7f2f:	8b 75 10             	mov    0x10(%ebp),%esi
    7f32:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7f35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f38:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7f3b:	8b 45 24             	mov    0x24(%ebp),%eax
    7f3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7f41:	8b 45 28             	mov    0x28(%ebp),%eax
	if (!cpkt || !data || !max_len) {
    7f44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
{
    7f48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7f4b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!cpkt || !data || !max_len) {
    7f4e:	0f 94 c1             	sete   %cl
    7f51:	66 85 f6             	test   %si,%si
{
    7f54:	8b 7d 18             	mov    0x18(%ebp),%edi
	if (!cpkt || !data || !max_len) {
    7f57:	0f 94 c0             	sete   %al
    7f5a:	08 c1                	or     %al,%cl
    7f5c:	75 04                	jne    7f62 <coap_packet_init+0x3f>
    7f5e:	85 db                	test   %ebx,%ebx
    7f60:	75 0a                	jne    7f6c <coap_packet_init+0x49>
		return -EINVAL;
    7f62:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    7f67:	e9 94 00 00 00       	jmp    8000 <coap_packet_init+0xdd>
	hdr |= (type & 0x3) << 4;
    7f6c:	c1 e7 04             	shl    $0x4,%edi
	memset(cpkt, 0, sizeof(*cpkt));
    7f6f:	6a 10                	push   $0x10
    7f71:	6a 00                	push   $0x0
	hdr |= (type & 0x3) << 4;
    7f73:	83 e7 30             	and    $0x30,%edi
	memset(cpkt, 0, sizeof(*cpkt));
    7f76:	53                   	push   %ebx
    7f77:	e8 24 2a 00 00       	call   a9a0 <memset>
	hdr = (ver & 0x3) << 6;
    7f7c:	8a 55 ec             	mov    -0x14(%ebp),%dl
	cpkt->data = data;
    7f7f:	8b 45 0c             	mov    0xc(%ebp),%eax
	hdr = (ver & 0x3) << 6;
    7f82:	c1 e2 06             	shl    $0x6,%edx
	memset(cpkt, 0, sizeof(*cpkt));
    7f85:	83 c4 0c             	add    $0xc,%esp
	hdr |= (type & 0x3) << 4;
    7f88:	09 fa                	or     %edi,%edx
	hdr |= tokenlen & 0xF;
    7f8a:	8b 7d f0             	mov    -0x10(%ebp),%edi
    7f8d:	83 e7 0f             	and    $0xf,%edi
	cpkt->data = data;
    7f90:	89 03                	mov    %eax,(%ebx)
	hdr |= tokenlen & 0xF;
    7f92:	09 fa                	or     %edi,%edx
	cpkt->offset = 0;
    7f94:	66 c7 43 04 00 00    	movw   $0x0,0x4(%ebx)
	cpkt->max_len = max_len;
    7f9a:	66 89 73 06          	mov    %si,0x6(%ebx)
	cpkt->delta = 0;
    7f9e:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	res = append_u8(cpkt, hdr);
    7fa4:	0f b6 d2             	movzbl %dl,%edx
    7fa7:	89 d8                	mov    %ebx,%eax
    7fa9:	e8 ee fb ff ff       	call   7b9c <append_u8>
	if (!res) {
    7fae:	84 c0                	test   %al,%al
    7fb0:	74 b0                	je     7f62 <coap_packet_init+0x3f>
	res = append_u8(cpkt, code);
    7fb2:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    7fb6:	89 d8                	mov    %ebx,%eax
    7fb8:	e8 df fb ff ff       	call   7b9c <append_u8>
	if (!res) {
    7fbd:	84 c0                	test   %al,%al
    7fbf:	74 a1                	je     7f62 <coap_packet_init+0x3f>
	res = append_be16(cpkt, id);
    7fc1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    7fc5:	89 d8                	mov    %ebx,%eax
    7fc7:	e8 04 fc ff ff       	call   7bd0 <append_be16>
	if (!res) {
    7fcc:	84 c0                	test   %al,%al
    7fce:	74 92                	je     7f62 <coap_packet_init+0x3f>
	if (token && tokenlen) {
    7fd0:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
    7fd4:	74 06                	je     7fdc <coap_packet_init+0xb9>
    7fd6:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
    7fda:	75 0d                	jne    7fe9 <coap_packet_init+0xc6>
	cpkt->hdr_len = 1 + 1 + 2 + tokenlen;
    7fdc:	8a 45 f0             	mov    -0x10(%ebp),%al
    7fdf:	83 c0 04             	add    $0x4,%eax
    7fe2:	88 43 08             	mov    %al,0x8(%ebx)
	return 0;
    7fe5:	31 c0                	xor    %eax,%eax
    7fe7:	eb 17                	jmp    8000 <coap_packet_init+0xdd>
		res = append(cpkt, token, tokenlen);
    7fe9:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    7fed:	8b 55 20             	mov    0x20(%ebp),%edx
    7ff0:	89 d8                	mov    %ebx,%eax
    7ff2:	e8 2c fd ff ff       	call   7d23 <append>
		if (!res) {
    7ff7:	84 c0                	test   %al,%al
    7ff9:	75 e1                	jne    7fdc <coap_packet_init+0xb9>
    7ffb:	e9 62 ff ff ff       	jmp    7f62 <coap_packet_init+0x3f>
}
    8000:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8003:	5b                   	pop    %ebx
    8004:	5e                   	pop    %esi
    8005:	5f                   	pop    %edi
    8006:	5d                   	pop    %ebp
    8007:	c3                   	ret    

00008008 <coap_packet_append_option>:
{
    8008:	55                   	push   %ebp
    8009:	89 e5                	mov    %esp,%ebp
    800b:	57                   	push   %edi
    800c:	56                   	push   %esi
    800d:	53                   	push   %ebx
    800e:	83 ec 0c             	sub    $0xc,%esp
    8011:	8b 5d 08             	mov    0x8(%ebp),%ebx
    8014:	8b 45 0c             	mov    0xc(%ebp),%eax
    8017:	8b 55 14             	mov    0x14(%ebp),%edx
	if (!cpkt) {
    801a:	85 db                	test   %ebx,%ebx
    801c:	74 46                	je     8064 <coap_packet_append_option+0x5c>
	if (len && !value) {
    801e:	66 85 d2             	test   %dx,%dx
    8021:	89 c6                	mov    %eax,%esi
    8023:	0f 95 45 ef          	setne  -0x11(%ebp)
    8027:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    802b:	75 06                	jne    8033 <coap_packet_append_option+0x2b>
    802d:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    8031:	75 31                	jne    8064 <coap_packet_append_option+0x5c>
	if (code < cpkt->delta) {
    8033:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    8036:	66 39 c1             	cmp    %ax,%cx
    8039:	76 33                	jbe    806e <coap_packet_append_option+0x66>
		NET_ERR("Options should be in ascending order");
    803b:	f6 05 68 a8 40 00 07 	testb  $0x7,0x40a868
    8042:	74 20                	je     8064 <coap_packet_append_option+0x5c>
    8044:	b8 54 51 02 00       	mov    $0x25154,%eax
    8049:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    804e:	c1 e8 03             	shr    $0x3,%eax
    8051:	c1 e0 06             	shl    $0x6,%eax
    8054:	83 c8 01             	or     $0x1,%eax
    8057:	50                   	push   %eax
    8058:	68 bf 74 02 00       	push   $0x274bf
    805d:	e8 28 b4 ff ff       	call   348a <log_0>
    8062:	58                   	pop    %eax
    8063:	5a                   	pop    %edx
    8064:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8069:	e9 32 01 00 00       	jmp    81a0 <coap_packet_append_option+0x198>
	if (cpkt->opt_len) {
    806e:	0f b7 fa             	movzwl %dx,%edi
    8071:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
    8076:	74 09                	je     8081 <coap_packet_append_option+0x79>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
    8078:	66 39 c1             	cmp    %ax,%cx
    807b:	74 0c                	je     8089 <coap_packet_append_option+0x81>
    807d:	89 c6                	mov    %eax,%esi
    807f:	29 ce                	sub    %ecx,%esi
	if (num < COAP_OPTION_EXT_13) {
    8081:	66 83 fe 0c          	cmp    $0xc,%si
    8085:	77 0e                	ja     8095 <coap_packet_append_option+0x8d>
    8087:	eb 02                	jmp    808b <coap_packet_append_option+0x83>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
    8089:	31 f6                	xor    %esi,%esi
		*opt = num;
    808b:	89 f0                	mov    %esi,%eax
		*ext = 0U;
    808d:	31 c9                	xor    %ecx,%ecx
		return 0;
    808f:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
    8093:	eb 1e                	jmp    80b3 <coap_packet_append_option+0xab>
	} else if (num < COAP_OPTION_EXT_269) {
    8095:	66 81 fe 0c 01       	cmp    $0x10c,%si
    809a:	77 0b                	ja     80a7 <coap_packet_append_option+0x9f>
		*ext = num - COAP_OPTION_EXT_13;
    809c:	8d 4e f3             	lea    -0xd(%esi),%ecx
		*opt = COAP_OPTION_EXT_13;
    809f:	b0 0d                	mov    $0xd,%al
		return 1;
    80a1:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)
    80a5:	eb 0c                	jmp    80b3 <coap_packet_append_option+0xab>
	*ext = num - COAP_OPTION_EXT_269;
    80a7:	8d 8e f3 fe ff ff    	lea    -0x10d(%esi),%ecx
	*opt = COAP_OPTION_EXT_14;
    80ad:	b0 0e                	mov    $0xe,%al
	return 2;
    80af:	c6 45 f2 02          	movb   $0x2,-0xe(%ebp)
	if (num < COAP_OPTION_EXT_13) {
    80b3:	66 83 fa 0c          	cmp    $0xc,%dx
    80b7:	77 0c                	ja     80c5 <coap_packet_append_option+0xbd>
		*ext = 0U;
    80b9:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
		return 0;
    80bf:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    80c3:	eb 25                	jmp    80ea <coap_packet_append_option+0xe2>
	} else if (num < COAP_OPTION_EXT_269) {
    80c5:	66 81 fa 0c 01       	cmp    $0x10c,%dx
    80ca:	77 0f                	ja     80db <coap_packet_append_option+0xd3>
		*ext = num - COAP_OPTION_EXT_13;
    80cc:	83 ea 0d             	sub    $0xd,%edx
		return 1;
    80cf:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
		*ext = num - COAP_OPTION_EXT_13;
    80d3:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
		*opt = COAP_OPTION_EXT_13;
    80d7:	b2 0d                	mov    $0xd,%dl
    80d9:	eb 0f                	jmp    80ea <coap_packet_append_option+0xe2>
	*ext = num - COAP_OPTION_EXT_269;
    80db:	66 81 ea 0d 01       	sub    $0x10d,%dx
	return 2;
    80e0:	c6 45 f3 02          	movb   $0x2,-0xd(%ebp)
	*ext = num - COAP_OPTION_EXT_269;
    80e4:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
	*opt = COAP_OPTION_EXT_14;
    80e8:	b2 0e                	mov    $0xe,%dl
	*opt = (delta & 0xF) << 4;
    80ea:	c1 e0 04             	shl    $0x4,%eax
    80ed:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	*opt |= (len & 0xF);
    80f0:	09 c2                	or     %eax,%edx
	res = append_u8(cpkt, opt);
    80f2:	89 d8                	mov    %ebx,%eax
    80f4:	0f b6 d2             	movzbl %dl,%edx
    80f7:	e8 a0 fa ff ff       	call   7b9c <append_u8>
	if (!res) {
    80fc:	84 c0                	test   %al,%al
    80fe:	0f 84 60 ff ff ff    	je     8064 <coap_packet_append_option+0x5c>
	if (delta_size == 1) {
    8104:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
    8108:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    810b:	75 13                	jne    8120 <coap_packet_append_option+0x118>
		res = append_u8(cpkt, (u8_t)delta_ext);
    810d:	0f b6 d1             	movzbl %cl,%edx
    8110:	89 d8                	mov    %ebx,%eax
    8112:	e8 85 fa ff ff       	call   7b9c <append_u8>
		if (!res) {
    8117:	84 c0                	test   %al,%al
    8119:	75 7d                	jne    8198 <coap_packet_append_option+0x190>
    811b:	e9 44 ff ff ff       	jmp    8064 <coap_packet_append_option+0x5c>
	} else if (delta_size == 2) {
    8120:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
    8124:	75 72                	jne    8198 <coap_packet_append_option+0x190>
		res = append_be16(cpkt, delta_ext);
    8126:	0f b7 d1             	movzwl %cx,%edx
    8129:	89 d8                	mov    %ebx,%eax
    812b:	e8 a0 fa ff ff       	call   7bd0 <append_be16>
		if (!res) {
    8130:	84 c0                	test   %al,%al
    8132:	0f 84 2c ff ff ff    	je     8064 <coap_packet_append_option+0x5c>
	if (len_size == 1) {
    8138:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
    813c:	75 0d                	jne    814b <coap_packet_append_option+0x143>
		res = append_u8(cpkt, (u8_t)len_ext);
    813e:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
    8142:	89 d8                	mov    %ebx,%eax
    8144:	e8 53 fa ff ff       	call   7b9c <append_u8>
		if (!res) {
    8149:	eb 0b                	jmp    8156 <coap_packet_append_option+0x14e>
		res = append_be16(cpkt, len_ext);
    814b:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
    814f:	89 d8                	mov    %ebx,%eax
    8151:	e8 7a fa ff ff       	call   7bd0 <append_be16>
		if (!res) {
    8156:	84 c0                	test   %al,%al
    8158:	0f 84 06 ff ff ff    	je     8064 <coap_packet_append_option+0x5c>
	if (len && value) {
    815e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8162:	74 1a                	je     817e <coap_packet_append_option+0x176>
    8164:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    8168:	74 14                	je     817e <coap_packet_append_option+0x176>
		res = append(cpkt, value, len);
    816a:	89 f9                	mov    %edi,%ecx
    816c:	8b 55 10             	mov    0x10(%ebp),%edx
    816f:	89 d8                	mov    %ebx,%eax
    8171:	e8 ad fb ff ff       	call   7d23 <append>
		if (!res) {
    8176:	84 c0                	test   %al,%al
    8178:	0f 84 e6 fe ff ff    	je     8064 <coap_packet_append_option+0x5c>
	return  (1 + delta_size + len_size + len);
    817e:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
	cpkt->delta += code;
    8182:	66 01 73 0c          	add    %si,0xc(%ebx)
	return  (1 + delta_size + len_size + len);
    8186:	8d 44 07 01          	lea    0x1(%edi,%eax,1),%eax
    818a:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
    818e:	01 c7                	add    %eax,%edi
	return 0;
    8190:	31 c0                	xor    %eax,%eax
	cpkt->opt_len += r;
    8192:	66 01 7b 0a          	add    %di,0xa(%ebx)
	return 0;
    8196:	eb 08                	jmp    81a0 <coap_packet_append_option+0x198>
	if (len_size == 1) {
    8198:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
    819c:	75 c0                	jne    815e <coap_packet_append_option+0x156>
    819e:	eb 9e                	jmp    813e <coap_packet_append_option+0x136>
}
    81a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    81a3:	5b                   	pop    %ebx
    81a4:	5e                   	pop    %esi
    81a5:	5f                   	pop    %edi
    81a6:	5d                   	pop    %ebp
    81a7:	c3                   	ret    

000081a8 <coap_append_option_int>:
{
    81a8:	55                   	push   %ebp
    81a9:	89 e5                	mov    %esp,%ebp
    81ab:	50                   	push   %eax
    81ac:	8b 45 10             	mov    0x10(%ebp),%eax
    81af:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (val == 0) {
    81b2:	85 c0                	test   %eax,%eax
    81b4:	75 06                	jne    81bc <coap_append_option_int+0x14>
		data[0] = 0U;
    81b6:	c6 45 fc 00          	movb   $0x0,-0x4(%ebp)
		len = 0U;
    81ba:	eb 3f                	jmp    81fb <coap_append_option_int+0x53>
	} else if (val < 0xFF) {
    81bc:	3d fe 00 00 00       	cmp    $0xfe,%eax
    81c1:	77 07                	ja     81ca <coap_append_option_int+0x22>
		data[0] = (u8_t) val;
    81c3:	88 45 fc             	mov    %al,-0x4(%ebp)
		len = 1U;
    81c6:	b0 01                	mov    $0x1,%al
    81c8:	eb 31                	jmp    81fb <coap_append_option_int+0x53>
	} else if (val < 0xFFFF) {
    81ca:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    81cf:	77 0a                	ja     81db <coap_append_option_int+0x33>
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(u16_t val, u8_t dst[2])
{
	dst[0] = val >> 8;
    81d1:	86 e0                	xchg   %ah,%al
    81d3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
		len = 2U;
    81d7:	b0 02                	mov    $0x2,%al
    81d9:	eb 20                	jmp    81fb <coap_append_option_int+0x53>
	} else if (val < 0xFFFFFF) {
    81db:	89 c1                	mov    %eax,%ecx
    81dd:	c1 e9 10             	shr    $0x10,%ecx
    81e0:	3d fe ff ff 00       	cmp    $0xfffffe,%eax
    81e5:	77 0d                	ja     81f4 <coap_append_option_int+0x4c>
    81e7:	86 e0                	xchg   %ah,%al
		data[0] = val >> 16;
    81e9:	88 4d fc             	mov    %cl,-0x4(%ebp)
    81ec:	66 89 45 fd          	mov    %ax,-0x3(%ebp)
		len = 3U;
    81f0:	b0 03                	mov    $0x3,%al
    81f2:	eb 07                	jmp    81fb <coap_append_option_int+0x53>
	dst[1] = val;
    81f4:	0f c8                	bswap  %eax
	dst[0] = val >> 8;
    81f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
		len = 4U;
    81f9:	b0 04                	mov    $0x4,%al
	return coap_packet_append_option(cpkt, code, data, len);
    81fb:	0f b6 c0             	movzbl %al,%eax
    81fe:	50                   	push   %eax
    81ff:	8d 45 fc             	lea    -0x4(%ebp),%eax
    8202:	50                   	push   %eax
    8203:	0f b7 d2             	movzwl %dx,%edx
    8206:	52                   	push   %edx
    8207:	ff 75 08             	pushl  0x8(%ebp)
    820a:	e8 f9 fd ff ff       	call   8008 <coap_packet_append_option>
    820f:	83 c4 10             	add    $0x10,%esp
}
    8212:	c9                   	leave  
    8213:	c3                   	ret    

00008214 <coap_option_value_to_int>:
{
    8214:	55                   	push   %ebp
    8215:	89 e5                	mov    %esp,%ebp
    8217:	8b 55 08             	mov    0x8(%ebp),%edx
	switch (option->len) {
    821a:	8a 42 02             	mov    0x2(%edx),%al
    821d:	3c 02                	cmp    $0x2,%al
    821f:	74 1a                	je     823b <coap_option_value_to_int+0x27>
    8221:	77 06                	ja     8229 <coap_option_value_to_int+0x15>
    8223:	fe c8                	dec    %al
    8225:	74 0e                	je     8235 <coap_option_value_to_int+0x21>
    8227:	eb 08                	jmp    8231 <coap_option_value_to_int+0x1d>
    8229:	3c 03                	cmp    $0x3,%al
    822b:	74 19                	je     8246 <coap_option_value_to_int+0x32>
    822d:	3c 04                	cmp    $0x4,%al
    822f:	74 2d                	je     825e <coap_option_value_to_int+0x4a>
		return 0;
    8231:	31 c0                	xor    %eax,%eax
    8233:	eb 2e                	jmp    8263 <coap_option_value_to_int+0x4f>
		return option->value[0];
    8235:	0f b6 42 03          	movzbl 0x3(%edx),%eax
    8239:	eb 28                	jmp    8263 <coap_option_value_to_int+0x4f>
		return (option->value[1] << 0) | (option->value[0] << 8);
    823b:	66 8b 42 03          	mov    0x3(%edx),%ax
    823f:	86 e0                	xchg   %ah,%al
    8241:	0f b7 c0             	movzwl %ax,%eax
    8244:	eb 1d                	jmp    8263 <coap_option_value_to_int+0x4f>
		return (option->value[2] << 0) | (option->value[1] << 8) |
    8246:	0f b6 42 04          	movzbl 0x4(%edx),%eax
			(option->value[0] << 16);
    824a:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
		return (option->value[2] << 0) | (option->value[1] << 8) |
    824e:	c1 e0 08             	shl    $0x8,%eax
			(option->value[0] << 16);
    8251:	c1 e1 10             	shl    $0x10,%ecx
		return (option->value[2] << 0) | (option->value[1] << 8) |
    8254:	0f b6 52 05          	movzbl 0x5(%edx),%edx
    8258:	09 c8                	or     %ecx,%eax
    825a:	09 d0                	or     %edx,%eax
    825c:	eb 05                	jmp    8263 <coap_option_value_to_int+0x4f>
		return (option->value[3] << 0) | (option->value[2] << 8) |
    825e:	8b 42 03             	mov    0x3(%edx),%eax
    8261:	0f c8                	bswap  %eax
}
    8263:	5d                   	pop    %ebp
    8264:	c3                   	ret    

00008265 <coap_packet_append_payload_marker>:
{
    8265:	55                   	push   %ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
    8266:	ba ff 00 00 00       	mov    $0xff,%edx
{
    826b:	89 e5                	mov    %esp,%ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
    826d:	8b 45 08             	mov    0x8(%ebp),%eax
    8270:	e8 27 f9 ff ff       	call   7b9c <append_u8>
}
    8275:	5d                   	pop    %ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
    8276:	3c 01                	cmp    $0x1,%al
    8278:	19 c0                	sbb    %eax,%eax
    827a:	83 e0 ea             	and    $0xffffffea,%eax
}
    827d:	c3                   	ret    

0000827e <coap_next_token>:
{
    827e:	55                   	push   %ebp
    827f:	89 e5                	mov    %esp,%ebp
	rand[0] = sys_rand32_get();
    8281:	e8 86 13 00 00       	call   960c <sys_rand32_get>
    8286:	a3 4c 42 40 00       	mov    %eax,0x40424c
	rand[1] = sys_rand32_get();
    828b:	e8 7c 13 00 00       	call   960c <sys_rand32_get>
}
    8290:	5d                   	pop    %ebp
	rand[1] = sys_rand32_get();
    8291:	a3 50 42 40 00       	mov    %eax,0x404250
}
    8296:	b8 4c 42 40 00       	mov    $0x40424c,%eax
    829b:	c3                   	ret    

0000829c <coap_packet_parse>:
{
    829c:	55                   	push   %ebp
    829d:	89 e5                	mov    %esp,%ebp
    829f:	57                   	push   %edi
    82a0:	56                   	push   %esi
    82a1:	53                   	push   %ebx
    82a2:	83 ec 0c             	sub    $0xc,%esp
    82a5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    82a8:	8b 75 10             	mov    0x10(%ebp),%esi
	if (!cpkt || !data) {
    82ab:	85 ff                	test   %edi,%edi
{
    82ad:	8b 4d 18             	mov    0x18(%ebp),%ecx
	if (!cpkt || !data) {
    82b0:	0f 94 c2             	sete   %dl
	if (len < BASIC_HEADER_SIZE) {
    82b3:	66 83 fe 03          	cmp    $0x3,%si
{
    82b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (len < BASIC_HEADER_SIZE) {
    82ba:	0f 96 c0             	setbe  %al
{
    82bd:	88 4d eb             	mov    %cl,-0x15(%ebp)
	if (len < BASIC_HEADER_SIZE) {
    82c0:	08 c2                	or     %al,%dl
    82c2:	75 04                	jne    82c8 <coap_packet_parse+0x2c>
    82c4:	85 db                	test   %ebx,%ebx
    82c6:	75 0a                	jne    82d2 <coap_packet_parse+0x36>
		return -EINVAL;
    82c8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    82cd:	e9 b6 00 00 00       	jmp    8388 <coap_packet_parse+0xec>
	if (options) {
    82d2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    82d6:	74 14                	je     82ec <coap_packet_parse+0x50>
		memset(options, 0, opt_num * sizeof(struct coap_option));
    82d8:	0f b6 c9             	movzbl %cl,%ecx
    82db:	c1 e1 04             	shl    $0x4,%ecx
    82de:	51                   	push   %ecx
    82df:	6a 00                	push   $0x0
    82e1:	ff 75 14             	pushl  0x14(%ebp)
    82e4:	e8 b7 26 00 00       	call   a9a0 <memset>
    82e9:	83 c4 0c             	add    $0xc,%esp
	cpkt->data = data;
    82ec:	89 3b                	mov    %edi,(%ebx)
	cpkt->offset = 0;
    82ee:	66 c7 43 04 00 00    	movw   $0x0,0x4(%ebx)
	cpkt->max_len = len;
    82f4:	66 89 73 06          	mov    %si,0x6(%ebx)
	cpkt->hdr_len = 0;
    82f8:	c6 43 08 00          	movb   $0x0,0x8(%ebx)
	cpkt->opt_len = 0;
    82fc:	c7 43 0a 00 00 00 00 	movl   $0x0,0xa(%ebx)
	tkl = cpkt->data[0] & 0x0f;
    8303:	8a 17                	mov    (%edi),%dl
    8305:	83 e2 0f             	and    $0xf,%edx
	if (tkl > 8) {
    8308:	80 fa 08             	cmp    $0x8,%dl
    830b:	77 bb                	ja     82c8 <coap_packet_parse+0x2c>
	cpkt->hdr_len = BASIC_HEADER_SIZE + tkl;
    830d:	83 c2 04             	add    $0x4,%edx
    8310:	88 53 08             	mov    %dl,0x8(%ebx)
	if (cpkt->hdr_len > len) {
    8313:	66 0f be d2          	movsbw %dl,%dx
    8317:	66 39 f2             	cmp    %si,%dx
    831a:	77 ac                	ja     82c8 <coap_packet_parse+0x2c>
	cpkt->offset = cpkt->hdr_len;
    831c:	66 89 53 04          	mov    %dx,0x4(%ebx)
		return 0;
    8320:	b8 00 00 00 00       	mov    $0x0,%eax
	if (cpkt->hdr_len == len) {
    8325:	74 61                	je     8388 <coap_packet_parse+0xec>
	offset = cpkt->offset;
    8327:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
	opt_len = 0U;
    832b:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
	delta = 0U;
    8331:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	num = 0U;
    8337:	31 f6                	xor    %esi,%esi
		option = num < opt_num ? &options[num++] : NULL;
    8339:	89 f1                	mov    %esi,%ecx
    833b:	31 c0                	xor    %eax,%eax
    833d:	3a 4d eb             	cmp    -0x15(%ebp),%cl
    8340:	73 0a                	jae    834c <coap_packet_parse+0xb0>
    8342:	0f b6 c1             	movzbl %cl,%eax
    8345:	c1 e0 04             	shl    $0x4,%eax
    8348:	46                   	inc    %esi
    8349:	03 45 14             	add    0x14(%ebp),%eax
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
    834c:	50                   	push   %eax
    834d:	8d 45 ee             	lea    -0x12(%ebp),%eax
    8350:	50                   	push   %eax
    8351:	8d 45 f2             	lea    -0xe(%ebp),%eax
    8354:	50                   	push   %eax
    8355:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    8358:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
    835c:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
    8360:	50                   	push   %eax
    8361:	8b 03                	mov    (%ebx),%eax
    8363:	e8 12 fa ff ff       	call   7d7a <parse_option>
    8368:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
    836b:	85 c0                	test   %eax,%eax
    836d:	78 19                	js     8388 <coap_packet_parse+0xec>
		} else if (ret == 0) {
    836f:	75 c8                	jne    8339 <coap_packet_parse+0x9d>
	cpkt->opt_len = opt_len;
    8371:	66 8b 55 ee          	mov    -0x12(%ebp),%dx
    8375:	66 89 53 0a          	mov    %dx,0xa(%ebx)
	cpkt->delta = delta;
    8379:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
    837d:	66 89 53 0c          	mov    %dx,0xc(%ebx)
	cpkt->offset = offset;
    8381:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8384:	66 89 53 04          	mov    %dx,0x4(%ebx)
}
    8388:	8d 65 f4             	lea    -0xc(%ebp),%esp
    838b:	5b                   	pop    %ebx
    838c:	5e                   	pop    %esi
    838d:	5f                   	pop    %edi
    838e:	5d                   	pop    %ebp
    838f:	c3                   	ret    

00008390 <coap_find_options>:
{
    8390:	55                   	push   %ebp
    8391:	89 e5                	mov    %esp,%ebp
    8393:	57                   	push   %edi
    8394:	56                   	push   %esi
    8395:	53                   	push   %ebx
	num = 0U;
    8396:	31 db                	xor    %ebx,%ebx
{
    8398:	83 ec 0c             	sub    $0xc,%esp
	opt_len = 0U;
    839b:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
{
    83a1:	8b 45 14             	mov    0x14(%ebp),%eax
    83a4:	8b 7d 0c             	mov    0xc(%ebp),%edi
    83a7:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	offset = cpkt->hdr_len;
    83ab:	8b 45 08             	mov    0x8(%ebp),%eax
	delta = 0U;
    83ae:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	offset = cpkt->hdr_len;
    83b4:	0f b6 40 08          	movzbl 0x8(%eax),%eax
    83b8:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	while (delta <= code && num < veclen) {
    83bc:	0f b6 c3             	movzbl %bl,%eax
    83bf:	66 3b 45 ea          	cmp    -0x16(%ebp),%ax
    83c3:	73 42                	jae    8407 <coap_find_options+0x77>
				 &options[num]);
    83c5:	0f b6 f3             	movzbl %bl,%esi
    83c8:	c1 e6 04             	shl    $0x4,%esi
		r = parse_option(cpkt->data, offset, &offset,
    83cb:	8d 45 ee             	lea    -0x12(%ebp),%eax
    83ce:	03 75 10             	add    0x10(%ebp),%esi
    83d1:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    83d4:	56                   	push   %esi
    83d5:	50                   	push   %eax
    83d6:	8d 45 f2             	lea    -0xe(%ebp),%eax
    83d9:	50                   	push   %eax
    83da:	8b 45 08             	mov    0x8(%ebp),%eax
    83dd:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
    83e1:	0f b7 40 06          	movzwl 0x6(%eax),%eax
    83e5:	50                   	push   %eax
    83e6:	8b 45 08             	mov    0x8(%ebp),%eax
    83e9:	8b 00                	mov    (%eax),%eax
    83eb:	e8 8a f9 ff ff       	call   7d7a <parse_option>
    83f0:	83 c4 10             	add    $0x10,%esp
		if (r < 0) {
    83f3:	85 c0                	test   %eax,%eax
    83f5:	78 15                	js     840c <coap_find_options+0x7c>
		if (code == options[num].delta) {
    83f7:	66 39 3e             	cmp    %di,(%esi)
    83fa:	75 01                	jne    83fd <coap_find_options+0x6d>
			num++;
    83fc:	43                   	inc    %ebx
		if (r == 0) {
    83fd:	85 c0                	test   %eax,%eax
    83ff:	74 06                	je     8407 <coap_find_options+0x77>
	while (delta <= code && num < veclen) {
    8401:	66 39 7d f2          	cmp    %di,-0xe(%ebp)
    8405:	76 b5                	jbe    83bc <coap_find_options+0x2c>
	return num;
    8407:	0f b6 c3             	movzbl %bl,%eax
    840a:	eb 05                	jmp    8411 <coap_find_options+0x81>
			return -EINVAL;
    840c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    8411:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8414:	5b                   	pop    %ebx
    8415:	5e                   	pop    %esi
    8416:	5f                   	pop    %edi
    8417:	5d                   	pop    %ebp
    8418:	c3                   	ret    

00008419 <get_block_option>:
{
    8419:	55                   	push   %ebp
    841a:	89 e5                	mov    %esp,%ebp
    841c:	53                   	push   %ebx
    841d:	83 ec 10             	sub    $0x10,%esp
	count = coap_find_options(cpkt, code, &option, count);
    8420:	8d 5d ec             	lea    -0x14(%ebp),%ebx
    8423:	6a 01                	push   $0x1
    8425:	53                   	push   %ebx
    8426:	0f b7 d2             	movzwl %dx,%edx
    8429:	52                   	push   %edx
    842a:	50                   	push   %eax
    842b:	e8 60 ff ff ff       	call   8390 <coap_find_options>
    8430:	83 c4 10             	add    $0x10,%esp
	if (count <= 0) {
    8433:	85 c0                	test   %eax,%eax
    8435:	7e 09                	jle    8440 <get_block_option+0x27>
	val = coap_option_value_to_int(&option);
    8437:	53                   	push   %ebx
    8438:	e8 d7 fd ff ff       	call   8214 <coap_option_value_to_int>
    843d:	5a                   	pop    %edx
	return val;
    843e:	eb 05                	jmp    8445 <get_block_option+0x2c>
		return -ENOENT;
    8440:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
    8445:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8448:	c9                   	leave  
    8449:	c3                   	ret    

0000844a <get_observe_option>:
	pending->timeout = 0;
	pending->data = NULL;
}

static int get_observe_option(const struct coap_packet *cpkt)
{
    844a:	55                   	push   %ebp
    844b:	89 c2                	mov    %eax,%edx
    844d:	89 e5                	mov    %esp,%ebp
    844f:	57                   	push   %edi
    8450:	83 ec 10             	sub    $0x10,%esp
	struct coap_option option = {};
    8453:	31 c0                	xor    %eax,%eax
    8455:	8d 7d ec             	lea    -0x14(%ebp),%edi
    8458:	b9 04 00 00 00       	mov    $0x4,%ecx
    845d:	f3 ab                	rep stos %eax,%es:(%edi)
	u16_t count = 1U;
	int r;

	r = coap_find_options(cpkt, COAP_OPTION_OBSERVE, &option, count);
    845f:	6a 01                	push   $0x1
    8461:	8d 7d ec             	lea    -0x14(%ebp),%edi
    8464:	57                   	push   %edi
    8465:	6a 06                	push   $0x6
    8467:	52                   	push   %edx
    8468:	e8 23 ff ff ff       	call   8390 <coap_find_options>
    846d:	83 c4 10             	add    $0x10,%esp
	if (r <= 0) {
    8470:	85 c0                	test   %eax,%eax
    8472:	7e 09                	jle    847d <get_observe_option+0x33>
		return -ENOENT;
	}

	return coap_option_value_to_int(&option);
    8474:	57                   	push   %edi
    8475:	e8 9a fd ff ff       	call   8214 <coap_option_value_to_int>
    847a:	5a                   	pop    %edx
    847b:	eb 05                	jmp    8482 <get_observe_option+0x38>
		return -ENOENT;
    847d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
    8482:	8b 7d fc             	mov    -0x4(%ebp),%edi
    8485:	c9                   	leave  
    8486:	c3                   	ret    

00008487 <coap_header_get_type>:
{
    8487:	55                   	push   %ebp
		return 0;
    8488:	31 c0                	xor    %eax,%eax
{
    848a:	89 e5                	mov    %esp,%ebp
    848c:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
    848f:	85 d2                	test   %edx,%edx
    8491:	74 0f                	je     84a2 <coap_header_get_type+0x1b>
    8493:	8b 12                	mov    (%edx),%edx
    8495:	85 d2                	test   %edx,%edx
    8497:	74 09                	je     84a2 <coap_header_get_type+0x1b>
	return (cpkt->data[0] & 0x30) >> 4;
    8499:	0f b6 02             	movzbl (%edx),%eax
    849c:	c1 f8 04             	sar    $0x4,%eax
    849f:	83 e0 03             	and    $0x3,%eax
}
    84a2:	5d                   	pop    %ebp
    84a3:	c3                   	ret    

000084a4 <coap_header_get_token>:
{
    84a4:	55                   	push   %ebp
    84a5:	89 e5                	mov    %esp,%ebp
    84a7:	53                   	push   %ebx
		return 0;
    84a8:	31 db                	xor    %ebx,%ebx
{
    84aa:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!cpkt || !cpkt->data) {
    84ad:	85 c0                	test   %eax,%eax
    84af:	74 20                	je     84d1 <coap_header_get_token+0x2d>
    84b1:	8b 00                	mov    (%eax),%eax
    84b3:	85 c0                	test   %eax,%eax
    84b5:	74 1a                	je     84d1 <coap_header_get_token+0x2d>
	if (tkl) {
    84b7:	8a 18                	mov    (%eax),%bl
    84b9:	80 e3 0f             	and    $0xf,%bl
    84bc:	74 13                	je     84d1 <coap_header_get_token+0x2d>
		memcpy(token, cpkt->data + BASIC_HEADER_SIZE, tkl);
    84be:	0f b6 d3             	movzbl %bl,%edx
    84c1:	52                   	push   %edx
    84c2:	83 c0 04             	add    $0x4,%eax
    84c5:	50                   	push   %eax
    84c6:	ff 75 0c             	pushl  0xc(%ebp)
    84c9:	e8 63 24 00 00       	call   a931 <memcpy>
    84ce:	83 c4 0c             	add    $0xc,%esp
}
    84d1:	88 d8                	mov    %bl,%al
    84d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    84d6:	c9                   	leave  
    84d7:	c3                   	ret    

000084d8 <coap_header_get_code>:
{
    84d8:	55                   	push   %ebp
		return 0;
    84d9:	31 c0                	xor    %eax,%eax
{
    84db:	89 e5                	mov    %esp,%ebp
    84dd:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
    84e0:	85 d2                	test   %edx,%edx
    84e2:	74 3f                	je     8523 <coap_header_get_code+0x4b>
    84e4:	8b 12                	mov    (%edx),%edx
    84e6:	85 d2                	test   %edx,%edx
    84e8:	74 39                	je     8523 <coap_header_get_code+0x4b>
	return cpkt->data[1];
    84ea:	8a 42 01             	mov    0x1(%edx),%al
	switch (code) {
    84ed:	3c 86                	cmp    $0x86,%al
    84ef:	77 14                	ja     8505 <coap_header_get_code+0x2d>
    84f1:	3c 80                	cmp    $0x80,%al
    84f3:	73 2e                	jae    8523 <coap_header_get_code+0x4b>
    84f5:	3c 45                	cmp    $0x45,%al
    84f7:	77 08                	ja     8501 <coap_header_get_code+0x29>
    84f9:	3c 40                	cmp    $0x40,%al
    84fb:	73 26                	jae    8523 <coap_header_get_code+0x4b>
    84fd:	3c 04                	cmp    $0x4,%al
    84ff:	eb 1e                	jmp    851f <coap_header_get_code+0x47>
    8501:	3c 5f                	cmp    $0x5f,%al
    8503:	eb 0a                	jmp    850f <coap_header_get_code+0x37>
    8505:	3c 8d                	cmp    $0x8d,%al
    8507:	77 0a                	ja     8513 <coap_header_get_code+0x3b>
    8509:	3c 8c                	cmp    $0x8c,%al
    850b:	73 16                	jae    8523 <coap_header_get_code+0x4b>
    850d:	3c 88                	cmp    $0x88,%al
    850f:	75 10                	jne    8521 <coap_header_get_code+0x49>
    8511:	eb 10                	jmp    8523 <coap_header_get_code+0x4b>
    8513:	3c 8f                	cmp    $0x8f,%al
    8515:	74 0c                	je     8523 <coap_header_get_code+0x4b>
    8517:	72 08                	jb     8521 <coap_header_get_code+0x49>
    8519:	8d 50 60             	lea    0x60(%eax),%edx
    851c:	80 fa 05             	cmp    $0x5,%dl
    851f:	76 02                	jbe    8523 <coap_header_get_code+0x4b>
		return COAP_CODE_EMPTY;
    8521:	31 c0                	xor    %eax,%eax
}
    8523:	5d                   	pop    %ebp
    8524:	c3                   	ret    

00008525 <is_request>:
{
    8525:	55                   	push   %ebp
    8526:	89 e5                	mov    %esp,%ebp
	u8_t code = coap_header_get_code(cpkt);
    8528:	50                   	push   %eax
    8529:	e8 aa ff ff ff       	call   84d8 <coap_header_get_code>
    852e:	5a                   	pop    %edx
	return !(code & ~COAP_REQUEST_MASK);
    852f:	a8 f8                	test   $0xf8,%al
}
    8531:	c9                   	leave  
	return !(code & ~COAP_REQUEST_MASK);
    8532:	0f 94 c0             	sete   %al
}
    8535:	c3                   	ret    

00008536 <coap_header_get_id>:
{
    8536:	55                   	push   %ebp
		return 0;
    8537:	31 c0                	xor    %eax,%eax
{
    8539:	89 e5                	mov    %esp,%ebp
    853b:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
    853e:	85 d2                	test   %edx,%edx
    8540:	74 15                	je     8557 <coap_header_get_id+0x21>
    8542:	8b 0a                	mov    (%edx),%ecx
    8544:	85 c9                	test   %ecx,%ecx
    8546:	74 0f                	je     8557 <coap_header_get_id+0x21>
	return (cpkt->data[2] << 8) | cpkt->data[3];
    8548:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    854c:	c1 e0 08             	shl    $0x8,%eax
    854f:	89 c2                	mov    %eax,%edx
    8551:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    8555:	09 d0                	or     %edx,%eax
}
    8557:	5d                   	pop    %ebp
    8558:	c3                   	ret    

00008559 <coap_packet_get_payload>:
{
    8559:	55                   	push   %ebp
    855a:	89 e5                	mov    %esp,%ebp
    855c:	56                   	push   %esi
    855d:	53                   	push   %ebx
    855e:	8b 55 08             	mov    0x8(%ebp),%edx
    8561:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!cpkt || !len) {
    8564:	85 d2                	test   %edx,%edx
    8566:	74 04                	je     856c <coap_packet_get_payload+0x13>
    8568:	85 db                	test   %ebx,%ebx
    856a:	75 04                	jne    8570 <coap_packet_get_payload+0x17>
		return NULL;
    856c:	31 c0                	xor    %eax,%eax
    856e:	eb 29                	jmp    8599 <coap_packet_get_payload+0x40>
	payload_len = cpkt->max_len - cpkt->hdr_len - cpkt->opt_len;
    8570:	0f b6 4a 08          	movzbl 0x8(%edx),%ecx
    8574:	0f b7 72 0a          	movzwl 0xa(%edx),%esi
    8578:	0f b7 42 06          	movzwl 0x6(%edx),%eax
    857c:	01 f1                	add    %esi,%ecx
    857e:	29 c8                	sub    %ecx,%eax
	if (payload_len > 0) {
    8580:	89 c1                	mov    %eax,%ecx
    8582:	79 02                	jns    8586 <coap_packet_get_payload+0x2d>
    8584:	31 c9                	xor    %ecx,%ecx
    8586:	66 89 0b             	mov    %cx,(%ebx)
	return !(*len) ? NULL :
    8589:	85 c0                	test   %eax,%eax
    858b:	7e df                	jle    856c <coap_packet_get_payload+0x13>
		cpkt->data + cpkt->hdr_len + cpkt->opt_len;
    858d:	0f b6 42 08          	movzbl 0x8(%edx),%eax
    8591:	0f b7 4a 0a          	movzwl 0xa(%edx),%ecx
    8595:	01 c8                	add    %ecx,%eax
	return !(*len) ? NULL :
    8597:	03 02                	add    (%edx),%eax
}
    8599:	5b                   	pop    %ebx
    859a:	5e                   	pop    %esi
    859b:	5d                   	pop    %ebp
    859c:	c3                   	ret    

0000859d <coap_block_transfer_init>:
{
    859d:	55                   	push   %ebp
    859e:	89 e5                	mov    %esp,%ebp
    85a0:	8b 45 08             	mov    0x8(%ebp),%eax
	ctx->block_size = block_size;
    85a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    85a6:	89 50 08             	mov    %edx,0x8(%eax)
	ctx->total_size = total_size;
    85a9:	8b 55 10             	mov    0x10(%ebp),%edx
    85ac:	89 10                	mov    %edx,(%eax)
	ctx->current = 0;
    85ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
    85b5:	5d                   	pop    %ebp
    85b6:	31 c0                	xor    %eax,%eax
    85b8:	c3                   	ret    

000085b9 <coap_append_block1_option>:
{
    85b9:	55                   	push   %ebp
    85ba:	89 e5                	mov    %esp,%ebp
    85bc:	57                   	push   %edi
    85bd:	56                   	push   %esi
 * @return The size in bytes that the block_size represents
 */
static inline u16_t coap_block_size_to_bytes(
	enum coap_block_size block_size)
{
	return (1 << (block_size + 4));
    85be:	bf 01 00 00 00       	mov    $0x1,%edi
    85c3:	8b 75 0c             	mov    0xc(%ebp),%esi
    85c6:	53                   	push   %ebx
	if (is_request(cpkt)) {
    85c7:	8b 45 08             	mov    0x8(%ebp),%eax
	u16_t bytes = coap_block_size_to_bytes(ctx->block_size);
    85ca:	8b 4e 08             	mov    0x8(%esi),%ecx
	if (is_request(cpkt)) {
    85cd:	e8 53 ff ff ff       	call   8525 <is_request>
    85d2:	89 cb                	mov    %ecx,%ebx
    85d4:	83 c1 04             	add    $0x4,%ecx
    85d7:	88 c2                	mov    %al,%dl
    85d9:	83 e3 07             	and    $0x7,%ebx
    85dc:	d3 e7                	shl    %cl,%edi
    85de:	8b 46 04             	mov    0x4(%esi),%eax
    85e1:	84 d2                	test   %dl,%dl
    85e3:	0f b7 cf             	movzwl %di,%ecx
    85e6:	74 17                	je     85ff <coap_append_block1_option+0x46>
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
    85e8:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    85eb:	3b 16                	cmp    (%esi),%edx
    85ed:	19 f6                	sbb    %esi,%esi
		SET_NUM(val, ctx->current / bytes);
    85ef:	31 d2                	xor    %edx,%edx
    85f1:	f7 f1                	div    %ecx
    85f3:	c1 e0 04             	shl    $0x4,%eax
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
    85f6:	83 e6 08             	and    $0x8,%esi
		SET_NUM(val, ctx->current / bytes);
    85f9:	09 c3                	or     %eax,%ebx
    85fb:	09 f3                	or     %esi,%ebx
    85fd:	eb 09                	jmp    8608 <coap_append_block1_option+0x4f>
		SET_NUM(val, ctx->current / bytes);
    85ff:	31 d2                	xor    %edx,%edx
    8601:	f7 f1                	div    %ecx
    8603:	c1 e0 04             	shl    $0x4,%eax
    8606:	09 c3                	or     %eax,%ebx
	r = coap_append_option_int(cpkt, COAP_OPTION_BLOCK1, val);
    8608:	53                   	push   %ebx
    8609:	6a 1b                	push   $0x1b
    860b:	ff 75 08             	pushl  0x8(%ebp)
    860e:	e8 95 fb ff ff       	call   81a8 <coap_append_option_int>
    8613:	83 c4 0c             	add    $0xc,%esp
}
    8616:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8619:	5b                   	pop    %ebx
    861a:	5e                   	pop    %esi
    861b:	5f                   	pop    %edi
    861c:	5d                   	pop    %ebp
    861d:	c3                   	ret    

0000861e <coap_append_block2_option>:
{
    861e:	55                   	push   %ebp
    861f:	89 e5                	mov    %esp,%ebp
    8621:	57                   	push   %edi
    8622:	56                   	push   %esi
    8623:	bf 01 00 00 00       	mov    $0x1,%edi
    8628:	8b 75 0c             	mov    0xc(%ebp),%esi
    862b:	53                   	push   %ebx
	if (is_request(cpkt)) {
    862c:	8b 45 08             	mov    0x8(%ebp),%eax
	u16_t bytes = coap_block_size_to_bytes(ctx->block_size);
    862f:	8b 4e 08             	mov    0x8(%esi),%ecx
	if (is_request(cpkt)) {
    8632:	e8 ee fe ff ff       	call   8525 <is_request>
    8637:	89 cb                	mov    %ecx,%ebx
    8639:	83 c1 04             	add    $0x4,%ecx
    863c:	88 c2                	mov    %al,%dl
    863e:	83 e3 07             	and    $0x7,%ebx
    8641:	d3 e7                	shl    %cl,%edi
    8643:	8b 46 04             	mov    0x4(%esi),%eax
    8646:	84 d2                	test   %dl,%dl
    8648:	0f b7 cf             	movzwl %di,%ecx
    864b:	74 09                	je     8656 <coap_append_block2_option+0x38>
		SET_NUM(val, ctx->current / bytes);
    864d:	31 d2                	xor    %edx,%edx
    864f:	f7 f1                	div    %ecx
    8651:	c1 e0 04             	shl    $0x4,%eax
    8654:	eb 13                	jmp    8669 <coap_append_block2_option+0x4b>
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
    8656:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    8659:	3b 16                	cmp    (%esi),%edx
    865b:	19 f6                	sbb    %esi,%esi
		SET_NUM(val, ctx->current / bytes);
    865d:	31 d2                	xor    %edx,%edx
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
    865f:	83 e6 08             	and    $0x8,%esi
		SET_NUM(val, ctx->current / bytes);
    8662:	f7 f1                	div    %ecx
    8664:	c1 e0 04             	shl    $0x4,%eax
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
    8667:	09 f3                	or     %esi,%ebx
		SET_NUM(val, ctx->current / bytes);
    8669:	09 c3                	or     %eax,%ebx
	r = coap_append_option_int(cpkt, COAP_OPTION_BLOCK2, val);
    866b:	53                   	push   %ebx
    866c:	6a 17                	push   $0x17
    866e:	ff 75 08             	pushl  0x8(%ebp)
    8671:	e8 32 fb ff ff       	call   81a8 <coap_append_option_int>
    8676:	83 c4 0c             	add    $0xc,%esp
}
    8679:	8d 65 f4             	lea    -0xc(%ebp),%esp
    867c:	5b                   	pop    %ebx
    867d:	5e                   	pop    %esi
    867e:	5f                   	pop    %edi
    867f:	5d                   	pop    %ebp
    8680:	c3                   	ret    

00008681 <coap_update_from_block>:
{
    8681:	55                   	push   %ebp
	block1 = get_block_option(cpkt, COAP_OPTION_BLOCK1);
    8682:	ba 1b 00 00 00       	mov    $0x1b,%edx
{
    8687:	89 e5                	mov    %esp,%ebp
    8689:	57                   	push   %edi
    868a:	56                   	push   %esi
    868b:	53                   	push   %ebx
    868c:	83 ec 0c             	sub    $0xc,%esp
    868f:	8b 75 08             	mov    0x8(%ebp),%esi
    8692:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	block1 = get_block_option(cpkt, COAP_OPTION_BLOCK1);
    8695:	89 f0                	mov    %esi,%eax
    8697:	e8 7d fd ff ff       	call   8419 <get_block_option>
	block2 = get_block_option(cpkt, COAP_OPTION_BLOCK2);
    869c:	ba 17 00 00 00       	mov    $0x17,%edx
	block1 = get_block_option(cpkt, COAP_OPTION_BLOCK1);
    86a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	block2 = get_block_option(cpkt, COAP_OPTION_BLOCK2);
    86a4:	89 f0                	mov    %esi,%eax
    86a6:	e8 6e fd ff ff       	call   8419 <get_block_option>
	size1 = get_block_option(cpkt, COAP_OPTION_SIZE1);
    86ab:	ba 3c 00 00 00       	mov    $0x3c,%edx
	block2 = get_block_option(cpkt, COAP_OPTION_BLOCK2);
    86b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size1 = get_block_option(cpkt, COAP_OPTION_SIZE1);
    86b3:	89 f0                	mov    %esi,%eax
    86b5:	e8 5f fd ff ff       	call   8419 <get_block_option>
	size2 = get_block_option(cpkt, COAP_OPTION_SIZE2);
    86ba:	ba 1c 00 00 00       	mov    $0x1c,%edx
	size1 = get_block_option(cpkt, COAP_OPTION_SIZE1);
    86bf:	89 c7                	mov    %eax,%edi
	size2 = get_block_option(cpkt, COAP_OPTION_SIZE2);
    86c1:	89 f0                	mov    %esi,%eax
    86c3:	e8 51 fd ff ff       	call   8419 <get_block_option>
	size1 = size1 == -ENOENT ? 0 : size1;
    86c8:	83 ff fe             	cmp    $0xfffffffe,%edi
	size2 = get_block_option(cpkt, COAP_OPTION_SIZE2);
    86cb:	89 c2                	mov    %eax,%edx
	size1 = size1 == -ENOENT ? 0 : size1;
    86cd:	75 02                	jne    86d1 <coap_update_from_block+0x50>
    86cf:	31 ff                	xor    %edi,%edi
	size2 = size2 == -ENOENT ? 0 : size2;
    86d1:	83 fa fe             	cmp    $0xfffffffe,%edx
    86d4:	75 02                	jne    86d8 <coap_update_from_block+0x57>
    86d6:	31 d2                	xor    %edx,%edx
	if (is_request(cpkt)) {
    86d8:	89 f0                	mov    %esi,%eax
    86da:	89 55 e8             	mov    %edx,-0x18(%ebp)
    86dd:	e8 43 fe ff ff       	call   8525 <is_request>
    86e2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    86e5:	84 c0                	test   %al,%al
    86e7:	74 3d                	je     8726 <coap_update_from_block+0xa5>
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
    86e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    86ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
    86ef:	c1 fa 04             	sar    $0x4,%edx
    86f2:	83 e0 07             	and    $0x7,%eax
    86f5:	89 d6                	mov    %edx,%esi
    86f7:	8d 48 04             	lea    0x4(%eax),%ecx
    86fa:	d3 e6                	shl    %cl,%esi
	if (block == -ENOENT) {
    86fc:	83 7d f0 fe          	cmpl   $0xfffffffe,-0x10(%ebp)
    8700:	74 1d                	je     871f <coap_update_from_block+0x9e>
	if (GET_MORE(block)) {
    8702:	f6 45 f0 08          	testb  $0x8,-0x10(%ebp)
    8706:	75 57                	jne    875f <coap_update_from_block+0xde>
	if (GET_NUM(block) > 0 && GET_BLOCK_SIZE(block) != ctx->block_size) {
    8708:	8b 4b 08             	mov    0x8(%ebx),%ecx
    870b:	85 d2                	test   %edx,%edx
    870d:	7e 04                	jle    8713 <coap_update_from_block+0x92>
    870f:	39 c1                	cmp    %eax,%ecx
    8711:	75 4c                	jne    875f <coap_update_from_block+0xde>
	ctx->current = new_current;
    8713:	89 73 04             	mov    %esi,0x4(%ebx)
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
    8716:	39 c1                	cmp    %eax,%ecx
    8718:	76 02                	jbe    871c <coap_update_from_block+0x9b>
    871a:	89 c1                	mov    %eax,%ecx
    871c:	89 4b 08             	mov    %ecx,0x8(%ebx)
		return update_descriptive_block(ctx, block1, size1);
    871f:	89 f9                	mov    %edi,%ecx
    8721:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8724:	eb 2b                	jmp    8751 <coap_update_from_block+0xd0>
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
    8726:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8729:	8b 75 ec             	mov    -0x14(%ebp),%esi
    872c:	c1 fe 04             	sar    $0x4,%esi
    872f:	83 e0 07             	and    $0x7,%eax
    8732:	8d 48 04             	lea    0x4(%eax),%ecx
    8735:	d3 e6                	shl    %cl,%esi
	if (block == -ENOENT) {
    8737:	83 7d ec fe          	cmpl   $0xfffffffe,-0x14(%ebp)
    873b:	74 0f                	je     874c <coap_update_from_block+0xcb>
	if (new_current != ctx->current) {
    873d:	3b 73 04             	cmp    0x4(%ebx),%esi
    8740:	75 1d                	jne    875f <coap_update_from_block+0xde>
	if (GET_BLOCK_SIZE(block) > ctx->block_size) {
    8742:	3b 43 08             	cmp    0x8(%ebx),%eax
    8745:	77 18                	ja     875f <coap_update_from_block+0xde>
	ctx->block_size = GET_BLOCK_SIZE(block);
    8747:	89 43 08             	mov    %eax,0x8(%ebx)
	ctx->total_size = size;
    874a:	89 3b                	mov    %edi,(%ebx)
	return update_descriptive_block(ctx, block2, size2);
    874c:	89 d1                	mov    %edx,%ecx
    874e:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
    8751:	83 c4 0c             	add    $0xc,%esp
	return update_descriptive_block(ctx, block2, size2);
    8754:	89 d8                	mov    %ebx,%eax
}
    8756:	5b                   	pop    %ebx
    8757:	5e                   	pop    %esi
    8758:	5f                   	pop    %edi
    8759:	5d                   	pop    %ebp
	return update_descriptive_block(ctx, block2, size2);
    875a:	e9 4e f5 ff ff       	jmp    7cad <update_descriptive_block>
}
    875f:	83 c4 0c             	add    $0xc,%esp
    8762:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8767:	5b                   	pop    %ebx
    8768:	5e                   	pop    %esi
    8769:	5f                   	pop    %edi
    876a:	5d                   	pop    %ebp
    876b:	c3                   	ret    

0000876c <coap_next_block>:
{
    876c:	55                   	push   %ebp
    876d:	89 e5                	mov    %esp,%ebp
    876f:	53                   	push   %ebx
    8770:	8b 4d 08             	mov    0x8(%ebp),%ecx
    8773:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (is_request(cpkt)) {
    8776:	89 c8                	mov    %ecx,%eax
    8778:	e8 a8 fd ff ff       	call   8525 <is_request>
		block = get_block_option(cpkt, COAP_OPTION_BLOCK1);
    877d:	ba 1b 00 00 00       	mov    $0x1b,%edx
	if (is_request(cpkt)) {
    8782:	84 c0                	test   %al,%al
    8784:	75 05                	jne    878b <coap_next_block+0x1f>
		block = get_block_option(cpkt, COAP_OPTION_BLOCK2);
    8786:	ba 17 00 00 00       	mov    $0x17,%edx
    878b:	89 c8                	mov    %ecx,%eax
    878d:	e8 87 fc ff ff       	call   8419 <get_block_option>
		return 0;
    8792:	31 d2                	xor    %edx,%edx
	if (!GET_MORE(block)) {
    8794:	a8 08                	test   $0x8,%al
    8796:	74 16                	je     87ae <coap_next_block+0x42>
    8798:	8b 43 08             	mov    0x8(%ebx),%eax
    879b:	ba 01 00 00 00       	mov    $0x1,%edx
    87a0:	8d 48 04             	lea    0x4(%eax),%ecx
    87a3:	d3 e2                	shl    %cl,%edx
	ctx->current += coap_block_size_to_bytes(ctx->block_size);
    87a5:	0f b7 d2             	movzwl %dx,%edx
    87a8:	03 53 04             	add    0x4(%ebx),%edx
    87ab:	89 53 04             	mov    %edx,0x4(%ebx)
}
    87ae:	5b                   	pop    %ebx
    87af:	89 d0                	mov    %edx,%eax
    87b1:	5d                   	pop    %ebp
    87b2:	c3                   	ret    

000087b3 <coap_pending_init>:
{
    87b3:	55                   	push   %ebp
    87b4:	89 e5                	mov    %esp,%ebp
    87b6:	56                   	push   %esi
    87b7:	53                   	push   %ebx
	memset(pending, 0, sizeof(*pending));
    87b8:	6a 28                	push   $0x28
{
    87ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(pending, 0, sizeof(*pending));
    87bd:	6a 00                	push   $0x0
{
    87bf:	8b 75 0c             	mov    0xc(%ebp),%esi
	memset(pending, 0, sizeof(*pending));
    87c2:	53                   	push   %ebx
    87c3:	e8 d8 21 00 00       	call   a9a0 <memset>
    87c8:	83 c4 0c             	add    $0xc,%esp
	pending->id = coap_header_get_id(request);
    87cb:	56                   	push   %esi
    87cc:	e8 65 fd ff ff       	call   8536 <coap_header_get_id>
    87d1:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
	memcpy(&pending->addr, addr, sizeof(*addr));
    87d5:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
    87dc:	ff 75 10             	pushl  0x10(%ebp)
    87df:	53                   	push   %ebx
    87e0:	e8 4c 21 00 00       	call   a931 <memcpy>
	pending->data = request->data;
    87e5:	8b 06                	mov    (%esi),%eax
	memcpy(&pending->addr, addr, sizeof(*addr));
    87e7:	83 c4 0c             	add    $0xc,%esp
	pending->data = request->data;
    87ea:	89 43 20             	mov    %eax,0x20(%ebx)
	pending->len = request->offset;
    87ed:	8b 46 04             	mov    0x4(%esi),%eax
    87f0:	66 89 43 24          	mov    %ax,0x24(%ebx)
}
    87f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    87f7:	31 c0                	xor    %eax,%eax
    87f9:	5b                   	pop    %ebx
    87fa:	5e                   	pop    %esi
    87fb:	5d                   	pop    %ebp
    87fc:	c3                   	ret    

000087fd <coap_pending_next_unused>:
{
    87fd:	55                   	push   %ebp
	for (i = 0, p = pendings; i < len; i++, p++) {
    87fe:	31 d2                	xor    %edx,%edx
{
    8800:	89 e5                	mov    %esp,%ebp
	for (i = 0, p = pendings; i < len; i++, p++) {
    8802:	8b 45 08             	mov    0x8(%ebp),%eax
    8805:	3b 55 0c             	cmp    0xc(%ebp),%edx
    8808:	74 0c                	je     8816 <coap_pending_next_unused+0x19>
		if (p->timeout == 0) {
    880a:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
    880e:	74 08                	je     8818 <coap_pending_next_unused+0x1b>
	for (i = 0, p = pendings; i < len; i++, p++) {
    8810:	42                   	inc    %edx
    8811:	83 c0 28             	add    $0x28,%eax
    8814:	eb ef                	jmp    8805 <coap_pending_next_unused+0x8>
	return NULL;
    8816:	31 c0                	xor    %eax,%eax
}
    8818:	5d                   	pop    %ebp
    8819:	c3                   	ret    

0000881a <coap_reply_next_unused>:
{
    881a:	55                   	push   %ebp
	for (i = 0, r = replies; i < len; i++, r++) {
    881b:	31 d2                	xor    %edx,%edx
{
    881d:	89 e5                	mov    %esp,%ebp
	for (i = 0, r = replies; i < len; i++, r++) {
    881f:	8b 45 08             	mov    0x8(%ebp),%eax
    8822:	3b 55 0c             	cmp    0xc(%ebp),%edx
    8825:	74 0b                	je     8832 <coap_reply_next_unused+0x18>
		if (!r->reply) {
    8827:	83 38 00             	cmpl   $0x0,(%eax)
    882a:	74 08                	je     8834 <coap_reply_next_unused+0x1a>
	for (i = 0, r = replies; i < len; i++, r++) {
    882c:	42                   	inc    %edx
    882d:	83 c0 18             	add    $0x18,%eax
    8830:	eb f0                	jmp    8822 <coap_reply_next_unused+0x8>
	return NULL;
    8832:	31 c0                	xor    %eax,%eax
}
    8834:	5d                   	pop    %ebp
    8835:	c3                   	ret    

00008836 <coap_pending_received>:
{
    8836:	55                   	push   %ebp
    8837:	89 e5                	mov    %esp,%ebp
	u16_t resp_id = coap_header_get_id(response);
    8839:	ff 75 08             	pushl  0x8(%ebp)
    883c:	e8 f5 fc ff ff       	call   8536 <coap_header_get_id>
	for (i = 0, p = pendings; i < len; i++, p++) {
    8841:	31 c9                	xor    %ecx,%ecx
	u16_t resp_id = coap_header_get_id(response);
    8843:	5a                   	pop    %edx
	for (i = 0, p = pendings; i < len; i++, p++) {
    8844:	8b 55 0c             	mov    0xc(%ebp),%edx
    8847:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    884a:	74 12                	je     885e <coap_pending_received+0x28>
		if (!p->timeout) {
    884c:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
    8850:	74 06                	je     8858 <coap_pending_received+0x22>
		if (resp_id != p->id) {
    8852:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
    8856:	74 08                	je     8860 <coap_pending_received+0x2a>
	for (i = 0, p = pendings; i < len; i++, p++) {
    8858:	41                   	inc    %ecx
    8859:	83 c2 28             	add    $0x28,%edx
    885c:	eb e9                	jmp    8847 <coap_pending_received+0x11>
	return NULL;
    885e:	31 d2                	xor    %edx,%edx
}
    8860:	89 d0                	mov    %edx,%eax
    8862:	c9                   	leave  
    8863:	c3                   	ret    

00008864 <coap_pending_next_to_expire>:
{
    8864:	55                   	push   %ebp
	for (i = 0, p = pendings; i < len; i++, p++) {
    8865:	31 c9                	xor    %ecx,%ecx
{
    8867:	89 e5                	mov    %esp,%ebp
	struct coap_pending *p, *found = NULL;
    8869:	31 c0                	xor    %eax,%eax
{
    886b:	53                   	push   %ebx
    886c:	8b 55 08             	mov    0x8(%ebp),%edx
	for (i = 0, p = pendings; i < len; i++, p++) {
    886f:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
    8872:	74 18                	je     888c <coap_pending_next_to_expire+0x28>
		if (p->timeout && (!found || found->timeout < p->timeout)) {
    8874:	8b 5a 18             	mov    0x18(%edx),%ebx
    8877:	85 db                	test   %ebx,%ebx
    8879:	74 0b                	je     8886 <coap_pending_next_to_expire+0x22>
    887b:	85 c0                	test   %eax,%eax
    887d:	74 05                	je     8884 <coap_pending_next_to_expire+0x20>
    887f:	3b 58 18             	cmp    0x18(%eax),%ebx
    8882:	7e 02                	jle    8886 <coap_pending_next_to_expire+0x22>
    8884:	89 d0                	mov    %edx,%eax
	for (i = 0, p = pendings; i < len; i++, p++) {
    8886:	41                   	inc    %ecx
    8887:	83 c2 28             	add    $0x28,%edx
    888a:	eb e3                	jmp    886f <coap_pending_next_to_expire+0xb>
}
    888c:	5b                   	pop    %ebx
    888d:	5d                   	pop    %ebp
    888e:	c3                   	ret    

0000888f <coap_pending_cycle>:
{
    888f:	55                   	push   %ebp
    8890:	89 e5                	mov    %esp,%ebp
    8892:	8b 4d 08             	mov    0x8(%ebp),%ecx
	s32_t old = pending->timeout;
    8895:	8b 51 18             	mov    0x18(%ecx),%edx
	switch (previous) {
    8898:	81 fa 52 12 00 00    	cmp    $0x1252,%edx
    889e:	74 31                	je     88d1 <coap_pending_cycle+0x42>
    88a0:	7f 0f                	jg     88b1 <coap_pending_cycle+0x22>
	return INIT_ACK_TIMEOUT;
    88a2:	b8 29 09 00 00       	mov    $0x929,%eax
	switch (previous) {
    88a7:	81 fa 29 09 00 00    	cmp    $0x929,%edx
    88ad:	75 25                	jne    88d4 <coap_pending_cycle+0x45>
    88af:	eb 20                	jmp    88d1 <coap_pending_cycle+0x42>
    88b1:	81 fa a4 24 00 00    	cmp    $0x24a4,%edx
    88b7:	74 18                	je     88d1 <coap_pending_cycle+0x42>
	return INIT_ACK_TIMEOUT;
    88b9:	31 c0                	xor    %eax,%eax
    88bb:	81 fa 48 49 00 00    	cmp    $0x4948,%edx
    88c1:	0f 94 c0             	sete   %al
    88c4:	48                   	dec    %eax
    88c5:	25 e1 bf ff ff       	and    $0xffffbfe1,%eax
    88ca:	05 48 49 00 00       	add    $0x4948,%eax
    88cf:	eb 03                	jmp    88d4 <coap_pending_cycle+0x45>
		return previous << 1;
    88d1:	8d 04 12             	lea    (%edx,%edx,1),%eax
	pending->timeout = next_timeout(pending->timeout);
    88d4:	89 41 18             	mov    %eax,0x18(%ecx)
	return (old != pending->timeout);
    88d7:	39 c2                	cmp    %eax,%edx
}
    88d9:	5d                   	pop    %ebp
	return (old != pending->timeout);
    88da:	0f 95 c0             	setne  %al
}
    88dd:	c3                   	ret    

000088de <coap_pending_clear>:
{
    88de:	55                   	push   %ebp
    88df:	89 e5                	mov    %esp,%ebp
    88e1:	8b 45 08             	mov    0x8(%ebp),%eax
	pending->timeout = 0;
    88e4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	pending->data = NULL;
    88eb:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    88f2:	5d                   	pop    %ebp
    88f3:	c3                   	ret    

000088f4 <coap_response_received>:

struct coap_reply *coap_response_received(
	const struct coap_packet *response,
	const struct sockaddr *from,
	struct coap_reply *replies, size_t len)
{
    88f4:	55                   	push   %ebp
    88f5:	89 e5                	mov    %esp,%ebp
    88f7:	57                   	push   %edi
    88f8:	56                   	push   %esi
	size_t i;

	id = coap_header_get_id(response);
	tkl = coap_header_get_token(response, (u8_t *)token);

	for (i = 0, r = replies; i < len; i++, r++) {
    88f9:	31 f6                	xor    %esi,%esi
{
    88fb:	53                   	push   %ebx
    88fc:	83 ec 0c             	sub    $0xc,%esp
	id = coap_header_get_id(response);
    88ff:	ff 75 08             	pushl  0x8(%ebp)
    8902:	e8 2f fc ff ff       	call   8536 <coap_header_get_id>
    8907:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	tkl = coap_header_get_token(response, (u8_t *)token);
    890b:	8d 45 ec             	lea    -0x14(%ebp),%eax
    890e:	89 04 24             	mov    %eax,(%esp)
    8911:	ff 75 08             	pushl  0x8(%ebp)
    8914:	e8 8b fb ff ff       	call   84a4 <coap_header_get_token>
	for (i = 0, r = replies; i < len; i++, r++) {
    8919:	8b 7d 10             	mov    0x10(%ebp),%edi
	tkl = coap_header_get_token(response, (u8_t *)token);
    891c:	5a                   	pop    %edx
    891d:	88 c3                	mov    %al,%bl
    891f:	59                   	pop    %ecx
	for (i = 0, r = replies; i < len; i++, r++) {
    8920:	3b 75 14             	cmp    0x14(%ebp),%esi
    8923:	74 67                	je     898c <coap_response_received+0x98>
		int age;

		if ((r->id == 0) && (r->tkl == 0)) {
    8925:	8b 47 0c             	mov    0xc(%edi),%eax
    8928:	66 85 c0             	test   %ax,%ax
    892b:	75 06                	jne    8933 <coap_response_received+0x3f>
    892d:	80 7f 16 00          	cmpb   $0x0,0x16(%edi)
    8931:	74 53                	je     8986 <coap_response_received+0x92>
			continue;
		}

		/* Piggybacked must match id when token is empty */
		if ((r->id != id) && (tkl == 0)) {
    8933:	66 3b 45 ea          	cmp    -0x16(%ebp),%ax
    8937:	74 06                	je     893f <coap_response_received+0x4b>
    8939:	84 db                	test   %bl,%bl
    893b:	75 14                	jne    8951 <coap_response_received+0x5d>
    893d:	eb 47                	jmp    8986 <coap_response_received+0x92>
			continue;
		}

		if (tkl > 0 && memcmp(r->token, token, tkl)) {
    893f:	84 db                	test   %bl,%bl
    8941:	75 0e                	jne    8951 <coap_response_received+0x5d>
			continue;
		}

		age = get_observe_option(response);
    8943:	8b 45 08             	mov    0x8(%ebp),%eax
    8946:	e8 ff fa ff ff       	call   844a <get_observe_option>
		if (age > 0) {
    894b:	85 c0                	test   %eax,%eax
    894d:	7f 1c                	jg     896b <coap_response_received+0x77>
    894f:	eb 27                	jmp    8978 <coap_response_received+0x84>
		if (tkl > 0 && memcmp(r->token, token, tkl)) {
    8951:	0f b6 c3             	movzbl %bl,%eax
    8954:	50                   	push   %eax
    8955:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8958:	50                   	push   %eax
    8959:	8d 47 0e             	lea    0xe(%edi),%eax
    895c:	50                   	push   %eax
    895d:	e8 64 1f 00 00       	call   a8c6 <memcmp>
    8962:	83 c4 0c             	add    $0xc,%esp
    8965:	85 c0                	test   %eax,%eax
    8967:	74 da                	je     8943 <coap_response_received+0x4f>
    8969:	eb 1b                	jmp    8986 <coap_response_received+0x92>
			/* age == 2 means that the notifications wrapped,
			 * or this is the first one
			 */
			if (r->age > age && age != 2) {
    896b:	39 47 08             	cmp    %eax,0x8(%edi)
    896e:	7e 05                	jle    8975 <coap_response_received+0x81>
    8970:	83 f8 02             	cmp    $0x2,%eax
    8973:	75 11                	jne    8986 <coap_response_received+0x92>
				continue;
			}

			r->age = age;
    8975:	89 47 08             	mov    %eax,0x8(%edi)
		}

		r->reply(response, r, from);
    8978:	ff 75 0c             	pushl  0xc(%ebp)
    897b:	57                   	push   %edi
    897c:	ff 75 08             	pushl  0x8(%ebp)
    897f:	ff 17                	call   *(%edi)
    8981:	83 c4 0c             	add    $0xc,%esp
		return r;
    8984:	eb 08                	jmp    898e <coap_response_received+0x9a>
	for (i = 0, r = replies; i < len; i++, r++) {
    8986:	46                   	inc    %esi
    8987:	83 c7 18             	add    $0x18,%edi
    898a:	eb 94                	jmp    8920 <coap_response_received+0x2c>
	}

	return NULL;
    898c:	31 ff                	xor    %edi,%edi
}
    898e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8991:	89 f8                	mov    %edi,%eax
    8993:	5b                   	pop    %ebx
    8994:	5e                   	pop    %esi
    8995:	5f                   	pop    %edi
    8996:	5d                   	pop    %ebp
    8997:	c3                   	ret    

00008998 <coap_reply_init>:

void coap_reply_init(struct coap_reply *reply,
		     const struct coap_packet *request)
{
    8998:	55                   	push   %ebp
    8999:	89 e5                	mov    %esp,%ebp
    899b:	57                   	push   %edi
    899c:	56                   	push   %esi
    899d:	53                   	push   %ebx
	u8_t token[8];
	u8_t tkl;
	int age;

	reply->id = coap_header_get_id(request);
	tkl = coap_header_get_token(request, (u8_t *)&token);
    899e:	8d 7d ec             	lea    -0x14(%ebp),%edi
{
    89a1:	83 ec 0c             	sub    $0xc,%esp
    89a4:	8b 75 0c             	mov    0xc(%ebp),%esi
    89a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	reply->id = coap_header_get_id(request);
    89aa:	56                   	push   %esi
    89ab:	e8 86 fb ff ff       	call   8536 <coap_header_get_id>
    89b0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
	tkl = coap_header_get_token(request, (u8_t *)&token);
    89b4:	89 3c 24             	mov    %edi,(%esp)
    89b7:	56                   	push   %esi
    89b8:	e8 e7 fa ff ff       	call   84a4 <coap_header_get_token>
    89bd:	5a                   	pop    %edx

	if (tkl > 0) {
    89be:	84 c0                	test   %al,%al
	tkl = coap_header_get_token(request, (u8_t *)&token);
    89c0:	59                   	pop    %ecx
    89c1:	88 c2                	mov    %al,%dl
	if (tkl > 0) {
    89c3:	74 17                	je     89dc <coap_reply_init+0x44>
		memcpy(reply->token, token, tkl);
    89c5:	0f b6 c0             	movzbl %al,%eax
    89c8:	50                   	push   %eax
    89c9:	8d 43 0e             	lea    0xe(%ebx),%eax
    89cc:	57                   	push   %edi
    89cd:	88 55 eb             	mov    %dl,-0x15(%ebp)
    89d0:	50                   	push   %eax
    89d1:	e8 5b 1f 00 00       	call   a931 <memcpy>
    89d6:	83 c4 0c             	add    $0xc,%esp
    89d9:	8a 55 eb             	mov    -0x15(%ebp),%dl
	}

	reply->tkl = tkl;
    89dc:	88 53 16             	mov    %dl,0x16(%ebx)

	age = get_observe_option(request);
    89df:	89 f0                	mov    %esi,%eax
    89e1:	e8 64 fa ff ff       	call   844a <get_observe_option>

	/* It means that the request enabled observing a resource */
	if (age == 0) {
    89e6:	85 c0                	test   %eax,%eax
    89e8:	75 07                	jne    89f1 <coap_reply_init+0x59>
		reply->age = 2;
    89ea:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
	}
}
    89f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    89f4:	5b                   	pop    %ebx
    89f5:	5e                   	pop    %esi
    89f6:	5f                   	pop    %edi
    89f7:	5d                   	pop    %ebp
    89f8:	c3                   	ret    

000089f9 <coap_reply_clear>:

void coap_reply_clear(struct coap_reply *reply)
{
    89f9:	55                   	push   %ebp
    89fa:	89 e5                	mov    %esp,%ebp
	(void)memset(reply, 0, sizeof(*reply));
    89fc:	6a 18                	push   $0x18
    89fe:	6a 00                	push   $0x0
    8a00:	ff 75 08             	pushl  0x8(%ebp)
    8a03:	e8 98 1f 00 00       	call   a9a0 <memset>
    8a08:	83 c4 0c             	add    $0xc,%esp
}
    8a0b:	c9                   	leave  
    8a0c:	c3                   	ret    

00008a0d <z_fdtable_call_ioctl>:
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
				       unsigned long request, ...)
{
    8a0d:	55                   	push   %ebp
    8a0e:	89 e5                	mov    %esp,%ebp
	va_list args;
	int res;

	va_start(args, request);
    8a10:	8d 45 14             	lea    0x14(%ebp),%eax
	res = vtable->ioctl(obj, request, args);
    8a13:	50                   	push   %eax
    8a14:	8b 45 08             	mov    0x8(%ebp),%eax
    8a17:	ff 75 10             	pushl  0x10(%ebp)
    8a1a:	ff 75 0c             	pushl  0xc(%ebp)
    8a1d:	ff 50 08             	call   *0x8(%eax)
    8a20:	83 c4 0c             	add    $0xc,%esp
	va_end(args);

	return res;
}
    8a23:	c9                   	leave  
    8a24:	c3                   	ret    

00008a25 <zsock_accepted_cb>:
}
#endif /* CONFIG_USERSPACE */

static void zsock_accepted_cb(struct net_context *new_ctx,
			      struct sockaddr *addr, socklen_t addrlen,
			      int status, void *user_data) {
    8a25:	55                   	push   %ebp
    8a26:	89 e5                	mov    %esp,%ebp
    8a28:	56                   	push   %esi
    8a29:	53                   	push   %ebx
    8a2a:	8b 75 08             	mov    0x8(%ebp),%esi
    8a2d:	8b 5d 18             	mov    0x18(%ebp),%ebx
	struct net_context *parent = user_data;

	NET_DBG("parent=%p, ctx=%p, st=%d", parent, new_ctx, status);

	if (status == 0) {
    8a30:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    8a34:	75 30                	jne    8a66 <zsock_accepted_cb+0x41>
		/* This just installs a callback, so cannot fail. */
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
    8a36:	6a 00                	push   $0x0
				       NULL);
		k_fifo_init(&new_ctx->recv_q);

		k_fifo_put(&parent->accept_q, new_ctx);
    8a38:	83 c3 78             	add    $0x78,%ebx
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
    8a3b:	6a 00                	push   $0x0
    8a3d:	68 6d 8a 00 00       	push   $0x8a6d
    8a42:	56                   	push   %esi
    8a43:	e8 f2 4a 00 00       	call   d53a <net_context_recv>
    8a48:	83 c4 10             	add    $0x10,%esp
		k_fifo_init(&new_ctx->recv_q);
    8a4b:	8d 46 78             	lea    0x78(%esi),%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_INIT, k_queue_init, struct k_queue *, queue)
    8a4e:	50                   	push   %eax
    8a4f:	e8 fd ab 01 00       	call   23651 <z_impl_k_queue_init>
		k_fifo_put(&parent->accept_q, new_ctx);
    8a54:	89 75 0c             	mov    %esi,0xc(%ebp)
    8a57:	89 5d 08             	mov    %ebx,0x8(%ebp)
    8a5a:	58                   	pop    %eax
	}
}
    8a5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8a5e:	5b                   	pop    %ebx
    8a5f:	5e                   	pop    %esi
    8a60:	5d                   	pop    %ebp
		k_fifo_put(&parent->accept_q, new_ctx);
    8a61:	e9 40 ac 01 00       	jmp    236a6 <k_queue_append>
}
    8a66:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8a69:	5b                   	pop    %ebx
    8a6a:	5e                   	pop    %esi
    8a6b:	5d                   	pop    %ebp
    8a6c:	c3                   	ret    

00008a6d <zsock_received_cb>:
			      struct net_pkt *pkt,
			      union net_ip_header *ip_hdr,
			      union net_proto_header *proto_hdr,
			      int status,
			      void *user_data)
{
    8a6d:	55                   	push   %ebp
    8a6e:	89 e5                	mov    %esp,%ebp
    8a70:	57                   	push   %edi
    8a71:	56                   	push   %esi
    8a72:	53                   	push   %ebx
    8a73:	8b 5d 08             	mov    0x8(%ebp),%ebx
    8a76:	8b 75 0c             	mov    0xc(%ebp),%esi
    8a79:	8d 7b 78             	lea    0x78(%ebx),%edi
	NET_DBG("ctx=%p, pkt=%p, st=%d, user_data=%p", ctx, pkt, status,
		user_data);

	/* if pkt is NULL, EOF */
	if (!pkt) {
    8a7c:	85 f6                	test   %esi,%esi
    8a7e:	75 2e                	jne    8aae <zsock_received_cb+0x41>
	return z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
    8a80:	6a 00                	push   $0x0
    8a82:	ff 73 7c             	pushl  0x7c(%ebx)
    8a85:	e8 9f ab 01 00       	call   23629 <z_queue_node_peek>
    8a8a:	59                   	pop    %ecx
		struct net_pkt *last_pkt = k_fifo_peek_tail(&ctx->recv_q);

		if (!last_pkt) {
    8a8b:	85 c0                	test   %eax,%eax
    8a8d:	5e                   	pop    %esi
    8a8e:	75 12                	jne    8aa2 <zsock_received_cb+0x35>
static inline void sock_set_flag(struct net_context *ctx, u32_t mask,
				 u32_t flag)
{
	u32_t val = POINTER_TO_INT(ctx->user_data);

	val = (val & ~mask) | flag;
    8a90:	83 0b 01             	orl    $0x1,(%ebx)
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_CANCEL_WAIT, k_queue_cancel_wait, struct k_queue *, queue)
    8a93:	89 7d 08             	mov    %edi,0x8(%ebp)
	if (net_context_get_type(ctx) == SOCK_STREAM) {
		net_context_update_recv_wnd(ctx, -net_pkt_remaining_data(pkt));
	}

	k_fifo_put(&ctx->recv_q, pkt);
}
    8a96:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8a99:	5b                   	pop    %ebx
    8a9a:	5e                   	pop    %esi
    8a9b:	5f                   	pop    %edi
    8a9c:	5d                   	pop    %ebp
    8a9d:	e9 dc ab 01 00       	jmp    2367e <z_impl_k_queue_cancel_wait>
	return pkt->sent_or_eof;
}

static inline void net_pkt_set_eof(struct net_pkt *pkt, bool eof)
{
	pkt->sent_or_eof = eof;
    8aa2:	80 48 3d 02          	orb    $0x2,0x3d(%eax)
    8aa6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8aa9:	5b                   	pop    %ebx
    8aaa:	5e                   	pop    %esi
    8aab:	5f                   	pop    %edi
    8aac:	5d                   	pop    %ebp
    8aad:	c3                   	ret    
    8aae:	80 66 3d fd          	andb   $0xfd,0x3d(%esi)
static inline
enum net_sock_type net_context_get_type(struct net_context *context)
{
	NET_ASSERT(context);

	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
    8ab2:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
    8ab9:	c1 e8 06             	shr    $0x6,%eax
    8abc:	83 e0 03             	and    $0x3,%eax
	if (net_context_get_type(ctx) == SOCK_STREAM) {
    8abf:	48                   	dec    %eax
    8ac0:	75 13                	jne    8ad5 <zsock_received_cb+0x68>
		net_context_update_recv_wnd(ctx, -net_pkt_remaining_data(pkt));
    8ac2:	56                   	push   %esi
    8ac3:	e8 85 79 00 00       	call   1044d <net_pkt_remaining_data>
    8ac8:	f7 d8                	neg    %eax
    8aca:	89 04 24             	mov    %eax,(%esp)
    8acd:	53                   	push   %ebx
    8ace:	e8 d8 4b 00 00       	call   d6ab <net_context_update_recv_wnd>
    8ad3:	58                   	pop    %eax
    8ad4:	5a                   	pop    %edx
	k_fifo_put(&ctx->recv_q, pkt);
    8ad5:	89 75 0c             	mov    %esi,0xc(%ebp)
    8ad8:	89 7d 08             	mov    %edi,0x8(%ebp)
}
    8adb:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8ade:	5b                   	pop    %ebx
    8adf:	5e                   	pop    %esi
    8ae0:	5f                   	pop    %edi
    8ae1:	5d                   	pop    %ebp
	k_fifo_put(&ctx->recv_q, pkt);
    8ae2:	e9 bf ab 01 00       	jmp    236a6 <k_queue_append>

00008ae7 <sock_getsockopt_vmeth>:
    8ae7:	55                   	push   %ebp
    8ae8:	89 e5                	mov    %esp,%ebp
    8aea:	e8 f9 a1 01 00       	call   22ce8 <z_impl_z_errno>
    8aef:	c7 00 2a 00 00 00    	movl   $0x2a,(%eax)
    8af5:	83 c8 ff             	or     $0xffffffff,%eax
    8af8:	5d                   	pop    %ebp
    8af9:	c3                   	ret    

00008afa <zsock_socket_internal>:
{
    8afa:	55                   	push   %ebp
    8afb:	89 e5                	mov    %esp,%ebp
    8afd:	56                   	push   %esi
    8afe:	53                   	push   %ebx
    8aff:	53                   	push   %ebx
	int fd = z_reserve_fd();
    8b00:	e8 9a 8f ff ff       	call   1a9f <z_reserve_fd>
	if (fd < 0) {
    8b05:	85 c0                	test   %eax,%eax
    8b07:	78 69                	js     8b72 <zsock_socket_internal+0x78>
    8b09:	89 c3                	mov    %eax,%ebx
	res = net_context_get(family, type, proto, &ctx);
    8b0b:	8d 45 f4             	lea    -0xc(%ebp),%eax
    8b0e:	50                   	push   %eax
    8b0f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
    8b13:	50                   	push   %eax
    8b14:	ff 75 0c             	pushl  0xc(%ebp)
    8b17:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    8b1b:	50                   	push   %eax
    8b1c:	e8 77 3e 00 00       	call   c998 <net_context_get>
    8b21:	83 c4 10             	add    $0x10,%esp
    8b24:	89 c6                	mov    %eax,%esi
	if (res < 0) {
    8b26:	85 c0                	test   %eax,%eax
    8b28:	79 12                	jns    8b3c <zsock_socket_internal+0x42>
		z_free_fd(fd);
    8b2a:	53                   	push   %ebx
    8b2b:	e8 dc 8f ff ff       	call   1b0c <z_free_fd>
    8b30:	59                   	pop    %ecx
    8b31:	e8 b2 a1 01 00       	call   22ce8 <z_impl_z_errno>
		errno = -res;
    8b36:	f7 de                	neg    %esi
    8b38:	89 30                	mov    %esi,(%eax)
		return -1;
    8b3a:	eb 36                	jmp    8b72 <zsock_socket_internal+0x78>
	ctx->user_data = NULL;
    8b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
	k_fifo_init(&ctx->recv_q);
    8b3f:	83 c0 78             	add    $0x78,%eax
	ctx->user_data = NULL;
    8b42:	c7 40 88 00 00 00 00 	movl   $0x0,-0x78(%eax)
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_INIT, k_queue_init, struct k_queue *, queue)
    8b49:	50                   	push   %eax
    8b4a:	e8 02 ab 01 00       	call   23651 <z_impl_k_queue_init>
    8b4f:	5a                   	pop    %edx
	if (proto == IPPROTO_TCP) {
    8b50:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    8b54:	75 09                	jne    8b5f <zsock_socket_internal+0x65>
		net_context_ref(ctx);
    8b56:	ff 75 f4             	pushl  -0xc(%ebp)
    8b59:	e8 00 40 00 00       	call   cb5e <net_context_ref>
    8b5e:	58                   	pop    %eax
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
    8b5f:	68 00 56 02 00       	push   $0x25600
    8b64:	ff 75 f4             	pushl  -0xc(%ebp)
    8b67:	53                   	push   %ebx
    8b68:	e8 83 8f ff ff       	call   1af0 <z_finalize_fd>
    8b6d:	83 c4 0c             	add    $0xc,%esp
	return fd;
    8b70:	eb 03                	jmp    8b75 <zsock_socket_internal+0x7b>
		return -1;
    8b72:	83 cb ff             	or     $0xffffffff,%ebx
}
    8b75:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8b78:	89 d8                	mov    %ebx,%eax
    8b7a:	5b                   	pop    %ebx
    8b7b:	5e                   	pop    %esi
    8b7c:	5d                   	pop    %ebp
    8b7d:	c3                   	ret    

00008b7e <z_impl_zsock_socket>:
	return zsock_socket_internal(family, type, proto);
    8b7e:	e9 77 ff ff ff       	jmp    8afa <zsock_socket_internal>

00008b83 <zsock_close_ctx>:
{
    8b83:	55                   	push   %ebp
    8b84:	89 e5                	mov    %esp,%ebp
    8b86:	57                   	push   %edi
    8b87:	56                   	push   %esi
    8b88:	53                   	push   %ebx
    8b89:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
    8b8c:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
    8b93:	83 f0 06             	xor    $0x6,%eax
    8b96:	a8 06                	test   $0x6,%al
    8b98:	75 0e                	jne    8ba8 <zsock_close_ctx+0x25>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
    8b9a:	6a 00                	push   $0x0
    8b9c:	6a 00                	push   $0x0
    8b9e:	6a 00                	push   $0x0
    8ba0:	53                   	push   %ebx
    8ba1:	e8 77 48 00 00       	call   d41d <net_context_accept>
    8ba6:	eb 0c                	jmp    8bb4 <zsock_close_ctx+0x31>
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
    8ba8:	6a 00                	push   $0x0
    8baa:	6a 00                	push   $0x0
    8bac:	6a 00                	push   $0x0
    8bae:	53                   	push   %ebx
    8baf:	e8 86 49 00 00       	call   d53a <net_context_recv>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
    8bb4:	66 8b b3 92 00 00 00 	mov    0x92(%ebx),%si
    8bbb:	83 c4 10             	add    $0x10,%esp
    8bbe:	66 d1 ee             	shr    %si
    8bc1:	83 e6 03             	and    $0x3,%esi
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    8bc4:	6a 00                	push   $0x0
	while ((p = k_fifo_get(&ctx->recv_q, K_NO_WAIT)) != NULL) {
    8bc6:	8d 7b 78             	lea    0x78(%ebx),%edi
    8bc9:	57                   	push   %edi
    8bca:	e8 08 ab 01 00       	call   236d7 <z_impl_k_queue_get>
    8bcf:	59                   	pop    %ecx
    8bd0:	85 c0                	test   %eax,%eax
    8bd2:	5a                   	pop    %edx
    8bd3:	74 17                	je     8bec <zsock_close_ctx+0x69>
		if (is_listen) {
    8bd5:	66 83 fe 03          	cmp    $0x3,%si
    8bd9:	75 08                	jne    8be3 <zsock_close_ctx+0x60>
			net_context_put(p);
    8bdb:	50                   	push   %eax
    8bdc:	e8 df 3f 00 00       	call   cbc0 <net_context_put>
    8be1:	eb 06                	jmp    8be9 <zsock_close_ctx+0x66>
			net_pkt_unref(p);
    8be3:	50                   	push   %eax
    8be4:	e8 18 72 00 00       	call   fe01 <net_pkt_unref>
    8be9:	59                   	pop    %ecx
    8bea:	eb d8                	jmp    8bc4 <zsock_close_ctx+0x41>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_CANCEL_WAIT, k_queue_cancel_wait, struct k_queue *, queue)
    8bec:	57                   	push   %edi
    8bed:	e8 8c aa 01 00       	call   2367e <z_impl_k_queue_cancel_wait>
	SET_ERRNO(net_context_put(ctx));
    8bf2:	89 1c 24             	mov    %ebx,(%esp)
    8bf5:	e8 c6 3f 00 00       	call   cbc0 <net_context_put>
    8bfa:	89 c3                	mov    %eax,%ebx
    8bfc:	5a                   	pop    %edx
	return 0;
    8bfd:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_put(ctx));
    8bff:	85 db                	test   %ebx,%ebx
    8c01:	79 0c                	jns    8c0f <zsock_close_ctx+0x8c>
    8c03:	e8 e0 a0 01 00       	call   22ce8 <z_impl_z_errno>
    8c08:	f7 db                	neg    %ebx
    8c0a:	89 18                	mov    %ebx,(%eax)
    8c0c:	83 c8 ff             	or     $0xffffffff,%eax
}
    8c0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8c12:	5b                   	pop    %ebx
    8c13:	5e                   	pop    %esi
    8c14:	5f                   	pop    %edi
    8c15:	5d                   	pop    %ebp
    8c16:	c3                   	ret    

00008c17 <sock_ioctl_vmeth>:
{
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
}

static int sock_ioctl_vmeth(void *obj, unsigned int request, va_list args)
{
    8c17:	55                   	push   %ebp
    8c18:	89 e5                	mov    %esp,%ebp
    8c1a:	53                   	push   %ebx
    8c1b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    8c1e:	8b 55 08             	mov    0x8(%ebp),%edx
    8c21:	8b 45 10             	mov    0x10(%ebp),%eax
	switch (request) {
    8c24:	81 f9 00 01 00 00    	cmp    $0x100,%ecx
    8c2a:	74 5a                	je     8c86 <sock_ioctl_vmeth+0x6f>
    8c2c:	77 0f                	ja     8c3d <sock_ioctl_vmeth+0x26>
    8c2e:	83 f9 03             	cmp    $0x3,%ecx
    8c31:	74 23                	je     8c56 <sock_ioctl_vmeth+0x3f>
    8c33:	83 f9 04             	cmp    $0x4,%ecx
    8c36:	74 2d                	je     8c65 <sock_ioctl_vmeth+0x4e>
    8c38:	e9 df 00 00 00       	jmp    8d1c <sock_ioctl_vmeth+0x105>
    8c3d:	81 f9 03 01 00 00    	cmp    $0x103,%ecx
    8c43:	74 48                	je     8c8d <sock_ioctl_vmeth+0x76>
    8c45:	81 f9 04 01 00 00    	cmp    $0x104,%ecx
    8c4b:	0f 84 93 00 00 00    	je     8ce4 <sock_ioctl_vmeth+0xcd>
    8c51:	e9 c6 00 00 00       	jmp    8d1c <sock_ioctl_vmeth+0x105>

	/* In Zephyr, fcntl() is just an alias of ioctl(). */
	case F_GETFL:
		if (sock_is_nonblock(obj)) {
		    return O_NONBLOCK;
    8c56:	b8 00 40 00 00       	mov    $0x4000,%eax
		if (sock_is_nonblock(obj)) {
    8c5b:	f6 02 02             	testb  $0x2,(%edx)
    8c5e:	74 18                	je     8c78 <sock_ioctl_vmeth+0x61>
    8c60:	e9 c5 00 00 00       	jmp    8d2a <sock_ioctl_vmeth+0x113>
	case F_SETFL: {
		int flags;

		flags = va_arg(args, int);

		if (flags & O_NONBLOCK) {
    8c65:	8b 00                	mov    (%eax),%eax
    8c67:	8b 0a                	mov    (%edx),%ecx
    8c69:	83 e1 fd             	and    $0xfffffffd,%ecx
    8c6c:	25 00 40 00 00       	and    $0x4000,%eax
    8c71:	74 0c                	je     8c7f <sock_ioctl_vmeth+0x68>
    8c73:	83 c9 02             	or     $0x2,%ecx
    8c76:	89 0a                	mov    %ecx,(%edx)
			sock_set_flag(obj, SOCK_NONBLOCK, SOCK_NONBLOCK);
		} else {
			sock_set_flag(obj, SOCK_NONBLOCK, 0);
		}

		return 0;
    8c78:	31 c0                	xor    %eax,%eax
    8c7a:	e9 ab 00 00 00       	jmp    8d2a <sock_ioctl_vmeth+0x113>
	(ctx)->user_data = INT_TO_POINTER(val);
    8c7f:	89 0a                	mov    %ecx,(%edx)
    8c81:	e9 a4 00 00 00       	jmp    8d2a <sock_ioctl_vmeth+0x113>

	default:
		errno = EOPNOTSUPP;
		return -1;
	}
}
    8c86:	5b                   	pop    %ebx
    8c87:	5d                   	pop    %ebp
		return zsock_close_ctx(obj);
    8c88:	e9 f6 fe ff ff       	jmp    8b83 <zsock_close_ctx>
		return zsock_poll_prepare_ctx(obj, pfd, pev, pev_end);
    8c8d:	8b 08                	mov    (%eax),%ecx
	if (pfd->events & ZSOCK_POLLIN) {
    8c8f:	f6 41 04 01          	testb  $0x1,0x4(%ecx)
    8c93:	74 3d                	je     8cd2 <sock_ioctl_vmeth+0xbb>
		pev = va_arg(args, struct k_poll_event **);
    8c95:	8b 48 04             	mov    0x4(%eax),%ecx
		if (*pev == pev_end) {
    8c98:	8b 19                	mov    (%ecx),%ebx
    8c9a:	39 58 08             	cmp    %ebx,0x8(%eax)
    8c9d:	75 0d                	jne    8cac <sock_ioctl_vmeth+0x95>
    8c9f:	e8 44 a0 01 00       	call   22ce8 <z_impl_z_errno>
			errno = ENOMEM;
    8ca4:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
			return -1;
    8caa:	eb 7b                	jmp    8d27 <sock_ioctl_vmeth+0x110>
		(*pev)->obj = &ctx->recv_q;
    8cac:	8d 42 78             	lea    0x78(%edx),%eax
    8caf:	89 43 10             	mov    %eax,0x10(%ebx)
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
    8cb2:	8b 19                	mov    (%ecx),%ebx
    8cb4:	8a 43 0d             	mov    0xd(%ebx),%al
    8cb7:	83 e0 f0             	and    $0xfffffff0,%eax
    8cba:	83 c8 04             	or     $0x4,%eax
    8cbd:	88 43 0d             	mov    %al,0xd(%ebx)
		(*pev)->mode = K_POLL_MODE_NOTIFY_ONLY;
    8cc0:	8b 01                	mov    (%ecx),%eax
    8cc2:	80 60 0e fd          	andb   $0xfd,0xe(%eax)
		(*pev)->state = K_POLL_STATE_NOT_READY;
    8cc6:	8b 01                	mov    (%ecx),%eax
    8cc8:	81 60 0c ff 0f fe ff 	andl   $0xfffe0fff,0xc(%eax)
		(*pev)++;
    8ccf:	83 01 14             	addl   $0x14,(%ecx)
	if (sock_is_eof(ctx)) {
    8cd2:	f6 02 01             	testb  $0x1,(%edx)
    8cd5:	74 a1                	je     8c78 <sock_ioctl_vmeth+0x61>
    8cd7:	e8 0c a0 01 00       	call   22ce8 <z_impl_z_errno>
		errno = EALREADY;
    8cdc:	c7 00 45 00 00 00    	movl   $0x45,(%eax)
		return -1;
    8ce2:	eb 43                	jmp    8d27 <sock_ioctl_vmeth+0x110>
		pfd = va_arg(args, struct zsock_pollfd *);
    8ce4:	8b 08                	mov    (%eax),%ecx
		pev = va_arg(args, struct k_poll_event **);
    8ce6:	8b 58 04             	mov    0x4(%eax),%ebx
	if (pfd->events & ZSOCK_POLLOUT) {
    8ce9:	8b 41 04             	mov    0x4(%ecx),%eax
    8cec:	a8 04                	test   $0x4,%al
    8cee:	74 05                	je     8cf5 <sock_ioctl_vmeth+0xde>
		pfd->revents |= ZSOCK_POLLOUT;
    8cf0:	66 83 49 06 04       	orw    $0x4,0x6(%ecx)
	if (pfd->events & ZSOCK_POLLIN) {
    8cf5:	a8 01                	test   $0x1,%al
    8cf7:	0f 84 7b ff ff ff    	je     8c78 <sock_ioctl_vmeth+0x61>
		if ((*pev)->state != K_POLL_STATE_NOT_READY || sock_is_eof(ctx)) {
    8cfd:	8b 03                	mov    (%ebx),%eax
    8cff:	f7 40 0c 00 f0 01 00 	testl  $0x1f000,0xc(%eax)
    8d06:	75 05                	jne    8d0d <sock_ioctl_vmeth+0xf6>
    8d08:	f6 02 01             	testb  $0x1,(%edx)
    8d0b:	74 05                	je     8d12 <sock_ioctl_vmeth+0xfb>
			pfd->revents |= ZSOCK_POLLIN;
    8d0d:	66 83 49 06 01       	orw    $0x1,0x6(%ecx)
		(*pev)++;
    8d12:	83 c0 14             	add    $0x14,%eax
    8d15:	89 03                	mov    %eax,(%ebx)
    8d17:	e9 5c ff ff ff       	jmp    8c78 <sock_ioctl_vmeth+0x61>
    8d1c:	e8 c7 9f 01 00       	call   22ce8 <z_impl_z_errno>
		errno = EOPNOTSUPP;
    8d21:	c7 00 2d 00 00 00    	movl   $0x2d,(%eax)
		return -1;
    8d27:	83 c8 ff             	or     $0xffffffff,%eax
}
    8d2a:	5b                   	pop    %ebx
    8d2b:	5d                   	pop    %ebp
    8d2c:	c3                   	ret    

00008d2d <z_impl_zsock_close>:
{
    8d2d:	55                   	push   %ebp
    8d2e:	89 e5                	mov    %esp,%ebp
    8d30:	56                   	push   %esi
    8d31:	53                   	push   %ebx
    8d32:	50                   	push   %eax
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
    8d33:	8d 45 f4             	lea    -0xc(%ebp),%eax
    8d36:	50                   	push   %eax
{
    8d37:	8b 75 08             	mov    0x8(%ebp),%esi
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
    8d3a:	56                   	push   %esi
    8d3b:	e8 33 8d ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    8d40:	5a                   	pop    %edx
    8d41:	89 c3                	mov    %eax,%ebx
    8d43:	59                   	pop    %ecx
    8d44:	83 c8 ff             	or     $0xffffffff,%eax
	if (ctx == NULL) {
    8d47:	85 db                	test   %ebx,%ebx
    8d49:	74 19                	je     8d64 <z_impl_zsock_close+0x37>
	z_free_fd(sock);
    8d4b:	56                   	push   %esi
    8d4c:	e8 bb 8d ff ff       	call   1b0c <z_free_fd>
	return z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_CLOSE);
    8d51:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
    8d58:	53                   	push   %ebx
    8d59:	ff 75 f4             	pushl  -0xc(%ebp)
    8d5c:	e8 ac fc ff ff       	call   8a0d <z_fdtable_call_ioctl>
    8d61:	83 c4 0c             	add    $0xc,%esp
}
    8d64:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8d67:	5b                   	pop    %ebx
    8d68:	5e                   	pop    %esi
    8d69:	5d                   	pop    %ebp
    8d6a:	c3                   	ret    

00008d6b <zsock_bind_ctx>:
{
    8d6b:	55                   	push   %ebp
    8d6c:	89 e5                	mov    %esp,%ebp
    8d6e:	56                   	push   %esi
    8d6f:	53                   	push   %ebx
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
    8d70:	ff 75 10             	pushl  0x10(%ebp)
    8d73:	ff 75 0c             	pushl  0xc(%ebp)
{
    8d76:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
    8d79:	53                   	push   %ebx
    8d7a:	e8 a1 3e 00 00       	call   cc20 <net_context_bind>
    8d7f:	83 c4 0c             	add    $0xc,%esp
    8d82:	85 c0                	test   %eax,%eax
    8d84:	79 0d                	jns    8d93 <zsock_bind_ctx+0x28>
    8d86:	89 c6                	mov    %eax,%esi
    8d88:	e8 5b 9f 01 00       	call   22ce8 <z_impl_z_errno>
    8d8d:	f7 de                	neg    %esi
    8d8f:	89 30                	mov    %esi,(%eax)
    8d91:	eb 37                	jmp    8dca <zsock_bind_ctx+0x5f>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
    8d93:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
    8d9a:	c1 e8 06             	shr    $0x6,%eax
    8d9d:	83 e0 03             	and    $0x3,%eax
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
    8da0:	83 f8 02             	cmp    $0x2,%eax
    8da3:	74 04                	je     8da9 <zsock_bind_ctx+0x3e>
	return 0;
    8da5:	31 c0                	xor    %eax,%eax
    8da7:	eb 24                	jmp    8dcd <zsock_bind_ctx+0x62>
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    8da9:	ff 33                	pushl  (%ebx)
    8dab:	6a 00                	push   $0x0
    8dad:	68 6d 8a 00 00       	push   $0x8a6d
    8db2:	53                   	push   %ebx
    8db3:	e8 82 47 00 00       	call   d53a <net_context_recv>
    8db8:	83 c4 10             	add    $0x10,%esp
    8dbb:	89 c3                	mov    %eax,%ebx
    8dbd:	85 c0                	test   %eax,%eax
    8dbf:	79 e4                	jns    8da5 <zsock_bind_ctx+0x3a>
    8dc1:	e8 22 9f 01 00       	call   22ce8 <z_impl_z_errno>
    8dc6:	f7 db                	neg    %ebx
    8dc8:	89 18                	mov    %ebx,(%eax)
    8dca:	83 c8 ff             	or     $0xffffffff,%eax
}
    8dcd:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8dd0:	5b                   	pop    %ebx
    8dd1:	5e                   	pop    %esi
    8dd2:	5d                   	pop    %ebp
    8dd3:	c3                   	ret    

00008dd4 <sock_bind_vmeth>:

static int sock_bind_vmeth(void *obj, const struct sockaddr *addr,
			   socklen_t addrlen)
{
	return zsock_bind_ctx(obj, addr, addrlen);
    8dd4:	e9 92 ff ff ff       	jmp    8d6b <zsock_bind_ctx>

00008dd9 <zsock_connect_ctx>:
{
    8dd9:	55                   	push   %ebp
    8dda:	89 e5                	mov    %esp,%ebp
    8ddc:	56                   	push   %esi
    8ddd:	53                   	push   %ebx
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL, K_FOREVER,
    8dde:	6a 00                	push   $0x0
{
    8de0:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL, K_FOREVER,
    8de3:	6a ff                	push   $0xffffffff
    8de5:	6a 00                	push   $0x0
    8de7:	ff 75 10             	pushl  0x10(%ebp)
    8dea:	ff 75 0c             	pushl  0xc(%ebp)
    8ded:	56                   	push   %esi
    8dee:	e8 94 44 00 00       	call   d287 <net_context_connect>
    8df3:	83 c4 18             	add    $0x18,%esp
    8df6:	89 c3                	mov    %eax,%ebx
    8df8:	85 c0                	test   %eax,%eax
    8dfa:	78 1a                	js     8e16 <zsock_connect_ctx+0x3d>
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    8dfc:	ff 36                	pushl  (%esi)
    8dfe:	6a 00                	push   $0x0
    8e00:	68 6d 8a 00 00       	push   $0x8a6d
    8e05:	56                   	push   %esi
    8e06:	e8 2f 47 00 00       	call   d53a <net_context_recv>
    8e0b:	89 c3                	mov    %eax,%ebx
    8e0d:	83 c4 10             	add    $0x10,%esp
	return 0;
    8e10:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    8e12:	85 db                	test   %ebx,%ebx
    8e14:	79 0c                	jns    8e22 <zsock_connect_ctx+0x49>
    8e16:	e8 cd 9e 01 00       	call   22ce8 <z_impl_z_errno>
    8e1b:	f7 db                	neg    %ebx
    8e1d:	89 18                	mov    %ebx,(%eax)
    8e1f:	83 c8 ff             	or     $0xffffffff,%eax
}
    8e22:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8e25:	5b                   	pop    %ebx
    8e26:	5e                   	pop    %esi
    8e27:	5d                   	pop    %ebp
    8e28:	c3                   	ret    

00008e29 <sock_connect_vmeth>:
}

static int sock_connect_vmeth(void *obj, const struct sockaddr *addr,
			      socklen_t addrlen)
{
	return zsock_connect_ctx(obj, addr, addrlen);
    8e29:	e9 ab ff ff ff       	jmp    8dd9 <zsock_connect_ctx>

00008e2e <z_impl_zsock_connect>:
{
    8e2e:	55                   	push   %ebp
    8e2f:	89 e5                	mov    %esp,%ebp
    8e31:	50                   	push   %eax
	return z_get_fd_obj_and_vtable(sock,
    8e32:	8d 45 fc             	lea    -0x4(%ebp),%eax
    8e35:	50                   	push   %eax
    8e36:	ff 75 08             	pushl  0x8(%ebp)
    8e39:	e8 35 8c ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    8e3e:	5a                   	pop    %edx
    8e3f:	89 c2                	mov    %eax,%edx
    8e41:	59                   	pop    %ecx
    8e42:	83 c8 ff             	or     $0xffffffff,%eax
	VTABLE_CALL(connect, sock, addr, addrlen);
    8e45:	85 d2                	test   %edx,%edx
    8e47:	74 10                	je     8e59 <z_impl_zsock_connect+0x2b>
    8e49:	ff 75 10             	pushl  0x10(%ebp)
    8e4c:	ff 75 0c             	pushl  0xc(%ebp)
    8e4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e52:	52                   	push   %edx
    8e53:	ff 50 10             	call   *0x10(%eax)
    8e56:	83 c4 0c             	add    $0xc,%esp
}
    8e59:	c9                   	leave  
    8e5a:	c3                   	ret    

00008e5b <zsock_listen_ctx>:
{
    8e5b:	55                   	push   %ebp
    8e5c:	89 e5                	mov    %esp,%ebp
    8e5e:	56                   	push   %esi
    8e5f:	53                   	push   %ebx
	SET_ERRNO(net_context_listen(ctx, backlog));
    8e60:	ff 75 0c             	pushl  0xc(%ebp)
{
    8e63:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_listen(ctx, backlog));
    8e66:	56                   	push   %esi
    8e67:	e8 22 41 00 00       	call   cf8e <net_context_listen>
    8e6c:	5a                   	pop    %edx
    8e6d:	89 c3                	mov    %eax,%ebx
    8e6f:	59                   	pop    %ecx
    8e70:	85 c0                	test   %eax,%eax
    8e72:	78 19                	js     8e8d <zsock_listen_ctx+0x32>
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
    8e74:	56                   	push   %esi
    8e75:	6a 00                	push   $0x0
    8e77:	68 25 8a 00 00       	push   $0x8a25
    8e7c:	56                   	push   %esi
    8e7d:	e8 9b 45 00 00       	call   d41d <net_context_accept>
    8e82:	89 c3                	mov    %eax,%ebx
    8e84:	83 c4 10             	add    $0x10,%esp
	return 0;
    8e87:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
    8e89:	85 db                	test   %ebx,%ebx
    8e8b:	79 0c                	jns    8e99 <zsock_listen_ctx+0x3e>
    8e8d:	e8 56 9e 01 00       	call   22ce8 <z_impl_z_errno>
    8e92:	f7 db                	neg    %ebx
    8e94:	89 18                	mov    %ebx,(%eax)
    8e96:	83 c8 ff             	or     $0xffffffff,%eax
}
    8e99:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8e9c:	5b                   	pop    %ebx
    8e9d:	5e                   	pop    %esi
    8e9e:	5d                   	pop    %ebp
    8e9f:	c3                   	ret    

00008ea0 <sock_listen_vmeth>:
}

static int sock_listen_vmeth(void *obj, int backlog)
{
	return zsock_listen_ctx(obj, backlog);
    8ea0:	e9 b6 ff ff ff       	jmp    8e5b <zsock_listen_ctx>

00008ea5 <zsock_accept_ctx>:
{
    8ea5:	55                   	push   %ebp
    8ea6:	89 e5                	mov    %esp,%ebp
    8ea8:	57                   	push   %edi
    8ea9:	56                   	push   %esi
    8eaa:	53                   	push   %ebx
    8eab:	8b 75 10             	mov    0x10(%ebp),%esi
	fd = z_reserve_fd();
    8eae:	e8 ec 8b ff ff       	call   1a9f <z_reserve_fd>
	if (fd < 0) {
    8eb3:	85 c0                	test   %eax,%eax
    8eb5:	78 7f                	js     8f36 <zsock_accept_ctx+0x91>
    8eb7:	89 c3                	mov    %eax,%ebx
	struct net_context *ctx = k_fifo_get(&parent->accept_q, K_FOREVER);
    8eb9:	8b 45 08             	mov    0x8(%ebp),%eax
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    8ebc:	6a ff                	push   $0xffffffff
    8ebe:	83 c0 78             	add    $0x78,%eax
    8ec1:	50                   	push   %eax
    8ec2:	e8 10 a8 01 00       	call   236d7 <z_impl_k_queue_get>
    8ec7:	5a                   	pop    %edx
    8ec8:	89 c7                	mov    %eax,%edi
    8eca:	59                   	pop    %ecx
	if (addr != NULL && addrlen != NULL) {
    8ecb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    8ecf:	74 4c                	je     8f1d <zsock_accept_ctx+0x78>
    8ed1:	85 f6                	test   %esi,%esi
    8ed3:	74 48                	je     8f1d <zsock_accept_ctx+0x78>
		int len = MIN(*addrlen, sizeof(ctx->remote));
    8ed5:	8b 06                	mov    (%esi),%eax
    8ed7:	83 f8 18             	cmp    $0x18,%eax
    8eda:	76 05                	jbe    8ee1 <zsock_accept_ctx+0x3c>
    8edc:	b8 18 00 00 00       	mov    $0x18,%eax
		memcpy(addr, &ctx->remote, len);
    8ee1:	50                   	push   %eax
    8ee2:	8d 47 30             	lea    0x30(%edi),%eax
    8ee5:	50                   	push   %eax
    8ee6:	ff 75 0c             	pushl  0xc(%ebp)
    8ee9:	e8 43 1a 00 00       	call   a931 <memcpy>
		if (ctx->remote.sa_family == AF_INET) {
    8eee:	8b 47 30             	mov    0x30(%edi),%eax
		memcpy(addr, &ctx->remote, len);
    8ef1:	83 c4 0c             	add    $0xc,%esp
		if (ctx->remote.sa_family == AF_INET) {
    8ef4:	66 83 f8 01          	cmp    $0x1,%ax
    8ef8:	75 08                	jne    8f02 <zsock_accept_ctx+0x5d>
			*addrlen = sizeof(struct sockaddr_in);
    8efa:	c7 06 08 00 00 00    	movl   $0x8,(%esi)
    8f00:	eb 1b                	jmp    8f1d <zsock_accept_ctx+0x78>
		} else if (ctx->remote.sa_family == AF_INET6) {
    8f02:	66 83 f8 02          	cmp    $0x2,%ax
    8f06:	75 08                	jne    8f10 <zsock_accept_ctx+0x6b>
			*addrlen = sizeof(struct sockaddr_in6);
    8f08:	c7 06 18 00 00 00    	movl   $0x18,(%esi)
    8f0e:	eb 0d                	jmp    8f1d <zsock_accept_ctx+0x78>
    8f10:	e8 d3 9d 01 00       	call   22ce8 <z_impl_z_errno>
			errno = ENOTSUP;
    8f15:	c7 00 23 00 00 00    	movl   $0x23,(%eax)
			return -1;
    8f1b:	eb 19                	jmp    8f36 <zsock_accept_ctx+0x91>
	net_context_ref(ctx);
    8f1d:	57                   	push   %edi
    8f1e:	e8 3b 3c 00 00       	call   cb5e <net_context_ref>
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
    8f23:	c7 04 24 00 56 02 00 	movl   $0x25600,(%esp)
    8f2a:	57                   	push   %edi
    8f2b:	53                   	push   %ebx
    8f2c:	e8 bf 8b ff ff       	call   1af0 <z_finalize_fd>
    8f31:	83 c4 0c             	add    $0xc,%esp
	return fd;
    8f34:	eb 03                	jmp    8f39 <zsock_accept_ctx+0x94>
		return -1;
    8f36:	83 cb ff             	or     $0xffffffff,%ebx
}
    8f39:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8f3c:	89 d8                	mov    %ebx,%eax
    8f3e:	5b                   	pop    %ebx
    8f3f:	5e                   	pop    %esi
    8f40:	5f                   	pop    %edi
    8f41:	5d                   	pop    %ebp
    8f42:	c3                   	ret    

00008f43 <sock_accept_vmeth>:
}

static int sock_accept_vmeth(void *obj, struct sockaddr *addr,
			     socklen_t *addrlen)
{
	return zsock_accept_ctx(obj, addr, addrlen);
    8f43:	e9 5d ff ff ff       	jmp    8ea5 <zsock_accept_ctx>

00008f48 <zsock_sendto_ctx>:
{
    8f48:	55                   	push   %ebp
    8f49:	89 e5                	mov    %esp,%ebp
    8f4b:	57                   	push   %edi
    8f4c:	56                   	push   %esi
    8f4d:	53                   	push   %ebx
    8f4e:	31 db                	xor    %ebx,%ebx
    8f50:	50                   	push   %eax
    8f51:	8b 75 08             	mov    0x8(%ebp),%esi
    8f54:	8b 7d 18             	mov    0x18(%ebp),%edi
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    8f57:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
    8f5b:	8b 06                	mov    (%esi),%eax
    8f5d:	75 0c                	jne    8f6b <zsock_sendto_ctx+0x23>
    8f5f:	89 c3                	mov    %eax,%ebx
    8f61:	d1 eb                	shr    %ebx
    8f63:	83 f3 01             	xor    $0x1,%ebx
    8f66:	83 e3 01             	and    $0x1,%ebx
    8f69:	f7 db                	neg    %ebx
	status = net_context_recv(ctx, zsock_received_cb,
    8f6b:	50                   	push   %eax
    8f6c:	6a 00                	push   $0x0
    8f6e:	68 6d 8a 00 00       	push   $0x8a6d
    8f73:	56                   	push   %esi
    8f74:	e8 c1 45 00 00       	call   d53a <net_context_recv>
    8f79:	83 c4 10             	add    $0x10,%esp
	if (status < 0) {
    8f7c:	85 c0                	test   %eax,%eax
    8f7e:	79 11                	jns    8f91 <zsock_sendto_ctx+0x49>
    8f80:	89 45 f0             	mov    %eax,-0x10(%ebp)
    8f83:	e8 60 9d 01 00       	call   22ce8 <z_impl_z_errno>
		errno = -status;
    8f88:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8f8b:	f7 d9                	neg    %ecx
    8f8d:	89 08                	mov    %ecx,(%eax)
		return -1;
    8f8f:	eb 41                	jmp    8fd2 <zsock_sendto_ctx+0x8a>
	if (dest_addr) {
    8f91:	8b 06                	mov    (%esi),%eax
    8f93:	85 ff                	test   %edi,%edi
    8f95:	74 19                	je     8fb0 <zsock_sendto_ctx+0x68>
		status = net_context_sendto(ctx, buf, len, dest_addr,
    8f97:	50                   	push   %eax
    8f98:	53                   	push   %ebx
    8f99:	6a 00                	push   $0x0
    8f9b:	ff 75 1c             	pushl  0x1c(%ebp)
    8f9e:	57                   	push   %edi
    8f9f:	ff 75 10             	pushl  0x10(%ebp)
    8fa2:	ff 75 0c             	pushl  0xc(%ebp)
    8fa5:	56                   	push   %esi
    8fa6:	e8 4c 45 00 00       	call   d4f7 <net_context_sendto>
    8fab:	83 c4 20             	add    $0x20,%esp
    8fae:	eb 13                	jmp    8fc3 <zsock_sendto_ctx+0x7b>
		status = net_context_send(ctx, buf, len, NULL, timeout,
    8fb0:	50                   	push   %eax
    8fb1:	53                   	push   %ebx
    8fb2:	6a 00                	push   $0x0
    8fb4:	ff 75 10             	pushl  0x10(%ebp)
    8fb7:	ff 75 0c             	pushl  0xc(%ebp)
    8fba:	56                   	push   %esi
    8fbb:	e8 bf 44 00 00       	call   d47f <net_context_send>
    8fc0:	83 c4 18             	add    $0x18,%esp
    8fc3:	89 c3                	mov    %eax,%ebx
	if (status < 0) {
    8fc5:	85 c0                	test   %eax,%eax
    8fc7:	79 0c                	jns    8fd5 <zsock_sendto_ctx+0x8d>
    8fc9:	e8 1a 9d 01 00       	call   22ce8 <z_impl_z_errno>
		errno = -status;
    8fce:	f7 db                	neg    %ebx
    8fd0:	89 18                	mov    %ebx,(%eax)
		return -1;
    8fd2:	83 cb ff             	or     $0xffffffff,%ebx
}
    8fd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8fd8:	89 d8                	mov    %ebx,%eax
    8fda:	5b                   	pop    %ebx
    8fdb:	5e                   	pop    %esi
    8fdc:	5f                   	pop    %edi
    8fdd:	5d                   	pop    %ebp
    8fde:	c3                   	ret    

00008fdf <sock_sendto_vmeth>:

static ssize_t sock_sendto_vmeth(void *obj, const void *buf, size_t len,
				 int flags, const struct sockaddr *dest_addr,
				 socklen_t addrlen)
{
	return zsock_sendto_ctx(obj, buf, len, flags, dest_addr, addrlen);
    8fdf:	e9 64 ff ff ff       	jmp    8f48 <zsock_sendto_ctx>

00008fe4 <sock_write_vmeth>:
{
    8fe4:	55                   	push   %ebp
    8fe5:	89 e5                	mov    %esp,%ebp
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
    8fe7:	6a 00                	push   $0x0
    8fe9:	6a 00                	push   $0x0
    8feb:	6a 00                	push   $0x0
    8fed:	ff 75 10             	pushl  0x10(%ebp)
    8ff0:	ff 75 0c             	pushl  0xc(%ebp)
    8ff3:	ff 75 08             	pushl  0x8(%ebp)
    8ff6:	e8 4d ff ff ff       	call   8f48 <zsock_sendto_ctx>
    8ffb:	83 c4 18             	add    $0x18,%esp
}
    8ffe:	c9                   	leave  
    8fff:	c3                   	ret    

00009000 <z_impl_zsock_sendto>:
{
    9000:	55                   	push   %ebp
    9001:	89 e5                	mov    %esp,%ebp
    9003:	50                   	push   %eax
	return z_get_fd_obj_and_vtable(sock,
    9004:	8d 45 fc             	lea    -0x4(%ebp),%eax
    9007:	50                   	push   %eax
    9008:	ff 75 08             	pushl  0x8(%ebp)
    900b:	e8 63 8a ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    9010:	5a                   	pop    %edx
    9011:	89 c2                	mov    %eax,%edx
    9013:	59                   	pop    %ecx
    9014:	83 c8 ff             	or     $0xffffffff,%eax
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
    9017:	85 d2                	test   %edx,%edx
    9019:	74 19                	je     9034 <z_impl_zsock_sendto+0x34>
    901b:	ff 75 1c             	pushl  0x1c(%ebp)
    901e:	ff 75 18             	pushl  0x18(%ebp)
    9021:	ff 75 14             	pushl  0x14(%ebp)
    9024:	ff 75 10             	pushl  0x10(%ebp)
    9027:	ff 75 0c             	pushl  0xc(%ebp)
    902a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    902d:	52                   	push   %edx
    902e:	ff 50 1c             	call   *0x1c(%eax)
    9031:	83 c4 18             	add    $0x18,%esp
}
    9034:	c9                   	leave  
    9035:	c3                   	ret    

00009036 <zsock_recvfrom_ctx>:
{
    9036:	55                   	push   %ebp
    9037:	89 e5                	mov    %esp,%ebp
    9039:	57                   	push   %edi
    903a:	56                   	push   %esi
    903b:	53                   	push   %ebx
    903c:	83 ec 38             	sub    $0x38,%esp
    903f:	8b 75 08             	mov    0x8(%ebp),%esi
	enum net_sock_type sock_type = net_context_get_type(ctx);
    9042:	66 8b 96 92 00 00 00 	mov    0x92(%esi),%dx
    9049:	89 d0                	mov    %edx,%eax
    904b:	c1 e8 06             	shr    $0x6,%eax
    904e:	83 e0 03             	and    $0x3,%eax
	if (sock_type == SOCK_DGRAM) {
    9051:	83 f8 02             	cmp    $0x2,%eax
    9054:	0f 85 6f 02 00 00    	jne    92c9 <zsock_recvfrom_ctx+0x293>
		timeout = K_NO_WAIT;
    905a:	31 d2                	xor    %edx,%edx
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    905c:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
    9060:	75 0c                	jne    906e <zsock_recvfrom_ctx+0x38>
    9062:	8b 16                	mov    (%esi),%edx
    9064:	d1 ea                	shr    %edx
    9066:	83 f2 01             	xor    $0x1,%edx
    9069:	83 e2 01             	and    $0x1,%edx
    906c:	f7 da                	neg    %edx
	if (flags & ZSOCK_MSG_PEEK) {
    906e:	8b 45 14             	mov    0x14(%ebp),%eax
    9071:	8d 5e 78             	lea    0x78(%esi),%ebx
    9074:	83 e0 02             	and    $0x2,%eax
    9077:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    907a:	74 41                	je     90bd <zsock_recvfrom_ctx+0x87>
	struct k_poll_event events[] = {
    907c:	31 c0                	xor    %eax,%eax
    907e:	8d 7d e0             	lea    -0x20(%ebp),%edi
    9081:	b9 04 00 00 00       	mov    $0x4,%ecx
    9086:	f3 ab                	rep stos %eax,%es:(%edi)
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    9088:	52                   	push   %edx
    9089:	8d 45 e0             	lea    -0x20(%ebp),%eax
    908c:	6a 01                	push   $0x1
    908e:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    9091:	50                   	push   %eax
    9092:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
    9096:	e8 48 ba 01 00       	call   24ae3 <z_impl_k_poll>
    909b:	83 c4 0c             	add    $0xc,%esp
    909e:	89 c3                	mov    %eax,%ebx
		if (res && res != -EAGAIN && res != -EINTR) {
    90a0:	8d 40 04             	lea    0x4(%eax),%eax
    90a3:	83 e0 fb             	and    $0xfffffffb,%eax
    90a6:	74 09                	je     90b1 <zsock_recvfrom_ctx+0x7b>
    90a8:	83 fb f5             	cmp    $0xfffffff5,%ebx
    90ab:	0f 85 91 02 00 00    	jne    9342 <zsock_recvfrom_ctx+0x30c>
	return z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
    90b1:	6a 00                	push   $0x0
    90b3:	ff 76 78             	pushl  0x78(%esi)
    90b6:	e8 6e a5 01 00       	call   23629 <z_queue_node_peek>
    90bb:	eb 07                	jmp    90c4 <zsock_recvfrom_ctx+0x8e>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    90bd:	52                   	push   %edx
    90be:	53                   	push   %ebx
    90bf:	e8 13 a6 01 00       	call   236d7 <z_impl_k_queue_get>
    90c4:	5a                   	pop    %edx
    90c5:	89 c3                	mov    %eax,%ebx
    90c7:	59                   	pop    %ecx
	if (!pkt) {
    90c8:	85 c0                	test   %eax,%eax
    90ca:	75 13                	jne    90df <zsock_recvfrom_ctx+0xa9>
    90cc:	e8 17 9c 01 00       	call   22ce8 <z_impl_z_errno>
		errno = EAGAIN;
    90d1:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
		return -1;
    90d7:	83 cb ff             	or     $0xffffffff,%ebx
    90da:	e9 27 03 00 00       	jmp    9406 <zsock_recvfrom_ctx+0x3d0>
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
    90df:	8b 40 18             	mov    0x18(%eax),%eax
    90e2:	89 45 cc             	mov    %eax,-0x34(%ebp)
	backup->pos = pkt->cursor.pos;
    90e5:	8b 43 1c             	mov    0x1c(%ebx),%eax
    90e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	if (src_addr && addrlen) {
    90eb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    90ef:	0f 84 8d 01 00 00    	je     9282 <zsock_recvfrom_ctx+0x24c>
    90f5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    90f9:	0f 84 83 01 00 00    	je     9282 <zsock_recvfrom_ctx+0x24c>
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
    90ff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    9102:	8b 38                	mov    (%eax),%edi
    9104:	66 8b 86 90 00 00 00 	mov    0x90(%esi),%ax
	net_pkt_cursor_init(pkt);
    910b:	53                   	push   %ebx
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
    910c:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
	net_pkt_cursor_init(pkt);
    9110:	e8 58 6e 00 00       	call   ff6d <net_pkt_cursor_init>
    9115:	58                   	pop    %eax
	return pkt->family;
    9116:	8a 43 3f             	mov    0x3f(%ebx),%al
	addr->sa_family = net_pkt_family(pkt);
    9119:	8b 4d 18             	mov    0x18(%ebp),%ecx
    911c:	d0 e8                	shr    %al
    911e:	83 e0 07             	and    $0x7,%eax
    9121:	0f b6 d0             	movzbl %al,%edx
    9124:	66 89 11             	mov    %dx,(%ecx)
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    9127:	3c 01                	cmp    $0x1,%al
    9129:	75 52                	jne    917d <zsock_recvfrom_ctx+0x147>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
    912b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    9132:	c7 45 e4 14 00 00 00 	movl   $0x14,-0x1c(%ebp)
			ret = -EINVAL;
    9139:	be ea ff ff ff       	mov    $0xffffffea,%esi
		if (addrlen < sizeof(struct sockaddr_in)) {
    913e:	83 ff 07             	cmp    $0x7,%edi
    9141:	0f 86 e5 00 00 00    	jbe    922c <zsock_recvfrom_ctx+0x1f6>
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
    9147:	8d 45 e0             	lea    -0x20(%ebp),%eax
    914a:	50                   	push   %eax
    914b:	53                   	push   %ebx
    914c:	e8 16 74 00 00       	call   10567 <net_pkt_get_data>
    9151:	59                   	pop    %ecx
		if (!ipv4_hdr || net_pkt_acknowledge_data(pkt, &ipv4_access)) {
    9152:	85 c0                	test   %eax,%eax
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
    9154:	5e                   	pop    %esi
    9155:	89 c6                	mov    %eax,%esi
		if (!ipv4_hdr || net_pkt_acknowledge_data(pkt, &ipv4_access)) {
    9157:	0f 84 c0 00 00 00    	je     921d <zsock_recvfrom_ctx+0x1e7>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
    915d:	ff 75 e4             	pushl  -0x1c(%ebp)
    9160:	53                   	push   %ebx
    9161:	e8 7a 71 00 00       	call   102e0 <net_pkt_skip>
    9166:	5f                   	pop    %edi
    9167:	85 c0                	test   %eax,%eax
    9169:	5a                   	pop    %edx
    916a:	0f 85 ad 00 00 00    	jne    921d <zsock_recvfrom_ctx+0x1e7>
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
    9170:	8b 4d 18             	mov    0x18(%ebp),%ecx
    9173:	8b 46 0c             	mov    0xc(%esi),%eax
    9176:	89 41 04             	mov    %eax,0x4(%ecx)
		port = &addr4->sin_port;
    9179:	89 c8                	mov    %ecx,%eax
    917b:	eb 79                	jmp    91f6 <zsock_recvfrom_ctx+0x1c0>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    917d:	3c 02                	cmp    $0x2,%al
    917f:	74 0a                	je     918b <zsock_recvfrom_ctx+0x155>
		ret = -ENOTSUP;
    9181:	be dd ff ff ff       	mov    $0xffffffdd,%esi
    9186:	e9 a1 00 00 00       	jmp    922c <zsock_recvfrom_ctx+0x1f6>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access,
    918b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    9192:	c7 45 dc 28 00 00 00 	movl   $0x28,-0x24(%ebp)
			ret = -EINVAL;
    9199:	be ea ff ff ff       	mov    $0xffffffea,%esi
		if (addrlen < sizeof(struct sockaddr_in6)) {
    919e:	83 ff 17             	cmp    $0x17,%edi
    91a1:	0f 86 85 00 00 00    	jbe    922c <zsock_recvfrom_ctx+0x1f6>
		ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(
    91a7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    91aa:	50                   	push   %eax
    91ab:	53                   	push   %ebx
    91ac:	e8 b6 73 00 00       	call   10567 <net_pkt_get_data>
    91b1:	59                   	pop    %ecx
		if (!ipv6_hdr ||
    91b2:	85 c0                	test   %eax,%eax
		ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(
    91b4:	5e                   	pop    %esi
    91b5:	89 c6                	mov    %eax,%esi
		if (!ipv6_hdr ||
    91b7:	74 64                	je     921d <zsock_recvfrom_ctx+0x1e7>
    91b9:	ff 75 dc             	pushl  -0x24(%ebp)
    91bc:	53                   	push   %ebx
    91bd:	e8 1e 71 00 00       	call   102e0 <net_pkt_skip>
    91c2:	5f                   	pop    %edi
    91c3:	85 c0                	test   %eax,%eax
    91c5:	5a                   	pop    %edx
    91c6:	75 55                	jne    921d <zsock_recvfrom_ctx+0x1e7>
		    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
    91c8:	0f b7 43 42          	movzwl 0x42(%ebx),%eax
    91cc:	50                   	push   %eax
    91cd:	53                   	push   %ebx
    91ce:	e8 0d 71 00 00       	call   102e0 <net_pkt_skip>
    91d3:	5a                   	pop    %edx
		    net_pkt_acknowledge_data(pkt, &ipv6_access) ||
    91d4:	85 c0                	test   %eax,%eax
		    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
    91d6:	59                   	pop    %ecx
		    net_pkt_acknowledge_data(pkt, &ipv6_access) ||
    91d7:	75 44                	jne    921d <zsock_recvfrom_ctx+0x1e7>
		net_ipaddr_copy(&addr6->sin6_addr, &ipv6_hdr->src);
    91d9:	8d 7d e0             	lea    -0x20(%ebp),%edi
    91dc:	83 c6 08             	add    $0x8,%esi
    91df:	b9 04 00 00 00       	mov    $0x4,%ecx
    91e4:	8b 45 18             	mov    0x18(%ebp),%eax
    91e7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    91e9:	8d 78 04             	lea    0x4(%eax),%edi
    91ec:	8d 75 e0             	lea    -0x20(%ebp),%esi
    91ef:	b9 04 00 00 00       	mov    $0x4,%ecx
    91f4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		port = &addr6->sin6_port;
    91f6:	8d 70 02             	lea    0x2(%eax),%esi
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    91f9:	66 83 7d c0 11       	cmpw   $0x11,-0x40(%ebp)
    91fe:	75 81                	jne    9181 <zsock_recvfrom_ctx+0x14b>
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    9200:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9203:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
    920a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt,
    920d:	8d 45 d0             	lea    -0x30(%ebp),%eax
    9210:	50                   	push   %eax
    9211:	53                   	push   %ebx
    9212:	e8 50 73 00 00       	call   10567 <net_pkt_get_data>
    9217:	59                   	pop    %ecx
		if (!udp_hdr) {
    9218:	85 c0                	test   %eax,%eax
		udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt,
    921a:	5f                   	pop    %edi
		if (!udp_hdr) {
    921b:	75 07                	jne    9224 <zsock_recvfrom_ctx+0x1ee>
			ret = -ENOBUFS;
    921d:	be c9 ff ff ff       	mov    $0xffffffc9,%esi
    9222:	eb 08                	jmp    922c <zsock_recvfrom_ctx+0x1f6>
		*port = udp_hdr->src_port;
    9224:	66 8b 00             	mov    (%eax),%ax
    9227:	66 89 06             	mov    %ax,(%esi)
	int ret = 0;
    922a:	31 f6                	xor    %esi,%esi
	pkt->cursor.buf = backup->buf;
    922c:	8b 45 cc             	mov    -0x34(%ebp),%eax
		if (rv < 0) {
    922f:	85 f6                	test   %esi,%esi
    9231:	89 43 18             	mov    %eax,0x18(%ebx)
	pkt->cursor.pos = backup->pos;
    9234:	8b 45 c8             	mov    -0x38(%ebp),%eax
    9237:	89 43 1c             	mov    %eax,0x1c(%ebx)
    923a:	74 0e                	je     924a <zsock_recvfrom_ctx+0x214>
    923c:	e8 a7 9a 01 00       	call   22ce8 <z_impl_z_errno>
			errno = -rv;
    9241:	f7 de                	neg    %esi
    9243:	89 30                	mov    %esi,(%eax)
			return -1;
    9245:	e9 8d fe ff ff       	jmp    90d7 <zsock_recvfrom_ctx+0xa1>
		if (src_addr->sa_family == AF_INET) {
    924a:	8b 45 18             	mov    0x18(%ebp),%eax
    924d:	66 8b 00             	mov    (%eax),%ax
    9250:	66 83 f8 01          	cmp    $0x1,%ax
    9254:	75 0b                	jne    9261 <zsock_recvfrom_ctx+0x22b>
			*addrlen = sizeof(struct sockaddr_in);
    9256:	8b 45 1c             	mov    0x1c(%ebp),%eax
    9259:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    925f:	eb 21                	jmp    9282 <zsock_recvfrom_ctx+0x24c>
		} else if (src_addr->sa_family == AF_INET6) {
    9261:	66 83 f8 02          	cmp    $0x2,%ax
    9265:	75 0b                	jne    9272 <zsock_recvfrom_ctx+0x23c>
			*addrlen = sizeof(struct sockaddr_in6);
    9267:	8b 45 1c             	mov    0x1c(%ebp),%eax
    926a:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
    9270:	eb 10                	jmp    9282 <zsock_recvfrom_ctx+0x24c>
    9272:	e8 71 9a 01 00       	call   22ce8 <z_impl_z_errno>
			errno = ENOTSUP;
    9277:	c7 00 23 00 00 00    	movl   $0x23,(%eax)
			return -1;
    927d:	e9 55 fe ff ff       	jmp    90d7 <zsock_recvfrom_ctx+0xa1>
	recv_len = net_pkt_remaining_data(pkt);
    9282:	53                   	push   %ebx
    9283:	e8 c5 71 00 00       	call   1044d <net_pkt_remaining_data>
    9288:	8b 75 10             	mov    0x10(%ebp),%esi
    928b:	5a                   	pop    %edx
	if (recv_len > max_len) {
    928c:	39 c6                	cmp    %eax,%esi
    928e:	76 02                	jbe    9292 <zsock_recvfrom_ctx+0x25c>
    9290:	89 c6                	mov    %eax,%esi
	if (net_pkt_read(pkt, buf, recv_len)) {
    9292:	56                   	push   %esi
    9293:	ff 75 0c             	pushl  0xc(%ebp)
    9296:	53                   	push   %ebx
    9297:	e8 7c 70 00 00       	call   10318 <net_pkt_read>
    929c:	83 c4 0c             	add    $0xc,%esp
    929f:	85 c0                	test   %eax,%eax
    92a1:	0f 85 fe 00 00 00    	jne    93a5 <zsock_recvfrom_ctx+0x36f>
	if (!(flags & ZSOCK_MSG_PEEK)) {
    92a7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    92ab:	75 09                	jne    92b6 <zsock_recvfrom_ctx+0x280>
		net_pkt_unref(pkt);
    92ad:	53                   	push   %ebx
    92ae:	e8 4e 6b 00 00       	call   fe01 <net_pkt_unref>
    92b3:	58                   	pop    %eax
    92b4:	eb 0c                	jmp    92c2 <zsock_recvfrom_ctx+0x28c>
	pkt->cursor.buf = backup->buf;
    92b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    92b9:	89 43 18             	mov    %eax,0x18(%ebx)
	pkt->cursor.pos = backup->pos;
    92bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
    92bf:	89 43 1c             	mov    %eax,0x1c(%ebx)
	return recv_len;
    92c2:	89 f3                	mov    %esi,%ebx
    92c4:	e9 3d 01 00 00       	jmp    9406 <zsock_recvfrom_ctx+0x3d0>
	} else if (sock_type == SOCK_STREAM) {
    92c9:	48                   	dec    %eax
    92ca:	74 07                	je     92d3 <zsock_recvfrom_ctx+0x29d>
	return 0;
    92cc:	31 db                	xor    %ebx,%ebx
    92ce:	e9 33 01 00 00       	jmp    9406 <zsock_recvfrom_ctx+0x3d0>
	if (!net_context_is_used(ctx)) {
    92d3:	80 e2 01             	and    $0x1,%dl
    92d6:	75 10                	jne    92e8 <zsock_recvfrom_ctx+0x2b2>
    92d8:	e8 0b 9a 01 00       	call   22ce8 <z_impl_z_errno>
		errno = EBADF;
    92dd:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
		return -1;
    92e3:	e9 ef fd ff ff       	jmp    90d7 <zsock_recvfrom_ctx+0xa1>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    92e8:	8b 06                	mov    (%esi),%eax
		timeout = K_NO_WAIT;
    92ea:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    92f1:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
    92f5:	75 0d                	jne    9304 <zsock_recvfrom_ctx+0x2ce>
    92f7:	d1 e8                	shr    %eax
    92f9:	83 f0 01             	xor    $0x1,%eax
    92fc:	83 e0 01             	and    $0x1,%eax
    92ff:	f7 d8                	neg    %eax
    9301:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (sock_is_eof(ctx)) {
    9304:	8b 06                	mov    (%esi),%eax
    9306:	83 e0 01             	and    $0x1,%eax
    9309:	75 c1                	jne    92cc <zsock_recvfrom_ctx+0x296>
	struct k_poll_event events[] = {
    930b:	8d 7d e0             	lea    -0x20(%ebp),%edi
    930e:	b9 04 00 00 00       	mov    $0x4,%ecx
    9313:	f3 ab                	rep stos %eax,%es:(%edi)
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    9315:	ff 75 cc             	pushl  -0x34(%ebp)
		res = _k_fifo_wait_non_empty(&ctx->recv_q, timeout);
    9318:	8d 56 78             	lea    0x78(%esi),%edx
    931b:	8d 45 e0             	lea    -0x20(%ebp),%eax
    931e:	6a 01                	push   $0x1
    9320:	89 55 c8             	mov    %edx,-0x38(%ebp)
    9323:	50                   	push   %eax
	struct k_poll_event events[] = {
    9324:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
    9328:	89 55 f0             	mov    %edx,-0x10(%ebp)
    932b:	e8 b3 b7 01 00       	call   24ae3 <z_impl_k_poll>
    9330:	89 c3                	mov    %eax,%ebx
    9332:	83 c4 0c             	add    $0xc,%esp
		if (res && res != -EAGAIN && res != -EINTR) {
    9335:	8d 40 04             	lea    0x4(%eax),%eax
    9338:	83 e0 fb             	and    $0xfffffffb,%eax
    933b:	74 13                	je     9350 <zsock_recvfrom_ctx+0x31a>
    933d:	83 fb f5             	cmp    $0xfffffff5,%ebx
    9340:	74 0e                	je     9350 <zsock_recvfrom_ctx+0x31a>
    9342:	e8 a1 99 01 00       	call   22ce8 <z_impl_z_errno>
			errno = -res;
    9347:	f7 db                	neg    %ebx
    9349:	89 18                	mov    %ebx,(%eax)
			return -1;
    934b:	e9 87 fd ff ff       	jmp    90d7 <zsock_recvfrom_ctx+0xa1>
    9350:	6a 00                	push   $0x0
    9352:	ff 76 78             	pushl  0x78(%esi)
    9355:	e8 cf a2 01 00       	call   23629 <z_queue_node_peek>
    935a:	5b                   	pop    %ebx
		if (!pkt) {
    935b:	85 c0                	test   %eax,%eax
    935d:	5f                   	pop    %edi
    935e:	89 c7                	mov    %eax,%edi
    9360:	75 0e                	jne    9370 <zsock_recvfrom_ctx+0x33a>
			if (sock_is_eof(ctx)) {
    9362:	f6 06 01             	testb  $0x1,(%esi)
    9365:	0f 85 61 ff ff ff    	jne    92cc <zsock_recvfrom_ctx+0x296>
    936b:	e9 5c fd ff ff       	jmp    90cc <zsock_recvfrom_ctx+0x96>
	backup->buf = pkt->cursor.buf;
    9370:	8b 40 18             	mov    0x18(%eax),%eax
    9373:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	backup->pos = pkt->cursor.pos;
    9376:	8b 47 1c             	mov    0x1c(%edi),%eax
    9379:	89 45 c0             	mov    %eax,-0x40(%ebp)
		data_len = net_pkt_remaining_data(pkt);
    937c:	57                   	push   %edi
    937d:	e8 cb 70 00 00       	call   1044d <net_pkt_remaining_data>
    9382:	8b 5d 10             	mov    0x10(%ebp),%ebx
    9385:	59                   	pop    %ecx
    9386:	39 c3                	cmp    %eax,%ebx
    9388:	89 c1                	mov    %eax,%ecx
		if (recv_len > max_len) {
    938a:	76 02                	jbe    938e <zsock_recvfrom_ctx+0x358>
    938c:	89 c3                	mov    %eax,%ebx
		if (net_pkt_read(pkt, buf, recv_len)) {
    938e:	53                   	push   %ebx
    938f:	89 4d bc             	mov    %ecx,-0x44(%ebp)
    9392:	ff 75 0c             	pushl  0xc(%ebp)
    9395:	57                   	push   %edi
    9396:	e8 7d 6f 00 00       	call   10318 <net_pkt_read>
    939b:	83 c4 0c             	add    $0xc,%esp
    939e:	8b 4d bc             	mov    -0x44(%ebp),%ecx
    93a1:	85 c0                	test   %eax,%eax
    93a3:	74 10                	je     93b5 <zsock_recvfrom_ctx+0x37f>
    93a5:	e8 3e 99 01 00       	call   22ce8 <z_impl_z_errno>
			errno = ENOBUFS;
    93aa:	c7 00 37 00 00 00    	movl   $0x37,(%eax)
			return -1;
    93b0:	e9 22 fd ff ff       	jmp    90d7 <zsock_recvfrom_ctx+0xa1>
		if (!(flags & ZSOCK_MSG_PEEK)) {
    93b5:	8b 45 14             	mov    0x14(%ebp),%eax
    93b8:	83 e0 02             	and    $0x2,%eax
    93bb:	89 45 bc             	mov    %eax,-0x44(%ebp)
    93be:	75 23                	jne    93e3 <zsock_recvfrom_ctx+0x3ad>
			if (recv_len == data_len) {
    93c0:	39 4d 10             	cmp    %ecx,0x10(%ebp)
    93c3:	72 2a                	jb     93ef <zsock_recvfrom_ctx+0x3b9>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    93c5:	6a 00                	push   $0x0
    93c7:	ff 75 c8             	pushl  -0x38(%ebp)
    93ca:	e8 08 a3 01 00       	call   236d7 <z_impl_k_queue_get>
				if (net_pkt_eof(pkt)) {
    93cf:	f6 47 3d 02          	testb  $0x2,0x3d(%edi)
    93d3:	58                   	pop    %eax
    93d4:	5a                   	pop    %edx
    93d5:	74 03                	je     93da <zsock_recvfrom_ctx+0x3a4>
	val = (val & ~mask) | flag;
    93d7:	83 0e 01             	orl    $0x1,(%esi)
				net_pkt_unref(pkt);
    93da:	57                   	push   %edi
    93db:	e8 21 6a 00 00       	call   fe01 <net_pkt_unref>
    93e0:	59                   	pop    %ecx
    93e1:	eb 0c                	jmp    93ef <zsock_recvfrom_ctx+0x3b9>
	pkt->cursor.buf = backup->buf;
    93e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    93e6:	89 47 18             	mov    %eax,0x18(%edi)
	pkt->cursor.pos = backup->pos;
    93e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
    93ec:	89 47 1c             	mov    %eax,0x1c(%edi)
	} while (recv_len == 0);
    93ef:	85 db                	test   %ebx,%ebx
    93f1:	0f 84 0d ff ff ff    	je     9304 <zsock_recvfrom_ctx+0x2ce>
	if (!(flags & ZSOCK_MSG_PEEK)) {
    93f7:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
    93fb:	75 09                	jne    9406 <zsock_recvfrom_ctx+0x3d0>
		net_context_update_recv_wnd(ctx, recv_len);
    93fd:	53                   	push   %ebx
    93fe:	56                   	push   %esi
    93ff:	e8 a7 42 00 00       	call   d6ab <net_context_update_recv_wnd>
    9404:	58                   	pop    %eax
    9405:	5a                   	pop    %edx
}
    9406:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9409:	89 d8                	mov    %ebx,%eax
    940b:	5b                   	pop    %ebx
    940c:	5e                   	pop    %esi
    940d:	5f                   	pop    %edi
    940e:	5d                   	pop    %ebp
    940f:	c3                   	ret    

00009410 <sock_recvfrom_vmeth>:

static ssize_t sock_recvfrom_vmeth(void *obj, void *buf, size_t max_len,
				   int flags, struct sockaddr *src_addr,
				   socklen_t *addrlen)
{
	return zsock_recvfrom_ctx(obj, buf, max_len, flags,
    9410:	e9 21 fc ff ff       	jmp    9036 <zsock_recvfrom_ctx>

00009415 <sock_read_vmeth>:
{
    9415:	55                   	push   %ebp
    9416:	89 e5                	mov    %esp,%ebp
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
    9418:	6a 00                	push   $0x0
    941a:	6a 00                	push   $0x0
    941c:	6a 00                	push   $0x0
    941e:	ff 75 10             	pushl  0x10(%ebp)
    9421:	ff 75 0c             	pushl  0xc(%ebp)
    9424:	ff 75 08             	pushl  0x8(%ebp)
    9427:	e8 0a fc ff ff       	call   9036 <zsock_recvfrom_ctx>
    942c:	83 c4 18             	add    $0x18,%esp
}
    942f:	c9                   	leave  
    9430:	c3                   	ret    

00009431 <z_impl_zsock_recvfrom>:
{
    9431:	55                   	push   %ebp
    9432:	89 e5                	mov    %esp,%ebp
    9434:	50                   	push   %eax
	return z_get_fd_obj_and_vtable(sock,
    9435:	8d 45 fc             	lea    -0x4(%ebp),%eax
    9438:	50                   	push   %eax
    9439:	ff 75 08             	pushl  0x8(%ebp)
    943c:	e8 32 86 ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    9441:	5a                   	pop    %edx
    9442:	89 c2                	mov    %eax,%edx
    9444:	59                   	pop    %ecx
    9445:	83 c8 ff             	or     $0xffffffff,%eax
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
    9448:	85 d2                	test   %edx,%edx
    944a:	74 19                	je     9465 <z_impl_zsock_recvfrom+0x34>
    944c:	ff 75 1c             	pushl  0x1c(%ebp)
    944f:	ff 75 18             	pushl  0x18(%ebp)
    9452:	ff 75 14             	pushl  0x14(%ebp)
    9455:	ff 75 10             	pushl  0x10(%ebp)
    9458:	ff 75 0c             	pushl  0xc(%ebp)
    945b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    945e:	52                   	push   %edx
    945f:	ff 50 20             	call   *0x20(%eax)
    9462:	83 c4 18             	add    $0x18,%esp
}
    9465:	c9                   	leave  
    9466:	c3                   	ret    

00009467 <z_impl_zsock_poll>:
{
    9467:	55                   	push   %ebp
    9468:	89 e5                	mov    %esp,%ebp
    946a:	57                   	push   %edi
    946b:	56                   	push   %esi
    946c:	53                   	push   %ebx
    946d:	83 ec 54             	sub    $0x54,%esp
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    9470:	e8 7d b4 01 00       	call   248f2 <z_impl_k_uptime_get_32>
    9475:	8b 75 10             	mov    0x10(%ebp),%esi
    9478:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (timeout < 0) {
    947b:	85 f6                	test   %esi,%esi
    947d:	79 03                	jns    9482 <z_impl_zsock_poll+0x1b>
    947f:	83 ce ff             	or     $0xffffffff,%esi
	pev = poll_events;
    9482:	8d 45 b8             	lea    -0x48(%ebp),%eax
	for (pfd = fds, i = nfds; i--; pfd++) {
    9485:	8b 7d 0c             	mov    0xc(%ebp),%edi
	pev = poll_events;
    9488:	89 45 b0             	mov    %eax,-0x50(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
    948b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    948e:	85 ff                	test   %edi,%edi
    9490:	74 4a                	je     94dc <z_impl_zsock_poll+0x75>
		if (pfd->fd < 0) {
    9492:	8b 03                	mov    (%ebx),%eax
    9494:	85 c0                	test   %eax,%eax
    9496:	78 3e                	js     94d6 <z_impl_zsock_poll+0x6f>
		ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    9498:	8d 55 b4             	lea    -0x4c(%ebp),%edx
    949b:	52                   	push   %edx
    949c:	50                   	push   %eax
    949d:	e8 d1 85 ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    94a2:	5a                   	pop    %edx
		if (ctx == NULL) {
    94a3:	85 c0                	test   %eax,%eax
		ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    94a5:	59                   	pop    %ecx
		if (ctx == NULL) {
    94a6:	74 2e                	je     94d6 <z_impl_zsock_poll+0x6f>
		if (z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_POLL_PREPARE,
    94a8:	8d 55 f4             	lea    -0xc(%ebp),%edx
    94ab:	52                   	push   %edx
    94ac:	8d 55 b0             	lea    -0x50(%ebp),%edx
    94af:	52                   	push   %edx
    94b0:	53                   	push   %ebx
    94b1:	68 03 01 00 00       	push   $0x103
    94b6:	50                   	push   %eax
    94b7:	ff 75 b4             	pushl  -0x4c(%ebp)
    94ba:	e8 4e f5 ff ff       	call   8a0d <z_fdtable_call_ioctl>
    94bf:	83 c4 18             	add    $0x18,%esp
    94c2:	85 c0                	test   %eax,%eax
    94c4:	79 10                	jns    94d6 <z_impl_zsock_poll+0x6f>
    94c6:	e8 1d 98 01 00       	call   22ce8 <z_impl_z_errno>
			if (errno == EALREADY) {
    94cb:	83 38 45             	cmpl   $0x45,(%eax)
    94ce:	0f 85 f7 00 00 00    	jne    95cb <z_impl_zsock_poll+0x164>
				timeout = K_NO_WAIT;
    94d4:	31 f6                	xor    %esi,%esi
	for (pfd = fds, i = nfds; i--; pfd++) {
    94d6:	83 c3 08             	add    $0x8,%ebx
    94d9:	4f                   	dec    %edi
    94da:	eb b2                	jmp    948e <z_impl_zsock_poll+0x27>
    94dc:	89 75 ac             	mov    %esi,-0x54(%ebp)
		ret = k_poll(poll_events, pev - poll_events, remaining_time);
    94df:	8d 7d b8             	lea    -0x48(%ebp),%edi
    94e2:	8b 45 b0             	mov    -0x50(%ebp),%eax
    94e5:	29 f8                	sub    %edi,%eax
    94e7:	c1 f8 02             	sar    $0x2,%eax
    94ea:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    94f0:	ff 75 ac             	pushl  -0x54(%ebp)
    94f3:	50                   	push   %eax
    94f4:	57                   	push   %edi
    94f5:	e8 e9 b5 01 00       	call   24ae3 <z_impl_k_poll>
    94fa:	89 c3                	mov    %eax,%ebx
    94fc:	83 c4 0c             	add    $0xc,%esp
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
    94ff:	8d 40 04             	lea    0x4(%eax),%eax
    9502:	83 e0 fb             	and    $0xfffffffb,%eax
    9505:	0f 95 c2             	setne  %dl
    9508:	83 fb f5             	cmp    $0xfffffff5,%ebx
    950b:	0f 95 c0             	setne  %al
    950e:	20 c2                	and    %al,%dl
    9510:	88 55 ab             	mov    %dl,-0x55(%ebp)
    9513:	74 0e                	je     9523 <z_impl_zsock_poll+0xbc>
    9515:	e8 ce 97 01 00       	call   22ce8 <z_impl_z_errno>
			errno = -ret;
    951a:	f7 db                	neg    %ebx
    951c:	89 18                	mov    %ebx,(%eax)
			return -1;
    951e:	e9 a8 00 00 00       	jmp    95cb <z_impl_zsock_poll+0x164>
		for (pfd = fds, i = nfds; i--; pfd++) {
    9523:	8b 45 0c             	mov    0xc(%ebp),%eax
		pev = poll_events;
    9526:	89 7d b0             	mov    %edi,-0x50(%ebp)
		for (pfd = fds, i = nfds; i--; pfd++) {
    9529:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    952c:	8b 7d 08             	mov    0x8(%ebp),%edi
		ret = 0;
    952f:	31 db                	xor    %ebx,%ebx
		for (pfd = fds, i = nfds; i--; pfd++) {
    9531:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
    9535:	74 5e                	je     9595 <z_impl_zsock_poll+0x12e>
			if (pfd->fd < 0) {
    9537:	8b 07                	mov    (%edi),%eax
			pfd->revents = 0;
    9539:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
			if (pfd->fd < 0) {
    953f:	85 c0                	test   %eax,%eax
    9541:	78 4a                	js     958d <z_impl_zsock_poll+0x126>
			ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    9543:	8d 4d b4             	lea    -0x4c(%ebp),%ecx
    9546:	51                   	push   %ecx
    9547:	50                   	push   %eax
    9548:	e8 26 85 ff ff       	call   1a73 <z_get_fd_obj_and_vtable>
    954d:	5a                   	pop    %edx
			if (ctx == NULL) {
    954e:	85 c0                	test   %eax,%eax
			ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    9550:	59                   	pop    %ecx
			if (ctx == NULL) {
    9551:	75 08                	jne    955b <z_impl_zsock_poll+0xf4>
				pfd->revents = ZSOCK_POLLNVAL;
    9553:	66 c7 47 06 20 00    	movw   $0x20,0x6(%edi)
				ret++;
    9559:	eb 31                	jmp    958c <z_impl_zsock_poll+0x125>
			if (z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_POLL_UPDATE,
    955b:	8d 4d b0             	lea    -0x50(%ebp),%ecx
    955e:	51                   	push   %ecx
    955f:	57                   	push   %edi
    9560:	68 04 01 00 00       	push   $0x104
    9565:	50                   	push   %eax
    9566:	ff 75 b4             	pushl  -0x4c(%ebp)
    9569:	e8 9f f4 ff ff       	call   8a0d <z_fdtable_call_ioctl>
    956e:	83 c4 14             	add    $0x14,%esp
    9571:	85 c0                	test   %eax,%eax
    9573:	79 10                	jns    9585 <z_impl_zsock_poll+0x11e>
    9575:	e8 6e 97 01 00       	call   22ce8 <z_impl_z_errno>
				if (errno == EAGAIN) {
    957a:	83 38 0b             	cmpl   $0xb,(%eax)
    957d:	75 4c                	jne    95cb <z_impl_zsock_poll+0x164>
					retry = true;
    957f:	c6 45 ab 01          	movb   $0x1,-0x55(%ebp)
    9583:	eb 08                	jmp    958d <z_impl_zsock_poll+0x126>
			if (pfd->revents != 0) {
    9585:	66 83 7f 06 00       	cmpw   $0x0,0x6(%edi)
    958a:	74 01                	je     958d <z_impl_zsock_poll+0x126>
				ret++;
    958c:	43                   	inc    %ebx
		for (pfd = fds, i = nfds; i--; pfd++) {
    958d:	83 c7 08             	add    $0x8,%edi
    9590:	ff 4d a4             	decl   -0x5c(%ebp)
    9593:	eb 9c                	jmp    9531 <z_impl_zsock_poll+0xca>
			if (timeout == K_NO_WAIT) {
    9595:	8a 45 ab             	mov    -0x55(%ebp),%al
    9598:	83 f0 01             	xor    $0x1,%eax
			if (ret > 0) {
    959b:	85 db                	test   %ebx,%ebx
    959d:	0f 9f c2             	setg   %dl
			if (timeout == K_NO_WAIT) {
    95a0:	08 d0                	or     %dl,%al
    95a2:	75 2a                	jne    95ce <z_impl_zsock_poll+0x167>
    95a4:	85 f6                	test   %esi,%esi
    95a6:	74 26                	je     95ce <z_impl_zsock_poll+0x167>
			if (timeout != K_FOREVER) {
    95a8:	83 fe ff             	cmp    $0xffffffff,%esi
    95ab:	0f 84 2e ff ff ff    	je     94df <z_impl_zsock_poll+0x78>
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    95b1:	e8 3c b3 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	return timeout - elapsed;
    95b6:	8b 4d a0             	mov    -0x60(%ebp),%ecx
    95b9:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
    95bc:	29 c2                	sub    %eax,%edx
    95be:	89 55 ac             	mov    %edx,-0x54(%ebp)
				if (remaining_time <= 0) {
    95c1:	85 d2                	test   %edx,%edx
    95c3:	0f 8f 16 ff ff ff    	jg     94df <z_impl_zsock_poll+0x78>
    95c9:	eb 03                	jmp    95ce <z_impl_zsock_poll+0x167>
			return -1;
    95cb:	83 cb ff             	or     $0xffffffff,%ebx
}
    95ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
    95d1:	89 d8                	mov    %ebx,%eax
    95d3:	5b                   	pop    %ebx
    95d4:	5e                   	pop    %esi
    95d5:	5f                   	pop    %edi
    95d6:	5d                   	pop    %ebp
    95d7:	c3                   	ret    

000095d8 <zsock_setsockopt_ctx>:
{
    95d8:	55                   	push   %ebp
    95d9:	89 e5                	mov    %esp,%ebp
    95db:	8b 45 0c             	mov    0xc(%ebp),%eax
    95de:	8b 55 10             	mov    0x10(%ebp),%edx
	switch (level) {
    95e1:	83 f8 01             	cmp    $0x1,%eax
    95e4:	74 0a                	je     95f0 <zsock_setsockopt_ctx+0x18>
    95e6:	83 f8 06             	cmp    $0x6,%eax
    95e9:	75 0c                	jne    95f7 <zsock_setsockopt_ctx+0x1f>
			return 0;
    95eb:	31 c0                	xor    %eax,%eax
    95ed:	4a                   	dec    %edx
    95ee:	eb 05                	jmp    95f5 <zsock_setsockopt_ctx+0x1d>
    95f0:	31 c0                	xor    %eax,%eax
    95f2:	83 fa 02             	cmp    $0x2,%edx
    95f5:	74 0e                	je     9605 <zsock_setsockopt_ctx+0x2d>
    95f7:	e8 ec 96 01 00       	call   22ce8 <z_impl_z_errno>
	errno = ENOPROTOOPT;
    95fc:	c7 00 2a 00 00 00    	movl   $0x2a,(%eax)
    9602:	83 c8 ff             	or     $0xffffffff,%eax
}
    9605:	5d                   	pop    %ebp
    9606:	c3                   	ret    

00009607 <sock_setsockopt_vmeth>:
}

static int sock_setsockopt_vmeth(void *obj, int level, int optname,
				 const void *optval, socklen_t optlen)
{
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
    9607:	e9 cc ff ff ff       	jmp    95d8 <zsock_setsockopt_ctx>

0000960c <sys_rand32_get>:
static ALWAYS_INLINE
	u32_t _do_read_cpu_timestamp32(void)
{
	u32_t rv;

	__asm__ volatile("rdtsc" : "=a"(rv) :  : "%edx");
    960c:	0f 31                	rdtsc  
 */

u32_t sys_rand32_get(void)
{
	return _do_read_cpu_timestamp32();
}
    960e:	c3                   	ret    

0000960f <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    960f:	55                   	push   %ebp
    9610:	89 e5                	mov    %esp,%ebp
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    9612:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
    9616:	75 10                	jne    9628 <console_out+0x19>
    9618:	a1 54 42 40 00       	mov    0x404254,%eax
	api->poll_out(dev, out_char);
    961d:	8b 50 04             	mov    0x4(%eax),%edx
    9620:	6a 0d                	push   $0xd
    9622:	50                   	push   %eax
    9623:	ff 52 04             	call   *0x4(%edx)
    9626:	59                   	pop    %ecx
    9627:	58                   	pop    %eax
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    9628:	a1 54 42 40 00       	mov    0x404254,%eax
    962d:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    9631:	8b 50 04             	mov    0x4(%eax),%edx
    9634:	51                   	push   %ecx
    9635:	50                   	push   %eax
    9636:	ff 52 04             	call   *0x4(%edx)
    9639:	58                   	pop    %eax
    963a:	5a                   	pop    %edx

	return c;
}
    963b:	8b 45 08             	mov    0x8(%ebp),%eax
    963e:	c9                   	leave  
    963f:	c3                   	ret    

00009640 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    9640:	55                   	push   %ebp
    9641:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
    9643:	68 0f 96 00 00       	push   $0x960f
    9648:	e8 0c 21 00 00       	call   b759 <__stdout_hook_install>
	__printk_hook_install(console_out);
    964d:	c7 04 24 0f 96 00 00 	movl   $0x960f,(%esp)
    9654:	e8 c6 91 ff ff       	call   281f <__printk_hook_install>
    9659:	58                   	pop    %eax
}
    965a:	c9                   	leave  
    965b:	c3                   	ret    

0000965c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    965c:	55                   	push   %ebp
    965d:	89 e5                	mov    %esp,%ebp
    965f:	68 df 6d 02 00       	push   $0x26ddf
    9664:	e8 24 96 01 00       	call   22c8d <z_impl_device_get_binding>
    9669:	5a                   	pop    %edx

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    966a:	a3 54 42 40 00       	mov    %eax,0x404254
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    966f:	e8 cc ff ff ff       	call   9640 <uart_console_hook_install>

	return 0;
}
    9674:	31 c0                	xor    %eax,%eax
    9676:	c9                   	leave  
    9677:	c3                   	ret    

00009678 <uart_pipe_isr>:
		recv_buf = app_cb(recv_buf, &recv_off);
	}
}

static void uart_pipe_isr(struct device *dev)
{
    9678:	55                   	push   %ebp
    9679:	89 e5                	mov    %esp,%ebp
    967b:	53                   	push   %ebx
    967c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (api->irq_update) {
    967f:	8b 43 04             	mov    0x4(%ebx),%eax
    9682:	8b 40 44             	mov    0x44(%eax),%eax
    9685:	85 c0                	test   %eax,%eax
    9687:	74 04                	je     968d <uart_pipe_isr+0x15>
		return api->irq_update(dev);
    9689:	53                   	push   %ebx
    968a:	ff d0                	call   *%eax
    968c:	59                   	pop    %ecx
	if (api->irq_is_pending)	{
    968d:	8b 43 04             	mov    0x4(%ebx),%eax
    9690:	8b 40 40             	mov    0x40(%eax),%eax
    9693:	85 c0                	test   %eax,%eax
    9695:	74 69                	je     9700 <uart_pipe_isr+0x88>
		return api->irq_is_pending(dev);
    9697:	53                   	push   %ebx
    9698:	ff d0                	call   *%eax
    969a:	5a                   	pop    %edx
	uart_irq_update(dev);

	if (uart_irq_is_pending(dev)) {
    969b:	85 c0                	test   %eax,%eax
    969d:	74 61                	je     9700 <uart_pipe_isr+0x88>
	if (api->irq_rx_ready) {
    969f:	8b 43 04             	mov    0x4(%ebx),%eax
    96a2:	8b 40 34             	mov    0x34(%eax),%eax
    96a5:	85 c0                	test   %eax,%eax
    96a7:	74 57                	je     9700 <uart_pipe_isr+0x88>
		return api->irq_rx_ready(dev);
    96a9:	53                   	push   %ebx
    96aa:	ff d0                	call   *%eax
    96ac:	5b                   	pop    %ebx
		if (uart_irq_rx_ready(dev)) {
    96ad:	85 c0                	test   %eax,%eax
    96af:	74 4f                	je     9700 <uart_pipe_isr+0x88>
		got = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off, avail);
    96b1:	8b 1d 68 42 40 00    	mov    0x404268,%ebx
	if (api->fifo_read) {
    96b7:	8b 43 04             	mov    0x4(%ebx),%eax
    96ba:	8b 48 18             	mov    0x18(%eax),%ecx
    96bd:	85 c9                	test   %ecx,%ecx
    96bf:	74 3f                	je     9700 <uart_pipe_isr+0x88>
		int avail = recv_buf_len - recv_off;
    96c1:	a1 58 42 40 00       	mov    0x404258,%eax
    96c6:	8b 15 60 42 40 00    	mov    0x404260,%edx
    96cc:	29 c2                	sub    %eax,%edx
		got = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off, avail);
    96ce:	03 05 64 42 40 00    	add    0x404264,%eax
		return api->fifo_read(dev, rx_data, size);
    96d4:	52                   	push   %edx
    96d5:	50                   	push   %eax
    96d6:	53                   	push   %ebx
    96d7:	ff d1                	call   *%ecx
    96d9:	83 c4 0c             	add    $0xc,%esp
		if (got <= 0) {
    96dc:	85 c0                	test   %eax,%eax
    96de:	7e 20                	jle    9700 <uart_pipe_isr+0x88>
		recv_buf = app_cb(recv_buf, &recv_off);
    96e0:	68 58 42 40 00       	push   $0x404258
		recv_off += got;
    96e5:	01 05 58 42 40 00    	add    %eax,0x404258
		recv_buf = app_cb(recv_buf, &recv_off);
    96eb:	ff 35 64 42 40 00    	pushl  0x404264
    96f1:	ff 15 5c 42 40 00    	call   *0x40425c
    96f7:	5a                   	pop    %edx
    96f8:	a3 64 42 40 00       	mov    %eax,0x404264
    96fd:	59                   	pop    %ecx
    96fe:	eb b1                	jmp    96b1 <uart_pipe_isr+0x39>
			uart_pipe_rx(dev);
		}
	}
}
    9700:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9703:	c9                   	leave  
    9704:	c3                   	ret    

00009705 <uart_pipe_send>:

int uart_pipe_send(const u8_t *data, int len)
{
    9705:	55                   	push   %ebp
    9706:	89 e5                	mov    %esp,%ebp
    9708:	56                   	push   %esi
    9709:	53                   	push   %ebx
    970a:	8b 75 0c             	mov    0xc(%ebp),%esi
    970d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	while (len--)  {
    9710:	01 de                	add    %ebx,%esi
    9712:	39 f3                	cmp    %esi,%ebx
    9714:	74 16                	je     972c <uart_pipe_send+0x27>
		uart_poll_out(uart_pipe_dev, *data++);
    9716:	43                   	inc    %ebx
    9717:	a1 68 42 40 00       	mov    0x404268,%eax
    971c:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
	api->poll_out(dev, out_char);
    9720:	8b 50 04             	mov    0x4(%eax),%edx
    9723:	51                   	push   %ecx
    9724:	50                   	push   %eax
    9725:	ff 52 04             	call   *0x4(%edx)
    9728:	58                   	pop    %eax
    9729:	5a                   	pop    %edx
    972a:	eb e6                	jmp    9712 <uart_pipe_send+0xd>
	}

	return 0;
}
    972c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    972f:	31 c0                	xor    %eax,%eax
    9731:	5b                   	pop    %ebx
    9732:	5e                   	pop    %esi
    9733:	5d                   	pop    %ebp
    9734:	c3                   	ret    

00009735 <uart_pipe_register>:

	uart_irq_rx_enable(uart);
}

void uart_pipe_register(u8_t *buf, size_t len, uart_pipe_recv_cb cb)
{
    9735:	55                   	push   %ebp
    9736:	89 e5                	mov    %esp,%ebp
    9738:	53                   	push   %ebx
    9739:	53                   	push   %ebx
	recv_buf = buf;
    973a:	8b 45 08             	mov    0x8(%ebp),%eax
    973d:	68 04 75 02 00       	push   $0x27504
    9742:	a3 64 42 40 00       	mov    %eax,0x404264
	recv_buf_len = len;
    9747:	8b 45 0c             	mov    0xc(%ebp),%eax
    974a:	a3 60 42 40 00       	mov    %eax,0x404260
	app_cb = cb;
    974f:	8b 45 10             	mov    0x10(%ebp),%eax
    9752:	a3 5c 42 40 00       	mov    %eax,0x40425c
    9757:	e8 31 95 01 00       	call   22c8d <z_impl_device_get_binding>
    975c:	5a                   	pop    %edx

	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
    975d:	a3 68 42 40 00       	mov    %eax,0x404268

	if (uart_pipe_dev != NULL) {
    9762:	85 c0                	test   %eax,%eax
    9764:	74 60                	je     97c6 <uart_pipe_register+0x91>
    9766:	89 c3                	mov    %eax,%ebx
	if (api->irq_rx_disable) {
    9768:	8b 40 04             	mov    0x4(%eax),%eax
    976b:	8b 40 2c             	mov    0x2c(%eax),%eax
    976e:	85 c0                	test   %eax,%eax
    9770:	74 04                	je     9776 <uart_pipe_register+0x41>
		api->irq_rx_disable(dev);
    9772:	53                   	push   %ebx
    9773:	ff d0                	call   *%eax
    9775:	59                   	pop    %ecx
	if (api->irq_tx_disable) {
    9776:	8b 43 04             	mov    0x4(%ebx),%eax
    9779:	8b 40 20             	mov    0x20(%eax),%eax
    977c:	85 c0                	test   %eax,%eax
    977e:	74 04                	je     9784 <uart_pipe_register+0x4f>
		api->irq_tx_disable(dev);
    9780:	53                   	push   %ebx
    9781:	ff d0                	call   *%eax
    9783:	5a                   	pop    %edx
	if (api->fifo_read) {
    9784:	8b 43 04             	mov    0x4(%ebx),%eax
    9787:	8b 40 18             	mov    0x18(%eax),%eax
    978a:	85 c0                	test   %eax,%eax
    978c:	74 10                	je     979e <uart_pipe_register+0x69>
		return api->fifo_read(dev, rx_data, size);
    978e:	6a 01                	push   $0x1
    9790:	8d 55 fb             	lea    -0x5(%ebp),%edx
    9793:	52                   	push   %edx
    9794:	53                   	push   %ebx
    9795:	ff d0                	call   *%eax
    9797:	83 c4 0c             	add    $0xc,%esp
	while (uart_fifo_read(uart, &c, 1)) {
    979a:	85 c0                	test   %eax,%eax
    979c:	75 e6                	jne    9784 <uart_pipe_register+0x4f>
	const struct uart_driver_api *api =
    979e:	8b 43 04             	mov    0x4(%ebx),%eax
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    97a1:	85 c0                	test   %eax,%eax
    97a3:	74 13                	je     97b8 <uart_pipe_register+0x83>
    97a5:	8b 40 48             	mov    0x48(%eax),%eax
    97a8:	85 c0                	test   %eax,%eax
    97aa:	74 0c                	je     97b8 <uart_pipe_register+0x83>
		api->irq_callback_set(dev, cb, user_data);
    97ac:	53                   	push   %ebx
    97ad:	68 78 96 00 00       	push   $0x9678
    97b2:	53                   	push   %ebx
    97b3:	ff d0                	call   *%eax
    97b5:	83 c4 0c             	add    $0xc,%esp
	if (api->irq_rx_enable) {
    97b8:	8b 43 04             	mov    0x4(%ebx),%eax
    97bb:	8b 40 28             	mov    0x28(%eax),%eax
    97be:	85 c0                	test   %eax,%eax
    97c0:	74 04                	je     97c6 <uart_pipe_register+0x91>
		api->irq_rx_enable(dev);
    97c2:	53                   	push   %ebx
    97c3:	ff d0                	call   *%eax
    97c5:	58                   	pop    %eax
		uart_pipe_setup(uart_pipe_dev);
	}
}
    97c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    97c9:	c9                   	leave  
    97ca:	c3                   	ret    

000097cb <__IoApicSet>:
	__asm__ volatile (
    97cb:	9c                   	pushf  
    97cc:	fa                   	cli    
    97cd:	59                   	pop    %ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
    97ce:	0f be c0             	movsbl %al,%eax
    97d1:	0f ba e1 09          	bt     $0x9,%ecx
    97d5:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
	*((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
    97da:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
    97e0:	73 01                	jae    97e3 <__IoApicSet+0x18>
	__asm__ volatile (
    97e2:	fb                   	sti    

	irq_unlock(key);
}
    97e3:	c3                   	ret    

000097e4 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				u32_t value,
				u32_t mask)
{
    97e4:	55                   	push   %ebp
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    97e5:	01 c0                	add    %eax,%eax
{
    97e7:	89 e5                	mov    %esp,%ebp
    97e9:	56                   	push   %esi
    97ea:	53                   	push   %ebx
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    97eb:	83 c0 10             	add    $0x10,%eax
	__asm__ volatile (
    97ee:	9c                   	pushf  
    97ef:	fa                   	cli    
    97f0:	5e                   	pop    %esi
		(DT_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
    97f1:	0f be d8             	movsbl %al,%ebx
    97f4:	0f ba e6 09          	bt     $0x9,%esi
    97f8:	89 1d 00 00 c0 fe    	mov    %ebx,0xfec00000
	value = *((volatile u32_t *)(DT_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
    97fe:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
    9804:	73 01                	jae    9807 <_IoApicRedUpdateLo+0x23>
	__asm__ volatile (
    9806:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
    9807:	31 da                	xor    %ebx,%edx
    9809:	21 ca                	and    %ecx,%edx
    980b:	31 da                	xor    %ebx,%edx
}
    980d:	5b                   	pop    %ebx
    980e:	5e                   	pop    %esi
    980f:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
    9810:	e9 b6 ff ff ff       	jmp    97cb <__IoApicSet>

00009815 <_ioapic_init>:
{
    9815:	55                   	push   %ebp
    9816:	89 e5                	mov    %esp,%ebp
    9818:	53                   	push   %ebx
    9819:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
    981e:	31 d2                	xor    %edx,%edx
    9820:	89 d8                	mov    %ebx,%eax
    9822:	e8 a4 ff ff ff       	call   97cb <__IoApicSet>
	__IoApicSet(offset, lower32);
    9827:	8d 43 ff             	lea    -0x1(%ebx),%eax
    982a:	ba 00 00 01 00       	mov    $0x10000,%edx
    982f:	83 c3 02             	add    $0x2,%ebx
    9832:	e8 94 ff ff ff       	call   97cb <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
    9837:	83 fb 41             	cmp    $0x41,%ebx
    983a:	75 e2                	jne    981e <_ioapic_init+0x9>
}
    983c:	5b                   	pop    %ebx
    983d:	31 c0                	xor    %eax,%eax
    983f:	5d                   	pop    %ebp
    9840:	c3                   	ret    

00009841 <z_ioapic_irq_enable>:
{
    9841:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    9842:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
    9847:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    9849:	31 d2                	xor    %edx,%edx
    984b:	8b 45 08             	mov    0x8(%ebp),%eax
}
    984e:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    984f:	e9 90 ff ff ff       	jmp    97e4 <_IoApicRedUpdateLo>

00009854 <z_ioapic_irq_set>:
{
    9854:	55                   	push   %ebp
	__IoApicSet(offset, upper32);
    9855:	31 d2                	xor    %edx,%edx
{
    9857:	89 e5                	mov    %esp,%ebp
    9859:	57                   	push   %edi
    985a:	56                   	push   %esi
    985b:	53                   	push   %ebx
    985c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
    985f:	01 db                	add    %ebx,%ebx
{
    9861:	8b 75 0c             	mov    0xc(%ebp),%esi
    9864:	8b 7d 10             	mov    0x10(%ebp),%edi
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
    9867:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
    986a:	e8 5c ff ff ff       	call   97cb <__IoApicSet>
		   (vector & IOAPIC_VEC_MASK) | flags;
    986f:	89 f0                	mov    %esi,%eax
    9871:	0f b6 d0             	movzbl %al,%edx
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    9874:	8d 43 10             	lea    0x10(%ebx),%eax
}
    9877:	5b                   	pop    %ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
    9878:	09 fa                	or     %edi,%edx
}
    987a:	5e                   	pop    %esi
    987b:	5f                   	pop    %edi
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
    987c:	81 ca 00 00 01 00    	or     $0x10000,%edx
}
    9882:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
    9883:	e9 43 ff ff ff       	jmp    97cb <__IoApicSet>

00009888 <_loapic_init>:
static ALWAYS_INLINE
	u32_t sys_read32(mm_reg_t addr)
{
	u32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
    9888:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
{
	ARG_UNUSED(unused);
	s32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	LOAPIC_WRITE(LOAPIC_SVR, LOAPIC_READ(LOAPIC_SVR) | LOAPIC_ENABLE);
    988d:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
    9890:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
	__asm__ volatile("movl	%1, %0;\n\t"
    9895:	8b 15 30 00 e0 fe    	mov    0xfee00030,%edx
	loApicMaxLvt = (LOAPIC_READ(LOAPIC_VER) & LOAPIC_MAXLVT_MASK) >> 16;
    989b:	c1 ea 10             	shr    $0x10,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
    989e:	83 c8 ff             	or     $0xffffffff,%eax
    98a1:	0f b6 ca             	movzbl %dl,%ecx
    98a4:	a3 e0 00 e0 fe       	mov    %eax,0xfee000e0
    98a9:	31 c0                	xor    %eax,%eax
    98ab:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
    98b0:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
    98b5:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	__asm__ volatile("movl	%1, %0;\n\t"
    98ba:	a1 50 03 e0 fe       	mov    0xfee00350,%eax
	 * ever be waiting for interrupts on those
	 */
#ifndef CONFIG_JAILHOUSE
	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	LOAPIC_WRITE(LOAPIC_LINT0, (LOAPIC_READ(LOAPIC_LINT0) &
    98bf:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
    98c4:	80 cc 07             	or     $0x7,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
    98c7:	a3 50 03 e0 fe       	mov    %eax,0xfee00350
	__asm__ volatile("movl	%1, %0;\n\t"
    98cc:	a1 60 03 e0 fe       	mov    0xfee00360,%eax
		  LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE));

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	LOAPIC_WRITE(LOAPIC_LINT1, (LOAPIC_READ(LOAPIC_LINT1) &
    98d1:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
    98d6:	80 cc 04             	or     $0x4,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
    98d9:	a3 60 03 e0 fe       	mov    %eax,0xfee00360
    98de:	b8 00 00 01 00       	mov    $0x10000,%eax
    98e3:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
    98e8:	a3 70 03 e0 fe       	mov    %eax,0xfee00370
	/* lock the Local APIC interrupts */

	LOAPIC_WRITE(LOAPIC_TIMER, LOAPIC_LVT_MASKED);
	LOAPIC_WRITE(LOAPIC_ERROR, LOAPIC_LVT_MASKED);

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
    98ed:	80 e2 fc             	and    $0xfc,%dl
    98f0:	74 05                	je     98f7 <_loapic_init+0x6f>
    98f2:	a3 40 03 e0 fe       	mov    %eax,0xfee00340
		LOAPIC_WRITE(LOAPIC_PMC, LOAPIC_LVT_MASKED);

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
    98f7:	83 f9 04             	cmp    $0x4,%ecx
    98fa:	7e 0a                	jle    9906 <_loapic_init+0x7e>
    98fc:	b8 00 00 01 00       	mov    $0x10000,%eax
    9901:	a3 30 03 e0 fe       	mov    %eax,0xfee00330
    9906:	31 c0                	xor    %eax,%eax
    9908:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#else
	LOAPIC_WRITE(LOAPIC_EOI, 0);
#endif

	return 0;
}
    990d:	c3                   	ret    

0000990e <z_loapic_int_vec_set>:
 */

void z_loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
    990e:	55                   	push   %ebp
    990f:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
    9911:	9c                   	pushf  
    9912:	fa                   	cli    
    9913:	59                   	pop    %ecx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
		     (LOAPIC_READ(LOAPIC_TIMER + (irq * 0x10)) &
    9914:	8b 45 08             	mov    0x8(%ebp),%eax
    9917:	83 c0 32             	add    $0x32,%eax
    991a:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
    991d:	8b 90 00 00 e0 fe    	mov    -0x1200000(%eax),%edx
    9923:	30 d2                	xor    %dl,%dl
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
    9925:	0b 55 0c             	or     0xc(%ebp),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
    9928:	89 90 00 00 e0 fe    	mov    %edx,-0x1200000(%eax)
    992e:	0f ba e1 09          	bt     $0x9,%ecx
    9932:	73 01                	jae    9935 <z_loapic_int_vec_set+0x27>
	__asm__ volatile (
    9934:	fb                   	sti    
		      ~LOAPIC_VECTOR) | vector);
	irq_unlock(oldLevel);
}
    9935:	5d                   	pop    %ebp
    9936:	c3                   	ret    

00009937 <z_loapic_irq_enable>:
 *
 * @return N/A
 */

void z_loapic_irq_enable(unsigned int irq)
{
    9937:	55                   	push   %ebp
    9938:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
    993a:	9c                   	pushf  
    993b:	fa                   	cli    
    993c:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
		     LOAPIC_READ(LOAPIC_TIMER + (irq * 0x10)) &
    993d:	8b 45 08             	mov    0x8(%ebp),%eax
    9940:	83 c0 32             	add    $0x32,%eax
    9943:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
    9946:	8b 90 00 00 e0 fe    	mov    -0x1200000(%eax),%edx
	LOAPIC_WRITE(LOAPIC_TIMER + (irq * 0x10),
    994c:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
	__asm__ volatile("movl	%0, %1;\n\t"
    9952:	89 90 00 00 e0 fe    	mov    %edx,-0x1200000(%eax)
    9958:	0f ba e1 09          	bt     $0x9,%ecx
    995c:	73 01                	jae    995f <z_loapic_irq_enable+0x28>
	__asm__ volatile (
    995e:	fb                   	sti    
		     ~LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
}
    995f:	5d                   	pop    %ebp
    9960:	c3                   	ret    

00009961 <__irq_controller_isr_vector_get>:
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
    9961:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
    9966:	89 c2                	mov    %eax,%edx
    9968:	c1 e2 04             	shl    $0x4,%edx
    996b:	8b 92 00 01 e0 fe    	mov    -0x11fff00(%edx),%edx
		pReg = LOAPIC_READ(LOAPIC_ISR + (block * 0x10));
		if (pReg) {
    9971:	85 d2                	test   %edx,%edx
    9973:	74 10                	je     9985 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
    9975:	0f bd d2             	bsr    %edx,%edx
    9978:	75 05                	jne    997f <__irq_controller_isr_vector_get+0x1e>
    997a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
    997f:	c1 e0 05             	shl    $0x5,%eax
    9982:	01 d0                	add    %edx,%eax
    9984:	c3                   	ret    
	for (block = 7; likely(block > 0); block--) {
    9985:	48                   	dec    %eax
    9986:	75 de                	jne    9966 <__irq_controller_isr_vector_get+0x5>
		}

	}
	return -1;
    9988:	83 c8 ff             	or     $0xffffffff,%eax
}
    998b:	c3                   	ret    

0000998c <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 u32_t flags)
{
    998c:	55                   	push   %ebp
    998d:	89 e5                	mov    %esp,%ebp
    998f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9992:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		z_ioapic_irq_set(irq, vector, flags);
    9995:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (IS_IOAPIC_IRQ(irq)) {
    9998:	83 f8 17             	cmp    $0x17,%eax
    999b:	77 09                	ja     99a6 <__irq_controller_irq_config+0x1a>
		z_ioapic_irq_set(irq, vector, flags);
    999d:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
    99a0:	5d                   	pop    %ebp
		z_ioapic_irq_set(irq, vector, flags);
    99a1:	e9 ae fe ff ff       	jmp    9854 <z_ioapic_irq_set>
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
    99a6:	83 e8 18             	sub    $0x18,%eax
    99a9:	89 45 08             	mov    %eax,0x8(%ebp)
}
    99ac:	5d                   	pop    %ebp
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
    99ad:	e9 5c ff ff ff       	jmp    990e <z_loapic_int_vec_set>

000099b2 <z_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void z_arch_irq_enable(unsigned int irq)
{
    99b2:	55                   	push   %ebp
    99b3:	89 e5                	mov    %esp,%ebp
    99b5:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
    99b8:	83 f8 17             	cmp    $0x17,%eax
    99bb:	77 06                	ja     99c3 <z_arch_irq_enable+0x11>
		z_ioapic_irq_enable(irq);
	} else {
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
    99bd:	5d                   	pop    %ebp
		z_ioapic_irq_enable(irq);
    99be:	e9 7e fe ff ff       	jmp    9841 <z_ioapic_irq_enable>
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
    99c3:	83 e8 18             	sub    $0x18,%eax
    99c6:	89 45 08             	mov    %eax,0x8(%ebp)
}
    99c9:	5d                   	pop    %ebp
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
    99ca:	e9 68 ff ff ff       	jmp    9937 <z_loapic_irq_enable>

000099cf <_i8259_init>:
	__asm__ volatile("outb	%b0, %w1;\n\t"
    99cf:	b0 ff                	mov    $0xff,%al
    99d1:	e6 a1                	out    %al,$0xa1
    99d3:	e6 21                	out    %al,$0x21
{
	ARG_UNUSED(unused);
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_SLAVE_BASE_ADRS));
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_MASTER_BASE_ADRS));
	return 0;
}
    99d5:	31 c0                	xor    %eax,%eax
    99d7:	c3                   	ret    

000099d8 <eth_capabilities>:
	return ETHERNET_HW_VLAN
#if defined(CONFIG_NET_LLDP)
		| ETHERNET_LLDP
#endif
		;
}
    99d8:	b8 04 00 00 00       	mov    $0x4,%eax
    99dd:	c3                   	ret    

000099de <slip_init>:
{
    99de:	55                   	push   %ebp
    99df:	89 e5                	mov    %esp,%ebp
	struct slip_context *slip = dev->driver_data;
    99e1:	8b 45 08             	mov    0x8(%ebp),%eax
    99e4:	8b 40 08             	mov    0x8(%eax),%eax
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
    99e7:	83 c0 02             	add    $0x2,%eax
	slip->state = STATE_OK;
    99ea:	c6 40 12 01          	movb   $0x1,0x12(%eax)
	slip->rx = NULL;
    99ee:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	slip->first = false;
    99f5:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
    99f9:	68 0d 9a 00 00       	push   $0x9a0d
    99fe:	6a 01                	push   $0x1
    9a00:	50                   	push   %eax
    9a01:	e8 2f fd ff ff       	call   9735 <uart_pipe_register>
    9a06:	83 c4 0c             	add    $0xc,%esp
}
    9a09:	31 c0                	xor    %eax,%eax
    9a0b:	c9                   	leave  
    9a0c:	c3                   	ret    

00009a0d <recv_cb>:
{
    9a0d:	55                   	push   %ebp
    9a0e:	89 e5                	mov    %esp,%ebp
    9a10:	57                   	push   %edi
    9a11:	56                   	push   %esi
    9a12:	53                   	push   %ebx
    9a13:	83 ec 0c             	sub    $0xc,%esp
    9a16:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!slip->init_done) {
    9a19:	80 7e fe 00          	cmpb   $0x0,-0x2(%esi)
    9a1d:	0f 84 38 02 00 00    	je     9c5b <recv_cb+0x24e>
    9a23:	b8 7c 52 02 00       	mov    $0x2527c,%eax
	struct slip_context *slip =
    9a28:	8d 7e fe             	lea    -0x2(%esi),%edi
    9a2b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
	for (i = 0; i < *off; i++) {
    9a30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9a37:	c1 e8 03             	shr    $0x3,%eax
			LOG_ERR("[%p] cannot allocate next data buf", slip);
    9a3a:	c1 e0 06             	shl    $0x6,%eax
    9a3d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	for (i = 0; i < *off; i++) {
    9a41:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a44:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9a47:	3b 10                	cmp    (%eax),%edx
    9a49:	0f 83 0c 02 00 00    	jae    9c5b <recv_cb+0x24e>
		if (slip_input_byte(slip, buf[i])) {
    9a4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a52:	0f b6 1c 06          	movzbl (%esi,%eax,1),%ebx
	switch (slip->state) {
    9a56:	8a 46 12             	mov    0x12(%esi),%al
    9a59:	3c 01                	cmp    $0x1,%al
    9a5b:	74 4b                	je     9aa8 <recv_cb+0x9b>
    9a5d:	84 c0                	test   %al,%al
    9a5f:	74 09                	je     9a6a <recv_cb+0x5d>
    9a61:	3c 02                	cmp    $0x2,%al
    9a63:	74 17                	je     9a7c <recv_cb+0x6f>
    9a65:	e9 15 01 00 00       	jmp    9b7f <recv_cb+0x172>
		if (c == SLIP_END) {
    9a6a:	80 fb c0             	cmp    $0xc0,%bl
    9a6d:	0f 85 e0 01 00 00    	jne    9c53 <recv_cb+0x246>
			slip->state = STATE_OK;
    9a73:	c6 46 12 01          	movb   $0x1,0x12(%esi)
    9a77:	e9 d7 01 00 00       	jmp    9c53 <recv_cb+0x246>
		if (c == SLIP_ESC_END) {
    9a7c:	80 fb dc             	cmp    $0xdc,%bl
    9a7f:	74 12                	je     9a93 <recv_cb+0x86>
		} else if (c == SLIP_ESC_ESC) {
    9a81:	80 fb dd             	cmp    $0xdd,%bl
    9a84:	74 14                	je     9a9a <recv_cb+0x8d>
			SLIP_STATS(slip->garbage++);
    9a86:	66 ff 46 22          	incw   0x22(%esi)
			slip->state = STATE_GARBAGE;
    9a8a:	c6 46 12 00          	movb   $0x0,0x12(%esi)
			return 0;
    9a8e:	e9 c0 01 00 00       	jmp    9c53 <recv_cb+0x246>
			c = SLIP_END;
    9a93:	bb c0 00 00 00       	mov    $0xc0,%ebx
    9a98:	eb 05                	jmp    9a9f <recv_cb+0x92>
			c = SLIP_ESC;
    9a9a:	bb db 00 00 00       	mov    $0xdb,%ebx
		slip->state = STATE_OK;
    9a9f:	c6 46 12 01          	movb   $0x1,0x12(%esi)
		break;
    9aa3:	e9 d7 00 00 00       	jmp    9b7f <recv_cb+0x172>
		if (c == SLIP_ESC) {
    9aa8:	80 fb db             	cmp    $0xdb,%bl
    9aab:	75 09                	jne    9ab6 <recv_cb+0xa9>
			slip->state = STATE_ESC;
    9aad:	c6 46 12 02          	movb   $0x2,0x12(%esi)
			return 0;
    9ab1:	e9 9d 01 00 00       	jmp    9c53 <recv_cb+0x246>
		if (c == SLIP_END) {
    9ab6:	80 fb c0             	cmp    $0xc0,%bl
    9ab9:	75 14                	jne    9acf <recv_cb+0xc2>
			if (slip->rx) {
    9abb:	8b 5e 02             	mov    0x2(%esi),%ebx
			slip->first = false;
    9abe:	c6 46 ff 00          	movb   $0x0,-0x1(%esi)
			if (slip->rx) {
    9ac2:	85 db                	test   %ebx,%ebx
    9ac4:	0f 85 4f 01 00 00    	jne    9c19 <recv_cb+0x20c>
    9aca:	e9 84 01 00 00       	jmp    9c53 <recv_cb+0x246>
		if (slip->first && !slip->rx) {
    9acf:	80 7e ff 00          	cmpb   $0x0,-0x1(%esi)
    9ad3:	74 0f                	je     9ae4 <recv_cb+0xd7>
    9ad5:	83 7e 02 00          	cmpl   $0x0,0x2(%esi)
    9ad9:	0f 85 a0 00 00 00    	jne    9b7f <recv_cb+0x172>
    9adf:	e9 6f 01 00 00       	jmp    9c53 <recv_cb+0x246>
			slip->first = true;
    9ae4:	c6 46 ff 01          	movb   $0x1,-0x1(%esi)
			slip->rx = net_pkt_rx_alloc_on_iface(slip->iface,
    9ae8:	6a 00                	push   $0x0
    9aea:	ff 76 0e             	pushl  0xe(%esi)
    9aed:	e8 1a 65 00 00       	call   1000c <net_pkt_rx_alloc_on_iface>
    9af2:	5a                   	pop    %edx
			if (!slip->rx) {
    9af3:	85 c0                	test   %eax,%eax
			slip->rx = net_pkt_rx_alloc_on_iface(slip->iface,
    9af5:	59                   	pop    %ecx
    9af6:	89 46 02             	mov    %eax,0x2(%esi)
			if (!slip->rx) {
    9af9:	75 28                	jne    9b23 <recv_cb+0x116>
				LOG_ERR("[%p] cannot allocate pkt", slip);
    9afb:	f6 05 fc a8 40 00 07 	testb  $0x7,0x40a8fc
    9b02:	0f 84 4b 01 00 00    	je     9c53 <recv_cb+0x246>
    9b08:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
    9b0c:	83 c8 01             	or     $0x1,%eax
    9b0f:	50                   	push   %eax
    9b10:	57                   	push   %edi
    9b11:	68 0b 75 02 00       	push   $0x2750b
    9b16:	e8 94 99 ff ff       	call   34af <log_1>
    9b1b:	83 c4 0c             	add    $0xc,%esp
    9b1e:	e9 30 01 00 00       	jmp    9c53 <recv_cb+0x246>
			slip->last = net_pkt_get_frag(slip->rx, K_NO_WAIT);
    9b23:	6a 00                	push   $0x0
    9b25:	50                   	push   %eax
    9b26:	e8 7e 62 00 00       	call   fda9 <net_pkt_get_frag>
    9b2b:	5a                   	pop    %edx
			if (!slip->last) {
    9b2c:	85 c0                	test   %eax,%eax
			slip->last = net_pkt_get_frag(slip->rx, K_NO_WAIT);
    9b2e:	59                   	pop    %ecx
    9b2f:	89 46 06             	mov    %eax,0x6(%esi)
			if (!slip->last) {
    9b32:	75 34                	jne    9b68 <recv_cb+0x15b>
				LOG_ERR("[%p] cannot allocate 1st data buffer",
    9b34:	f6 05 fc a8 40 00 07 	testb  $0x7,0x40a8fc
    9b3b:	74 16                	je     9b53 <recv_cb+0x146>
    9b3d:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
    9b41:	83 c8 01             	or     $0x1,%eax
    9b44:	50                   	push   %eax
    9b45:	57                   	push   %edi
    9b46:	68 24 75 02 00       	push   $0x27524
    9b4b:	e8 5f 99 ff ff       	call   34af <log_1>
    9b50:	83 c4 0c             	add    $0xc,%esp
				net_pkt_unref(slip->rx);
    9b53:	ff 76 02             	pushl  0x2(%esi)
    9b56:	e8 a6 62 00 00       	call   fe01 <net_pkt_unref>
    9b5b:	59                   	pop    %ecx
				slip->rx = NULL;
    9b5c:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
				return 0;
    9b63:	e9 eb 00 00 00       	jmp    9c53 <recv_cb+0x246>
			net_pkt_append_buffer(slip->rx, slip->last);
    9b68:	50                   	push   %eax
    9b69:	ff 76 02             	pushl  0x2(%esi)
    9b6c:	e8 af 64 00 00       	call   10020 <net_pkt_append_buffer>
    9b71:	58                   	pop    %eax
			slip->ptr = net_pkt_ip_data(slip->rx);
    9b72:	8b 46 02             	mov    0x2(%esi),%eax
			net_pkt_append_buffer(slip->rx, slip->last);
    9b75:	5a                   	pop    %edx
	return pkt->frags->data;
    9b76:	8b 40 14             	mov    0x14(%eax),%eax
			slip->ptr = net_pkt_ip_data(slip->rx);
    9b79:	8b 40 08             	mov    0x8(%eax),%eax
    9b7c:	89 46 0a             	mov    %eax,0xa(%esi)
	if (!slip->last) {
    9b7f:	8b 46 06             	mov    0x6(%esi),%eax
    9b82:	85 c0                	test   %eax,%eax
    9b84:	0f 84 c9 00 00 00    	je     9c53 <recv_cb+0x246>
	if (!net_buf_tailroom(slip->last)) {
    9b8a:	83 c0 08             	add    $0x8,%eax
    9b8d:	50                   	push   %eax
    9b8e:	e8 ac 1e 00 00       	call   ba3f <net_buf_simple_tailroom>
    9b93:	59                   	pop    %ecx
    9b94:	85 c0                	test   %eax,%eax
    9b96:	75 5e                	jne    9bf6 <recv_cb+0x1e9>
		buf = net_pkt_get_reserve_rx_data(K_NO_WAIT);
    9b98:	6a 00                	push   $0x0
    9b9a:	e8 e2 61 00 00       	call   fd81 <net_pkt_get_reserve_rx_data>
    9b9f:	5a                   	pop    %edx
		if (!buf) {
    9ba0:	85 c0                	test   %eax,%eax
    9ba2:	75 38                	jne    9bdc <recv_cb+0x1cf>
			LOG_ERR("[%p] cannot allocate next data buf", slip);
    9ba4:	f6 05 fc a8 40 00 07 	testb  $0x7,0x40a8fc
    9bab:	74 16                	je     9bc3 <recv_cb+0x1b6>
    9bad:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
    9bb1:	83 c8 01             	or     $0x1,%eax
    9bb4:	50                   	push   %eax
    9bb5:	57                   	push   %edi
    9bb6:	68 49 75 02 00       	push   $0x27549
    9bbb:	e8 ef 98 ff ff       	call   34af <log_1>
    9bc0:	83 c4 0c             	add    $0xc,%esp
			net_pkt_unref(slip->rx);
    9bc3:	ff 76 02             	pushl  0x2(%esi)
    9bc6:	e8 36 62 00 00       	call   fe01 <net_pkt_unref>
    9bcb:	58                   	pop    %eax
			slip->rx = NULL;
    9bcc:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
			slip->last = NULL;
    9bd3:	c7 46 06 00 00 00 00 	movl   $0x0,0x6(%esi)
			return 0;
    9bda:	eb 77                	jmp    9c53 <recv_cb+0x246>
		net_buf_frag_insert(slip->last, buf);
    9bdc:	50                   	push   %eax
    9bdd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9be0:	ff 76 06             	pushl  0x6(%esi)
    9be3:	e8 ee 1d 00 00       	call   b9d6 <net_buf_frag_insert>
    9be8:	59                   	pop    %ecx
    9be9:	58                   	pop    %eax
		slip->last = buf;
    9bea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9bed:	89 46 06             	mov    %eax,0x6(%esi)
		slip->ptr = slip->last->data;
    9bf0:	8b 40 08             	mov    0x8(%eax),%eax
    9bf3:	89 46 0a             	mov    %eax,0xa(%esi)
	if (slip->ptr < slip->last->data) {
    9bf6:	8b 46 06             	mov    0x6(%esi),%eax
    9bf9:	8b 4e 0a             	mov    0xa(%esi),%ecx
    9bfc:	3b 48 08             	cmp    0x8(%eax),%ecx
    9bff:	73 04                	jae    9c05 <recv_cb+0x1f8>
		*slip->ptr = c;
    9c01:	88 19                	mov    %bl,(%ecx)
    9c03:	eb 0f                	jmp    9c14 <recv_cb+0x207>
		slip->ptr = net_buf_add_u8(slip->last, c);
    9c05:	53                   	push   %ebx
    9c06:	83 c0 08             	add    $0x8,%eax
    9c09:	50                   	push   %eax
    9c0a:	e8 03 1e 00 00       	call   ba12 <net_buf_simple_add_u8>
    9c0f:	5b                   	pop    %ebx
    9c10:	5a                   	pop    %edx
    9c11:	89 46 0a             	mov    %eax,0xa(%esi)
	slip->ptr++;
    9c14:	ff 46 0a             	incl   0xa(%esi)
	return 0;
    9c17:	eb 3a                	jmp    9c53 <recv_cb+0x246>
	if (slip->last && slip->last->len) {
    9c19:	8b 46 06             	mov    0x6(%esi),%eax
    9c1c:	85 c0                	test   %eax,%eax
    9c1e:	74 3b                	je     9c5b <recv_cb+0x24e>
    9c20:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
    9c25:	74 34                	je     9c5b <recv_cb+0x24e>
	if (!pkt || !pkt->buffer) {
    9c27:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    9c2b:	74 2e                	je     9c5b <recv_cb+0x24e>
	if (net_recv_data(get_iface(slip, vlan_tag), pkt) < 0) {
    9c2d:	53                   	push   %ebx
    9c2e:	ff 76 0e             	pushl  0xe(%esi)
    9c31:	e8 0f 3e 00 00       	call   da45 <net_recv_data>
    9c36:	5a                   	pop    %edx
    9c37:	85 c0                	test   %eax,%eax
    9c39:	59                   	pop    %ecx
    9c3a:	79 07                	jns    9c43 <recv_cb+0x236>
		net_pkt_unref(pkt);
    9c3c:	53                   	push   %ebx
    9c3d:	e8 bf 61 00 00       	call   fe01 <net_pkt_unref>
    9c42:	58                   	pop    %eax
	slip->rx = NULL;
    9c43:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
	slip->last = NULL;
    9c4a:	c7 46 06 00 00 00 00 	movl   $0x0,0x6(%esi)
    9c51:	eb 08                	jmp    9c5b <recv_cb+0x24e>
	for (i = 0; i < *off; i++) {
    9c53:	ff 45 f0             	incl   -0x10(%ebp)
    9c56:	e9 e6 fd ff ff       	jmp    9a41 <recv_cb+0x34>
		*off = 0;
    9c5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c5e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    9c64:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9c67:	89 f0                	mov    %esi,%eax
    9c69:	5b                   	pop    %ebx
    9c6a:	5e                   	pop    %esi
    9c6b:	5f                   	pop    %edi
    9c6c:	5d                   	pop    %ebp
    9c6d:	c3                   	ret    

00009c6e <slip_writeb>:
{
    9c6e:	55                   	push   %ebp
    9c6f:	89 e5                	mov    %esp,%ebp
    9c71:	52                   	push   %edx
	uart_pipe_send(&buf[0], 1);
    9c72:	6a 01                	push   $0x1
	u8_t buf[1] = { c };
    9c74:	88 45 ff             	mov    %al,-0x1(%ebp)
	uart_pipe_send(&buf[0], 1);
    9c77:	8d 45 ff             	lea    -0x1(%ebp),%eax
    9c7a:	50                   	push   %eax
    9c7b:	e8 85 fa ff ff       	call   9705 <uart_pipe_send>
    9c80:	59                   	pop    %ecx
    9c81:	58                   	pop    %eax
}
    9c82:	c9                   	leave  
    9c83:	c3                   	ret    

00009c84 <slip_send>:
{
    9c84:	55                   	push   %ebp
    9c85:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
    9c8a:	89 e5                	mov    %esp,%ebp
    9c8c:	57                   	push   %edi
    9c8d:	56                   	push   %esi
    9c8e:	53                   	push   %ebx
    9c8f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
    9c92:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    9c96:	74 60                	je     9cf8 <slip_send+0x74>
	slip_writeb(SLIP_END);
    9c98:	b8 c0 00 00 00       	mov    $0xc0,%eax
    9c9d:	e8 cc ff ff ff       	call   9c6e <slip_writeb>
	for (buf = pkt->buffer; buf; buf = buf->frags) {
    9ca2:	8b 5b 14             	mov    0x14(%ebx),%ebx
    9ca5:	85 db                	test   %ebx,%ebx
    9ca7:	74 43                	je     9cec <slip_send+0x68>
		ptr = buf->data;
    9ca9:	8b 7b 08             	mov    0x8(%ebx),%edi
		for (i = 0U; i < buf->len; ++i) {
    9cac:	31 f6                	xor    %esi,%esi
    9cae:	66 39 73 0c          	cmp    %si,0xc(%ebx)
    9cb2:	76 34                	jbe    9ce8 <slip_send+0x64>
			c = *ptr++;
    9cb4:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
	switch (c) {
    9cb8:	3c c0                	cmp    $0xc0,%al
    9cba:	74 15                	je     9cd1 <slip_send+0x4d>
    9cbc:	3c db                	cmp    $0xdb,%al
    9cbe:	75 20                	jne    9ce0 <slip_send+0x5c>
		slip_writeb(SLIP_ESC);
    9cc0:	b8 db 00 00 00       	mov    $0xdb,%eax
    9cc5:	e8 a4 ff ff ff       	call   9c6e <slip_writeb>
		slip_writeb(SLIP_ESC_ESC);
    9cca:	b8 dd 00 00 00       	mov    $0xdd,%eax
    9ccf:	eb 0f                	jmp    9ce0 <slip_send+0x5c>
		slip_writeb(SLIP_ESC);
    9cd1:	b8 db 00 00 00       	mov    $0xdb,%eax
    9cd6:	e8 93 ff ff ff       	call   9c6e <slip_writeb>
		slip_writeb(SLIP_ESC_END);
    9cdb:	b8 dc 00 00 00       	mov    $0xdc,%eax
		slip_writeb(c);
    9ce0:	e8 89 ff ff ff       	call   9c6e <slip_writeb>
    9ce5:	46                   	inc    %esi
    9ce6:	eb c6                	jmp    9cae <slip_send+0x2a>
	for (buf = pkt->buffer; buf; buf = buf->frags) {
    9ce8:	8b 1b                	mov    (%ebx),%ebx
    9cea:	eb b9                	jmp    9ca5 <slip_send+0x21>
	slip_writeb(SLIP_END);
    9cec:	b8 c0 00 00 00       	mov    $0xc0,%eax
    9cf1:	e8 78 ff ff ff       	call   9c6e <slip_writeb>
	return 0;
    9cf6:	31 c0                	xor    %eax,%eax
}
    9cf8:	5b                   	pop    %ebx
    9cf9:	5e                   	pop    %esi
    9cfa:	5f                   	pop    %edi
    9cfb:	5d                   	pop    %ebp
    9cfc:	c3                   	ret    

00009cfd <slip_iface_init>:
{
    9cfd:	55                   	push   %ebp
    9cfe:	89 e5                	mov    %esp,%ebp
    9d00:	56                   	push   %esi
    9d01:	53                   	push   %ebx
    9d02:	8b 75 08             	mov    0x8(%ebp),%esi
 *
 * @return a pointer to the device driver instance
 */
static inline struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
    9d05:	8b 06                	mov    (%esi),%eax
	struct slip_context *slip = net_if_get_device(iface)->driver_data;
    9d07:	8b 00                	mov    (%eax),%eax
    9d09:	8b 58 08             	mov    0x8(%eax),%ebx
	ethernet_init(iface);
    9d0c:	56                   	push   %esi
    9d0d:	e8 b2 2a 00 00       	call   c7c4 <ethernet_init>
    9d12:	58                   	pop    %eax
	if (slip->init_done) {
    9d13:	80 3b 00             	cmpb   $0x0,(%ebx)
    9d16:	75 3e                	jne    9d56 <slip_iface_init+0x59>
	slip->ll_addr.addr = slip->mac_addr;
    9d18:	8d 43 15             	lea    0x15(%ebx),%eax
	slip->ll_addr.len = sizeof(slip->mac_addr);
    9d1b:	c6 43 20 06          	movb   $0x6,0x20(%ebx)
	slip->ll_addr.addr = slip->mac_addr;
    9d1f:	89 43 1c             	mov    %eax,0x1c(%ebx)
	slip->init_done = true;
    9d22:	c6 03 01             	movb   $0x1,(%ebx)
	slip->iface = iface;
    9d25:	89 73 10             	mov    %esi,0x10(%ebx)
		slip->mac_addr[0] = 0x00;
    9d28:	c7 43 15 00 00 5e 00 	movl   $0x5e0000,0x15(%ebx)
		slip->mac_addr[4] = 0x53;
    9d2f:	c6 43 19 53          	movb   $0x53,0x19(%ebx)
		slip->mac_addr[5] = sys_rand32_get();
    9d33:	e8 d4 f8 ff ff       	call   960c <sys_rand32_get>
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
    9d38:	8a 53 20             	mov    0x20(%ebx),%dl
		slip->mac_addr[5] = sys_rand32_get();
    9d3b:	88 43 1a             	mov    %al,0x1a(%ebx)
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
    9d3e:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    9d41:	8b 06                	mov    (%esi),%eax
    9d43:	8b 40 0c             	mov    0xc(%eax),%eax
 */
static inline int net_if_set_link_addr(struct net_if *iface,
				       u8_t *addr, u8_t len,
				       enum net_link_type type)
{
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    9d46:	a8 01                	test   $0x1,%al
    9d48:	75 0c                	jne    9d56 <slip_iface_init+0x59>
		return -EPERM;
	}

	net_if_get_link_addr(iface)->addr = addr;
    9d4a:	8b 06                	mov    (%esi),%eax
    9d4c:	89 48 10             	mov    %ecx,0x10(%eax)
	net_if_get_link_addr(iface)->len = len;
    9d4f:	88 50 14             	mov    %dl,0x14(%eax)
	net_if_get_link_addr(iface)->type = type;
    9d52:	c6 40 15 03          	movb   $0x3,0x15(%eax)
}
    9d56:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9d59:	5b                   	pop    %ebx
    9d5a:	5e                   	pop    %esi
    9d5b:	5d                   	pop    %ebp
    9d5c:	c3                   	ret    

00009d5d <hpet_isr>:
static unsigned int max_ticks;
static unsigned int cyc_per_tick;
static unsigned int last_count;

static void hpet_isr(void *arg)
{
    9d5d:	55                   	push   %ebp
    9d5e:	89 e5                	mov    %esp,%ebp
    9d60:	53                   	push   %ebx
	__asm__ volatile (
    9d61:	9c                   	pushf  
    9d62:	fa                   	cli    
    9d63:	5b                   	pop    %ebx
	ARG_UNUSED(arg);
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t now = MAIN_COUNTER_REG;
    9d64:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
	u32_t dticks = (now - last_count) / cyc_per_tick;
    9d69:	8b 0d 70 42 40 00    	mov    0x404270,%ecx
    9d6f:	2b 05 6c 42 40 00    	sub    0x40426c,%eax
    9d75:	31 d2                	xor    %edx,%edx
    9d77:	f7 f1                	div    %ecx

	last_count += dticks * cyc_per_tick;
    9d79:	0f af c8             	imul   %eax,%ecx
    9d7c:	03 0d 6c 42 40 00    	add    0x40426c,%ecx
    9d82:	0f ba e3 09          	bt     $0x9,%ebx
    9d86:	89 0d 6c 42 40 00    	mov    %ecx,0x40426c
    9d8c:	73 01                	jae    9d8f <hpet_isr+0x32>
	__asm__ volatile (
    9d8e:	fb                   	sti    
		TIMER0_COMPARATOR_REG = next;
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
    9d8f:	5b                   	pop    %ebx
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    9d90:	89 45 08             	mov    %eax,0x8(%ebp)
}
    9d93:	5d                   	pop    %ebp
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    9d94:	e9 4a aa 01 00       	jmp    247e3 <z_clock_announce>

00009d99 <z_clock_driver_init>:

	TIMER0_CONF_REG = val;
}

int z_clock_driver_init(struct device *device)
{
    9d99:	55                   	push   %ebp
    9d9a:	89 e5                	mov    %esp,%ebp
	extern int z_clock_hw_cycles_per_sec;
	u32_t hz;

	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
    9d9c:	0f b6 05 f2 b2 02 00 	movzbl 0x2b2f2,%eax
 * @returns: N/A
 */
static inline void z_irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, u32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
    9da3:	6a 00                	push   $0x0
    9da5:	6a 02                	push   $0x2
    9da7:	50                   	push   %eax
    9da8:	e8 df fb ff ff       	call   998c <__irq_controller_irq_config>
	u32_t val = (TIMER0_CONF_REG & ~(0x1f << 9)) | ((irq & 0x1f) << 9);
    9dad:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
    9db2:	83 c4 0c             	add    $0xc,%esp
    9db5:	80 e4 c1             	and    $0xc1,%ah
    9db8:	80 cc 04             	or     $0x4,%ah
	TIMER0_CONF_REG = val;
    9dbb:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
		    hpet_isr, 0, 0);
	set_timer0_irq(CONFIG_HPET_TIMER_IRQ);
	irq_enable(CONFIG_HPET_TIMER_IRQ);
    9dc0:	6a 02                	push   $0x2
    9dc2:	e8 eb fb ff ff       	call   99b2 <z_arch_irq_enable>

	/* CLK_PERIOD_REG is in femtoseconds (1e-15 sec) */
	hz = (u32_t)(1000000000000000ull / CLK_PERIOD_REG);
    9dc7:	a1 04 00 d0 fe       	mov    0xfed00004,%eax
    9dcc:	31 d2                	xor    %edx,%edx
    9dce:	89 14 24             	mov    %edx,(%esp)
    9dd1:	50                   	push   %eax
    9dd2:	68 7e 8d 03 00       	push   $0x38d7e
    9dd7:	68 00 80 c6 a4       	push   $0xa4c68000
    9ddc:	e8 0c 74 ff ff       	call   11ed <__udivdi3>
	z_clock_hw_cycles_per_sec = hz;
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    9de1:	b9 64 00 00 00       	mov    $0x64,%ecx
    9de6:	31 d2                	xor    %edx,%edx
	z_clock_hw_cycles_per_sec = hz;
    9de8:	a3 24 a7 40 00       	mov    %eax,0x40a724
	hz = (u32_t)(1000000000000000ull / CLK_PERIOD_REG);
    9ded:	83 c4 10             	add    $0x10,%esp
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    9df0:	f7 f1                	div    %ecx
    9df2:	a3 70 42 40 00       	mov    %eax,0x404270
	 */
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
	TIMER0_CONF_REG |= TCONF_MODE32;

	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
    9df7:	31 d2                	xor    %edx,%edx
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
    9df9:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
    9dfe:	83 c8 03             	or     $0x3,%eax
    9e01:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
    9e06:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
    9e0b:	83 e0 f7             	and    $0xfffffff7,%eax
    9e0e:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	TIMER0_CONF_REG |= TCONF_MODE32;
    9e13:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
    9e18:	80 cc 01             	or     $0x1,%ah
    9e1b:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
    9e20:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
    9e25:	8b 0d 70 42 40 00    	mov    0x404270,%ecx
    9e2b:	29 c8                	sub    %ecx,%eax
    9e2d:	f7 f1                	div    %ecx
    9e2f:	a3 74 42 40 00       	mov    %eax,0x404274
	last_count = MAIN_COUNTER_REG;
    9e34:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
    9e39:	a3 6c 42 40 00       	mov    %eax,0x40426c

	TIMER0_CONF_REG |= TCONF_INT_ENABLE;
    9e3e:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
    9e43:	83 c8 04             	or     $0x4,%eax
    9e46:	a3 00 01 d0 fe       	mov    %eax,0xfed00100
	TIMER0_COMPARATOR_REG = MAIN_COUNTER_REG + cyc_per_tick;
    9e4b:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
    9e50:	03 05 70 42 40 00    	add    0x404270,%eax
    9e56:	a3 08 01 d0 fe       	mov    %eax,0xfed00108

	return 0;
}
    9e5b:	31 c0                	xor    %eax,%eax
    9e5d:	c9                   	leave  
    9e5e:	c3                   	ret    

00009e5f <hpet_isr_irq2_stub>:
    9e5f:	6a 00                	push   $0x0
    9e61:	68 5d 9d 00 00       	push   $0x9d5d
    9e66:	e9 0a 01 00 00       	jmp    9f75 <_interrupt_enter>

00009e6b <z_clock_set_timeout>:
	 * nothing to do at initialization on auxiliary CPUs.
	 */
}

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    9e6b:	55                   	push   %ebp
    9e6c:	89 e5                	mov    %esp,%ebp
    9e6e:	57                   	push   %edi
    9e6f:	56                   	push   %esi
    9e70:	8b 45 08             	mov    0x8(%ebp),%eax
    9e73:	53                   	push   %ebx
    9e74:	8b 55 0c             	mov    0xc(%ebp),%edx
	ARG_UNUSED(idle);

#if defined(CONFIG_TICKLESS_KERNEL) && !defined(CONFIG_QEMU_TICKLESS_WORKAROUND)
	if (ticks == K_FOREVER && idle) {
    9e77:	83 f8 ff             	cmp    $0xffffffff,%eax
    9e7a:	75 13                	jne    9e8f <z_clock_set_timeout+0x24>
    9e7c:	84 d2                	test   %dl,%dl
    9e7e:	74 0f                	je     9e8f <z_clock_set_timeout+0x24>
		GENERAL_CONF_REG &= ~GCONF_ENABLE;
    9e80:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
    9e85:	83 e0 fe             	and    $0xfffffffe,%eax
    9e88:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
		return;
    9e8d:	eb 5d                	jmp    9eec <z_clock_set_timeout+0x81>
	}

	ticks = ticks == K_FOREVER ? max_ticks : ticks;
    9e8f:	8b 15 74 42 40 00    	mov    0x404274,%edx
    9e95:	83 f8 ff             	cmp    $0xffffffff,%eax
    9e98:	75 02                	jne    9e9c <z_clock_set_timeout+0x31>
    9e9a:	89 d0                	mov    %edx,%eax
	__asm__ volatile (
    9e9c:	9c                   	pushf  
    9e9d:	fa                   	cli    
    9e9e:	5f                   	pop    %edi
	ticks = MAX(MIN(ticks - 1, (s32_t)max_ticks), 0);
    9e9f:	48                   	dec    %eax

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t now = MAIN_COUNTER_REG, cyc;
    9ea0:	8b 35 f0 00 d0 fe    	mov    0xfed000f0,%esi

	/* Round up to next tick boundary */
	cyc = ticks * cyc_per_tick + (now - last_count) + (cyc_per_tick - 1);
    9ea6:	8b 1d 70 42 40 00    	mov    0x404270,%ebx
    9eac:	8b 0d 6c 42 40 00    	mov    0x40426c,%ecx
	ticks = MAX(MIN(ticks - 1, (s32_t)max_ticks), 0);
    9eb2:	39 d0                	cmp    %edx,%eax
    9eb4:	7e 02                	jle    9eb8 <z_clock_set_timeout+0x4d>
    9eb6:	89 d0                	mov    %edx,%eax
    9eb8:	85 c0                	test   %eax,%eax
    9eba:	79 02                	jns    9ebe <z_clock_set_timeout+0x53>
    9ebc:	31 c0                	xor    %eax,%eax
	cyc = ticks * cyc_per_tick + (now - last_count) + (cyc_per_tick - 1);
    9ebe:	0f af c3             	imul   %ebx,%eax
    9ec1:	8d 54 33 ff          	lea    -0x1(%ebx,%esi,1),%edx
    9ec5:	29 ca                	sub    %ecx,%edx
    9ec7:	01 d0                	add    %edx,%eax
	cyc = (cyc / cyc_per_tick) * cyc_per_tick;
    9ec9:	31 d2                	xor    %edx,%edx
    9ecb:	f7 f3                	div    %ebx
    9ecd:	0f af c3             	imul   %ebx,%eax
	cyc += last_count;
    9ed0:	01 c1                	add    %eax,%ecx

	if ((cyc - now) < MIN_DELAY) {
    9ed2:	89 c8                	mov    %ecx,%eax
    9ed4:	29 f0                	sub    %esi,%eax
    9ed6:	3d e7 03 00 00       	cmp    $0x3e7,%eax
    9edb:	77 02                	ja     9edf <z_clock_set_timeout+0x74>
		cyc += cyc_per_tick;
    9edd:	01 d9                	add    %ebx,%ecx
    9edf:	0f ba e7 09          	bt     $0x9,%edi
	}

	TIMER0_COMPARATOR_REG = cyc;
    9ee3:	89 0d 08 01 d0 fe    	mov    %ecx,0xfed00108
    9ee9:	73 01                	jae    9eec <z_clock_set_timeout+0x81>
	__asm__ volatile (
    9eeb:	fb                   	sti    
	k_spin_unlock(&lock, key);
#endif
}
    9eec:	5b                   	pop    %ebx
    9eed:	5e                   	pop    %esi
    9eee:	5f                   	pop    %edi
    9eef:	5d                   	pop    %ebp
    9ef0:	c3                   	ret    

00009ef1 <z_clock_elapsed>:
	__asm__ volatile (
    9ef1:	9c                   	pushf  
    9ef2:	fa                   	cli    
    9ef3:	59                   	pop    %ecx
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = (MAIN_COUNTER_REG - last_count) / cyc_per_tick;
    9ef4:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
    9ef9:	31 d2                	xor    %edx,%edx
    9efb:	2b 05 6c 42 40 00    	sub    0x40426c,%eax
    9f01:	f7 35 70 42 40 00    	divl   0x404270
    9f07:	0f ba e1 09          	bt     $0x9,%ecx
    9f0b:	73 01                	jae    9f0e <z_clock_elapsed+0x1d>
	__asm__ volatile (
    9f0d:	fb                   	sti    

	k_spin_unlock(&lock, key);
	return ret;
}
    9f0e:	c3                   	ret    

00009f0f <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
	return MAIN_COUNTER_REG;
    9f0f:	a1 f0 00 d0 fe       	mov    0xfed000f0,%eax
}
    9f14:	c3                   	ret    

00009f15 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
    9f15:	55                   	push   %ebp
    9f16:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
    9f18:	e8 09 00 00 00       	call   9f26 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
    9f1d:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
    9f1e:	a3 78 42 40 00       	mov    %eax,0x404278
}
    9f23:	31 c0                	xor    %eax,%eax
    9f25:	c3                   	ret    

00009f26 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
    9f26:	53                   	push   %ebx
	movl $1, %eax
    9f27:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
    9f2c:	0f a2                	cpuid  
	movl %ebx, %eax
    9f2e:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
    9f30:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
    9f35:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
    9f38:	5b                   	pop    %ebx
	ret
    9f39:	c3                   	ret    

00009f3a <k_cpu_idle>:
	z_sys_trace_idle();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_time_stamp = (u64_t)k_cycle_get_32();
#endif

	__asm__ volatile (
    9f3a:	fb                   	sti    
    9f3b:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
    9f3c:	c3                   	ret    

00009f3d <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
    9f3d:	fc                   	cld    
	call z_x86_trampoline_to_kernel
#endif
	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
    9f3e:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
    9f41:	50                   	push   %eax
	pushl	%edx
    9f42:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
    9f43:	57                   	push   %edi
	pushl	%esi
    9f44:	56                   	push   %esi
	pushl	%ebx
    9f45:	53                   	push   %ebx
	pushl	%ebp
    9f46:	55                   	push   %ebp
	 */
	pushl	44(%esp)
	jmp 2f
1:
#endif
	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
    9f47:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
    9f4b:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
    9f4c:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
    9f53:	00 
	je	allDone
    9f54:	74 01                	je     9f57 <allDone>
	sti
    9f56:	fb                   	sti    

00009f57 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
    9f57:	54                   	push   %esp
#endif
	INDIRECT_CALL(%ecx)		/* call exception handler */
    9f58:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
    9f5a:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
    9f5d:	5d                   	pop    %ebp
	popl	%ebp
    9f5e:	5d                   	pop    %ebp
	popl	%ebx
    9f5f:	5b                   	pop    %ebx
	popl	%esi
    9f60:	5e                   	pop    %esi
	popl	%edi
    9f61:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
    9f62:	5a                   	pop    %edx
	popl	%eax
    9f63:	58                   	pop    %eax
	popl	%ecx
    9f64:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
    9f65:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
    9f68:	cf                   	iret   

00009f69 <_kernel_oops_handler>:

#if CONFIG_X86_KERNEL_OOPS
SECTION_FUNC(TEXT, _kernel_oops_handler)
	push $0 /* dummy error code */
    9f69:	6a 00                	push   $0x0
	push $_do_kernel_oops
    9f6b:	68 5d a3 00 00       	push   $0xa35d
	jmp _exception_enter
    9f70:	e9 c8 ff ff ff       	jmp    9f3d <_exception_enter>

00009f75 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
    9f75:	fc                   	cld    
#endif
	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
    9f76:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
    9f7a:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
    9f7d:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, __swap(), etc)
	 */
	pushl	%edi
    9f7e:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
    9f7f:	b9 20 41 40 00       	mov    $0x404120,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
    9f84:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
    9f86:	83 39 01             	cmpl   $0x1,(%ecx)
	jne	alreadyOnIntStack
    9f89:	75 06                	jne    9f91 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
    9f8b:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
    9f8d:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
    9f90:	57                   	push   %edi

00009f91 <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
    9f91:	50                   	push   %eax
	pop %edx
	pop %eax
#endif

#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
    9f92:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	INDIRECT_CALL(%edx)
    9f93:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
    9f95:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
    9f98:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
    9f99:	31 c0                	xor    %eax,%eax
    9f9b:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
    9fa0:	b9 20 41 40 00       	mov    $0x404120,%ecx
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
    9fa5:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
    9fa7:	75 18                	jne    9fc1 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
    9fa9:	8b 51 08             	mov    0x8(%ecx),%edx

	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
    9fac:	39 51 20             	cmp    %edx,0x20(%ecx)
	je	noReschedule
    9faf:	74 0f                	je     9fc0 <noReschedule>
	 * the existing __swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
    9fb1:	5c                   	pop    %esp

#ifdef CONFIG_STACK_SENTINEL
	call	z_check_stack_sentinel
#endif
	pushfl			/* push KERNEL_LOCK_KEY argument */
    9fb2:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	__swap
    9fb3:	e8 26 00 00 00       	call   9fde <__swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
    9fb8:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_stop
#endif
	popl	%edi
    9fbb:	5f                   	pop    %edi
	popl	%ecx
    9fbc:	59                   	pop    %ecx
	popl	%edx
    9fbd:	5a                   	pop    %edx
	popl	%eax
    9fbe:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
    9fbf:	cf                   	iret   

00009fc0 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
    9fc0:	5c                   	pop    %esp

00009fc1 <nestedInterrupt>:
nestedInterrupt:
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	z_int_latency_stop
#endif

	popl	%edi
    9fc1:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
    9fc2:	59                   	pop    %ecx
	popl	%edx
    9fc3:	5a                   	pop    %edx
	popl	%eax
    9fc4:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
    9fc5:	cf                   	iret   

00009fc6 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
    9fc6:	6a 00                	push   $0x0

00009fc8 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
    9fc8:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
    9fc9:	50                   	push   %eax
	pushl %ecx
    9fca:	51                   	push   %ecx
	pushl %edx
    9fcb:	52                   	push   %edx
	pushl %edi
    9fcc:	57                   	push   %edi
	pushl %esi
    9fcd:	56                   	push   %esi
	pushl %ebx
    9fce:	53                   	push   %ebx
	pushl %ebp
    9fcf:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
    9fd0:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
    9fd4:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
    9fd5:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
    9fd6:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
    9fd7:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	z_NanoFatalErrorHandler
    9fd9:	e8 e2 01 00 00       	call   a1c0 <z_NanoFatalErrorHandler>

00009fde <__swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
    9fde:	57                   	push   %edi

	movl	$_kernel, %edi
    9fdf:	bf 20 41 40 00       	mov    $0x404120,%edi

	pushl	%esi
    9fe4:	56                   	push   %esi
	pushl	%ebx
    9fe5:	53                   	push   %ebx
	pushl	%ebp
    9fe6:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * z_set_thread_return_value().
	 */

	pushl   _k_neg_eagain
    9fe7:	ff 35 3c 66 02 00    	pushl  0x2663c


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %edx
    9fed:	8b 57 08             	mov    0x8(%edi),%edx
	movl	%esp, _thread_offset_to_esp(%edx)
    9ff0:	89 62 28             	mov    %esp,0x28(%edx)
	/* Register the context switch */
	push %edx
	call	z_sys_trace_thread_switched_in
	pop %edx
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
    9ff3:	8b 47 20             	mov    0x20(%edi),%eax

#endif /* CONFIG_LAZY_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
    9ff6:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover thread stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
    9ff9:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible z_set_thread_return_value() */

	popl	%eax
    9ffc:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
    9ffd:	5d                   	pop    %ebp
	popl	%ebx
    9ffe:	5b                   	pop    %ebx
	popl	%esi
    9fff:	5e                   	pop    %esi
	popl	%edi
    a000:	5f                   	pop    %edi
	 * - -EINVAL
	 */

	/* Utilize the 'eflags' parameter to __swap() */

	pushl	4(%esp)
    a001:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore __swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
    a005:	9d                   	popf   
	jne time_read_not_needed
	movw $0x2,__read_swap_end_time_value
	read_tsc __common_var_swap_end_time
time_read_not_needed:
#endif
	ret
    a006:	c3                   	ret    

0000a007 <_x86_thread_entry_wrapper>:
	pop	%eax
	pop	%edx
	pop	%ecx
	push	$0	 /* Null return address */
#endif
	movl	$0, (%esp)
    a007:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	INDIRECT_JMP(%edi)
    a00e:	ff e7                	jmp    *%edi

0000a010 <z_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN __weak void z_SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
    a010:	55                   	push   %ebp
    a011:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(pEsf);

	LOG_PANIC();
    a013:	e8 38 97 ff ff       	call   3750 <log_panic>
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
    a018:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
    a01c:	74 54                	je     a072 <z_SysFatalErrorHandler+0x62>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
    a01e:	e8 1e a1 01 00       	call   24141 <k_is_in_isr>
    a023:	84 c0                	test   %al,%al
    a025:	74 15                	je     a03c <z_SysFatalErrorHandler+0x2c>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
    a027:	e8 15 a1 01 00       	call   24141 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
    a02c:	ba 7b 75 02 00       	mov    $0x2757b,%edx
    a031:	84 c0                	test   %al,%al
    a033:	75 30                	jne    a065 <z_SysFatalErrorHandler+0x55>
    a035:	ba 7f 75 02 00       	mov    $0x2757f,%edx
    a03a:	eb 29                	jmp    a065 <z_SysFatalErrorHandler+0x55>
	if (k_is_in_isr() || z_is_thread_essential()) {
    a03c:	e8 0b a1 01 00       	call   2414c <z_is_thread_essential>
    a041:	84 c0                	test   %al,%al
    a043:	75 e2                	jne    a027 <z_SysFatalErrorHandler+0x17>
		goto hang_system;
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
    a045:	ff 35 28 41 40 00    	pushl  0x404128
    a04b:	68 b0 75 02 00       	push   $0x275b0
    a050:	e8 75 8b ff ff       	call   2bca <printk>
    a055:	5a                   	pop    %edx
    a056:	59                   	pop    %ecx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
    a057:	ff 35 28 41 40 00    	pushl  0x404128
    a05d:	e8 fd a2 01 00       	call   2435f <z_impl_k_thread_abort>
    a062:	58                   	pop    %eax
    a063:	eb 0d                	jmp    a072 <z_SysFatalErrorHandler+0x62>
		printk("Fatal fault in %s! Spinning...\n",
    a065:	52                   	push   %edx
    a066:	68 90 75 02 00       	push   $0x27590
    a06b:	e8 5a 8b ff ff       	call   2bca <printk>
    a070:	58                   	pop    %eax
    a071:	5a                   	pop    %edx
#else
	ARG_UNUSED(reason);
#endif

#ifdef CONFIG_BOARD_QEMU_X86
	printk("Terminate emulator due to fatal kernel error\n");
    a072:	68 d5 75 02 00       	push   $0x275d5
    a077:	e8 4e 8b ff ff       	call   2bca <printk>
    a07c:	58                   	pop    %eax
	__asm__ volatile("outl	%0, %w1;\n\t"
    a07d:	31 c0                	xor    %eax,%eax
    a07f:	e7 f4                	out    %eax,$0xf4

0000a081 <z_new_thread>:
 */
void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stack_size, k_thread_entry_t entry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
    a081:	55                   	push   %ebp
    a082:	89 e5                	mov    %esp,%ebp
    a084:	53                   	push   %ebx
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    a085:	ff 75 28             	pushl  0x28(%ebp)
    a088:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a08b:	6a 04                	push   $0x4
    a08d:	ff 75 24             	pushl  0x24(%ebp)
    a090:	53                   	push   %ebx
    a091:	e8 9d a2 01 00       	call   24333 <z_init_thread_base>
#if CONFIG_X86_STACK_PROTECTION
	z_x86_mmu_set_flags(&z_x86_kernel_pdpt, stack, MMU_PAGE_SIZE,
			   MMU_ENTRY_NOT_PRESENT, MMU_PTE_P_MASK);
#endif

	stack_high = (char *)STACK_ROUND_DOWN(stack_buf + stack_size);
    a096:	8b 45 10             	mov    0x10(%ebp),%eax

	/* Create an initial context on the stack expected by z_swap() */
	initial_frame = (struct _x86_initial_frame *)
		(stack_high - sizeof(struct _x86_initial_frame));
	/* z_thread_entry() arguments */
	initial_frame->entry = entry;
    a099:	8b 55 14             	mov    0x14(%ebp),%edx
	stack_high = (char *)STACK_ROUND_DOWN(stack_buf + stack_size);
    a09c:	03 45 0c             	add    0xc(%ebp),%eax

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
    a09f:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
    a0a6:	83 e0 fc             	and    $0xfffffffc,%eax
	thread->fn_abort = NULL;
    a0a9:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    a0b0:	83 c4 10             	add    $0x10,%esp
	initial_frame->entry = entry;
    a0b3:	89 50 f0             	mov    %edx,-0x10(%eax)
	initial_frame->p1 = parameter1;
    a0b6:	8b 55 18             	mov    0x18(%ebp),%edx
    a0b9:	89 50 f4             	mov    %edx,-0xc(%eax)
	initial_frame->p2 = parameter2;
    a0bc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a0bf:	89 50 f8             	mov    %edx,-0x8(%eax)
	initial_frame->p3 = parameter3;
    a0c2:	8b 55 20             	mov    0x20(%ebp),%edx
    a0c5:	89 50 fc             	mov    %edx,-0x4(%eax)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
    a0c8:	9c                   	pushf  
    a0c9:	5a                   	pop    %edx
	/* initial EFLAGS; only modify IF and IOPL bits */
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    a0ca:	80 e6 cd             	and    $0xcd,%dh
#endif /* _THREAD_WRAPPER_REQUIRED */
	} else
#endif /* CONFIG_X86_USERSPACE */
	{
#ifdef _THREAD_WRAPPER_REQUIRED
		initial_frame->edi = (u32_t)z_thread_entry;
    a0cd:	c7 40 e4 67 26 00 00 	movl   $0x2667,-0x1c(%eax)
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    a0d4:	80 ce 02             	or     $0x2,%dh
		initial_frame->thread_entry = _x86_thread_entry_wrapper;
    a0d7:	c7 40 e8 07 a0 00 00 	movl   $0xa007,-0x18(%eax)
	initial_frame->eflags = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    a0de:	89 50 ec             	mov    %edx,-0x14(%eax)
	initial_frame = (struct _x86_initial_frame *)
    a0e1:	83 e8 2c             	sub    $0x2c,%eax
    a0e4:	89 43 28             	mov    %eax,0x28(%ebx)
	thread->callee_saved.esp = (unsigned long)initial_frame;

#if defined(CONFIG_LAZY_FP_SHARING)
	thread->arch.excNestCount = 0;
#endif /* CONFIG_LAZY_FP_SHARING */
}
    a0e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a0ea:	c9                   	leave  
    a0eb:	c3                   	ret    

0000a0ec <z_x86_mmu_get_flags>:


void z_x86_mmu_get_flags(struct x86_mmu_pdpt *pdpt, void *addr,
			x86_page_entry_data_t *pde_flags,
			x86_page_entry_data_t *pte_flags)
{
    a0ec:	55                   	push   %ebp
    a0ed:	89 e5                	mov    %esp,%ebp
    a0ef:	57                   	push   %edi
    a0f0:	56                   	push   %esi
	*pde_flags =
		(x86_page_entry_data_t)(X86_MMU_GET_PDE(pdpt, addr)->value &
    a0f1:	8b 75 0c             	mov    0xc(%ebp),%esi
{
    a0f4:	53                   	push   %ebx
		(x86_page_entry_data_t)(X86_MMU_GET_PDE(pdpt, addr)->value &
    a0f5:	c1 ee 1e             	shr    $0x1e,%esi
{
    a0f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
		(x86_page_entry_data_t)(X86_MMU_GET_PDE(pdpt, addr)->value &
    a0fb:	8b 55 0c             	mov    0xc(%ebp),%edx
{
    a0fe:	8b 7d 10             	mov    0x10(%ebp),%edi
		(x86_page_entry_data_t)(X86_MMU_GET_PDE(pdpt, addr)->value &
    a101:	c1 ea 15             	shr    $0x15,%edx
    a104:	8b 0c f3             	mov    (%ebx,%esi,8),%ecx
    a107:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    a10d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
    a113:	8b 04 d1             	mov    (%ecx,%edx,8),%eax
    a116:	8b 4c d1 04          	mov    0x4(%ecx,%edx,8),%ecx
    a11a:	89 4f 04             	mov    %ecx,0x4(%edi)
    a11d:	89 c1                	mov    %eax,%ecx
    a11f:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
			~(x86_page_entry_data_t)MMU_PDE_PAGE_TABLE_MASK);

	if ((*pde_flags & MMU_ENTRY_PRESENT) != 0) {
    a125:	83 e0 01             	and    $0x1,%eax
		(x86_page_entry_data_t)(X86_MMU_GET_PDE(pdpt, addr)->value &
    a128:	89 0f                	mov    %ecx,(%edi)
	if ((*pde_flags & MMU_ENTRY_PRESENT) != 0) {
    a12a:	74 2b                	je     a157 <z_x86_mmu_get_flags+0x6b>
		*pte_flags = (x86_page_entry_data_t)
			(X86_MMU_GET_PTE(pdpt, addr)->value &
    a12c:	8b 04 f3             	mov    (%ebx,%esi,8),%eax
    a12f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a134:	8b 0c d0             	mov    (%eax,%edx,8),%ecx
    a137:	8b 55 0c             	mov    0xc(%ebp),%edx
    a13a:	c1 ea 0c             	shr    $0xc,%edx
    a13d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
    a143:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
		*pte_flags = (x86_page_entry_data_t)
    a149:	8b 04 d1             	mov    (%ecx,%edx,8),%eax
    a14c:	8b 4c d1 04          	mov    0x4(%ecx,%edx,8),%ecx
    a150:	25 ff 0f 00 00       	and    $0xfff,%eax
    a155:	eb 02                	jmp    a159 <z_x86_mmu_get_flags+0x6d>
    a157:	31 c9                	xor    %ecx,%ecx
    a159:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a15c:	89 03                	mov    %eax,(%ebx)
    a15e:	89 4b 04             	mov    %ecx,0x4(%ebx)
			 ~(x86_page_entry_data_t)MMU_PTE_PAGE_MASK);
	} else {
		*pte_flags = 0;
	}
}
    a161:	5b                   	pop    %ebx
    a162:	5e                   	pop    %esi
    a163:	5f                   	pop    %edi
    a164:	5d                   	pop    %ebp
    a165:	c3                   	ret    

0000a166 <dump_entry_flags>:
#define PK	BIT(5)
#define SGX	BIT(15)

#ifdef CONFIG_X86_MMU
static void dump_entry_flags(x86_page_entry_data_t flags)
{
    a166:	55                   	push   %ebp
	printk("0x%x%x %s, %s, %s, %s\n", (u32_t)(flags>>32),
    a167:	85 d2                	test   %edx,%edx
{
    a169:	89 e5                	mov    %esp,%ebp
    a16b:	57                   	push   %edi
    a16c:	56                   	push   %esi
	printk("0x%x%x %s, %s, %s, %s\n", (u32_t)(flags>>32),
    a16d:	bf 13 76 02 00       	mov    $0x27613,%edi
{
    a172:	53                   	push   %ebx
	printk("0x%x%x %s, %s, %s, %s\n", (u32_t)(flags>>32),
    a173:	79 05                	jns    a17a <dump_entry_flags+0x14>
    a175:	bf 03 76 02 00       	mov    $0x27603,%edi
    a17a:	be 23 76 02 00       	mov    $0x27623,%esi
    a17f:	a8 04                	test   $0x4,%al
    a181:	75 05                	jne    a188 <dump_entry_flags+0x22>
    a183:	be 28 76 02 00       	mov    $0x27628,%esi
    a188:	bb 33 76 02 00       	mov    $0x27633,%ebx
    a18d:	a8 02                	test   $0x2,%al
    a18f:	75 05                	jne    a196 <dump_entry_flags+0x30>
    a191:	bb 3c 76 02 00       	mov    $0x2763c,%ebx
    a196:	b9 46 76 02 00       	mov    $0x27646,%ecx
    a19b:	a8 01                	test   $0x1,%al
    a19d:	75 05                	jne    a1a4 <dump_entry_flags+0x3e>
    a19f:	b9 4e 76 02 00       	mov    $0x2764e,%ecx
    a1a4:	57                   	push   %edi
    a1a5:	56                   	push   %esi
    a1a6:	53                   	push   %ebx
    a1a7:	51                   	push   %ecx
    a1a8:	50                   	push   %eax
    a1a9:	52                   	push   %edx
    a1aa:	68 5a 76 02 00       	push   $0x2765a
    a1af:	e8 16 8a ff ff       	call   2bca <printk>
    a1b4:	83 c4 1c             	add    $0x1c,%esp
	       "Writable" : "Read-only",
	       flags & (x86_page_entry_data_t)MMU_ENTRY_USER ?
	       "User" : "Supervisor",
	       flags & (x86_page_entry_data_t)MMU_ENTRY_EXECUTE_DISABLE ?
	       "Execute Disable" : "Execute Enabled");
}
    a1b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a1ba:	5b                   	pop    %ebx
    a1bb:	5e                   	pop    %esi
    a1bc:	5f                   	pop    %edi
    a1bd:	5d                   	pop    %ebp
    a1be:	c3                   	ret    

0000a1bf <_debug_fatal_hook>:
__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
    a1bf:	c3                   	ret    

0000a1c0 <z_NanoFatalErrorHandler>:
{
    a1c0:	55                   	push   %ebp
    a1c1:	89 e5                	mov    %esp,%ebp
    a1c3:	57                   	push   %edi
    a1c4:	56                   	push   %esi
    a1c5:	53                   	push   %ebx
    a1c6:	83 ec 24             	sub    $0x24,%esp
    a1c9:	8b 7d 0c             	mov    0xc(%ebp),%edi
	LOG_PANIC();
    a1cc:	e8 7f 95 ff ff       	call   3750 <log_panic>
	_debug_fatal_hook(pEsf);
    a1d1:	57                   	push   %edi
    a1d2:	e8 e8 ff ff ff       	call   a1bf <_debug_fatal_hook>
    a1d7:	58                   	pop    %eax
	switch (reason) {
    a1d8:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
    a1dc:	77 4f                	ja     a22d <z_NanoFatalErrorHandler+0x6d>
    a1de:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e1:	ff 24 85 cc 5f 02 00 	jmp    *0x25fcc(,%eax,4)
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
    a1e8:	e8 74 f7 ff ff       	call   9961 <__irq_controller_isr_vector_get>
		printk("***** Unhandled interrupt vector ");
    a1ed:	68 71 76 02 00       	push   $0x27671
    a1f2:	89 c3                	mov    %eax,%ebx
    a1f4:	e8 d1 89 ff ff       	call   2bca <printk>
    a1f9:	58                   	pop    %eax
		if (vector >= 0) {
    a1fa:	85 db                	test   %ebx,%ebx
    a1fc:	78 0d                	js     a20b <z_NanoFatalErrorHandler+0x4b>
			printk("%d ", vector);
    a1fe:	53                   	push   %ebx
    a1ff:	68 93 76 02 00       	push   $0x27693
    a204:	e8 c1 89 ff ff       	call   2bca <printk>
    a209:	5e                   	pop    %esi
    a20a:	58                   	pop    %eax
		printk("*****\n");
    a20b:	68 aa 76 02 00       	push   $0x276aa
    a210:	eb 05                	jmp    a217 <z_NanoFatalErrorHandler+0x57>
		printk("***** Kernel OOPS! *****\n");
    a212:	68 97 76 02 00       	push   $0x27697
    a217:	e8 ae 89 ff ff       	call   2bca <printk>
    a21c:	5b                   	pop    %ebx
		break;
    a21d:	eb 1d                	jmp    a23c <z_NanoFatalErrorHandler+0x7c>
		printk("***** Kernel Panic! *****\n");
    a21f:	68 b1 76 02 00       	push   $0x276b1
    a224:	eb f1                	jmp    a217 <z_NanoFatalErrorHandler+0x57>
		printk("**** Kernel Allocation Failure! ****\n");
    a226:	68 cc 76 02 00       	push   $0x276cc
    a22b:	eb ea                	jmp    a217 <z_NanoFatalErrorHandler+0x57>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
    a22d:	ff 75 08             	pushl  0x8(%ebp)
    a230:	68 f2 76 02 00       	push   $0x276f2
    a235:	e8 90 89 ff ff       	call   2bca <printk>
    a23a:	5a                   	pop    %edx
    a23b:	59                   	pop    %ecx
	printk("Current thread ID = %p\n"
    a23c:	8b 47 2c             	mov    0x2c(%edi),%eax
    a23f:	8b 4f 24             	mov    0x24(%edi),%ecx
    a242:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a245:	8b 07                	mov    (%edi),%eax
    a247:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a24a:	8b 47 04             	mov    0x4(%edi),%eax
    a24d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    a250:	8b 47 10             	mov    0x10(%edi),%eax
    a253:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a256:	8b 47 0c             	mov    0xc(%edi),%eax
    a259:	0f b7 57 28          	movzwl 0x28(%edi),%edx
    a25d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    a260:	8b 47 14             	mov    0x14(%edi),%eax
    a263:	89 45 dc             	mov    %eax,-0x24(%ebp)
    a266:	8b 47 1c             	mov    0x1c(%edi),%eax
    a269:	8b 77 08             	mov    0x8(%edi),%esi
    a26c:	8b 5f 18             	mov    0x18(%edi),%ebx
    a26f:	89 4d d0             	mov    %ecx,-0x30(%ebp)
    a272:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    a275:	89 45 d8             	mov    %eax,-0x28(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    a278:	e8 25 9d 01 00       	call   23fa2 <z_impl_k_current_get>
    a27d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    a280:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    a283:	51                   	push   %ecx
    a284:	52                   	push   %edx
    a285:	ff 75 f0             	pushl  -0x10(%ebp)
    a288:	ff 75 ec             	pushl  -0x14(%ebp)
    a28b:	ff 75 e8             	pushl  -0x18(%ebp)
    a28e:	ff 75 e4             	pushl  -0x1c(%ebp)
    a291:	ff 75 e0             	pushl  -0x20(%ebp)
    a294:	ff 75 dc             	pushl  -0x24(%ebp)
    a297:	ff 75 d8             	pushl  -0x28(%ebp)
    a29a:	56                   	push   %esi
	if (base_ptr == 0) {
    a29b:	be 08 00 00 00       	mov    $0x8,%esi
	printk("Current thread ID = %p\n"
    a2a0:	53                   	push   %ebx
    a2a1:	50                   	push   %eax
    a2a2:	68 15 77 02 00       	push   $0x27715
    a2a7:	e8 1e 89 ff ff       	call   2bca <printk>
	unwind_stack(pEsf->ebp, pEsf->cs);
    a2ac:	8b 5f 04             	mov    0x4(%edi),%ebx
	printk("Current thread ID = %p\n"
    a2af:	83 c4 34             	add    $0x34,%esp
	if (base_ptr == 0) {
    a2b2:	85 db                	test   %ebx,%ebx
    a2b4:	75 28                	jne    a2de <z_NanoFatalErrorHandler+0x11e>
		printk("NULL base ptr\n");
    a2b6:	68 c5 77 02 00       	push   $0x277c5
    a2bb:	eb 2b                	jmp    a2e8 <z_NanoFatalErrorHandler+0x128>
		if (frame == NULL) {
    a2bd:	85 db                	test   %ebx,%ebx
    a2bf:	74 2d                	je     a2ee <z_NanoFatalErrorHandler+0x12e>
		if (frame->ret_addr == 0) {
    a2c1:	8b 43 04             	mov    0x4(%ebx),%eax
    a2c4:	85 c0                	test   %eax,%eax
    a2c6:	74 26                	je     a2ee <z_NanoFatalErrorHandler+0x12e>
		printk("     0x%08x (0x%x)\n", frame->ret_addr, frame->args);
    a2c8:	ff 73 08             	pushl  0x8(%ebx)
    a2cb:	50                   	push   %eax
    a2cc:	68 e9 77 02 00       	push   $0x277e9
    a2d1:	e8 f4 88 ff ff       	call   2bca <printk>
    a2d6:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
    a2d9:	4e                   	dec    %esi
		base_ptr = frame->next;
    a2da:	8b 1b                	mov    (%ebx),%ebx
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
    a2dc:	74 10                	je     a2ee <z_NanoFatalErrorHandler+0x12e>
		if (base_ptr % sizeof(base_ptr) != 0) {
    a2de:	f6 c3 03             	test   $0x3,%bl
    a2e1:	74 da                	je     a2bd <z_NanoFatalErrorHandler+0xfd>
			printk("unaligned frame ptr\n");
    a2e3:	68 d4 77 02 00       	push   $0x277d4
    a2e8:	e8 dd 88 ff ff       	call   2bca <printk>
    a2ed:	58                   	pop    %eax
	z_SysFatalErrorHandler(reason, pEsf);
    a2ee:	57                   	push   %edi
    a2ef:	ff 75 08             	pushl  0x8(%ebp)
    a2f2:	e8 19 fd ff ff       	call   a010 <z_SysFatalErrorHandler>

0000a2f7 <generic_exc_handle>:
{
    a2f7:	55                   	push   %ebp
    a2f8:	89 e5                	mov    %esp,%ebp
    a2fa:	56                   	push   %esi
    a2fb:	53                   	push   %ebx
    a2fc:	89 c3                	mov    %eax,%ebx
	printk("***** ");
    a2fe:	68 fd 77 02 00       	push   $0x277fd
{
    a303:	89 d6                	mov    %edx,%esi
	printk("***** ");
    a305:	e8 c0 88 ff ff       	call   2bca <printk>
    a30a:	58                   	pop    %eax
	switch (vector) {
    a30b:	83 fb 07             	cmp    $0x7,%ebx
    a30e:	74 12                	je     a322 <generic_exc_handle+0x2b>
    a310:	83 fb 0d             	cmp    $0xd,%ebx
    a313:	75 1a                	jne    a32f <generic_exc_handle+0x38>
		printk("General Protection Fault\n");
    a315:	68 04 78 02 00       	push   $0x27804
    a31a:	e8 ab 88 ff ff       	call   2bca <printk>
    a31f:	58                   	pop    %eax
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
    a320:	eb 24                	jmp    a346 <generic_exc_handle+0x4f>
		printk("Floating point unit not enabled\n");
    a322:	68 1e 78 02 00       	push   $0x2781e
    a327:	e8 9e 88 ff ff       	call   2bca <printk>
    a32c:	58                   	pop    %eax
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
    a32d:	eb 26                	jmp    a355 <generic_exc_handle+0x5e>
		printk("CPU exception %d\n", vector);
    a32f:	53                   	push   %ebx
    a330:	68 3f 78 02 00       	push   $0x2783f
    a335:	e8 90 88 ff ff       	call   2bca <printk>
    a33a:	59                   	pop    %ecx
    a33b:	58                   	pop    %eax
	if ((BIT(vector) & _EXC_ERROR_CODE_FAULTS) != 0) {
    a33c:	b8 00 7d 02 00       	mov    $0x27d00,%eax
    a341:	0f a3 d8             	bt     %ebx,%eax
    a344:	73 0f                	jae    a355 <generic_exc_handle+0x5e>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
    a346:	ff 76 20             	pushl  0x20(%esi)
    a349:	68 51 78 02 00       	push   $0x27851
    a34e:	e8 77 88 ff ff       	call   2bca <printk>
    a353:	58                   	pop    %eax
    a354:	5a                   	pop    %edx
	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
    a355:	56                   	push   %esi
    a356:	6a 06                	push   $0x6
    a358:	e8 63 fe ff ff       	call   a1c0 <z_NanoFatalErrorHandler>

0000a35d <_do_kernel_oops>:
{
    a35d:	55                   	push   %ebp
    a35e:	89 e5                	mov    %esp,%ebp
    a360:	8b 45 08             	mov    0x8(%ebp),%eax
	z_NanoFatalErrorHandler(*stack_ptr, esf);
    a363:	50                   	push   %eax
    a364:	8b 00                	mov    (%eax),%eax
    a366:	ff 30                	pushl  (%eax)
    a368:	e8 53 fe ff ff       	call   a1c0 <z_NanoFatalErrorHandler>

0000a36d <handle_exc_0>:
EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
    a36d:	55                   	push   %ebp
    a36e:	31 c0                	xor    %eax,%eax
    a370:	89 e5                	mov    %esp,%ebp
    a372:	8b 55 08             	mov    0x8(%ebp),%edx
    a375:	e8 7d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a37a <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
    a37a:	55                   	push   %ebp
    a37b:	b8 02 00 00 00       	mov    $0x2,%eax
    a380:	89 e5                	mov    %esp,%ebp
    a382:	8b 55 08             	mov    0x8(%ebp),%edx
    a385:	e8 6d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a38a <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
    a38a:	55                   	push   %ebp
    a38b:	b8 04 00 00 00       	mov    $0x4,%eax
    a390:	89 e5                	mov    %esp,%ebp
    a392:	8b 55 08             	mov    0x8(%ebp),%edx
    a395:	e8 5d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a39a <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
    a39a:	55                   	push   %ebp
    a39b:	b8 05 00 00 00       	mov    $0x5,%eax
    a3a0:	89 e5                	mov    %esp,%ebp
    a3a2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3a5:	e8 4d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a3aa <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
    a3aa:	55                   	push   %ebp
    a3ab:	b8 06 00 00 00       	mov    $0x6,%eax
    a3b0:	89 e5                	mov    %esp,%ebp
    a3b2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3b5:	e8 3d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a3ba <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
    a3ba:	55                   	push   %ebp
    a3bb:	b8 07 00 00 00       	mov    $0x7,%eax
    a3c0:	89 e5                	mov    %esp,%ebp
    a3c2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3c5:	e8 2d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a3ca <handle_exc_8>:
EXC_FUNC_NOCODE(IV_DOUBLE_FAULT);
    a3ca:	55                   	push   %ebp
    a3cb:	b8 08 00 00 00       	mov    $0x8,%eax
    a3d0:	89 e5                	mov    %esp,%ebp
    a3d2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3d5:	e8 1d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a3da <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
    a3da:	55                   	push   %ebp
    a3db:	b8 0a 00 00 00       	mov    $0xa,%eax
    a3e0:	89 e5                	mov    %esp,%ebp
    a3e2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3e5:	e8 0d ff ff ff       	call   a2f7 <generic_exc_handle>

0000a3ea <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
    a3ea:	55                   	push   %ebp
    a3eb:	b8 0b 00 00 00       	mov    $0xb,%eax
    a3f0:	89 e5                	mov    %esp,%ebp
    a3f2:	8b 55 08             	mov    0x8(%ebp),%edx
    a3f5:	e8 fd fe ff ff       	call   a2f7 <generic_exc_handle>

0000a3fa <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
    a3fa:	55                   	push   %ebp
    a3fb:	b8 0c 00 00 00       	mov    $0xc,%eax
    a400:	89 e5                	mov    %esp,%ebp
    a402:	8b 55 08             	mov    0x8(%ebp),%edx
    a405:	e8 ed fe ff ff       	call   a2f7 <generic_exc_handle>

0000a40a <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
    a40a:	55                   	push   %ebp
    a40b:	b8 0d 00 00 00       	mov    $0xd,%eax
    a410:	89 e5                	mov    %esp,%ebp
    a412:	8b 55 08             	mov    0x8(%ebp),%edx
    a415:	e8 dd fe ff ff       	call   a2f7 <generic_exc_handle>

0000a41a <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
    a41a:	55                   	push   %ebp
    a41b:	b8 10 00 00 00       	mov    $0x10,%eax
    a420:	89 e5                	mov    %esp,%ebp
    a422:	8b 55 08             	mov    0x8(%ebp),%edx
    a425:	e8 cd fe ff ff       	call   a2f7 <generic_exc_handle>

0000a42a <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
    a42a:	55                   	push   %ebp
    a42b:	b8 11 00 00 00       	mov    $0x11,%eax
    a430:	89 e5                	mov    %esp,%ebp
    a432:	8b 55 08             	mov    0x8(%ebp),%edx
    a435:	e8 bd fe ff ff       	call   a2f7 <generic_exc_handle>

0000a43a <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
    a43a:	55                   	push   %ebp
    a43b:	b8 12 00 00 00       	mov    $0x12,%eax
    a440:	89 e5                	mov    %esp,%ebp
    a442:	8b 55 08             	mov    0x8(%ebp),%edx
    a445:	e8 ad fe ff ff       	call   a2f7 <generic_exc_handle>

0000a44a <page_fault_handler>:
	Z_EXC_HANDLE(z_arch_user_string_nlen)
};
#endif

void page_fault_handler(NANO_ESF *esf)
{
    a44a:	55                   	push   %ebp
    a44b:	89 e5                	mov    %esp,%ebp
    a44d:	57                   	push   %edi
    a44e:	56                   	push   %esi
    a44f:	53                   	push   %ebx
    a450:	83 ec 10             	sub    $0x10,%esp
    a453:	8b 75 08             	mov    0x8(%ebp),%esi
	__asm__ ("mov %%cr2, %0" : "=r" (cr2));
    a456:	0f 20 d7             	mov    %cr2,%edi
	err = esf->errorCode;
    a459:	8b 5e 20             	mov    0x20(%esi),%ebx
	printk("***** CPU Page Fault (error code 0x%08x)\n", err);
    a45c:	53                   	push   %ebx
    a45d:	68 7c 78 02 00       	push   $0x2787c
    a462:	e8 63 87 ff ff       	call   2bca <printk>
    a467:	59                   	pop    %ecx
    a468:	58                   	pop    %eax
	printk("%s thread %s address 0x%08x\n",
    a469:	b8 6d 78 02 00       	mov    $0x2786d,%eax
    a46e:	f6 c3 10             	test   $0x10,%bl
    a471:	75 0f                	jne    a482 <page_fault_handler+0x38>
	       err & ID ? "executed" : (err & WR ? "wrote" : "read"),
    a473:	b8 76 78 02 00       	mov    $0x27876,%eax
    a478:	f6 c3 02             	test   $0x2,%bl
    a47b:	75 05                	jne    a482 <page_fault_handler+0x38>
    a47d:	b8 8b 75 02 00       	mov    $0x2758b,%eax
	printk("%s thread %s address 0x%08x\n",
    a482:	ba 23 76 02 00       	mov    $0x27623,%edx
    a487:	80 e3 04             	and    $0x4,%bl
    a48a:	75 05                	jne    a491 <page_fault_handler+0x47>
    a48c:	ba 28 76 02 00       	mov    $0x27628,%edx
    a491:	57                   	push   %edi
    a492:	50                   	push   %eax
    a493:	52                   	push   %edx
    a494:	68 a6 78 02 00       	push   $0x278a6
    a499:	e8 2c 87 ff ff       	call   2bca <printk>
    a49e:	83 c4 10             	add    $0x10,%esp
	z_x86_mmu_get_flags(pdpt, addr, &pde_flags, &pte_flags);
    a4a1:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a4a4:	50                   	push   %eax
    a4a5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    a4a8:	50                   	push   %eax
    a4a9:	57                   	push   %edi
    a4aa:	68 00 b0 40 00       	push   $0x40b000
    a4af:	e8 38 fc ff ff       	call   a0ec <z_x86_mmu_get_flags>
    a4b4:	83 c4 10             	add    $0x10,%esp
	printk("PDE: ");
    a4b7:	68 c3 78 02 00       	push   $0x278c3
    a4bc:	e8 09 87 ff ff       	call   2bca <printk>
    a4c1:	58                   	pop    %eax
	dump_entry_flags(pde_flags);
    a4c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a4c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a4c8:	e8 99 fc ff ff       	call   a166 <dump_entry_flags>
	printk("PTE: ");
    a4cd:	68 c9 78 02 00       	push   $0x278c9
    a4d2:	e8 f3 86 ff ff       	call   2bca <printk>
    a4d7:	5a                   	pop    %edx
	dump_entry_flags(pte_flags);
    a4d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a4db:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a4de:	e8 83 fc ff ff       	call   a166 <dump_entry_flags>
#ifdef CONFIG_THREAD_STACK_INFO
	if (check_stack_bounds(esf->esp, 0, esf->cs)) {
		z_NanoFatalErrorHandler(_NANO_ERR_STACK_CHK_FAIL, esf);
	}
#endif
	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
    a4e3:	56                   	push   %esi
    a4e4:	6a 06                	push   $0x6
    a4e6:	e8 d5 fc ff ff       	call   a1c0 <z_NanoFatalErrorHandler>

0000a4eb <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
    a4eb:	55                   	push   %ebp
    a4ec:	89 e5                	mov    %esp,%ebp
    a4ee:	57                   	push   %edi
    a4ef:	56                   	push   %esi
    a4f0:	53                   	push   %ebx
    a4f1:	83 ec 10             	sub    $0x10,%esp
    a4f4:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
    a4f7:	8b 45 08             	mov    0x8(%ebp),%eax
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
    a4fa:	8d 58 01             	lea    0x1(%eax),%ebx
    a4fd:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
    a501:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
    a504:	83 fa 04             	cmp    $0x4,%edx
    a507:	77 04                	ja     a50d <strtol+0x22>
    a509:	89 d8                	mov    %ebx,%eax
    a50b:	eb ed                	jmp    a4fa <strtol+0xf>
    a50d:	83 f9 20             	cmp    $0x20,%ecx
    a510:	74 f7                	je     a509 <strtol+0x1e>
	if (c == '-') {
    a512:	83 f9 2d             	cmp    $0x2d,%ecx
    a515:	75 0f                	jne    a526 <strtol+0x3b>
		neg = 1;
		c = *s++;
    a517:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
    a51a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
    a521:	8d 58 02             	lea    0x2(%eax),%ebx
    a524:	eb 12                	jmp    a538 <strtol+0x4d>
	register int neg = 0, any, cutlim;
    a526:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+')
    a52d:	83 f9 2b             	cmp    $0x2b,%ecx
    a530:	75 06                	jne    a538 <strtol+0x4d>
		c = *s++;
    a532:	0f be 0b             	movsbl (%ebx),%ecx
    a535:	8d 58 02             	lea    0x2(%eax),%ebx
	if ((base == 0 || base == 16) &&
    a538:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
    a53e:	75 29                	jne    a569 <strtol+0x7e>
    a540:	83 f9 30             	cmp    $0x30,%ecx
    a543:	75 1b                	jne    a560 <strtol+0x75>
	    c == '0' && (*s == 'x' || *s == 'X')) {
    a545:	8a 03                	mov    (%ebx),%al
    a547:	83 e0 df             	and    $0xffffffdf,%eax
    a54a:	3c 58                	cmp    $0x58,%al
    a54c:	0f 85 c6 00 00 00    	jne    a618 <strtol+0x12d>
		c = s[1];
    a552:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
    a556:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
    a55b:	83 c3 02             	add    $0x2,%ebx
		base = 16;
    a55e:	eb 09                	jmp    a569 <strtol+0x7e>
	}
	if (base == 0) {
    a560:	85 f6                	test   %esi,%esi
    a562:	75 05                	jne    a569 <strtol+0x7e>
		base = c == '0' ? 8 : 10;
    a564:	be 0a 00 00 00       	mov    $0xa,%esi
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    a569:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a56c:	31 d2                	xor    %edx,%edx
    a56e:	05 ff ff ff 7f       	add    $0x7fffffff,%eax
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    a573:	31 ff                	xor    %edi,%edi
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    a575:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cutlim = cutoff % (unsigned long)base;
    a578:	f7 f6                	div    %esi
    a57a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (acc = 0, any = 0;; c = *s++) {
    a57d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    a580:	31 c0                	xor    %eax,%eax
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    a582:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c)) {
    a585:	83 fa 09             	cmp    $0x9,%edx
    a588:	77 04                	ja     a58e <strtol+0xa3>
			c -= '0';
    a58a:	89 d1                	mov    %edx,%ecx
    a58c:	eb 1d                	jmp    a5ab <strtol+0xc0>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    a58e:	89 ca                	mov    %ecx,%edx
    a590:	83 ca 20             	or     $0x20,%edx
    a593:	83 ea 61             	sub    $0x61,%edx
		} else if (isalpha(c)) {
    a596:	83 fa 19             	cmp    $0x19,%edx
    a599:	77 40                	ja     a5db <strtol+0xf0>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    a59b:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    a59e:	83 fa 1a             	cmp    $0x1a,%edx
    a5a1:	19 d2                	sbb    %edx,%edx
    a5a3:	83 e2 e0             	and    $0xffffffe0,%edx
    a5a6:	83 c2 57             	add    $0x57,%edx
    a5a9:	29 d1                	sub    %edx,%ecx
		} else {
			break;
		}
		if (c >= base) {
    a5ab:	39 ce                	cmp    %ecx,%esi
    a5ad:	7e 2c                	jle    a5db <strtol+0xf0>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    a5af:	85 ff                	test   %edi,%edi
    a5b1:	78 1e                	js     a5d1 <strtol+0xe6>
    a5b3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    a5b6:	77 19                	ja     a5d1 <strtol+0xe6>
    a5b8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    a5bb:	75 08                	jne    a5c5 <strtol+0xda>
			any = -1;
    a5bd:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    a5c0:	3b 4d e4             	cmp    -0x1c(%ebp),%ecx
    a5c3:	7f 0f                	jg     a5d4 <strtol+0xe9>
		} else {
			any = 1;
			acc *= base;
    a5c5:	0f af c6             	imul   %esi,%eax
			any = 1;
    a5c8:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
    a5cd:	01 c8                	add    %ecx,%eax
    a5cf:	eb 03                	jmp    a5d4 <strtol+0xe9>
			any = -1;
    a5d1:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
    a5d4:	43                   	inc    %ebx
    a5d5:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c)) {
    a5d9:	eb a7                	jmp    a582 <strtol+0x97>
		}
	}
	if (any < 0) {
    a5db:	83 ff ff             	cmp    $0xffffffff,%edi
    a5de:	75 16                	jne    a5f6 <strtol+0x10b>
    a5e0:	e8 03 87 01 00       	call   22ce8 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
	} else if (neg)
		acc = -acc;
	if (endptr != NULL) {
    a5e5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
		errno = ERANGE;
    a5e9:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = neg ? LONG_MIN : LONG_MAX;
    a5ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if (endptr != NULL) {
    a5f2:	75 14                	jne    a608 <strtol+0x11d>
    a5f4:	eb 34                	jmp    a62a <strtol+0x13f>
	} else if (neg)
    a5f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a5fa:	74 02                	je     a5fe <strtol+0x113>
		acc = -acc;
    a5fc:	f7 d8                	neg    %eax
	if (endptr != NULL) {
    a5fe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    a602:	74 26                	je     a62a <strtol+0x13f>
		*endptr = (char *)(any ? s - 1 : nptr);
    a604:	85 ff                	test   %edi,%edi
    a606:	74 06                	je     a60e <strtol+0x123>
    a608:	8d 7b ff             	lea    -0x1(%ebx),%edi
    a60b:	89 7d 08             	mov    %edi,0x8(%ebp)
    a60e:	8b 75 0c             	mov    0xc(%ebp),%esi
    a611:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a614:	89 1e                	mov    %ebx,(%esi)
	}
	return acc;
    a616:	eb 12                	jmp    a62a <strtol+0x13f>
	if (base == 0) {
    a618:	85 f6                	test   %esi,%esi
    a61a:	0f 85 49 ff ff ff    	jne    a569 <strtol+0x7e>
		base = c == '0' ? 8 : 10;
    a620:	be 08 00 00 00       	mov    $0x8,%esi
    a625:	e9 3f ff ff ff       	jmp    a569 <strtol+0x7e>
}
    a62a:	83 c4 10             	add    $0x10,%esp
    a62d:	5b                   	pop    %ebx
    a62e:	5e                   	pop    %esi
    a62f:	5f                   	pop    %edi
    a630:	5d                   	pop    %ebp
    a631:	c3                   	ret    

0000a632 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
    a632:	55                   	push   %ebp
    a633:	89 e5                	mov    %esp,%ebp
    a635:	57                   	push   %edi
    a636:	56                   	push   %esi
    a637:	53                   	push   %ebx
    a638:	83 ec 0c             	sub    $0xc,%esp
    a63b:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
    a63e:	8b 45 08             	mov    0x8(%ebp),%eax

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
    a641:	8d 58 01             	lea    0x1(%eax),%ebx
    a644:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    a648:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
    a64b:	83 fa 04             	cmp    $0x4,%edx
    a64e:	77 04                	ja     a654 <strtoul+0x22>
    a650:	89 d8                	mov    %ebx,%eax
    a652:	eb ed                	jmp    a641 <strtoul+0xf>
    a654:	83 f9 20             	cmp    $0x20,%ecx
    a657:	74 f7                	je     a650 <strtoul+0x1e>
	if (c == '-') {
    a659:	83 f9 2d             	cmp    $0x2d,%ecx
    a65c:	75 0f                	jne    a66d <strtoul+0x3b>
		neg = 1;
		c = *s++;
    a65e:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
    a661:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
    a668:	8d 58 02             	lea    0x2(%eax),%ebx
    a66b:	eb 12                	jmp    a67f <strtoul+0x4d>
	register int neg = 0, any, cutlim;
    a66d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+')
    a674:	83 f9 2b             	cmp    $0x2b,%ecx
    a677:	75 06                	jne    a67f <strtoul+0x4d>
		c = *s++;
    a679:	0f be 0b             	movsbl (%ebx),%ecx
    a67c:	8d 58 02             	lea    0x2(%eax),%ebx
	if ((base == 0 || base == 16) &&
    a67f:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
    a685:	75 29                	jne    a6b0 <strtoul+0x7e>
    a687:	83 f9 30             	cmp    $0x30,%ecx
    a68a:	0f 85 c7 00 00 00    	jne    a757 <strtoul+0x125>
	    c == '0' && (*s == 'x' || *s == 'X')) {
    a690:	8a 03                	mov    (%ebx),%al
    a692:	83 e0 df             	and    $0xffffffdf,%eax
    a695:	3c 58                	cmp    $0x58,%al
    a697:	75 0e                	jne    a6a7 <strtoul+0x75>
		c = s[1];
    a699:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
    a69d:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
    a6a2:	83 c3 02             	add    $0x2,%ebx
		base = 16;
    a6a5:	eb 09                	jmp    a6b0 <strtoul+0x7e>
	}
	if (base == 0) {
    a6a7:	85 f6                	test   %esi,%esi
    a6a9:	75 05                	jne    a6b0 <strtoul+0x7e>
		base = c == '0' ? 8 : 10;
    a6ab:	be 08 00 00 00       	mov    $0x8,%esi
	}
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    a6b0:	83 c8 ff             	or     $0xffffffff,%eax
    a6b3:	31 d2                	xor    %edx,%edx
    a6b5:	f7 f6                	div    %esi
    a6b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a6ba:	89 55 e8             	mov    %edx,-0x18(%ebp)
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    a6bd:	31 ff                	xor    %edi,%edi
    a6bf:	31 c0                	xor    %eax,%eax
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    a6c1:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c)) {
    a6c4:	83 fa 09             	cmp    $0x9,%edx
    a6c7:	77 04                	ja     a6cd <strtoul+0x9b>
			c -= '0';
    a6c9:	89 d1                	mov    %edx,%ecx
    a6cb:	eb 1d                	jmp    a6ea <strtoul+0xb8>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    a6cd:	89 ca                	mov    %ecx,%edx
    a6cf:	83 ca 20             	or     $0x20,%edx
    a6d2:	83 ea 61             	sub    $0x61,%edx
		} else if (isalpha(c)) {
    a6d5:	83 fa 19             	cmp    $0x19,%edx
    a6d8:	77 40                	ja     a71a <strtoul+0xe8>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    a6da:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    a6dd:	83 fa 1a             	cmp    $0x1a,%edx
    a6e0:	19 d2                	sbb    %edx,%edx
    a6e2:	83 e2 e0             	and    $0xffffffe0,%edx
    a6e5:	83 c2 57             	add    $0x57,%edx
    a6e8:	29 d1                	sub    %edx,%ecx
		} else {
			break;
		}
		if (c >= base) {
    a6ea:	39 ce                	cmp    %ecx,%esi
    a6ec:	7e 2c                	jle    a71a <strtoul+0xe8>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    a6ee:	85 ff                	test   %edi,%edi
    a6f0:	78 1e                	js     a710 <strtoul+0xde>
    a6f2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    a6f5:	77 19                	ja     a710 <strtoul+0xde>
    a6f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    a6fa:	75 08                	jne    a704 <strtoul+0xd2>
			any = -1;
    a6fc:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    a6ff:	3b 4d e8             	cmp    -0x18(%ebp),%ecx
    a702:	7f 0f                	jg     a713 <strtoul+0xe1>
		} else {
			any = 1;
			acc *= base;
    a704:	0f af c6             	imul   %esi,%eax
			any = 1;
    a707:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
    a70c:	01 c8                	add    %ecx,%eax
    a70e:	eb 03                	jmp    a713 <strtoul+0xe1>
			any = -1;
    a710:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
    a713:	43                   	inc    %ebx
    a714:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c)) {
    a718:	eb a7                	jmp    a6c1 <strtoul+0x8f>
		}
	}
	if (any < 0) {
    a71a:	83 ff ff             	cmp    $0xffffffff,%edi
    a71d:	75 16                	jne    a735 <strtoul+0x103>
    a71f:	e8 c4 85 01 00       	call   22ce8 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
    a724:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = ULONG_MAX;
    a72a:	83 c8 ff             	or     $0xffffffff,%eax
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
    a72d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    a731:	75 14                	jne    a747 <strtoul+0x115>
    a733:	eb 34                	jmp    a769 <strtoul+0x137>
	} else if (neg) {
    a735:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a739:	74 02                	je     a73d <strtoul+0x10b>
		acc = -acc;
    a73b:	f7 d8                	neg    %eax
	if (endptr != NULL) {
    a73d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    a741:	74 26                	je     a769 <strtoul+0x137>
		*endptr = (char *)(any ? s - 1 : nptr);
    a743:	85 ff                	test   %edi,%edi
    a745:	74 06                	je     a74d <strtoul+0x11b>
    a747:	8d 7b ff             	lea    -0x1(%ebx),%edi
    a74a:	89 7d 08             	mov    %edi,0x8(%ebp)
    a74d:	8b 75 0c             	mov    0xc(%ebp),%esi
    a750:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a753:	89 1e                	mov    %ebx,(%esi)
	}
	return acc;
    a755:	eb 12                	jmp    a769 <strtoul+0x137>
	if (base == 0) {
    a757:	85 f6                	test   %esi,%esi
    a759:	0f 85 51 ff ff ff    	jne    a6b0 <strtoul+0x7e>
		base = c == '0' ? 8 : 10;
    a75f:	be 0a 00 00 00       	mov    $0xa,%esi
    a764:	e9 47 ff ff ff       	jmp    a6b0 <strtoul+0x7e>
}
    a769:	83 c4 0c             	add    $0xc,%esp
    a76c:	5b                   	pop    %ebx
    a76d:	5e                   	pop    %esi
    a76e:	5f                   	pop    %edi
    a76f:	5d                   	pop    %ebp
    a770:	c3                   	ret    

0000a771 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
    a771:	55                   	push   %ebp
    a772:	89 e5                	mov    %esp,%ebp
    a774:	57                   	push   %edi
    a775:	56                   	push   %esi
    a776:	53                   	push   %ebx
    a777:	83 ec 08             	sub    $0x8,%esp
    a77a:	8b 75 0c             	mov    0xc(%ebp),%esi
    a77d:	8b 7d 08             	mov    0x8(%ebp),%edi
	char c, sc;
	size_t len;

	c = *find++;
    a780:	8a 1e                	mov    (%esi),%bl
	if (c != 0) {
    a782:	84 db                	test   %bl,%bl
    a784:	74 3b                	je     a7c1 <strstr+0x50>
	c = *find++;
    a786:	46                   	inc    %esi
		len = strlen(find);
    a787:	56                   	push   %esi
    a788:	e8 d6 00 00 00       	call   a863 <strlen>
    a78d:	5a                   	pop    %edx
    a78e:	89 c1                	mov    %eax,%ecx
		do {
			do {
				sc = *s++;
    a790:	8d 57 01             	lea    0x1(%edi),%edx
    a793:	8a 42 ff             	mov    -0x1(%edx),%al
				if (sc == 0)
    a796:	84 c0                	test   %al,%al
    a798:	74 25                	je     a7bf <strstr+0x4e>
				return NULL;
			} while (sc != c);
    a79a:	38 c3                	cmp    %al,%bl
    a79c:	74 04                	je     a7a2 <strstr+0x31>
{
    a79e:	89 d7                	mov    %edx,%edi
    a7a0:	eb ee                	jmp    a790 <strstr+0x1f>
		} while (strncmp(s, find, len) != 0);
    a7a2:	51                   	push   %ecx
    a7a3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    a7a6:	56                   	push   %esi
    a7a7:	89 55 f0             	mov    %edx,-0x10(%ebp)
    a7aa:	52                   	push   %edx
    a7ab:	e8 e6 00 00 00       	call   a896 <strncmp>
    a7b0:	83 c4 0c             	add    $0xc,%esp
    a7b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a7b6:	85 c0                	test   %eax,%eax
    a7b8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a7bb:	75 e1                	jne    a79e <strstr+0x2d>
    a7bd:	eb 02                	jmp    a7c1 <strstr+0x50>
				return NULL;
    a7bf:	31 ff                	xor    %edi,%edi
	s--;
	}
	return (char *)s;
}
    a7c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    a7c4:	89 f8                	mov    %edi,%eax
    a7c6:	5b                   	pop    %ebx
    a7c7:	5e                   	pop    %esi
    a7c8:	5f                   	pop    %edi
    a7c9:	5d                   	pop    %ebp
    a7ca:	c3                   	ret    

0000a7cb <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
    a7cb:	55                   	push   %ebp
	char *dest = d;

	while (*s != '\0') {
    a7cc:	31 d2                	xor    %edx,%edx
{
    a7ce:	89 e5                	mov    %esp,%ebp
    a7d0:	53                   	push   %ebx
    a7d1:	8b 45 08             	mov    0x8(%ebp),%eax
	while (*s != '\0') {
    a7d4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a7d7:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    a7da:	8a 0c 11             	mov    (%ecx,%edx,1),%cl
    a7dd:	84 c9                	test   %cl,%cl
    a7df:	74 06                	je     a7e7 <strcpy+0x1c>
		*d = *s;
    a7e1:	88 0c 10             	mov    %cl,(%eax,%edx,1)
		d++;
		s++;
    a7e4:	42                   	inc    %edx
    a7e5:	eb ed                	jmp    a7d4 <strcpy+0x9>
	}

	*d = '\0';
    a7e7:	c6 03 00             	movb   $0x0,(%ebx)

	return dest;
}
    a7ea:	5b                   	pop    %ebx
    a7eb:	5d                   	pop    %ebp
    a7ec:	c3                   	ret    

0000a7ed <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
    a7ed:	55                   	push   %ebp
    a7ee:	89 e5                	mov    %esp,%ebp
    a7f0:	57                   	push   %edi
    a7f1:	56                   	push   %esi
    a7f2:	53                   	push   %ebx
    a7f3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a7f6:	8b 45 10             	mov    0x10(%ebp),%eax
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    a7f9:	8b 55 08             	mov    0x8(%ebp),%edx
    a7fc:	85 c0                	test   %eax,%eax
    a7fe:	74 21                	je     a821 <strncpy+0x34>
    a800:	8a 19                	mov    (%ecx),%bl
    a802:	8d 72 01             	lea    0x1(%edx),%esi
    a805:	8d 78 ff             	lea    -0x1(%eax),%edi
    a808:	84 db                	test   %bl,%bl
    a80a:	74 0a                	je     a816 <strncpy+0x29>
		*d = *s;
    a80c:	88 5e ff             	mov    %bl,-0x1(%esi)
		s++;
    a80f:	41                   	inc    %ecx
		d++;
		n--;
    a810:	89 f8                	mov    %edi,%eax
    a812:	89 f2                	mov    %esi,%edx
    a814:	eb e6                	jmp    a7fc <strncpy+0xf>
    a816:	31 c9                	xor    %ecx,%ecx
	}

	while (n > 0) {
		*d = '\0';
    a818:	c6 04 0a 00          	movb   $0x0,(%edx,%ecx,1)
		d++;
		n--;
    a81c:	41                   	inc    %ecx
	while (n > 0) {
    a81d:	39 c8                	cmp    %ecx,%eax
    a81f:	75 f7                	jne    a818 <strncpy+0x2b>
	}

	return dest;
}
    a821:	5b                   	pop    %ebx
    a822:	8b 45 08             	mov    0x8(%ebp),%eax
    a825:	5e                   	pop    %esi
    a826:	5f                   	pop    %edi
    a827:	5d                   	pop    %ebp
    a828:	c3                   	ret    

0000a829 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
    a829:	55                   	push   %ebp
    a82a:	89 e5                	mov    %esp,%ebp
    a82c:	53                   	push   %ebx
    a82d:	8b 55 0c             	mov    0xc(%ebp),%edx
	char tmp = (char) c;

	while ((*s != tmp) && (*s != '\0'))
    a830:	8b 45 08             	mov    0x8(%ebp),%eax
	char tmp = (char) c;
    a833:	88 d3                	mov    %dl,%bl
	while ((*s != tmp) && (*s != '\0'))
    a835:	8a 08                	mov    (%eax),%cl
    a837:	38 d9                	cmp    %bl,%cl
    a839:	74 0d                	je     a848 <strchr+0x1f>
    a83b:	84 c9                	test   %cl,%cl
    a83d:	74 03                	je     a842 <strchr+0x19>
		s++;
    a83f:	40                   	inc    %eax
    a840:	eb f3                	jmp    a835 <strchr+0xc>

	return (*s == tmp) ? (char *) s : NULL;
    a842:	84 d2                	test   %dl,%dl
    a844:	74 02                	je     a848 <strchr+0x1f>
    a846:	31 c0                	xor    %eax,%eax
}
    a848:	5b                   	pop    %ebx
    a849:	5d                   	pop    %ebp
    a84a:	c3                   	ret    

0000a84b <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
    a84b:	55                   	push   %ebp
	char *match = NULL;
    a84c:	31 c0                	xor    %eax,%eax
{
    a84e:	89 e5                	mov    %esp,%ebp
    a850:	8b 55 08             	mov    0x8(%ebp),%edx

	do {
		if (*s == (char)c) {
    a853:	8a 0a                	mov    (%edx),%cl
    a855:	3a 4d 0c             	cmp    0xc(%ebp),%cl
    a858:	75 02                	jne    a85c <strrchr+0x11>
    a85a:	89 d0                	mov    %edx,%eax
			match = (char *)s;
		}
	} while (*s++);
    a85c:	42                   	inc    %edx
    a85d:	84 c9                	test   %cl,%cl
    a85f:	75 f2                	jne    a853 <strrchr+0x8>

	return match;
}
    a861:	5d                   	pop    %ebp
    a862:	c3                   	ret    

0000a863 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    a863:	55                   	push   %ebp
	size_t n = 0;
    a864:	31 c0                	xor    %eax,%eax
{
    a866:	89 e5                	mov    %esp,%ebp
    a868:	8b 55 08             	mov    0x8(%ebp),%edx

	while (*s != '\0') {
    a86b:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
    a86f:	74 03                	je     a874 <strlen+0x11>
		s++;
		n++;
    a871:	40                   	inc    %eax
    a872:	eb f7                	jmp    a86b <strlen+0x8>
	}

	return n;
}
    a874:	5d                   	pop    %ebp
    a875:	c3                   	ret    

0000a876 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
    a876:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a877:	31 c9                	xor    %ecx,%ecx
{
    a879:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a87b:	8b 45 08             	mov    0x8(%ebp),%eax
    a87e:	8b 55 0c             	mov    0xc(%ebp),%edx
    a881:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
    a885:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
    a889:	38 d0                	cmp    %dl,%al
    a88b:	75 05                	jne    a892 <strcmp+0x1c>
    a88d:	41                   	inc    %ecx
    a88e:	84 c0                	test   %al,%al
    a890:	75 e9                	jne    a87b <strcmp+0x5>
		s1++;
		s2++;
	}

	return *s1 - *s2;
    a892:	29 d0                	sub    %edx,%eax
}
    a894:	5d                   	pop    %ebp
    a895:	c3                   	ret    

0000a896 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
    a896:	55                   	push   %ebp
    a897:	89 e5                	mov    %esp,%ebp
    a899:	56                   	push   %esi
    a89a:	53                   	push   %ebx
    a89b:	8b 55 08             	mov    0x8(%ebp),%edx
    a89e:	8b 75 10             	mov    0x10(%ebp),%esi
    a8a1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    a8a4:	01 d6                	add    %edx,%esi
    a8a6:	39 f2                	cmp    %esi,%edx
    a8a8:	74 12                	je     a8bc <strncmp+0x26>
    a8aa:	0f be 02             	movsbl (%edx),%eax
    a8ad:	0f be 0b             	movsbl (%ebx),%ecx
    a8b0:	84 c0                	test   %al,%al
    a8b2:	74 0c                	je     a8c0 <strncmp+0x2a>
    a8b4:	38 c8                	cmp    %cl,%al
    a8b6:	75 08                	jne    a8c0 <strncmp+0x2a>
		s1++;
    a8b8:	42                   	inc    %edx
		s2++;
    a8b9:	43                   	inc    %ebx
		n--;
    a8ba:	eb ea                	jmp    a8a6 <strncmp+0x10>
	}

	return (n == 0) ? 0 : (*s1 - *s2);
    a8bc:	31 c0                	xor    %eax,%eax
    a8be:	eb 02                	jmp    a8c2 <strncmp+0x2c>
    a8c0:	29 c8                	sub    %ecx,%eax
}
    a8c2:	5b                   	pop    %ebx
    a8c3:	5e                   	pop    %esi
    a8c4:	5d                   	pop    %ebp
    a8c5:	c3                   	ret    

0000a8c6 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    a8c6:	55                   	push   %ebp
    a8c7:	31 c0                	xor    %eax,%eax
    a8c9:	89 e5                	mov    %esp,%ebp
    a8cb:	56                   	push   %esi
    a8cc:	53                   	push   %ebx
    a8cd:	8b 75 10             	mov    0x10(%ebp),%esi
    a8d0:	8b 55 08             	mov    0x8(%ebp),%edx
    a8d3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n)
    a8d6:	85 f6                	test   %esi,%esi
    a8d8:	74 1a                	je     a8f4 <memcmp+0x2e>
    a8da:	8d 4a 01             	lea    0x1(%edx),%ecx
    a8dd:	01 d6                	add    %edx,%esi
    a8df:	0f be 41 ff          	movsbl -0x1(%ecx),%eax
    a8e3:	0f be 13             	movsbl (%ebx),%edx
		return 0;

	while ((--n > 0) && (*c1 == *c2)) {
    a8e6:	39 f1                	cmp    %esi,%ecx
    a8e8:	74 08                	je     a8f2 <memcmp+0x2c>
    a8ea:	41                   	inc    %ecx
    a8eb:	38 d0                	cmp    %dl,%al
    a8ed:	75 03                	jne    a8f2 <memcmp+0x2c>
		c1++;
		c2++;
    a8ef:	43                   	inc    %ebx
    a8f0:	eb ed                	jmp    a8df <memcmp+0x19>
	}

	return *c1 - *c2;
    a8f2:	29 d0                	sub    %edx,%eax
}
    a8f4:	5b                   	pop    %ebx
    a8f5:	5e                   	pop    %esi
    a8f6:	5d                   	pop    %ebp
    a8f7:	c3                   	ret    

0000a8f8 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
    a8f8:	55                   	push   %ebp
    a8f9:	89 e5                	mov    %esp,%ebp
    a8fb:	56                   	push   %esi
    a8fc:	53                   	push   %ebx
    a8fd:	8b 45 08             	mov    0x8(%ebp),%eax
    a900:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    a903:	89 c3                	mov    %eax,%ebx
{
    a905:	8b 55 10             	mov    0x10(%ebp),%edx
	if ((size_t) (dest - src) < n) {
    a908:	29 cb                	sub    %ecx,%ebx
    a90a:	39 d3                	cmp    %edx,%ebx
    a90c:	72 07                	jb     a915 <memmove+0x1d>
    a90e:	8d 34 0a             	lea    (%edx,%ecx,1),%esi
    a911:	89 c3                	mov    %eax,%ebx
    a913:	eb 0b                	jmp    a920 <memmove+0x28>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
    a915:	4a                   	dec    %edx
			dest[n] = src[n];
    a916:	8a 1c 11             	mov    (%ecx,%edx,1),%bl
    a919:	88 1c 10             	mov    %bl,(%eax,%edx,1)
		while (n > 0) {
    a91c:	75 f7                	jne    a915 <memmove+0x1d>
    a91e:	eb 0d                	jmp    a92d <memmove+0x35>
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    a920:	39 f1                	cmp    %esi,%ecx
    a922:	74 09                	je     a92d <memmove+0x35>
			*dest = *src;
    a924:	8a 11                	mov    (%ecx),%dl
			dest++;
    a926:	43                   	inc    %ebx
			*dest = *src;
    a927:	88 53 ff             	mov    %dl,-0x1(%ebx)
			src++;
    a92a:	41                   	inc    %ecx
			n--;
    a92b:	eb f3                	jmp    a920 <memmove+0x28>
		}
	}

	return d;
}
    a92d:	5b                   	pop    %ebx
    a92e:	5e                   	pop    %esi
    a92f:	5d                   	pop    %ebp
    a930:	c3                   	ret    

0000a931 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    a931:	55                   	push   %ebp
    a932:	89 e5                	mov    %esp,%ebp
    a934:	57                   	push   %edi
    a935:	56                   	push   %esi
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
    a936:	8b 45 08             	mov    0x8(%ebp),%eax
{
    a939:	53                   	push   %ebx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
    a93a:	33 45 0c             	xor    0xc(%ebp),%eax
{
    a93d:	8b 55 10             	mov    0x10(%ebp),%edx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
    a940:	a8 03                	test   $0x3,%al
    a942:	74 05                	je     a949 <memcpy+0x18>
	unsigned char *d_byte = (unsigned char *)d;
    a944:	8b 7d 08             	mov    0x8(%ebp),%edi
    a947:	eb 40                	jmp    a989 <memcpy+0x58>
    a949:	8b 45 08             	mov    0x8(%ebp),%eax

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
    a94c:	a8 03                	test   $0x3,%al
    a94e:	74 12                	je     a962 <memcpy+0x31>
			if (n == 0) {
    a950:	85 d2                	test   %edx,%edx
    a952:	74 44                	je     a998 <memcpy+0x67>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    a954:	89 c7                	mov    %eax,%edi
    a956:	8b 75 0c             	mov    0xc(%ebp),%esi
    a959:	a4                   	movsb  %ds:(%esi),%es:(%edi)
			n--;
    a95a:	4a                   	dec    %edx
			*(d_byte++) = *(s_byte++);
    a95b:	89 75 0c             	mov    %esi,0xc(%ebp)
    a95e:	89 f8                	mov    %edi,%eax
			n--;
    a960:	eb ea                	jmp    a94c <memcpy+0x1b>
    a962:	8b 75 0c             	mov    0xc(%ebp),%esi
    a965:	89 c7                	mov    %eax,%edi
    a967:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
    a96a:	89 cb                	mov    %ecx,%ebx
    a96c:	29 fb                	sub    %edi,%ebx
    a96e:	83 fb 03             	cmp    $0x3,%ebx
    a971:	76 03                	jbe    a976 <memcpy+0x45>
			*(d_word++) = *(s_word++);
    a973:	a5                   	movsl  %ds:(%esi),%es:(%edi)
			n -= sizeof(unsigned int);
    a974:	eb f4                	jmp    a96a <memcpy+0x39>
    a976:	89 d3                	mov    %edx,%ebx
    a978:	c1 eb 02             	shr    $0x2,%ebx
    a97b:	6b f3 fc             	imul   $0xfffffffc,%ebx,%esi
    a97e:	c1 e3 02             	shl    $0x2,%ebx
    a981:	01 f2                	add    %esi,%edx
    a983:	01 5d 0c             	add    %ebx,0xc(%ebp)
    a986:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
    a989:	01 fa                	add    %edi,%edx
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    a98b:	39 d7                	cmp    %edx,%edi
    a98d:	74 09                	je     a998 <memcpy+0x67>
		*(d_byte++) = *(s_byte++);
    a98f:	8b 75 0c             	mov    0xc(%ebp),%esi
    a992:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    a993:	89 75 0c             	mov    %esi,0xc(%ebp)
		n--;
    a996:	eb f3                	jmp    a98b <memcpy+0x5a>
	}

	return d;
}
    a998:	5b                   	pop    %ebx
    a999:	8b 45 08             	mov    0x8(%ebp),%eax
    a99c:	5e                   	pop    %esi
    a99d:	5f                   	pop    %edi
    a99e:	5d                   	pop    %ebp
    a99f:	c3                   	ret    

0000a9a0 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    a9a0:	55                   	push   %ebp
    a9a1:	89 e5                	mov    %esp,%ebp
    a9a3:	57                   	push   %edi
    a9a4:	56                   	push   %esi
    a9a5:	53                   	push   %ebx
    a9a6:	51                   	push   %ecx
    a9a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a9aa:	8b 55 10             	mov    0x10(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    a9ad:	88 5d f3             	mov    %bl,-0xd(%ebp)
	unsigned char *d_byte = (unsigned char *)buf;
    a9b0:	8b 45 08             	mov    0x8(%ebp),%eax

	while (((unsigned int)d_byte) & 0x3) {
    a9b3:	a8 03                	test   $0x3,%al
    a9b5:	74 0e                	je     a9c5 <memset+0x25>
		if (n == 0) {
    a9b7:	85 d2                	test   %edx,%edx
    a9b9:	74 4d                	je     aa08 <memset+0x68>
			return buf;
		}
		*(d_byte++) = c_byte;
    a9bb:	40                   	inc    %eax
    a9bc:	8a 4d f3             	mov    -0xd(%ebp),%cl
		n--;
    a9bf:	4a                   	dec    %edx
		*(d_byte++) = c_byte;
    a9c0:	88 48 ff             	mov    %cl,-0x1(%eax)
		n--;
    a9c3:	eb ee                	jmp    a9b3 <memset+0x13>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
    a9c5:	0f b6 db             	movzbl %bl,%ebx

	c_word |= c_word << 8;
    a9c8:	89 d9                	mov    %ebx,%ecx
    a9ca:	8d 34 10             	lea    (%eax,%edx,1),%esi
    a9cd:	c1 e1 08             	shl    $0x8,%ecx
    a9d0:	09 cb                	or     %ecx,%ebx
	c_word |= c_word << 16;
    a9d2:	89 d9                	mov    %ebx,%ecx
    a9d4:	c1 e1 10             	shl    $0x10,%ecx
    a9d7:	09 cb                	or     %ecx,%ebx

	while (n >= sizeof(unsigned int)) {
    a9d9:	89 c1                	mov    %eax,%ecx
    a9db:	89 f7                	mov    %esi,%edi
    a9dd:	29 cf                	sub    %ecx,%edi
    a9df:	83 ff 03             	cmp    $0x3,%edi
    a9e2:	76 08                	jbe    a9ec <memset+0x4c>
		*(d_word++) = c_word;
    a9e4:	83 c1 04             	add    $0x4,%ecx
    a9e7:	89 59 fc             	mov    %ebx,-0x4(%ecx)
		n -= sizeof(unsigned int);
    a9ea:	eb ef                	jmp    a9db <memset+0x3b>
    a9ec:	89 d1                	mov    %edx,%ecx
    a9ee:	c1 e9 02             	shr    $0x2,%ecx
    a9f1:	8d 04 88             	lea    (%eax,%ecx,4),%eax
    a9f4:	6b c9 fc             	imul   $0xfffffffc,%ecx,%ecx
    a9f7:	01 ca                	add    %ecx,%edx
    a9f9:	01 c2                	add    %eax,%edx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    a9fb:	39 d0                	cmp    %edx,%eax
    a9fd:	74 09                	je     aa08 <memset+0x68>
		*(d_byte++) = c_byte;
    a9ff:	40                   	inc    %eax
    aa00:	8a 5d f3             	mov    -0xd(%ebp),%bl
    aa03:	88 58 ff             	mov    %bl,-0x1(%eax)
		n--;
    aa06:	eb f3                	jmp    a9fb <memset+0x5b>
	}

	return buf;
}
    aa08:	8b 45 08             	mov    0x8(%ebp),%eax
    aa0b:	5a                   	pop    %edx
    aa0c:	5b                   	pop    %ebx
    aa0d:	5e                   	pop    %esi
    aa0e:	5f                   	pop    %edi
    aa0f:	5d                   	pop    %ebp
    aa10:	c3                   	ret    

0000aa11 <_to_x>:
/* Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes), padding with leading zeros up to the minimum length.
 */
static int _to_x(char *buf, uint32_t n, int base, int minlen)
{
    aa11:	55                   	push   %ebp
    aa12:	89 e5                	mov    %esp,%ebp
    aa14:	57                   	push   %edi
    aa15:	56                   	push   %esi
    aa16:	89 d7                	mov    %edx,%edi
    aa18:	53                   	push   %ebx
    aa19:	89 c6                	mov    %eax,%esi
    aa1b:	53                   	push   %ebx
    aa1c:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	do {
		int d = n % base;
    aa1e:	31 d2                	xor    %edx,%edx
    aa20:	89 f8                	mov    %edi,%eax
    aa22:	f7 f1                	div    %ecx

		n /= base;
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    aa24:	83 fa 0a             	cmp    $0xa,%edx
    aa27:	89 45 f0             	mov    %eax,-0x10(%ebp)
    aa2a:	19 c0                	sbb    %eax,%eax
    aa2c:	43                   	inc    %ebx
    aa2d:	f7 d0                	not    %eax
    aa2f:	83 e0 27             	and    $0x27,%eax
	} while (n);
    aa32:	39 f9                	cmp    %edi,%ecx
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    aa34:	8d 54 10 30          	lea    0x30(%eax,%edx,1),%edx
    aa38:	88 53 ff             	mov    %dl,-0x1(%ebx)
	} while (n);
    aa3b:	77 05                	ja     aa42 <_to_x+0x31>
		n /= base;
    aa3d:	8b 7d f0             	mov    -0x10(%ebp),%edi
    aa40:	eb dc                	jmp    aa1e <_to_x+0xd>
	while (end - start < minlen) {
    aa42:	89 d8                	mov    %ebx,%eax
    aa44:	29 f0                	sub    %esi,%eax
    aa46:	39 45 08             	cmp    %eax,0x8(%ebp)
    aa49:	7e 07                	jle    aa52 <_to_x+0x41>
		*end++ = '0';
    aa4b:	43                   	inc    %ebx
    aa4c:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
    aa50:	eb f0                	jmp    aa42 <_to_x+0x31>
	*end = 0;
    aa52:	c6 03 00             	movb   $0x0,(%ebx)
	for (end--; end > start; end--, start++) {
    aa55:	4b                   	dec    %ebx
    aa56:	39 f3                	cmp    %esi,%ebx
    aa58:	76 0d                	jbe    aa67 <_to_x+0x56>
		char tmp = *end;
    aa5a:	8a 0b                	mov    (%ebx),%cl
		*end = *start;
    aa5c:	8a 16                	mov    (%esi),%dl
    aa5e:	88 13                	mov    %dl,(%ebx)
	for (end--; end > start; end--, start++) {
    aa60:	46                   	inc    %esi
		*start = tmp;
    aa61:	88 4e ff             	mov    %cl,-0x1(%esi)
	for (end--; end > start; end--, start++) {
    aa64:	4b                   	dec    %ebx
    aa65:	eb ef                	jmp    aa56 <_to_x+0x45>
	return _reverse_and_pad(buf0, buf, minlen);
}
    aa67:	5a                   	pop    %edx
    aa68:	5b                   	pop    %ebx
    aa69:	5e                   	pop    %esi
    aa6a:	5f                   	pop    %edi
    aa6b:	5d                   	pop    %ebp
    aa6c:	c3                   	ret    

0000aa6d <_rlrshift>:

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
}

static	void _rlrshift(uint64_t *v)
{
    aa6d:	55                   	push   %ebp
	*v = (*v & 1) + (*v >> 1);
    aa6e:	8b 10                	mov    (%eax),%edx
{
    aa70:	89 e5                	mov    %esp,%ebp
    aa72:	57                   	push   %edi
    aa73:	56                   	push   %esi
	*v = (*v & 1) + (*v >> 1);
    aa74:	8b 48 04             	mov    0x4(%eax),%ecx
{
    aa77:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
    aa78:	89 d3                	mov    %edx,%ebx
    aa7a:	83 e3 01             	and    $0x1,%ebx
    aa7d:	31 ff                	xor    %edi,%edi
    aa7f:	89 de                	mov    %ebx,%esi
    aa81:	89 cb                	mov    %ecx,%ebx
    aa83:	89 d1                	mov    %edx,%ecx
    aa85:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
    aa89:	d1 eb                	shr    %ebx
    aa8b:	01 f1                	add    %esi,%ecx
    aa8d:	11 fb                	adc    %edi,%ebx
    aa8f:	89 08                	mov    %ecx,(%eax)
    aa91:	89 58 04             	mov    %ebx,0x4(%eax)
}
    aa94:	5b                   	pop    %ebx
    aa95:	5e                   	pop    %esi
    aa96:	5f                   	pop    %edi
    aa97:	5d                   	pop    %ebp
    aa98:	c3                   	ret    

0000aa99 <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
    aa99:	55                   	push   %ebp
	 */
	rem += 2;

	for (i = 0U; i < 3; i++) {
		hi = rem >> shifts[i];
		q = (uint64_t)(hi / 5) << shifts[i];
    aa9a:	b9 05 00 00 00       	mov    $0x5,%ecx
{
    aa9f:	89 e5                	mov    %esp,%ebp
    aaa1:	57                   	push   %edi
    aaa2:	56                   	push   %esi
    aaa3:	53                   	push   %ebx
    aaa4:	89 c3                	mov    %eax,%ebx
    aaa6:	83 ec 14             	sub    $0x14,%esp
	rem += 2;
    aaa9:	8b 30                	mov    (%eax),%esi
    aaab:	8b 78 04             	mov    0x4(%eax),%edi
    aaae:	83 c6 02             	add    $0x2,%esi
    aab1:	83 d7 00             	adc    $0x0,%edi
		q = (uint64_t)(hi / 5) << shifts[i];
    aab4:	31 d2                	xor    %edx,%edx
		hi = rem >> shifts[i];
    aab6:	89 f8                	mov    %edi,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
    aab8:	f7 f1                	div    %ecx
    aaba:	89 c2                	mov    %eax,%edx
    aabc:	b8 00 00 00 00       	mov    $0x0,%eax
    aac1:	89 55 f0             	mov    %edx,-0x10(%ebp)
    aac4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		rem -= q * 5;
    aac7:	6b 45 f0 05          	imul   $0x5,-0x10(%ebp),%eax
    aacb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    aace:	8b 45 ec             	mov    -0x14(%ebp),%eax
    aad1:	f7 e1                	mul    %ecx
    aad3:	03 55 e4             	add    -0x1c(%ebp),%edx
    aad6:	29 c6                	sub    %eax,%esi
    aad8:	19 d7                	sbb    %edx,%edi
		hi = rem >> shifts[i];
    aada:	89 f0                	mov    %esi,%eax
    aadc:	89 fa                	mov    %edi,%edx
    aade:	0f ac d0 03          	shrd   $0x3,%edx,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
    aae2:	31 d2                	xor    %edx,%edx
    aae4:	f7 f1                	div    %ecx
    aae6:	31 d2                	xor    %edx,%edx
    aae8:	0f a4 c2 03          	shld   $0x3,%eax,%edx
    aaec:	c1 e0 03             	shl    $0x3,%eax
    aaef:	89 55 e8             	mov    %edx,-0x18(%ebp)
    aaf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		quot += q;
    aaf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    aaf8:	03 45 e4             	add    -0x1c(%ebp),%eax
    aafb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    aafe:	13 55 e8             	adc    -0x18(%ebp),%edx
    ab01:	89 45 ec             	mov    %eax,-0x14(%ebp)
		rem -= q * 5;
    ab04:	6b 45 e8 05          	imul   $0x5,-0x18(%ebp),%eax
    ab08:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ab0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		quot += q;
    ab0e:	89 55 f0             	mov    %edx,-0x10(%ebp)
		rem -= q * 5;
    ab11:	f7 e1                	mul    %ecx
    ab13:	29 c6                	sub    %eax,%esi
		q = (uint64_t)(hi / 5) << shifts[i];
    ab15:	31 d2                	xor    %edx,%edx
		rem -= q * 5;
    ab17:	89 f0                	mov    %esi,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
    ab19:	f7 f1                	div    %ecx
    ab1b:	31 d2                	xor    %edx,%edx
		quot += q;
    ab1d:	03 45 ec             	add    -0x14(%ebp),%eax
    ab20:	13 55 f0             	adc    -0x10(%ebp),%edx
    ab23:	89 03                	mov    %eax,(%ebx)
    ab25:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	*v = quot;
}
    ab28:	83 c4 14             	add    $0x14,%esp
    ab2b:	5b                   	pop    %ebx
    ab2c:	5e                   	pop    %esi
    ab2d:	5f                   	pop    %edi
    ab2e:	5d                   	pop    %ebp
    ab2f:	c3                   	ret    

0000ab30 <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
    ab30:	55                   	push   %ebp
    ab31:	89 e5                	mov    %esp,%ebp
    ab33:	57                   	push   %edi
    ab34:	56                   	push   %esi
    ab35:	89 c6                	mov    %eax,%esi
    ab37:	53                   	push   %ebx
	int		rval;

	if (*digit_count > 0) {
    ab38:	8b 02                	mov    (%edx),%eax
    ab3a:	85 c0                	test   %eax,%eax
    ab3c:	7e 2d                	jle    ab6b <_get_digit+0x3b>
		*digit_count -= 1;
    ab3e:	48                   	dec    %eax
		*fr = *fr * 10;
    ab3f:	bb 0a 00 00 00       	mov    $0xa,%ebx
		*digit_count -= 1;
    ab44:	89 02                	mov    %eax,(%edx)
		*fr = *fr * 10;
    ab46:	89 d8                	mov    %ebx,%eax
    ab48:	f7 26                	mull   (%esi)
    ab4a:	6b 7e 04 0a          	imul   $0xa,0x4(%esi),%edi
    ab4e:	89 d3                	mov    %edx,%ebx
    ab50:	89 c1                	mov    %eax,%ecx
    ab52:	01 fb                	add    %edi,%ebx
		rval = ((*fr >> 60) & 0xF) + '0';
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    ab54:	89 0e                	mov    %ecx,(%esi)
		rval = ((*fr >> 60) & 0xF) + '0';
    ab56:	89 d8                	mov    %ebx,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    ab58:	89 da                	mov    %ebx,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
    ab5a:	c1 e8 1c             	shr    $0x1c,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    ab5d:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
    ab63:	83 c0 30             	add    $0x30,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    ab66:	89 56 04             	mov    %edx,0x4(%esi)
    ab69:	eb 05                	jmp    ab70 <_get_digit+0x40>
	} else {
		rval = '0';
    ab6b:	b8 30 00 00 00       	mov    $0x30,%eax
	}

	return (char) (rval);
}
    ab70:	5b                   	pop    %ebx
    ab71:	5e                   	pop    %esi
    ab72:	5f                   	pop    %edi
    ab73:	5d                   	pop    %ebp
    ab74:	c3                   	ret    

0000ab75 <_prf>:
	*sptr = p;
	return i;
}

int _prf(int (*func)(), void *dest, char *format, va_list vargs)
{
    ab75:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    ab79:	83 e4 f8             	and    $0xfffffff8,%esp
    ab7c:	ff 71 fc             	pushl  -0x4(%ecx)
    ab7f:	55                   	push   %ebp
    ab80:	89 e5                	mov    %esp,%ebp
    ab82:	57                   	push   %edi
    ab83:	56                   	push   %esi
    ab84:	53                   	push   %ebx
    ab85:	51                   	push   %ecx
    ab86:	81 ec 20 01 00 00    	sub    $0x120,%esp
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;
    ab8c:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
    ab93:	00 00 00 
{
    ab96:	8b 01                	mov    (%ecx),%eax
    ab98:	8b 59 0c             	mov    0xc(%ecx),%ebx
    ab9b:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
    aba1:	8b 41 04             	mov    0x4(%ecx),%eax
    aba4:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
    abaa:	8b 41 08             	mov    0x8(%ecx),%eax
    abad:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)

	while ((c = *format++)) {
    abb3:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    abb9:	8d 78 01             	lea    0x1(%eax),%edi
    abbc:	0f be 00             	movsbl (%eax),%eax
    abbf:	85 c0                	test   %eax,%eax
    abc1:	0f 84 7c 0b 00 00    	je     b743 <_binary_mmu_tables_bin_size+0x743>
		if (c != '%') {
    abc7:	83 f8 25             	cmp    $0x25,%eax
    abca:	74 31                	je     abfd <_prf+0x88>
			if ((*func) (c, dest) == EOF) {
    abcc:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    abd2:	50                   	push   %eax
    abd3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    abd9:	ff d0                	call   *%eax
    abdb:	5e                   	pop    %esi
    abdc:	5a                   	pop    %edx
    abdd:	40                   	inc    %eax
    abde:	75 0f                	jne    abef <_prf+0x7a>
				return EOF;
    abe0:	c7 85 e8 fe ff ff ff 	movl   $0xffffffff,-0x118(%ebp)
    abe7:	ff ff ff 
    abea:	e9 54 0b 00 00       	jmp    b743 <_binary_mmu_tables_bin_size+0x743>
			}

			count++;
    abef:	ff 85 e8 fe ff ff    	incl   -0x118(%ebp)
	while ((c = *format++)) {
    abf5:	89 bd 04 ff ff ff    	mov    %edi,-0xfc(%ebp)
    abfb:	eb b6                	jmp    abb3 <_prf+0x3e>

		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
    abfd:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)
			fminus = fplus = fspace = falt = false;
    ac04:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
    ac0b:	00 00 00 
    ac0e:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
    ac15:	00 00 00 
    ac18:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
    ac1f:	00 00 00 
    ac22:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
    ac29:	00 00 00 
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
    ac2c:	0f be 37             	movsbl (%edi),%esi
    ac2f:	8d 47 01             	lea    0x1(%edi),%eax
    ac32:	56                   	push   %esi
    ac33:	89 f2                	mov    %esi,%edx
    ac35:	68 cf 78 02 00       	push   $0x278cf
    ac3a:	88 95 0c ff ff ff    	mov    %dl,-0xf4(%ebp)
    ac40:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    ac46:	e8 de fb ff ff       	call   a829 <strchr>
    ac4b:	5a                   	pop    %edx
    ac4c:	59                   	pop    %ecx
    ac4d:	85 c0                	test   %eax,%eax
    ac4f:	8a 95 0c ff ff ff    	mov    -0xf4(%ebp),%dl
    ac55:	74 65                	je     acbc <_prf+0x147>
				switch (c) {
    ac57:	80 fa 23             	cmp    $0x23,%dl
    ac5a:	74 36                	je     ac92 <_prf+0x11d>
    ac5c:	7f 19                	jg     ac77 <_prf+0x102>
    ac5e:	84 d2                	test   %dl,%dl
    ac60:	0f 84 dd 0a 00 00    	je     b743 <_binary_mmu_tables_bin_size+0x743>
    ac66:	80 fa 20             	cmp    $0x20,%dl
    ac69:	75 46                	jne    acb1 <_prf+0x13c>
				case '+':
					fplus = true;
					break;

				case ' ':
					fspace = true;
    ac6b:	c7 85 e4 fe ff ff 01 	movl   $0x1,-0x11c(%ebp)
    ac72:	00 00 00 
    ac75:	eb 3a                	jmp    acb1 <_prf+0x13c>
				switch (c) {
    ac77:	80 fa 2d             	cmp    $0x2d,%dl
    ac7a:	74 22                	je     ac9e <_prf+0x129>
    ac7c:	80 fa 30             	cmp    $0x30,%dl
    ac7f:	74 29                	je     acaa <_prf+0x135>
    ac81:	80 fa 2b             	cmp    $0x2b,%dl
    ac84:	75 2b                	jne    acb1 <_prf+0x13c>
					fplus = true;
    ac86:	c7 85 e0 fe ff ff 01 	movl   $0x1,-0x120(%ebp)
    ac8d:	00 00 00 
    ac90:	eb 1f                	jmp    acb1 <_prf+0x13c>
					break;

				case '#':
					falt = true;
    ac92:	c7 85 08 ff ff ff 01 	movl   $0x1,-0xf8(%ebp)
    ac99:	00 00 00 
    ac9c:	eb 13                	jmp    acb1 <_prf+0x13c>
					fminus = true;
    ac9e:	c7 85 dc fe ff ff 01 	movl   $0x1,-0x124(%ebp)
    aca5:	00 00 00 
    aca8:	eb 07                	jmp    acb1 <_prf+0x13c>
					break;

				case '0':
					pad = '0';
    acaa:	c6 85 f7 fe ff ff 30 	movb   $0x30,-0x109(%ebp)
					fminus = true;
    acb1:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
    acb7:	e9 70 ff ff ff       	jmp    ac2c <_prf+0xb7>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
    acbc:	83 fe 2a             	cmp    $0x2a,%esi
    acbf:	75 30                	jne    acf1 <_prf+0x17c>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
    acc1:	8b 0b                	mov    (%ebx),%ecx
    acc3:	8d 43 04             	lea    0x4(%ebx),%eax
    acc6:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%ebp)
				if (width < 0) {
    accc:	85 c9                	test   %ecx,%ecx
    acce:	79 10                	jns    ace0 <_prf+0x16b>
					fminus = true;
					width = -width;
    acd0:	f7 9d fc fe ff ff    	negl   -0x104(%ebp)
					fminus = true;
    acd6:	c7 85 dc fe ff ff 01 	movl   $0x1,-0x124(%ebp)
    acdd:	00 00 00 
				width = (int32_t) va_arg(vargs, int32_t);
    ace0:	89 c3                	mov    %eax,%ebx
				}
				c = *format++;
    ace2:	8d 47 02             	lea    0x2(%edi),%eax
    ace5:	0f be 77 01          	movsbl 0x1(%edi),%esi
    ace9:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    acef:	eb 3f                	jmp    ad30 <_prf+0x1bb>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    acf1:	8d 46 d0             	lea    -0x30(%esi),%eax
			} else if (!isdigit(c)) {
				width = 0;
    acf4:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
    acfb:	00 00 00 
			} else if (!isdigit(c)) {
    acfe:	83 f8 09             	cmp    $0x9,%eax
    ad01:	77 43                	ja     ad46 <_prf+0x1d1>
	while (isdigit(((int) *p))) {
    ad03:	0f be 37             	movsbl (%edi),%esi
    ad06:	8d 47 01             	lea    0x1(%edi),%eax
    ad09:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    ad0f:	8d 46 d0             	lea    -0x30(%esi),%eax
    ad12:	83 f8 09             	cmp    $0x9,%eax
    ad15:	77 19                	ja     ad30 <_prf+0x1bb>
		i = 10 * i + *p++ - '0';
    ad17:	6b 85 fc fe ff ff 0a 	imul   $0xa,-0x104(%ebp),%eax
    ad1e:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
    ad24:	8d 44 06 d0          	lea    -0x30(%esi,%eax,1),%eax
    ad28:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
    ad2e:	eb d3                	jmp    ad03 <_prf+0x18e>
			 * If <width> is INT_MIN, then its absolute value can
			 * not be expressed as a positive number using 32-bit
			 * two's complement.  To cover that case, cast it to
			 * an unsigned before comparing it against MAXFLD.
			 */
			if ((unsigned) width > MAXFLD) {
    ad30:	81 bd fc fe ff ff c8 	cmpl   $0xc8,-0x104(%ebp)
    ad37:	00 00 00 
    ad3a:	76 0a                	jbe    ad46 <_prf+0x1d1>
				width = MAXFLD;
    ad3c:	c7 85 fc fe ff ff c8 	movl   $0xc8,-0x104(%ebp)
    ad43:	00 00 00 
			precision = -1;	/* No precision specified   */
    ad46:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
    ad4d:	ff ff ff 
			}

			if (c == '.') {
    ad50:	83 fe 2e             	cmp    $0x2e,%esi
    ad53:	0f 85 80 00 00 00    	jne    add9 <_prf+0x264>
				c = *format++;
				if (c == '*') {
    ad59:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    ad5f:	80 38 2a             	cmpb   $0x2a,(%eax)
    ad62:	75 13                	jne    ad77 <_prf+0x202>
					precision = (int32_t)
    ad64:	8b 03                	mov    (%ebx),%eax
				c = *format++;
    ad66:	ff 85 04 ff ff ff    	incl   -0xfc(%ebp)
					precision = (int32_t)
    ad6c:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
    ad72:	83 c3 04             	add    $0x4,%ebx
    ad75:	eb 3b                	jmp    adb2 <_prf+0x23d>
	i = 0;
    ad77:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
    ad7e:	00 00 00 
	while (isdigit(((int) *p))) {
    ad81:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    ad87:	8b 8d 04 ff ff ff    	mov    -0xfc(%ebp),%ecx
    ad8d:	41                   	inc    %ecx
    ad8e:	0f be 00             	movsbl (%eax),%eax
    ad91:	8d 50 d0             	lea    -0x30(%eax),%edx
    ad94:	83 fa 09             	cmp    $0x9,%edx
    ad97:	77 19                	ja     adb2 <_prf+0x23d>
		i = 10 * i + *p++ - '0';
    ad99:	6b 95 0c ff ff ff 0a 	imul   $0xa,-0xf4(%ebp),%edx
    ada0:	89 8d 04 ff ff ff    	mov    %ecx,-0xfc(%ebp)
    ada6:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
    adaa:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
    adb0:	eb cf                	jmp    ad81 <_prf+0x20c>
					va_arg(vargs, int32_t);
				} else {
					precision = _atoi(&format);
				}

				if (precision > MAXFLD) {
    adb2:	81 bd 0c ff ff ff c8 	cmpl   $0xc8,-0xf4(%ebp)
    adb9:	00 00 00 
    adbc:	7e 0a                	jle    adc8 <_prf+0x253>
					precision = -1;
    adbe:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
    adc5:	ff ff ff 
				}

				c = *format++;
    adc8:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    adce:	40                   	inc    %eax
    adcf:	0f be 70 ff          	movsbl -0x1(%eax),%esi
    add3:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
			 *    L: long double
			 *    z: size_t or ssize_t
			 * No further special processing is done for them.
			 */

			if (strchr("hlLz", c) != NULL) {
    add9:	56                   	push   %esi
    adda:	68 d5 78 02 00       	push   $0x278d5
    addf:	e8 45 fa ff ff       	call   a829 <strchr>
    ade4:	5a                   	pop    %edx
    ade5:	85 c0                	test   %eax,%eax
    ade7:	59                   	pop    %ecx
    ade8:	74 11                	je     adfb <_prf+0x286>
				i = c;
				c = *format++;
    adea:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    adf0:	40                   	inc    %eax
    adf1:	0f be 70 ff          	movsbl -0x1(%eax),%esi
    adf5:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
				 */
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
    adfb:	83 fe 67             	cmp    $0x67,%esi
    adfe:	0f 8f 3d 08 00 00    	jg     b641 <_binary_mmu_tables_bin_size+0x641>
    ae04:	83 fe 65             	cmp    $0x65,%esi
    ae07:	0f 8c 61 06 00 00    	jl     b46e <_binary_mmu_tables_bin_size+0x46e>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
    ae0d:	8d 43 08             	lea    0x8(%ebx),%eax
    ae10:	8b 53 04             	mov    0x4(%ebx),%edx
    ae13:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
    ae19:	8b 03                	mov    (%ebx),%eax
	exp = double_temp >> 52 & 0x7ff;
    ae1b:	89 d3                	mov    %edx,%ebx
	fract = (double_temp << 11) & ~HIGHBIT64;
    ae1d:	89 c1                	mov    %eax,%ecx
	exp = double_temp >> 52 & 0x7ff;
    ae1f:	c1 eb 14             	shr    $0x14,%ebx
	sign = !!(double_temp & HIGHBIT64);
    ae22:	89 d0                	mov    %edx,%eax
	exp = double_temp >> 52 & 0x7ff;
    ae24:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
    ae2a:	89 9d 00 ff ff ff    	mov    %ebx,-0x100(%ebp)
	fract = (double_temp << 11) & ~HIGHBIT64;
    ae30:	89 d3                	mov    %edx,%ebx
    ae32:	0f a4 cb 0b          	shld   $0xb,%ecx,%ebx
    ae36:	c1 e1 0b             	shl    $0xb,%ecx
    ae39:	89 9d f0 fe ff ff    	mov    %ebx,-0x110(%ebp)
    ae3f:	89 8d ec fe ff ff    	mov    %ecx,-0x114(%ebp)
    ae45:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
    ae4b:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
    ae51:	8b 8d ec fe ff ff    	mov    -0x114(%ebp),%ecx
    ae57:	89 8d 14 ff ff ff    	mov    %ecx,-0xec(%ebp)
    ae5d:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
	if (exp == 0x7ff) {
    ae63:	81 bd 00 ff ff ff ff 	cmpl   $0x7ff,-0x100(%ebp)
    ae6a:	07 00 00 
    ae6d:	75 66                	jne    aed5 <_prf+0x360>
		if (sign) {
    ae6f:	8d 95 27 ff ff ff    	lea    -0xd9(%ebp),%edx
    ae75:	85 c0                	test   %eax,%eax
    ae77:	79 0d                	jns    ae86 <_prf+0x311>
			*buf++ = '-';
    ae79:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
    ae80:	8d 95 28 ff ff ff    	lea    -0xd8(%ebp),%edx
		if (!fract) {
    ae86:	8d 5e bf             	lea    -0x41(%esi),%ebx
    ae89:	8d 42 03             	lea    0x3(%edx),%eax
    ae8c:	09 cf                	or     %ecx,%edi
    ae8e:	75 1b                	jne    aeab <_prf+0x336>
			if (isupper(c)) {
    ae90:	83 fb 19             	cmp    $0x19,%ebx
    ae93:	77 0b                	ja     aea0 <_prf+0x32b>
				*buf++ = 'I';
    ae95:	66 c7 02 49 4e       	movw   $0x4e49,(%edx)
				*buf++ = 'F';
    ae9a:	c6 42 02 46          	movb   $0x46,0x2(%edx)
    ae9e:	eb 24                	jmp    aec4 <_prf+0x34f>
				*buf++ = 'i';
    aea0:	66 c7 02 69 6e       	movw   $0x6e69,(%edx)
				*buf++ = 'f';
    aea5:	c6 42 02 66          	movb   $0x66,0x2(%edx)
    aea9:	eb 19                	jmp    aec4 <_prf+0x34f>
			if (isupper(c)) {
    aeab:	83 fb 19             	cmp    $0x19,%ebx
    aeae:	77 0b                	ja     aebb <_prf+0x346>
				*buf++ = 'N';
    aeb0:	66 c7 02 4e 41       	movw   $0x414e,(%edx)
				*buf++ = 'N';
    aeb5:	c6 42 02 4e          	movb   $0x4e,0x2(%edx)
    aeb9:	eb 09                	jmp    aec4 <_prf+0x34f>
				*buf++ = 'n';
    aebb:	66 c7 02 6e 61       	movw   $0x616e,(%edx)
				*buf++ = 'n';
    aec0:	c6 42 02 6e          	movb   $0x6e,0x2(%edx)
		*buf = 0;
    aec4:	c6 42 03 00          	movb   $0x0,0x3(%edx)
		return buf - start;
    aec8:	8d 95 27 ff ff ff    	lea    -0xd9(%ebp),%edx
    aece:	29 d0                	sub    %edx,%eax
    aed0:	e9 19 04 00 00       	jmp    b2ee <_binary_mmu_tables_bin_size+0x2ee>
	if (c == 'F') {
    aed5:	83 fe 46             	cmp    $0x46,%esi
    aed8:	75 05                	jne    aedf <_prf+0x36a>
		c = 'f';
    aeda:	be 66 00 00 00       	mov    $0x66,%esi
	if ((exp | fract) != 0) {
    aedf:	8b 95 00 ff ff ff    	mov    -0x100(%ebp),%edx
    aee5:	09 ca                	or     %ecx,%edx
    aee7:	09 fa                	or     %edi,%edx
    aee9:	74 31                	je     af1c <_prf+0x3a7>
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    aeeb:	8b 95 00 ff ff ff    	mov    -0x100(%ebp),%edx
		fract |= HIGHBIT64;
    aef1:	81 cf 00 00 00 80    	or     $0x80000000,%edi
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    aef7:	81 ea fe 03 00 00    	sub    $0x3fe,%edx
		fract |= HIGHBIT64;
    aefd:	89 8d 14 ff ff ff    	mov    %ecx,-0xec(%ebp)
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    af03:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
		fract |= HIGHBIT64;
    af09:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
	if (decexp && sign) {
    af0f:	85 c0                	test   %eax,%eax
    af11:	79 13                	jns    af26 <_prf+0x3b1>
		*buf++ = '-';
    af13:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
    af1a:	eb 32                	jmp    af4e <_prf+0x3d9>
	if ((exp | fract) != 0) {
    af1c:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
    af23:	00 00 00 
	} else if (fplus) {
    af26:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
    af2d:	74 09                	je     af38 <_prf+0x3c3>
		*buf++ = '+';
    af2f:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
    af36:	eb 16                	jmp    af4e <_prf+0x3d9>
	} else if (fspace) {
    af38:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
    af3e:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
    af45:	74 0d                	je     af54 <_prf+0x3df>
		*buf++ = ' ';
    af47:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
    af4e:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
	decexp = 0;
    af54:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
    af5b:	00 00 00 
	while (exp <= -3) {
    af5e:	83 bd ec fe ff ff fe 	cmpl   $0xfffffffe,-0x114(%ebp)
    af65:	0f 8d 80 00 00 00    	jge    afeb <_prf+0x476>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    af6b:	8b 8d 18 ff ff ff    	mov    -0xe8(%ebp),%ecx
    af71:	ff 85 ec fe ff ff    	incl   -0x114(%ebp)
    af77:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
    af7d:	81 f9 32 33 33 33    	cmp    $0x33333332,%ecx
    af83:	76 0d                	jbe    af92 <_prf+0x41d>
			_rlrshift(&fract);
    af85:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    af8b:	e8 dd fa ff ff       	call   aa6d <_rlrshift>
			exp++;
    af90:	eb d9                	jmp    af6b <_prf+0x3f6>
		fract *= 5;
    af92:	ba 05 00 00 00       	mov    $0x5,%edx
    af97:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
    af9a:	f7 e2                	mul    %edx
		decexp--;
    af9c:	ff 8d 00 ff ff ff    	decl   -0x100(%ebp)
		fract *= 5;
    afa2:	01 ca                	add    %ecx,%edx
    afa4:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    afaa:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
		decexp--;
    afb0:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    afb2:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
    afb7:	39 d7                	cmp    %edx,%edi
    afb9:	72 0e                	jb     afc9 <_prf+0x454>
			fract <<= 1;
    afbb:	01 c0                	add    %eax,%eax
    afbd:	b1 01                	mov    $0x1,%cl
    afbf:	11 d2                	adc    %edx,%edx
			exp--;
    afc1:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
    afc7:	eb ee                	jmp    afb7 <_prf+0x442>
    afc9:	84 c9                	test   %cl,%cl
    afcb:	74 91                	je     af5e <_prf+0x3e9>
    afcd:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    afd3:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
    afd9:	eb 83                	jmp    af5e <_prf+0x3e9>
    afdb:	84 c9                	test   %cl,%cl
    afdd:	74 0c                	je     afeb <_prf+0x476>
    afdf:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    afe5:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	while (exp > 0) {
    afeb:	83 bd ec fe ff ff 00 	cmpl   $0x0,-0x114(%ebp)
    aff2:	7e 3c                	jle    b030 <_binary_mmu_tables_bin_size+0x30>
		_ldiv5(&fract);
    aff4:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    affa:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
		_ldiv5(&fract);
    afff:	e8 95 fa ff ff       	call   aa99 <_ldiv5>
		exp--;
    b004:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
		decexp++;
    b00a:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
    b010:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
    b016:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
    b01c:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    b01e:	39 d7                	cmp    %edx,%edi
    b020:	72 b9                	jb     afdb <_prf+0x466>
			fract <<= 1;
    b022:	01 c0                	add    %eax,%eax
    b024:	b1 01                	mov    $0x1,%cl
    b026:	11 d2                	adc    %edx,%edx
			exp--;
    b028:	ff 8d ec fe ff ff    	decl   -0x114(%ebp)
    b02e:	eb ee                	jmp    b01e <_binary_mmu_tables_bin_size+0x1e>
		_rlrshift(&fract);
    b030:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b036:	e8 32 fa ff ff       	call   aa6d <_rlrshift>
		exp++;
    b03b:	ff 85 ec fe ff ff    	incl   -0x114(%ebp)
	while (exp < (0 + 4)) {
    b041:	83 bd ec fe ff ff 04 	cmpl   $0x4,-0x114(%ebp)
    b048:	75 e6                	jne    b030 <_binary_mmu_tables_bin_size+0x30>
	if (precision < 0)
    b04a:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    b051:	79 0a                	jns    b05d <_binary_mmu_tables_bin_size+0x5d>
		precision = 6;		/* Default precision if none given */
    b053:	c7 85 0c ff ff ff 06 	movl   $0x6,-0xf4(%ebp)
    b05a:	00 00 00 
	if ((c == 'g') || (c == 'G')) {
    b05d:	89 f0                	mov    %esi,%eax
    b05f:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    b066:	0f 9f 85 ec fe ff ff 	setg   -0x114(%ebp)
    b06d:	83 e0 df             	and    $0xffffffdf,%eax
    b070:	83 f8 47             	cmp    $0x47,%eax
    b073:	75 3c                	jne    b0b1 <_binary_mmu_tables_bin_size+0xb1>
		if (!falt && (precision > 0)) {
    b075:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
    b07b:	83 f0 01             	xor    $0x1,%eax
    b07e:	23 85 ec fe ff ff    	and    -0x114(%ebp),%eax
	prune_zero = false;		/* Assume trailing 0's allowed     */
    b084:	0f b6 c0             	movzbl %al,%eax
    b087:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
    b08d:	83 bd 00 ff ff ff fd 	cmpl   $0xfffffffd,-0x100(%ebp)
    b094:	7c 0f                	jl     b0a5 <_binary_mmu_tables_bin_size+0xa5>
    b096:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    b09c:	40                   	inc    %eax
    b09d:	39 85 00 ff ff ff    	cmp    %eax,-0x100(%ebp)
    b0a3:	7e 1b                	jle    b0c0 <_binary_mmu_tables_bin_size+0xc0>
			if (c == 'g') {
    b0a5:	83 fe 67             	cmp    $0x67,%esi
    b0a8:	75 37                	jne    b0e1 <_binary_mmu_tables_bin_size+0xe1>
				c = 'e';
    b0aa:	be 65 00 00 00       	mov    $0x65,%esi
    b0af:	eb 35                	jmp    b0e6 <_binary_mmu_tables_bin_size+0xe6>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    b0b1:	c7 85 d0 fe ff ff 00 	movl   $0x0,-0x130(%ebp)
    b0b8:	00 00 00 
	if (c == 'f') {
    b0bb:	83 fe 66             	cmp    $0x66,%esi
    b0be:	75 26                	jne    b0e6 <_binary_mmu_tables_bin_size+0xe6>
		if (exp < 0) {
    b0c0:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
    b0c6:	be 66 00 00 00       	mov    $0x66,%esi
    b0cb:	03 bd 0c ff ff ff    	add    -0xf4(%ebp),%edi
    b0d1:	79 1c                	jns    b0ef <_binary_mmu_tables_bin_size+0xef>
	digit_count = 16;
    b0d3:	c7 85 10 ff ff ff 10 	movl   $0x10,-0xf0(%ebp)
    b0da:	00 00 00 
			exp = 0;
    b0dd:	31 ff                	xor    %edi,%edi
    b0df:	eb 22                	jmp    b103 <_binary_mmu_tables_bin_size+0x103>
				c = 'E';
    b0e1:	be 45 00 00 00       	mov    $0x45,%esi
		exp = precision + 1;
    b0e6:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    b0ec:	8d 78 01             	lea    0x1(%eax),%edi
	digit_count = 16;
    b0ef:	c7 85 10 ff ff ff 10 	movl   $0x10,-0xf0(%ebp)
    b0f6:	00 00 00 
	if (exp > 16) {
    b0f9:	83 ff 10             	cmp    $0x10,%edi
    b0fc:	7e 05                	jle    b103 <_binary_mmu_tables_bin_size+0x103>
    b0fe:	bf 10 00 00 00       	mov    $0x10,%edi
	ltemp = 0x0800000000000000;
    b103:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
    b10a:	00 00 00 
    b10d:	c7 85 20 ff ff ff 00 	movl   $0x8000000,-0xe0(%ebp)
    b114:	00 00 08 
	while (exp--) {
    b117:	4f                   	dec    %edi
    b118:	83 ff ff             	cmp    $0xffffffff,%edi
    b11b:	74 18                	je     b135 <_binary_mmu_tables_bin_size+0x135>
		_ldiv5(&ltemp);
    b11d:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
    b123:	e8 71 f9 ff ff       	call   aa99 <_ldiv5>
		_rlrshift(&ltemp);
    b128:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
    b12e:	e8 3a f9 ff ff       	call   aa6d <_rlrshift>
    b133:	eb e2                	jmp    b117 <_binary_mmu_tables_bin_size+0x117>
	fract += ltemp;
    b135:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
    b13b:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
    b141:	03 85 14 ff ff ff    	add    -0xec(%ebp),%eax
    b147:	13 95 18 ff ff ff    	adc    -0xe8(%ebp),%edx
    b14d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
	if ((fract >> 32) & 0xF0000000) {
    b153:	89 d0                	mov    %edx,%eax
	fract += ltemp;
    b155:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	if ((fract >> 32) & 0xF0000000) {
    b15b:	a9 00 00 00 f0       	test   $0xf0000000,%eax
    b160:	74 1c                	je     b17e <_binary_mmu_tables_bin_size+0x17e>
		_ldiv5(&fract);
    b162:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b168:	e8 2c f9 ff ff       	call   aa99 <_ldiv5>
		_rlrshift(&fract);
    b16d:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b173:	e8 f5 f8 ff ff       	call   aa6d <_rlrshift>
		decexp++;
    b178:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
	if (c == 'f') {
    b17e:	8d 7b 01             	lea    0x1(%ebx),%edi
    b181:	83 fe 66             	cmp    $0x66,%esi
    b184:	0f 85 97 00 00 00    	jne    b221 <_binary_mmu_tables_bin_size+0x221>
		if (decexp > 0) {
    b18a:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    b191:	7e 2d                	jle    b1c0 <_binary_mmu_tables_bin_size+0x1c0>
    b193:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
    b199:	01 df                	add    %ebx,%edi
				*buf++ = _get_digit(&fract, &digit_count);
    b19b:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    b1a1:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b1a7:	e8 84 f9 ff ff       	call   ab30 <_get_digit>
    b1ac:	43                   	inc    %ebx
			while (decexp > 0) {
    b1ad:	39 df                	cmp    %ebx,%edi
				*buf++ = _get_digit(&fract, &digit_count);
    b1af:	88 43 ff             	mov    %al,-0x1(%ebx)
			while (decexp > 0) {
    b1b2:	75 e7                	jne    b19b <_binary_mmu_tables_bin_size+0x19b>
    b1b4:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
    b1bb:	00 00 00 
    b1be:	eb 03                	jmp    b1c3 <_binary_mmu_tables_bin_size+0x1c3>
			*buf++ = '0';
    b1c0:	c6 03 30             	movb   $0x30,(%ebx)
		if (falt || (precision > 0)) {
    b1c3:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
    b1ca:	75 09                	jne    b1d5 <_binary_mmu_tables_bin_size+0x1d5>
    b1cc:	80 bd ec fe ff ff 00 	cmpb   $0x0,-0x114(%ebp)
    b1d3:	74 06                	je     b1db <_binary_mmu_tables_bin_size+0x1db>
			*buf++ = '.';
    b1d5:	c6 07 2e             	movb   $0x2e,(%edi)
    b1d8:	47                   	inc    %edi
    b1d9:	eb 0a                	jmp    b1e5 <_binary_mmu_tables_bin_size+0x1e5>
		if (falt || (precision > 0)) {
    b1db:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
    b1e2:	00 00 00 
    b1e5:	8b 9d 0c ff ff ff    	mov    -0xf4(%ebp),%ebx
    b1eb:	01 fb                	add    %edi,%ebx
		while (precision-- > 0) {
    b1ed:	39 fb                	cmp    %edi,%ebx
    b1ef:	0f 84 91 00 00 00    	je     b286 <_binary_mmu_tables_bin_size+0x286>
			if (decexp < 0) {
    b1f5:	47                   	inc    %edi
    b1f6:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    b1fd:	74 0c                	je     b20b <_binary_mmu_tables_bin_size+0x20b>
				*buf++ = '0';
    b1ff:	c6 47 ff 30          	movb   $0x30,-0x1(%edi)
				decexp++;
    b203:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
    b209:	eb e2                	jmp    b1ed <_binary_mmu_tables_bin_size+0x1ed>
				*buf++ = _get_digit(&fract, &digit_count);
    b20b:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    b211:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b217:	e8 14 f9 ff ff       	call   ab30 <_get_digit>
    b21c:	88 47 ff             	mov    %al,-0x1(%edi)
    b21f:	eb cc                	jmp    b1ed <_binary_mmu_tables_bin_size+0x1ed>
		*buf = _get_digit(&fract, &digit_count);
    b221:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    b227:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b22d:	e8 fe f8 ff ff       	call   ab30 <_get_digit>
    b232:	88 03                	mov    %al,(%ebx)
		if (*buf++ != '0') {
    b234:	3c 30                	cmp    $0x30,%al
    b236:	74 06                	je     b23e <_binary_mmu_tables_bin_size+0x23e>
			decexp--;
    b238:	ff 8d 00 ff ff ff    	decl   -0x100(%ebp)
		if (falt || (precision > 0)) {
    b23e:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
    b245:	75 09                	jne    b250 <_binary_mmu_tables_bin_size+0x250>
    b247:	80 bd ec fe ff ff 00 	cmpb   $0x0,-0x114(%ebp)
    b24e:	74 09                	je     b259 <_binary_mmu_tables_bin_size+0x259>
			*buf++ = '.';
    b250:	8d 7b 02             	lea    0x2(%ebx),%edi
    b253:	c6 43 01 2e          	movb   $0x2e,0x1(%ebx)
    b257:	eb 0a                	jmp    b263 <_binary_mmu_tables_bin_size+0x263>
		if (falt || (precision > 0)) {
    b259:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
    b260:	00 00 00 
    b263:	8b 9d 0c ff ff ff    	mov    -0xf4(%ebp),%ebx
    b269:	01 fb                	add    %edi,%ebx
		while (precision-- > 0) {
    b26b:	39 fb                	cmp    %edi,%ebx
    b26d:	74 17                	je     b286 <_binary_mmu_tables_bin_size+0x286>
			*buf++ = _get_digit(&fract, &digit_count);
    b26f:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    b275:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    b27b:	e8 b0 f8 ff ff       	call   ab30 <_get_digit>
    b280:	47                   	inc    %edi
    b281:	88 47 ff             	mov    %al,-0x1(%edi)
    b284:	eb e5                	jmp    b26b <_binary_mmu_tables_bin_size+0x26b>
	if (prune_zero) {
    b286:	83 bd d0 fe ff ff 00 	cmpl   $0x0,-0x130(%ebp)
    b28d:	74 11                	je     b2a0 <_binary_mmu_tables_bin_size+0x2a0>
		while (*--buf == '0')
    b28f:	89 f8                	mov    %edi,%eax
    b291:	4f                   	dec    %edi
    b292:	8a 17                	mov    (%edi),%dl
    b294:	80 fa 30             	cmp    $0x30,%dl
    b297:	74 f6                	je     b28f <_binary_mmu_tables_bin_size+0x28f>
		if (*buf != '.') {
    b299:	80 fa 2e             	cmp    $0x2e,%dl
    b29c:	74 02                	je     b2a0 <_binary_mmu_tables_bin_size+0x2a0>
    b29e:	89 c7                	mov    %eax,%edi
	if ((c == 'e') || (c == 'E')) {
    b2a0:	89 f0                	mov    %esi,%eax
    b2a2:	83 e0 df             	and    $0xffffffdf,%eax
    b2a5:	83 f8 45             	cmp    $0x45,%eax
    b2a8:	75 37                	jne    b2e1 <_binary_mmu_tables_bin_size+0x2e1>
		*buf++ = (char) c;
    b2aa:	89 f0                	mov    %esi,%eax
    b2ac:	88 07                	mov    %al,(%edi)
			*buf++ = '+';
    b2ae:	b0 2b                	mov    $0x2b,%al
		if (decexp < 0) {
    b2b0:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    b2b7:	79 08                	jns    b2c1 <_binary_mmu_tables_bin_size+0x2c1>
			decexp = -decexp;
    b2b9:	f7 9d 00 ff ff ff    	negl   -0x100(%ebp)
			*buf++ = '-';
    b2bf:	b0 2d                	mov    $0x2d,%al
    b2c1:	88 47 01             	mov    %al,0x1(%edi)
		*buf++ = (char) ((decexp / 10) + '0');
    b2c4:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
    b2ca:	b9 0a 00 00 00       	mov    $0xa,%ecx
		*buf++ = (char) (decexp + '0');
    b2cf:	83 c7 04             	add    $0x4,%edi
		*buf++ = (char) ((decexp / 10) + '0');
    b2d2:	99                   	cltd   
    b2d3:	f7 f9                	idiv   %ecx
    b2d5:	83 c0 30             	add    $0x30,%eax
		*buf++ = (char) (decexp + '0');
    b2d8:	83 c2 30             	add    $0x30,%edx
		*buf++ = (char) ((decexp / 10) + '0');
    b2db:	88 47 fe             	mov    %al,-0x2(%edi)
		*buf++ = (char) (decexp + '0');
    b2de:	88 57 ff             	mov    %dl,-0x1(%edi)
	return buf - start;
    b2e1:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
	*buf = 0;
    b2e7:	c6 07 00             	movb   $0x0,(%edi)
	return buf - start;
    b2ea:	29 c7                	sub    %eax,%edi
    b2ec:	89 f8                	mov    %edi,%eax
#endif
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-')) {
    b2ee:	8b b5 e0 fe ff ff    	mov    -0x120(%ebp),%esi
    b2f4:	0b b5 e4 fe ff ff    	or     -0x11c(%ebp),%esi
    b2fa:	0f 85 8a 00 00 00    	jne    b38a <_binary_mmu_tables_bin_size+0x38a>
    b300:	31 c9                	xor    %ecx,%ecx
    b302:	80 bd 27 ff ff ff 2d 	cmpb   $0x2d,-0xd9(%ebp)
    b309:	0f 94 c1             	sete   %cl
    b30c:	89 ce                	mov    %ecx,%esi
    b30e:	eb 7a                	jmp    b38a <_binary_mmu_tables_bin_size+0x38a>
			switch (c) {
    b310:	0f 8e a3 02 00 00    	jle    b5b9 <_binary_mmu_tables_bin_size+0x5b9>
				int32_temp = (int32_t) va_arg(vargs, int32_t);
    b316:	8d 43 04             	lea    0x4(%ebx),%eax
    b319:	8b 33                	mov    (%ebx),%esi
    b31b:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (value < 0) {
    b321:	85 f6                	test   %esi,%esi
    b323:	0f 89 5a 02 00 00    	jns    b583 <_binary_mmu_tables_bin_size+0x583>
		*buf++ = '-';
    b329:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
		if (value != 0x80000000) {
    b330:	ba 00 00 00 80       	mov    $0x80000000,%edx
    b335:	81 fe 00 00 00 80    	cmp    $0x80000000,%esi
    b33b:	74 04                	je     b341 <_binary_mmu_tables_bin_size+0x341>
			value = -value;
    b33d:	89 f2                	mov    %esi,%edx
    b33f:	f7 da                	neg    %edx
		*buf++ = '-';
    b341:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
	return _to_x(buf, value, 10, precision);
    b347:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    b34d:	b9 0a 00 00 00       	mov    $0xa,%ecx
    b352:	89 d8                	mov    %ebx,%eax
				if (fplus || fspace || (int32_temp < 0)) {
    b354:	c1 ee 1f             	shr    $0x1f,%esi
	return _to_x(buf, value, 10, precision);
    b357:	e8 b5 f6 ff ff       	call   aa11 <_to_x>
				if (fplus || fspace || (int32_temp < 0)) {
    b35c:	8a 95 e0 fe ff ff    	mov    -0x120(%ebp),%dl
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
    b362:	8d 4d f0             	lea    -0x10(%ebp),%ecx
				if (fplus || fspace || (int32_temp < 0)) {
    b365:	0b 95 e4 fe ff ff    	or     -0x11c(%ebp),%edx
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
    b36b:	29 cb                	sub    %ecx,%ebx
			prefix = 0;
    b36d:	09 f2                	or     %esi,%edx
	return _to_x(buf, value, 10, precision);
    b36f:	5f                   	pop    %edi
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
    b370:	8d 84 03 c9 00 00 00 	lea    0xc9(%ebx,%eax,1),%eax
			prefix = 0;
    b377:	0f b6 f2             	movzbl %dl,%esi
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt) {
					prefix = 2;
				}
				need_justifying = true;
				if (precision != -1) {
    b37a:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
    b381:	74 07                	je     b38a <_binary_mmu_tables_bin_size+0x38a>
					pad = ' ';
    b383:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1) {
    b38a:	3d c8 00 00 00       	cmp    $0xc8,%eax
    b38f:	0f 8f 4b f8 ff ff    	jg     abe0 <_prf+0x6b>
    b395:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
				return EOF;
			}

			if (need_justifying) {
				if (c < width) {
    b39b:	8b bd 08 ff ff ff    	mov    -0xf8(%ebp),%edi
    b3a1:	39 bd fc fe ff ff    	cmp    %edi,-0x104(%ebp)
    b3a7:	7e 74                	jle    b41d <_binary_mmu_tables_bin_size+0x41d>
					if (fminus) {
    b3a9:	83 bd dc fe ff ff 00 	cmpl   $0x0,-0x124(%ebp)
    b3b0:	74 24                	je     b3d6 <_binary_mmu_tables_bin_size+0x3d6>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
    b3b2:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						for (i = c; i < width; i++)
    b3b8:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
    b3be:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
							buf[i] = ' ';
    b3c4:	c6 84 05 27 ff ff ff 	movb   $0x20,-0xd9(%ebp,%eax,1)
    b3cb:	20 
						for (i = c; i < width; i++)
    b3cc:	39 b5 fc fe ff ff    	cmp    %esi,-0x104(%ebp)
    b3d2:	75 de                	jne    b3b2 <_binary_mmu_tables_bin_size+0x3b2>
    b3d4:	eb 53                	jmp    b429 <_binary_mmu_tables_bin_size+0x429>
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    b3d6:	8b 9d fc fe ff ff    	mov    -0x104(%ebp),%ebx
										+ 1));
    b3dc:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    b3e2:	2b 9d 08 ff ff ff    	sub    -0xf8(%ebp),%ebx
										+ 1));
    b3e8:	40                   	inc    %eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    b3e9:	50                   	push   %eax
    b3ea:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    b3f0:	50                   	push   %eax
    b3f1:	01 d8                	add    %ebx,%eax
    b3f3:	50                   	push   %eax
    b3f4:	e8 ff f4 ff ff       	call   a8f8 <memmove>
    b3f9:	83 c4 0c             	add    $0xc,%esp
						if (pad == ' ')
    b3fc:	80 bd f7 fe ff ff 20 	cmpb   $0x20,-0x109(%ebp)
    b403:	75 02                	jne    b407 <_binary_mmu_tables_bin_size+0x407>
							prefix = 0;
    b405:	31 f6                	xor    %esi,%esi
						c = width - c + prefix;
    b407:	01 f3                	add    %esi,%ebx
						for (i = prefix; i < c; i++)
    b409:	39 de                	cmp    %ebx,%esi
    b40b:	7d 1c                	jge    b429 <_binary_mmu_tables_bin_size+0x429>
							buf[i] = pad;
    b40d:	8a 85 f7 fe ff ff    	mov    -0x109(%ebp),%al
    b413:	88 84 35 27 ff ff ff 	mov    %al,-0xd9(%ebp,%esi,1)
						for (i = prefix; i < c; i++)
    b41a:	46                   	inc    %esi
    b41b:	eb ec                	jmp    b409 <_binary_mmu_tables_bin_size+0x409>
    b41d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
    b423:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
    b429:	31 db                	xor    %ebx,%ebx
    b42b:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
    b431:	01 d8                	add    %ebx,%eax
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
    b433:	39 9d fc fe ff ff    	cmp    %ebx,-0x104(%ebp)
    b439:	74 22                	je     b45d <_binary_mmu_tables_bin_size+0x45d>
					if ((*func)(*cptr, dest) == EOF) {
    b43b:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    b441:	0f be 84 1d 27 ff ff 	movsbl -0xd9(%ebp,%ebx,1),%eax
    b448:	ff 
    b449:	50                   	push   %eax
    b44a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    b450:	ff d0                	call   *%eax
    b452:	5a                   	pop    %edx
    b453:	43                   	inc    %ebx
    b454:	59                   	pop    %ecx
    b455:	40                   	inc    %eax
    b456:	75 d3                	jne    b42b <_binary_mmu_tables_bin_size+0x42b>
    b458:	e9 83 f7 ff ff       	jmp    abe0 <_prf+0x6b>
    b45d:	8b 9d f8 fe ff ff    	mov    -0x108(%ebp),%ebx
    b463:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
    b469:	e9 45 f7 ff ff       	jmp    abb3 <_prf+0x3e>
			switch (c) {
    b46e:	83 fe 47             	cmp    $0x47,%esi
    b471:	7f 6e                	jg     b4e1 <_binary_mmu_tables_bin_size+0x4e1>
    b473:	83 fe 45             	cmp    $0x45,%esi
    b476:	0f 8d 91 f9 ff ff    	jge    ae0d <_prf+0x298>
    b47c:	85 f6                	test   %esi,%esi
    b47e:	0f 84 bf 02 00 00    	je     b743 <_binary_mmu_tables_bin_size+0x743>
    b484:	83 fe 25             	cmp    $0x25,%esi
    b487:	0f 85 26 f7 ff ff    	jne    abb3 <_prf+0x3e>
				if ((*func)('%', dest) == EOF) {
    b48d:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    b493:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    b499:	6a 25                	push   $0x25
    b49b:	ff d0                	call   *%eax
    b49d:	5e                   	pop    %esi
    b49e:	40                   	inc    %eax
    b49f:	5f                   	pop    %edi
    b4a0:	0f 84 3a f7 ff ff    	je     abe0 <_prf+0x6b>
				count++;
    b4a6:	ff 85 e8 fe ff ff    	incl   -0x118(%ebp)
				break;
    b4ac:	89 9d f8 fe ff ff    	mov    %ebx,-0x108(%ebp)
    b4b2:	eb 22                	jmp    b4d6 <_binary_mmu_tables_bin_size+0x4d6>
			switch (c) {
    b4b4:	0f 8f 41 02 00 00    	jg     b6fb <_binary_mmu_tables_bin_size+0x6fb>
    b4ba:	83 fe 6e             	cmp    $0x6e,%esi
    b4bd:	0f 85 b3 01 00 00    	jne    b676 <_binary_mmu_tables_bin_size+0x676>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
    b4c3:	8d 43 04             	lea    0x4(%ebx),%eax
				*int32ptr_temp = count;
    b4c6:	8b 8d e8 fe ff ff    	mov    -0x118(%ebp),%ecx
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
    b4cc:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
				*int32ptr_temp = count;
    b4d2:	8b 03                	mov    (%ebx),%eax
    b4d4:	89 08                	mov    %ecx,(%eax)
			if (need_justifying) {
    b4d6:	8b 9d f8 fe ff ff    	mov    -0x108(%ebp),%ebx
    b4dc:	e9 d2 f6 ff ff       	jmp    abb3 <_prf+0x3e>
			switch (c) {
    b4e1:	83 fe 63             	cmp    $0x63,%esi
    b4e4:	0f 85 26 fe ff ff    	jne    b310 <_binary_mmu_tables_bin_size+0x310>
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
    b4ea:	8d 43 04             	lea    0x4(%ebx),%eax
				buf[1] = '\0';
    b4ed:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
    b4f4:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
    b4fa:	8b 03                	mov    (%ebx),%eax
    b4fc:	88 85 27 ff ff ff    	mov    %al,-0xd9(%ebp)
				c = 1;
    b502:	c7 85 08 ff ff ff 01 	movl   $0x1,-0xf8(%ebp)
    b509:	00 00 00 
				break;
    b50c:	eb 6e                	jmp    b57c <_binary_mmu_tables_bin_size+0x57c>
			switch (c) {
    b50e:	83 fe 78             	cmp    $0x78,%esi
    b511:	0f 84 ab 00 00 00    	je     b5c2 <_binary_mmu_tables_bin_size+0x5c2>
    b517:	83 fe 73             	cmp    $0x73,%esi
    b51a:	0f 85 93 f6 ff ff    	jne    abb3 <_prf+0x3e>
				cptr_temp = (char *) va_arg(vargs, char *);
    b520:	8d 43 04             	lea    0x4(%ebx),%eax
				for (c = 0; c < MAXFLD; c++) {
    b523:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
    b52a:	00 00 00 
				cptr_temp = (char *) va_arg(vargs, char *);
    b52d:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
    b533:	8b 03                	mov    (%ebx),%eax
					if (cptr_temp[c] == '\0') {
    b535:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
    b53b:	80 3c 30 00          	cmpb   $0x0,(%eax,%esi,1)
    b53f:	0f 85 e3 01 00 00    	jne    b728 <_binary_mmu_tables_bin_size+0x728>
				if ((precision >= 0) && (precision < c)) {
    b545:	8b b5 0c ff ff ff    	mov    -0xf4(%ebp),%esi
    b54b:	39 b5 08 ff ff ff    	cmp    %esi,-0xf8(%ebp)
    b551:	76 06                	jbe    b559 <_binary_mmu_tables_bin_size+0x559>
    b553:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
				if (c > 0) {
    b559:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    b560:	0f 84 70 ff ff ff    	je     b4d6 <_binary_mmu_tables_bin_size+0x4d6>
					memcpy(buf, cptr_temp, (size_t) c);
    b566:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
    b56c:	50                   	push   %eax
    b56d:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    b573:	50                   	push   %eax
    b574:	e8 b8 f3 ff ff       	call   a931 <memcpy>
    b579:	83 c4 0c             	add    $0xc,%esp
					prefix = 2;
    b57c:	31 f6                	xor    %esi,%esi
    b57e:	e9 18 fe ff ff       	jmp    b39b <_binary_mmu_tables_bin_size+0x39b>
	} else if (fplus) {
    b583:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
    b58a:	74 09                	je     b595 <_binary_mmu_tables_bin_size+0x595>
		*buf++ = '+';
    b58c:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
    b593:	eb 10                	jmp    b5a5 <_binary_mmu_tables_bin_size+0x5a5>
	} else if (fspace) {
    b595:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
    b59c:	74 0e                	je     b5ac <_binary_mmu_tables_bin_size+0x5ac>
		*buf++ = ' ';
    b59e:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
    b5a5:	89 f2                	mov    %esi,%edx
    b5a7:	e9 95 fd ff ff       	jmp    b341 <_binary_mmu_tables_bin_size+0x341>
	} else if (fspace) {
    b5ac:	89 f2                	mov    %esi,%edx
    b5ae:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
    b5b4:	e9 8e fd ff ff       	jmp    b347 <_binary_mmu_tables_bin_size+0x347>
			switch (c) {
    b5b9:	83 fe 58             	cmp    $0x58,%esi
    b5bc:	0f 85 f1 f5 ff ff    	jne    abb3 <_prf+0x3e>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    b5c2:	8d 43 04             	lea    0x4(%ebx),%eax
    b5c5:	8b 13                	mov    (%ebx),%edx
    b5c7:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (alt_form) {
    b5cd:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
    b5d3:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    b5da:	74 0f                	je     b5eb <_binary_mmu_tables_bin_size+0x5eb>
		*buf++ = '0';
    b5dc:	66 c7 85 27 ff ff ff 	movw   $0x7830,-0xd9(%ebp)
    b5e3:	30 78 
		*buf++ = 'x';
    b5e5:	8d 9d 29 ff ff ff    	lea    -0xd7(%ebp),%ebx
	len = _to_x(buf, value, 16, precision);
    b5eb:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    b5f1:	b9 10 00 00 00       	mov    $0x10,%ecx
    b5f6:	89 d8                	mov    %ebx,%eax
    b5f8:	e8 14 f4 ff ff       	call   aa11 <_to_x>
    b5fd:	5a                   	pop    %edx
    b5fe:	89 c7                	mov    %eax,%edi
	if (prefix == 'X') {
    b600:	83 fe 58             	cmp    $0x58,%esi
    b603:	74 1f                	je     b624 <_binary_mmu_tables_bin_size+0x624>
	return len + (buf - buf0);
    b605:	8d 45 f0             	lea    -0x10(%ebp),%eax
    b608:	29 c3                	sub    %eax,%ebx
			prefix = 0;
    b60a:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
    b611:	19 f6                	sbb    %esi,%esi
	return len + (buf - buf0);
    b613:	8d 84 3b c9 00 00 00 	lea    0xc9(%ebx,%edi,1),%eax
			prefix = 0;
    b61a:	f7 d6                	not    %esi
    b61c:	83 e6 02             	and    $0x2,%esi
    b61f:	e9 56 fd ff ff       	jmp    b37a <_binary_mmu_tables_bin_size+0x37a>
	if (prefix == 'X') {
    b624:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
	for (/**/; *buf; buf++) {
    b62a:	8a 11                	mov    (%ecx),%dl
    b62c:	84 d2                	test   %dl,%dl
    b62e:	74 d5                	je     b605 <_binary_mmu_tables_bin_size+0x605>
		if (*buf >= 'a' && *buf <= 'z') {
    b630:	8d 72 9f             	lea    -0x61(%edx),%esi
    b633:	89 f0                	mov    %esi,%eax
    b635:	3c 19                	cmp    $0x19,%al
    b637:	77 05                	ja     b63e <_binary_mmu_tables_bin_size+0x63e>
			*buf += 'A' - 'a';
    b639:	83 ea 20             	sub    $0x20,%edx
    b63c:	88 11                	mov    %dl,(%ecx)
	for (/**/; *buf; buf++) {
    b63e:	41                   	inc    %ecx
    b63f:	eb e9                	jmp    b62a <_binary_mmu_tables_bin_size+0x62a>
			switch (c) {
    b641:	83 fe 70             	cmp    $0x70,%esi
    b644:	0f 85 6a fe ff ff    	jne    b4b4 <_binary_mmu_tables_bin_size+0x4b4>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    b64a:	8d 43 04             	lea    0x4(%ebx),%eax
    b64d:	8b 13                	mov    (%ebx),%edx
    b64f:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	len = _to_x(buf, value, 16, precision);
    b655:	b9 10 00 00 00       	mov    $0x10,%ecx
    b65a:	8d 85 29 ff ff ff    	lea    -0xd7(%ebp),%eax
    b660:	6a 08                	push   $0x8
		*buf++ = '0';
    b662:	66 c7 85 27 ff ff ff 	movw   $0x7830,-0xd9(%ebp)
    b669:	30 78 
	len = _to_x(buf, value, 16, precision);
    b66b:	e8 a1 f3 ff ff       	call   aa11 <_to_x>
    b670:	5b                   	pop    %ebx
	return len + (buf - buf0);
    b671:	83 c0 02             	add    $0x2,%eax
				if (precision != -1) {
    b674:	eb 46                	jmp    b6bc <_binary_mmu_tables_bin_size+0x6bc>
			switch (c) {
    b676:	7e 75                	jle    b6ed <_binary_mmu_tables_bin_size+0x6ed>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    b678:	8d 43 04             	lea    0x4(%ebx),%eax
    b67b:	8b 13                	mov    (%ebx),%edx
    b67d:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	if (alt_form) {
    b683:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    b68a:	74 59                	je     b6e5 <_binary_mmu_tables_bin_size+0x6e5>
		*buf++ = '0';
    b68c:	c6 85 27 ff ff ff 30 	movb   $0x30,-0xd9(%ebp)
    b693:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
		if (!value) {
    b699:	85 d2                	test   %edx,%edx
    b69b:	74 26                	je     b6c3 <_binary_mmu_tables_bin_size+0x6c3>
	return (buf - buf0) + _to_x(buf, value, 8, precision);
    b69d:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    b6a3:	89 d8                	mov    %ebx,%eax
    b6a5:	b9 08 00 00 00       	mov    $0x8,%ecx
    b6aa:	e8 62 f3 ff ff       	call   aa11 <_to_x>
    b6af:	5e                   	pop    %esi
    b6b0:	8d 75 f0             	lea    -0x10(%ebp),%esi
    b6b3:	29 f3                	sub    %esi,%ebx
    b6b5:	8d 84 03 c9 00 00 00 	lea    0xc9(%ebx,%eax,1),%eax
			prefix = 0;
    b6bc:	31 f6                	xor    %esi,%esi
    b6be:	e9 b7 fc ff ff       	jmp    b37a <_binary_mmu_tables_bin_size+0x37a>
    b6c3:	31 f6                	xor    %esi,%esi
			*buf++ = 0;
    b6c5:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				if (precision != -1) {
    b6cc:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
    b6d3:	0f 84 c2 fc ff ff    	je     b39b <_binary_mmu_tables_bin_size+0x39b>
					pad = ' ';
    b6d9:	c6 85 f7 fe ff ff 20 	movb   $0x20,-0x109(%ebp)
    b6e0:	e9 b6 fc ff ff       	jmp    b39b <_binary_mmu_tables_bin_size+0x39b>
	if (alt_form) {
    b6e5:	8d 9d 27 ff ff ff    	lea    -0xd9(%ebp),%ebx
    b6eb:	eb b0                	jmp    b69d <_binary_mmu_tables_bin_size+0x69d>
			switch (c) {
    b6ed:	83 fe 69             	cmp    $0x69,%esi
    b6f0:	0f 84 20 fc ff ff    	je     b316 <_binary_mmu_tables_bin_size+0x316>
    b6f6:	e9 b8 f4 ff ff       	jmp    abb3 <_prf+0x3e>
    b6fb:	83 fe 75             	cmp    $0x75,%esi
    b6fe:	0f 85 0a fe ff ff    	jne    b50e <_binary_mmu_tables_bin_size+0x50e>
	return _to_x(buf, value, 10, precision);
    b704:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    b70a:	8d 43 04             	lea    0x4(%ebx),%eax
	return _to_x(buf, value, 10, precision);
    b70d:	b9 0a 00 00 00       	mov    $0xa,%ecx
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    b712:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
	return _to_x(buf, value, 10, precision);
    b718:	8b 13                	mov    (%ebx),%edx
    b71a:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    b720:	e8 ec f2 ff ff       	call   aa11 <_to_x>
    b725:	59                   	pop    %ecx
    b726:	eb 94                	jmp    b6bc <_binary_mmu_tables_bin_size+0x6bc>
				for (c = 0; c < MAXFLD; c++) {
    b728:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
    b72e:	81 bd 08 ff ff ff c8 	cmpl   $0xc8,-0xf8(%ebp)
    b735:	00 00 00 
    b738:	0f 85 f7 fd ff ff    	jne    b535 <_binary_mmu_tables_bin_size+0x535>
    b73e:	e9 02 fe ff ff       	jmp    b545 <_binary_mmu_tables_bin_size+0x545>
				}
			}
		}
	}
	return count;
}
    b743:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
    b749:	8d 65 f0             	lea    -0x10(%ebp),%esp
    b74c:	59                   	pop    %ecx
    b74d:	5b                   	pop    %ebx
    b74e:	5e                   	pop    %esi
    b74f:	5f                   	pop    %edi
    b750:	5d                   	pop    %ebp
    b751:	8d 61 fc             	lea    -0x4(%ecx),%esp
    b754:	c3                   	ret    

0000b755 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    b755:	83 c8 ff             	or     $0xffffffff,%eax
    b758:	c3                   	ret    

0000b759 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
    b759:	55                   	push   %ebp
    b75a:	89 e5                	mov    %esp,%ebp
	_stdout_hook = hook;
    b75c:	8b 45 08             	mov    0x8(%ebp),%eax
}
    b75f:	5d                   	pop    %ebp
	_stdout_hook = hook;
    b760:	a3 8c a6 40 00       	mov    %eax,0x40a68c
}
    b765:	c3                   	ret    

0000b766 <sprintf_out>:
	char *ptr;
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
    b766:	55                   	push   %ebp
    b767:	89 e5                	mov    %esp,%ebp
    b769:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (p->len > 1) { /* need to reserve a byte for EOS */
    b76c:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    b770:	7e 0c                	jle    b77e <sprintf_out+0x18>
		*(p->ptr) = c;
    b772:	8b 10                	mov    (%eax),%edx
    b774:	8b 4d 08             	mov    0x8(%ebp),%ecx
    b777:	88 0a                	mov    %cl,(%edx)
		p->ptr += 1;
    b779:	ff 00                	incl   (%eax)
		p->len -= 1;
    b77b:	ff 48 04             	decl   0x4(%eax)
	}
	return 0; /* indicate keep going so we get the total count */
}
    b77e:	31 c0                	xor    %eax,%eax
    b780:	5d                   	pop    %ebp
    b781:	c3                   	ret    

0000b782 <snprintf>:

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
    b782:	55                   	push   %ebp
    b783:	89 e5                	mov    %esp,%ebp
    b785:	83 ec 0c             	sub    $0xc,%esp
    b788:	8b 45 0c             	mov    0xc(%ebp),%eax
    b78b:	8b 55 08             	mov    0x8(%ebp),%edx

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    b78e:	85 c0                	test   %eax,%eax
    b790:	75 03                	jne    b795 <snprintf+0x13>
		s = &dummy; /* write final NUL to dummy, can't change *s */
    b792:	8d 55 f7             	lea    -0x9(%ebp),%edx
	}

	p.ptr = s;
	p.len = (int) len;
    b795:	89 45 fc             	mov    %eax,-0x4(%ebp)

	va_start(vargs, format);
    b798:	8d 45 14             	lea    0x14(%ebp),%eax
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    b79b:	50                   	push   %eax
    b79c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    b79f:	ff 75 10             	pushl  0x10(%ebp)
	p.ptr = s;
    b7a2:	89 55 f8             	mov    %edx,-0x8(%ebp)
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    b7a5:	50                   	push   %eax
    b7a6:	68 66 b7 00 00       	push   $0xb766
    b7ab:	e8 c5 f3 ff ff       	call   ab75 <_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    b7b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    b7b3:	83 c4 10             	add    $0x10,%esp
	*(p.ptr) = 0;
    b7b6:	c6 02 00             	movb   $0x0,(%edx)
	return r;
}
    b7b9:	c9                   	leave  
    b7ba:	c3                   	ret    

0000b7bb <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, u8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
    b7bb:	c3                   	ret    

0000b7bc <net_buf_id>:
{
    b7bc:	55                   	push   %ebp
    b7bd:	89 e5                	mov    %esp,%ebp
    b7bf:	8b 45 08             	mov    0x8(%ebp),%eax
}
    b7c2:	5d                   	pop    %ebp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    b7c3:	0f b6 50 06          	movzbl 0x6(%eax),%edx
	return buf - pool->__bufs;
    b7c7:	6b d2 28             	imul   $0x28,%edx,%edx
    b7ca:	2b 82 74 aa 40 00    	sub    0x40aa74(%edx),%eax
    b7d0:	c1 f8 03             	sar    $0x3,%eax
    b7d3:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
}
    b7d9:	c3                   	ret    

0000b7da <fixed_data_alloc>:
{
    b7da:	55                   	push   %ebp
    b7db:	89 e5                	mov    %esp,%ebp
    b7dd:	56                   	push   %esi
    b7de:	53                   	push   %ebx
    b7df:	8b 55 08             	mov    0x8(%ebp),%edx
    b7e2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    b7e5:	0f b6 42 06          	movzbl 0x6(%edx),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    b7e9:	6b c0 28             	imul   $0x28,%eax,%eax
    b7ec:	8b 80 70 aa 40 00    	mov    0x40aa70(%eax),%eax
    b7f2:	8b 48 04             	mov    0x4(%eax),%ecx
	*size = MIN(fixed->data_size, *size);
    b7f5:	8b 03                	mov    (%ebx),%eax
    b7f7:	8b 31                	mov    (%ecx),%esi
    b7f9:	39 f0                	cmp    %esi,%eax
    b7fb:	76 02                	jbe    b7ff <fixed_data_alloc+0x25>
    b7fd:	89 f0                	mov    %esi,%eax
    b7ff:	89 03                	mov    %eax,(%ebx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    b801:	52                   	push   %edx
    b802:	e8 b5 ff ff ff       	call   b7bc <net_buf_id>
    b807:	5a                   	pop    %edx
    b808:	0f af 01             	imul   (%ecx),%eax
    b80b:	03 41 04             	add    0x4(%ecx),%eax
}
    b80e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    b811:	5b                   	pop    %ebx
    b812:	5e                   	pop    %esi
    b813:	5d                   	pop    %ebp
    b814:	c3                   	ret    

0000b815 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
    b815:	55                   	push   %ebp
    b816:	89 e5                	mov    %esp,%ebp
    b818:	57                   	push   %edi
    b819:	56                   	push   %esi
    b81a:	53                   	push   %ebx
    b81b:	83 ec 08             	sub    $0x8,%esp
    b81e:	8b 7d 08             	mov    0x8(%ebp),%edi
    b821:	8b 75 10             	mov    0x10(%ebp),%esi
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    b824:	e8 c9 90 01 00       	call   248f2 <z_impl_k_uptime_get_32>
    b829:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm__ volatile (
    b82c:	9c                   	pushf  
    b82d:	fa                   	cli    
    b82e:	59                   	pop    %ecx
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    b82f:	66 8b 47 1a          	mov    0x1a(%edi),%ax
    b833:	66 85 c0             	test   %ax,%ax
    b836:	74 5b                	je     b893 <net_buf_alloc_len+0x7e>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    b838:	81 e1 00 02 00 00    	and    $0x200,%ecx
    b83e:	66 3b 47 18          	cmp    0x18(%edi),%ax
    b842:	73 1d                	jae    b861 <net_buf_alloc_len+0x4c>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    b844:	6a 00                	push   $0x0
    b846:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    b849:	57                   	push   %edi
    b84a:	e8 88 7e 01 00       	call   236d7 <z_impl_k_queue_get>
    b84f:	5a                   	pop    %edx
    b850:	89 c3                	mov    %eax,%ebx
    b852:	59                   	pop    %ecx
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    b853:	85 c0                	test   %eax,%eax
    b855:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    b858:	74 07                	je     b861 <net_buf_alloc_len+0x4c>
    b85a:	85 c9                	test   %ecx,%ecx
    b85c:	74 4b                	je     b8a9 <net_buf_alloc_len+0x94>
	__asm__ volatile (
    b85e:	fb                   	sti    
    b85f:	eb 48                	jmp    b8a9 <net_buf_alloc_len+0x94>
				irq_unlock(key);
				goto success;
			}
		}

		uninit_count = pool->uninit_count--;
    b861:	0f b7 47 1a          	movzwl 0x1a(%edi),%eax
    b865:	85 c9                	test   %ecx,%ecx
    b867:	8d 58 ff             	lea    -0x1(%eax),%ebx
    b86a:	66 89 5f 1a          	mov    %bx,0x1a(%edi)
    b86e:	74 01                	je     b871 <net_buf_alloc_len+0x5c>
    b870:	fb                   	sti    
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    b871:	0f b7 5f 18          	movzwl 0x18(%edi),%ebx
    b875:	29 c3                	sub    %eax,%ebx
	return pool - _net_buf_pool_list;
    b877:	89 fa                	mov    %edi,%edx
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    b879:	6b db 18             	imul   $0x18,%ebx,%ebx
	return pool - _net_buf_pool_list;
    b87c:	81 ea 50 aa 40 00    	sub    $0x40aa50,%edx
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    b882:	03 5f 24             	add    0x24(%edi),%ebx
	return pool - _net_buf_pool_list;
    b885:	c1 fa 03             	sar    $0x3,%edx
    b888:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
	buf->pool_id = pool_id(pool);
    b88e:	88 53 06             	mov    %dl,0x6(%ebx)
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
		goto success;
    b891:	eb 16                	jmp    b8a9 <net_buf_alloc_len+0x94>
    b893:	0f ba e1 09          	bt     $0x9,%ecx
    b897:	73 01                	jae    b89a <net_buf_alloc_len+0x85>
    b899:	fb                   	sti    
    b89a:	56                   	push   %esi
    b89b:	57                   	push   %edi
    b89c:	e8 36 7e 01 00       	call   236d7 <z_impl_k_queue_get>
    b8a1:	59                   	pop    %ecx
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
#endif
	if (!buf) {
    b8a2:	85 c0                	test   %eax,%eax
    b8a4:	5b                   	pop    %ebx
    b8a5:	89 c3                	mov    %eax,%ebx
    b8a7:	74 7e                	je     b927 <net_buf_alloc_len+0x112>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    b8a9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    b8ad:	74 52                	je     b901 <net_buf_alloc_len+0xec>
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
    b8af:	8d 46 01             	lea    0x1(%esi),%eax
    b8b2:	83 f8 01             	cmp    $0x1,%eax
    b8b5:	76 10                	jbe    b8c7 <net_buf_alloc_len+0xb2>
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    b8b7:	e8 36 90 01 00       	call   248f2 <z_impl_k_uptime_get_32>
			u32_t diff = k_uptime_get_32() - alloc_start;

			timeout -= MIN(timeout, diff);
    b8bc:	2b 45 f0             	sub    -0x10(%ebp),%eax
    b8bf:	39 f0                	cmp    %esi,%eax
    b8c1:	76 02                	jbe    b8c5 <net_buf_alloc_len+0xb0>
    b8c3:	89 f0                	mov    %esi,%eax
    b8c5:	29 c6                	sub    %eax,%esi
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    b8c7:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
	return pool->alloc->cb->alloc(buf, size, timeout);
    b8cb:	6b c0 28             	imul   $0x28,%eax,%eax
    b8ce:	8d 55 0c             	lea    0xc(%ebp),%edx
    b8d1:	8b 80 70 aa 40 00    	mov    0x40aa70(%eax),%eax
    b8d7:	8b 00                	mov    (%eax),%eax
    b8d9:	56                   	push   %esi
    b8da:	52                   	push   %edx
    b8db:	53                   	push   %ebx
    b8dc:	ff 10                	call   *(%eax)
    b8de:	83 c4 0c             	add    $0xc,%esp
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    b8e1:	89 43 10             	mov    %eax,0x10(%ebx)
		if (!buf->__buf) {
    b8e4:	85 c0                	test   %eax,%eax
    b8e6:	75 20                	jne    b908 <net_buf_alloc_len+0xf3>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
    b8e8:	53                   	push   %ebx
    b8e9:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    b8ed:	6b c0 28             	imul   $0x28,%eax,%eax
    b8f0:	05 50 aa 40 00       	add    $0x40aa50,%eax
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    b8f5:	31 db                	xor    %ebx,%ebx
    b8f7:	50                   	push   %eax
    b8f8:	e8 c2 7d 01 00       	call   236bf <k_queue_prepend>
    b8fd:	58                   	pop    %eax
    b8fe:	5a                   	pop    %edx
    b8ff:	eb 26                	jmp    b927 <net_buf_alloc_len+0x112>
		}
	} else {
		buf->__buf = NULL;
    b901:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	}

	buf->ref   = 1;
	buf->flags = 0;
	buf->frags = NULL;
	buf->size  = size;
    b908:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf->frags = NULL;
    b90b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	buf->size  = size;
    b911:	66 89 43 0e          	mov    %ax,0xe(%ebx)
	buf->data = buf->__buf;
    b915:	8b 43 10             	mov    0x10(%ebx),%eax
	buf->ref   = 1;
    b918:	66 c7 43 04 01 00    	movw   $0x1,0x4(%ebx)
	buf->len  = 0;
    b91e:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	buf->data = buf->__buf;
    b924:	89 43 08             	mov    %eax,0x8(%ebx)
	pool->avail_count--;
	NET_BUF_ASSERT(pool->avail_count >= 0);
#endif

	return buf;
}
    b927:	8d 65 f4             	lea    -0xc(%ebp),%esp
    b92a:	89 d8                	mov    %ebx,%eax
    b92c:	5b                   	pop    %ebx
    b92d:	5e                   	pop    %esi
    b92e:	5f                   	pop    %edi
    b92f:	5d                   	pop    %ebp
    b930:	c3                   	ret    

0000b931 <net_buf_alloc_fixed>:
	return net_buf_alloc_len_debug(pool, fixed->data_size, timeout, func,
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool, s32_t timeout)
{
    b931:	55                   	push   %ebp
    b932:	89 e5                	mov    %esp,%ebp
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    b934:	ff 75 0c             	pushl  0xc(%ebp)
{
    b937:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    b93a:	8b 50 20             	mov    0x20(%eax),%edx
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    b93d:	8b 52 04             	mov    0x4(%edx),%edx
    b940:	ff 32                	pushl  (%edx)
    b942:	50                   	push   %eax
    b943:	e8 cd fe ff ff       	call   b815 <net_buf_alloc_len>
    b948:	83 c4 0c             	add    $0xc,%esp
}
    b94b:	c9                   	leave  
    b94c:	c3                   	ret    

0000b94d <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    b94d:	55                   	push   %ebp
    b94e:	89 e5                	mov    %esp,%ebp
    b950:	56                   	push   %esi
    b951:	53                   	push   %ebx
    b952:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_BUF_ASSERT(buf);

	while (buf) {
    b955:	85 db                	test   %ebx,%ebx
    b957:	74 64                	je     b9bd <net_buf_unref+0x70>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
    b959:	fe 4b 04             	decb   0x4(%ebx)
		struct net_buf *frags = buf->frags;
    b95c:	8b 33                	mov    (%ebx),%esi
		if (--buf->ref > 0) {
    b95e:	75 5d                	jne    b9bd <net_buf_unref+0x70>
			return;
		}

		if (buf->__buf) {
    b960:	8b 53 10             	mov    0x10(%ebx),%edx
    b963:	85 d2                	test   %edx,%edx
    b965:	74 23                	je     b98a <net_buf_unref+0x3d>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    b967:	f6 43 05 02          	testb  $0x2,0x5(%ebx)
    b96b:	75 16                	jne    b983 <net_buf_unref+0x36>
	pool->alloc->cb->unref(buf, data);
    b96d:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    b971:	6b c0 28             	imul   $0x28,%eax,%eax
    b974:	8b 80 70 aa 40 00    	mov    0x40aa70(%eax),%eax
    b97a:	8b 00                	mov    (%eax),%eax
    b97c:	52                   	push   %edx
    b97d:	53                   	push   %ebx
    b97e:	ff 50 08             	call   *0x8(%eax)
    b981:	58                   	pop    %eax
    b982:	5a                   	pop    %edx
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    b983:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
    b98a:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		pool->avail_count++;
		NET_BUF_ASSERT(pool->avail_count <= pool->buf_count);
#endif

		if (pool->destroy) {
    b98e:	6b c0 28             	imul   $0x28,%eax,%eax
    b991:	05 50 aa 40 00       	add    $0x40aa50,%eax
		buf->data = NULL;
    b996:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		buf->frags = NULL;
    b99d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		if (pool->destroy) {
    b9a3:	8b 50 1c             	mov    0x1c(%eax),%edx
    b9a6:	85 d2                	test   %edx,%edx
    b9a8:	74 06                	je     b9b0 <net_buf_unref+0x63>
			pool->destroy(buf);
    b9aa:	53                   	push   %ebx
    b9ab:	ff d2                	call   *%edx
    b9ad:	59                   	pop    %ecx
    b9ae:	eb 09                	jmp    b9b9 <net_buf_unref+0x6c>
	k_lifo_put(&pool->free, buf);
    b9b0:	53                   	push   %ebx
    b9b1:	50                   	push   %eax
    b9b2:	e8 08 7d 01 00       	call   236bf <k_queue_prepend>
    b9b7:	58                   	pop    %eax
    b9b8:	5a                   	pop    %edx
{
    b9b9:	89 f3                	mov    %esi,%ebx
    b9bb:	eb 98                	jmp    b955 <net_buf_unref+0x8>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    b9bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
    b9c0:	5b                   	pop    %ebx
    b9c1:	5e                   	pop    %esi
    b9c2:	5d                   	pop    %ebp
    b9c3:	c3                   	ret    

0000b9c4 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
    b9c4:	55                   	push   %ebp
    b9c5:	89 e5                	mov    %esp,%ebp
	NET_BUF_ASSERT(buf);

	while (buf->frags) {
    b9c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b9ca:	8b 10                	mov    (%eax),%edx
    b9cc:	85 d2                	test   %edx,%edx
    b9ce:	74 04                	je     b9d4 <net_buf_frag_last+0x10>
    b9d0:	89 d0                	mov    %edx,%eax
    b9d2:	eb f6                	jmp    b9ca <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
    b9d4:	5d                   	pop    %ebp
    b9d5:	c3                   	ret    

0000b9d6 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
    b9d6:	55                   	push   %ebp
    b9d7:	89 e5                	mov    %esp,%ebp
    b9d9:	56                   	push   %esi
    b9da:	53                   	push   %ebx
    b9db:	8b 55 08             	mov    0x8(%ebp),%edx
    b9de:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    b9e1:	89 c8                	mov    %ecx,%eax
	NET_BUF_ASSERT(parent);
	NET_BUF_ASSERT(frag);

	if (parent->frags) {
    b9e3:	8b 1a                	mov    (%edx),%ebx
    b9e5:	85 db                	test   %ebx,%ebx
    b9e7:	74 0c                	je     b9f5 <net_buf_frag_insert+0x1f>
	while (buf->frags) {
    b9e9:	8b 30                	mov    (%eax),%esi
    b9eb:	85 f6                	test   %esi,%esi
    b9ed:	74 04                	je     b9f3 <net_buf_frag_insert+0x1d>
    b9ef:	89 f0                	mov    %esi,%eax
    b9f1:	eb f6                	jmp    b9e9 <net_buf_frag_insert+0x13>
		net_buf_frag_last(frag)->frags = parent->frags;
    b9f3:	89 18                	mov    %ebx,(%eax)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
    b9f5:	89 0a                	mov    %ecx,(%edx)
}
    b9f7:	5b                   	pop    %ebx
    b9f8:	5e                   	pop    %esi
    b9f9:	5d                   	pop    %ebp
    b9fa:	c3                   	ret    

0000b9fb <net_buf_simple_add>:
#define NET_BUF_SIMPLE_INFO(fmt, ...)
#define NET_BUF_SIMPLE_ASSERT(cond)
#endif /* CONFIG_NET_BUF_SIMPLE_LOG */

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
    b9fb:	55                   	push   %ebp
    b9fc:	89 e5                	mov    %esp,%ebp
    b9fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
    ba01:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    ba05:	89 c2                	mov    %eax,%edx
    ba07:	03 01                	add    (%ecx),%eax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
    ba09:	03 55 0c             	add    0xc(%ebp),%edx
    ba0c:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
    ba10:	5d                   	pop    %ebp
    ba11:	c3                   	ret    

0000ba12 <net_buf_simple_add_u8>:

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
    ba12:	55                   	push   %ebp
    ba13:	89 e5                	mov    %esp,%ebp
    ba15:	8b 4d 08             	mov    0x8(%ebp),%ecx
    ba18:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    ba1c:	89 c2                	mov    %eax,%edx
    ba1e:	03 01                	add    (%ecx),%eax
	buf->len += len;
    ba20:	42                   	inc    %edx
    ba21:	66 89 51 04          	mov    %dx,0x4(%ecx)
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
    ba25:	8b 55 0c             	mov    0xc(%ebp),%edx
    ba28:	88 10                	mov    %dl,(%eax)

	return u8;
}
    ba2a:	5d                   	pop    %ebp
    ba2b:	c3                   	ret    

0000ba2c <net_buf_simple_pull>:

	*data = val;
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
    ba2c:	55                   	push   %ebp
    ba2d:	89 e5                	mov    %esp,%ebp
    ba2f:	8b 55 08             	mov    0x8(%ebp),%edx
    ba32:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
    ba35:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
    ba39:	03 02                	add    (%edx),%eax
    ba3b:	89 02                	mov    %eax,(%edx)
}
    ba3d:	5d                   	pop    %ebp
    ba3e:	c3                   	ret    

0000ba3f <net_buf_simple_tailroom>:
{
	return buf->data - buf->__buf;
}

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
    ba3f:	55                   	push   %ebp
    ba40:	89 e5                	mov    %esp,%ebp
    ba42:	8b 55 08             	mov    0x8(%ebp),%edx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}
    ba45:	5d                   	pop    %ebp
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
    ba46:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
    ba4a:	0f b7 42 06          	movzwl 0x6(%edx),%eax
    ba4e:	29 c8                	sub    %ecx,%eax
	return buf->data - buf->__buf;
    ba50:	8b 0a                	mov    (%edx),%ecx
    ba52:	2b 4a 08             	sub    0x8(%edx),%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
    ba55:	29 c8                	sub    %ecx,%eax
}
    ba57:	c3                   	ret    

0000ba58 <sys_slist_remove>:
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    ba58:	55                   	push   %ebp
    ba59:	85 d2                	test   %edx,%edx
    ba5b:	89 e5                	mov    %esp,%ebp
    ba5d:	53                   	push   %ebx
    ba5e:	8b 19                	mov    (%ecx),%ebx
    ba60:	75 0c                	jne    ba6e <sys_slist_remove+0x16>
	list->head = node;
    ba62:	89 18                	mov    %ebx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
    ba64:	3b 48 04             	cmp    0x4(%eax),%ecx
    ba67:	75 0f                	jne    ba78 <sys_slist_remove+0x20>
	list->tail = node;
    ba69:	89 58 04             	mov    %ebx,0x4(%eax)
    ba6c:	eb 0a                	jmp    ba78 <sys_slist_remove+0x20>
	parent->next = child;
    ba6e:	89 1a                	mov    %ebx,(%edx)
Z_GENLIST_REMOVE(slist, snode)
    ba70:	3b 48 04             	cmp    0x4(%eax),%ecx
    ba73:	75 03                	jne    ba78 <sys_slist_remove+0x20>
	list->tail = node;
    ba75:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_REMOVE(slist, snode)
    ba78:	5b                   	pop    %ebx
	parent->next = child;
    ba79:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
    ba7f:	5d                   	pop    %ebp
    ba80:	c3                   	ret    

0000ba81 <arp_entry_find>:

static struct arp_entry *arp_entry_find(sys_slist_t *list,
					struct net_if *iface,
					struct in_addr *dst,
					sys_snode_t **previous)
{
    ba81:	55                   	push   %ebp
    ba82:	89 e5                	mov    %esp,%ebp
    ba84:	56                   	push   %esi
    ba85:	53                   	push   %ebx
    ba86:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct arp_entry *entry;

	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
    ba89:	8b 00                	mov    (%eax),%eax
    ba8b:	85 c0                	test   %eax,%eax
    ba8d:	75 04                	jne    ba93 <arp_entry_find+0x12>
		if (previous) {
			*previous = &entry->node;
		}
	}

	return NULL;
    ba8f:	31 c0                	xor    %eax,%eax
    ba91:	eb 14                	jmp    baa7 <arp_entry_find+0x26>
		if (entry->iface == iface &&
    ba93:	3b 50 0c             	cmp    0xc(%eax),%edx
    ba96:	75 07                	jne    ba9f <arp_entry_find+0x1e>
    ba98:	8b 31                	mov    (%ecx),%esi
    ba9a:	39 70 10             	cmp    %esi,0x10(%eax)
    ba9d:	74 08                	je     baa7 <arp_entry_find+0x26>
		if (previous) {
    ba9f:	85 db                	test   %ebx,%ebx
    baa1:	74 e6                	je     ba89 <arp_entry_find+0x8>
			*previous = &entry->node;
    baa3:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    baa5:	eb e2                	jmp    ba89 <arp_entry_find+0x8>
}
    baa7:	5b                   	pop    %ebx
    baa8:	5e                   	pop    %esi
    baa9:	5d                   	pop    %ebp
    baaa:	c3                   	ret    

0000baab <arp_entry_cleanup>:
{
    baab:	55                   	push   %ebp
	if (pending) {
    baac:	84 d2                	test   %dl,%dl
{
    baae:	89 e5                	mov    %esp,%ebp
    bab0:	53                   	push   %ebx
    bab1:	89 c3                	mov    %eax,%ebx
	if (pending) {
    bab3:	74 10                	je     bac5 <arp_entry_cleanup+0x1a>
		net_pkt_unref(entry->pending);
    bab5:	ff 70 14             	pushl  0x14(%eax)
    bab8:	e8 44 43 00 00       	call   fe01 <net_pkt_unref>
    babd:	58                   	pop    %eax
		entry->pending = NULL;
    babe:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	entry->iface = NULL;
    bac5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	(void)memset(&entry->ip, 0, sizeof(struct in_addr));
    bacc:	6a 04                	push   $0x4
    bace:	6a 00                	push   $0x0
    bad0:	8d 43 10             	lea    0x10(%ebx),%eax
    bad3:	50                   	push   %eax
    bad4:	e8 c7 ee ff ff       	call   a9a0 <memset>
    bad9:	83 c4 0c             	add    $0xc,%esp
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
    badc:	83 c3 14             	add    $0x14,%ebx
    badf:	6a 06                	push   $0x6
    bae1:	6a 00                	push   $0x0
    bae3:	53                   	push   %ebx
    bae4:	e8 b7 ee ff ff       	call   a9a0 <memset>
    bae9:	83 c4 0c             	add    $0xc,%esp
}
    baec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    baef:	c9                   	leave  
    baf0:	c3                   	ret    

0000baf1 <if_get_addr.isra.14>:
					  struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
    baf1:	85 c0                	test   %eax,%eax
    baf3:	74 3e                	je     bb33 <if_get_addr.isra.14+0x42>
static inline struct in_addr *if_get_addr(struct net_if *iface,
    baf5:	55                   	push   %ebp
    baf6:	89 c1                	mov    %eax,%ecx
    baf8:	89 e5                	mov    %esp,%ebp
    bafa:	57                   	push   %edi
    bafb:	56                   	push   %esi
    bafc:	8d 78 04             	lea    0x4(%eax),%edi
    baff:	53                   	push   %ebx
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    bb00:	31 f6                	xor    %esi,%esi
		if (ipv4->unicast[i].is_used &&
    bb02:	6b de 48             	imul   $0x48,%esi,%ebx
    bb05:	f6 44 19 47 02       	testb  $0x2,0x47(%ecx,%ebx,1)
    bb0a:	74 1d                	je     bb29 <if_get_addr.isra.14+0x38>
    bb0c:	66 83 3c 19 01       	cmpw   $0x1,(%ecx,%ebx,1)
    bb11:	75 16                	jne    bb29 <if_get_addr.isra.14+0x38>
		    ipv4->unicast[i].address.family == AF_INET &&
    bb13:	80 7c 19 45 01       	cmpb   $0x1,0x45(%ecx,%ebx,1)
    bb18:	75 0f                	jne    bb29 <if_get_addr.isra.14+0x38>
    bb1a:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
    bb1d:	85 d2                	test   %edx,%edx
    bb1f:	74 15                	je     bb36 <if_get_addr.isra.14+0x45>
		    (!addr ||
    bb21:	8b 5c 19 04          	mov    0x4(%ecx,%ebx,1),%ebx
    bb25:	39 1a                	cmp    %ebx,(%edx)
    bb27:	74 0d                	je     bb36 <if_get_addr.isra.14+0x45>
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    bb29:	46                   	inc    %esi
    bb2a:	83 fe 03             	cmp    $0x3,%esi
    bb2d:	75 d3                	jne    bb02 <if_get_addr.isra.14+0x11>
		return NULL;
    bb2f:	31 c0                	xor    %eax,%eax
    bb31:	eb 03                	jmp    bb36 <if_get_addr.isra.14+0x45>
    bb33:	31 c0                	xor    %eax,%eax
			return &ipv4->unicast[i].address.in_addr;
		}
	}

	return NULL;
}
    bb35:	c3                   	ret    
    bb36:	5b                   	pop    %ebx
    bb37:	5e                   	pop    %esi
    bb38:	5f                   	pop    %edi
    bb39:	5d                   	pop    %ebp
    bb3a:	c3                   	ret    

0000bb3b <arp_request_timeout>:
{
    bb3b:	55                   	push   %ebp
    bb3c:	89 e5                	mov    %esp,%ebp
    bb3e:	57                   	push   %edi
    bb3f:	56                   	push   %esi
    bb40:	53                   	push   %ebx
    bb41:	83 ec 14             	sub    $0x14,%esp
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    bb44:	e8 c8 8d 01 00       	call   24911 <z_impl_k_uptime_get>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    bb49:	8b 1d 84 42 40 00    	mov    0x404284,%ebx
    bb4f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bb52:	89 55 ec             	mov    %edx,-0x14(%ebp)
    bb55:	85 db                	test   %ebx,%ebx
    bb57:	0f 84 9a 00 00 00    	je     bbf7 <arp_request_timeout+0xbc>
    bb5d:	8b 03                	mov    (%ebx),%eax
		if ((entry->req_start + ARP_REQUEST_TIMEOUT - current) > 0) {
    bb5f:	31 d2                	xor    %edx,%edx
    bb61:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bb64:	b8 d0 07 00 00       	mov    $0x7d0,%eax
    bb69:	2b 45 e8             	sub    -0x18(%ebp),%eax
    bb6c:	1b 55 ec             	sbb    -0x14(%ebp),%edx
    bb6f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bb72:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    bb75:	8b 43 04             	mov    0x4(%ebx),%eax
    bb78:	8b 75 e0             	mov    -0x20(%ebp),%esi
    bb7b:	01 c6                	add    %eax,%esi
    bb7d:	8b 53 08             	mov    0x8(%ebx),%edx
    bb80:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    bb83:	11 d7                	adc    %edx,%edi
    bb85:	31 c9                	xor    %ecx,%ecx
    bb87:	39 f1                	cmp    %esi,%ecx
    bb89:	19 f9                	sbb    %edi,%ecx
    bb8b:	7c 4f                	jl     bbdc <arp_request_timeout+0xa1>
		arp_entry_cleanup(entry, true);
    bb8d:	ba 01 00 00 00       	mov    $0x1,%edx
    bb92:	89 d8                	mov    %ebx,%eax
    bb94:	e8 12 ff ff ff       	call   baab <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
    bb99:	31 d2                	xor    %edx,%edx
    bb9b:	b8 84 42 40 00       	mov    $0x404284,%eax
    bba0:	89 d9                	mov    %ebx,%ecx
    bba2:	e8 b1 fe ff ff       	call   ba58 <sys_slist_remove>
	parent->next = child;
    bba7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_APPEND(slist, snode)
    bbad:	a1 90 42 40 00       	mov    0x404290,%eax
    bbb2:	85 c0                	test   %eax,%eax
    bbb4:	75 0e                	jne    bbc4 <arp_request_timeout+0x89>
	list->tail = node;
    bbb6:	89 1d 90 42 40 00    	mov    %ebx,0x404290
	list->head = node;
    bbbc:	89 1d 8c 42 40 00    	mov    %ebx,0x40428c
    bbc2:	eb 08                	jmp    bbcc <arp_request_timeout+0x91>
	parent->next = child;
    bbc4:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    bbc6:	89 1d 90 42 40 00    	mov    %ebx,0x404290
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    bbcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbd0:	74 25                	je     bbf7 <arp_request_timeout+0xbc>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    bbd2:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    bbd5:	8b 03                	mov    (%ebx),%eax
    bbd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bbda:	eb 99                	jmp    bb75 <arp_request_timeout+0x3a>
		k_delayed_work_submit(&arp_request_timer,
    bbdc:	2b 45 e8             	sub    -0x18(%ebp),%eax
    bbdf:	05 d0 07 00 00       	add    $0x7d0,%eax
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    bbe4:	50                   	push   %eax
    bbe5:	68 c0 06 40 00       	push   $0x4006c0
    bbea:	68 60 41 40 00       	push   $0x404160
    bbef:	e8 e1 88 01 00       	call   244d5 <k_delayed_work_submit_to_queue>
    bbf4:	83 c4 0c             	add    $0xc,%esp
}
    bbf7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    bbfa:	5b                   	pop    %ebx
    bbfb:	5e                   	pop    %esi
    bbfc:	5f                   	pop    %edi
    bbfd:	5d                   	pop    %ebp
    bbfe:	c3                   	ret    

0000bbff <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
    bbff:	55                   	push   %ebp
    bc00:	89 e5                	mov    %esp,%ebp
    bc02:	57                   	push   %edi
    bc03:	56                   	push   %esi
    bc04:	89 c6                	mov    %eax,%esi
    bc06:	53                   	push   %ebx
    bc07:	89 cf                	mov    %ecx,%edi
    bc09:	83 ec 10             	sub    $0x10,%esp
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
    bc0c:	89 d1                	mov    %edx,%ecx
{
    bc0e:	8b 45 08             	mov    0x8(%ebp),%eax
    bc11:	89 55 ec             	mov    %edx,-0x14(%ebp)
    bc14:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bc17:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
    bc1d:	8d 45 f0             	lea    -0x10(%ebp),%eax
    bc20:	50                   	push   %eax
    bc21:	89 f2                	mov    %esi,%edx
    bc23:	b8 84 42 40 00       	mov    $0x404284,%eax
	sys_snode_t *prev = NULL;
    bc28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
    bc2f:	e8 4d fe ff ff       	call   ba81 <arp_entry_find>
    bc34:	5a                   	pop    %edx
    bc35:	89 c3                	mov    %eax,%ebx
	if (entry) {
    bc37:	85 c0                	test   %eax,%eax
    bc39:	74 0f                	je     bc4a <arp_update+0x4b>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
    bc3b:	89 c1                	mov    %eax,%ecx
    bc3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bc40:	b8 84 42 40 00       	mov    $0x404284,%eax
    bc45:	e8 0e fe ff ff       	call   ba58 <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
    bc4a:	83 3d 84 42 40 00 00 	cmpl   $0x0,0x404284
    bc51:	75 0b                	jne    bc5e <arp_update+0x5f>
		k_delayed_work_cancel(&arp_request_timer);
    bc53:	68 c0 06 40 00       	push   $0x4006c0
    bc58:	e8 4a 89 01 00       	call   245a7 <k_delayed_work_cancel>
    bc5d:	58                   	pop    %eax
	struct net_pkt *pkt;

	NET_DBG("src %s", log_strdup(net_sprint_ipv4_addr(src)));

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
    bc5e:	85 db                	test   %ebx,%ebx
    bc60:	75 6e                	jne    bcd0 <arp_update+0xd1>
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
    bc62:	80 7d e8 00          	cmpb   $0x0,-0x18(%ebp)
    bc66:	74 2e                	je     bc96 <arp_update+0x97>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
    bc68:	8d 45 f0             	lea    -0x10(%ebp),%eax
    bc6b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    bc6e:	50                   	push   %eax
    bc6f:	89 f2                	mov    %esi,%edx
    bc71:	b8 7c 42 40 00       	mov    $0x40427c,%eax
	sys_snode_t *prev = NULL;
    bc76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_table, iface, src, &prev);
    bc7d:	e8 ff fd ff ff       	call   ba81 <arp_entry_find>
    bc82:	5b                   	pop    %ebx
	if (entry) {
    bc83:	85 c0                	test   %eax,%eax
    bc85:	74 0f                	je     bc96 <arp_update+0x97>
		memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
    bc87:	6a 06                	push   $0x6
    bc89:	83 c0 14             	add    $0x14,%eax
    bc8c:	57                   	push   %edi
    bc8d:	50                   	push   %eax
    bc8e:	e8 9e ec ff ff       	call   a931 <memcpy>
    bc93:	83 c4 0c             	add    $0xc,%esp
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
    bc96:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
    bc9a:	0f 84 81 00 00 00    	je     bd21 <arp_update+0x122>
			sys_snode_t *prev = NULL;
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
    bca0:	8d 45 f0             	lea    -0x10(%ebp),%eax
    bca3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    bca6:	50                   	push   %eax
    bca7:	89 f2                	mov    %esi,%edx
    bca9:	b8 7c 42 40 00       	mov    $0x40427c,%eax
			sys_snode_t *prev = NULL;
    bcae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			entry = arp_entry_find(&arp_table, iface, src, &prev);
    bcb5:	e8 c7 fd ff ff       	call   ba81 <arp_entry_find>
    bcba:	59                   	pop    %ecx
			if (entry) {
    bcbb:	85 c0                	test   %eax,%eax
    bcbd:	74 62                	je     bd21 <arp_update+0x122>
				memcpy(&entry->eth, hwaddr,
    bcbf:	6a 06                	push   $0x6
    bcc1:	83 c0 14             	add    $0x14,%eax
    bcc4:	57                   	push   %edi
    bcc5:	50                   	push   %eax
    bcc6:	e8 66 ec ff ff       	call   a931 <memcpy>
    bccb:	83 c4 0c             	add    $0xc,%esp
    bcce:	eb 51                	jmp    bd21 <arp_update+0x122>

		return;
	}

	/* Set the dst in the pending packet */
	net_pkt_lladdr_dst(entry->pending)->len = sizeof(struct net_eth_addr);
    bcd0:	8b 53 14             	mov    0x14(%ebx),%edx
	net_pkt_lladdr_dst(entry->pending)->addr =
    bcd3:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return pkt->frags->data;
    bcd6:	8b 42 14             	mov    0x14(%edx),%eax
	net_pkt_lladdr_dst(entry->pending)->len = sizeof(struct net_eth_addr);
    bcd9:	c6 42 38 06          	movb   $0x6,0x38(%edx)
	net_pkt_lladdr_dst(entry->pending)->addr =
    bcdd:	8b 40 08             	mov    0x8(%eax),%eax
    bce0:	89 42 34             	mov    %eax,0x34(%edx)
	NET_DBG("dst %s pending %p frag %p",
		log_strdup(net_sprint_ipv4_addr(&entry->ip)),
		entry->pending, entry->pending->frags);

	pkt = entry->pending;
	entry->pending = NULL;
    bce3:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)

	memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
    bcea:	6a 06                	push   $0x6
    bcec:	8d 43 14             	lea    0x14(%ebx),%eax
    bcef:	57                   	push   %edi
    bcf0:	50                   	push   %eax
    bcf1:	e8 3b ec ff ff       	call   a931 <memcpy>
Z_GENLIST_PREPEND(slist, snode)
    bcf6:	a1 7c 42 40 00       	mov    0x40427c,%eax
    bcfb:	83 c4 0c             	add    $0xc,%esp
	parent->next = child;
    bcfe:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(slist, snode)
    bd00:	8b 55 ec             	mov    -0x14(%ebp),%edx
	list->head = node;
    bd03:	89 1d 7c 42 40 00    	mov    %ebx,0x40427c
Z_GENLIST_PREPEND(slist, snode)
    bd09:	83 3d 80 42 40 00 00 	cmpl   $0x0,0x404280
    bd10:	75 06                	jne    bd18 <arp_update+0x119>
	list->tail = node;
    bd12:	89 1d 80 42 40 00    	mov    %ebx,0x404280

	/* Inserting entry into the table */
	sys_slist_prepend(&arp_table, &entry->node);

	net_if_queue_tx(iface, pkt);
    bd18:	52                   	push   %edx
    bd19:	56                   	push   %esi
    bd1a:	e8 2e 22 00 00       	call   df4d <net_if_queue_tx>
    bd1f:	58                   	pop    %eax
    bd20:	5a                   	pop    %edx
}
    bd21:	8d 65 f4             	lea    -0xc(%ebp),%esp
    bd24:	5b                   	pop    %ebx
    bd25:	5e                   	pop    %esi
    bd26:	5f                   	pop    %edi
    bd27:	5d                   	pop    %ebp
    bd28:	c3                   	ret    

0000bd29 <net_arp_prepare>:
{
    bd29:	55                   	push   %ebp
    bd2a:	89 e5                	mov    %esp,%ebp
    bd2c:	57                   	push   %edi
    bd2d:	56                   	push   %esi
    bd2e:	53                   	push   %ebx
    bd2f:	83 ec 0c             	sub    $0xc,%esp
    bd32:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!pkt || !pkt->buffer) {
    bd35:	85 ff                	test   %edi,%edi
    bd37:	74 64                	je     bd9d <net_arp_prepare+0x74>
    bd39:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
    bd3d:	74 5e                	je     bd9d <net_arp_prepare+0x74>
	if (!current_ip &&
    bd3f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    bd43:	75 5f                	jne    bda4 <net_arp_prepare+0x7b>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
    bd45:	ff 75 0c             	pushl  0xc(%ebp)
    bd48:	ff 77 24             	pushl  0x24(%edi)
    bd4b:	e8 8b 35 00 00       	call   f2db <net_if_ipv4_addr_mask_cmp>
    bd50:	5b                   	pop    %ebx
	if (!current_ip &&
    bd51:	84 c0                	test   %al,%al
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
    bd53:	5e                   	pop    %esi
	if (!current_ip &&
    bd54:	75 4e                	jne    bda4 <net_arp_prepare+0x7b>
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
    bd56:	8b 57 24             	mov    0x24(%edi),%edx
    bd59:	8b 42 08             	mov    0x8(%edx),%eax
		if (ipv4) {
    bd5c:	85 c0                	test   %eax,%eax
    bd5e:	74 44                	je     bda4 <net_arp_prepare+0x7b>
			addr = &ipv4->gw;
    bd60:	8d 88 08 01 00 00    	lea    0x108(%eax),%ecx
    bd66:	89 4d 0c             	mov    %ecx,0xc(%ebp)
			if (net_ipv4_is_addr_unspecified(addr)) {
    bd69:	83 b8 08 01 00 00 00 	cmpl   $0x0,0x108(%eax)
    bd70:	75 32                	jne    bda4 <net_arp_prepare+0x7b>
				NET_ERR("Gateway not set for iface %p",
    bd72:	f6 05 60 a8 40 00 07 	testb  $0x7,0x40a860
    bd79:	74 22                	je     bd9d <net_arp_prepare+0x74>
    bd7b:	b8 44 51 02 00       	mov    $0x25144,%eax
    bd80:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    bd85:	c1 e8 03             	shr    $0x3,%eax
    bd88:	c1 e0 06             	shl    $0x6,%eax
    bd8b:	83 c8 01             	or     $0x1,%eax
    bd8e:	50                   	push   %eax
    bd8f:	52                   	push   %edx
    bd90:	68 e2 78 02 00       	push   $0x278e2
    bd95:	e8 15 77 ff ff       	call   34af <log_1>
    bd9a:	83 c4 0c             	add    $0xc,%esp
				return NULL;
    bd9d:	31 f6                	xor    %esi,%esi
    bd9f:	e9 4d 02 00 00       	jmp    bff1 <net_arp_prepare+0x2c8>
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
    bda4:	8d 45 f0             	lea    -0x10(%ebp),%eax
	entry = arp_entry_find_move_first(net_pkt_iface(pkt), addr);
    bda7:	8b 57 24             	mov    0x24(%edi),%edx
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
    bdaa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    bdad:	50                   	push   %eax
    bdae:	b8 7c 42 40 00       	mov    $0x40427c,%eax
	sys_snode_t *prev = NULL;
    bdb3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
    bdba:	e8 c2 fc ff ff       	call   ba81 <arp_entry_find>
    bdbf:	59                   	pop    %ecx
    bdc0:	89 c3                	mov    %eax,%ebx
	if (entry) {
    bdc2:	85 c0                	test   %eax,%eax
    bdc4:	74 40                	je     be06 <net_arp_prepare+0xdd>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
    bdc6:	3b 05 7c 42 40 00    	cmp    0x40427c,%eax
    bdcc:	0f 84 04 02 00 00    	je     bfd6 <net_arp_prepare+0x2ad>
			sys_slist_remove(&arp_table, prev, &entry->node);
    bdd2:	89 c1                	mov    %eax,%ecx
    bdd4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bdd7:	b8 7c 42 40 00       	mov    $0x40427c,%eax
    bddc:	e8 77 fc ff ff       	call   ba58 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    bde1:	a1 7c 42 40 00       	mov    0x40427c,%eax
	parent->next = child;
    bde6:	89 03                	mov    %eax,(%ebx)
	list->head = node;
    bde8:	89 1d 7c 42 40 00    	mov    %ebx,0x40427c
Z_GENLIST_PREPEND(slist, snode)
    bdee:	83 3d 80 42 40 00 00 	cmpl   $0x0,0x404280
    bdf5:	0f 85 db 01 00 00    	jne    bfd6 <net_arp_prepare+0x2ad>
	list->tail = node;
    bdfb:	89 1d 80 42 40 00    	mov    %ebx,0x404280
    be01:	e9 d0 01 00 00       	jmp    bfd6 <net_arp_prepare+0x2ad>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
    be06:	8b 57 24             	mov    0x24(%edi),%edx
    be09:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    be0c:	b8 84 42 40 00       	mov    $0x404284,%eax
    be11:	6a 00                	push   $0x0
    be13:	e8 69 fc ff ff       	call   ba81 <arp_entry_find>
    be18:	5a                   	pop    %edx
		if (!entry) {
    be19:	85 c0                	test   %eax,%eax
    be1b:	75 47                	jne    be64 <net_arp_prepare+0x13b>
	node = sys_slist_peek_head(&arp_free_entries);
    be1d:	8b 35 8c 42 40 00    	mov    0x40428c,%esi
	if (!node) {
    be23:	85 f6                	test   %esi,%esi
    be25:	75 11                	jne    be38 <net_arp_prepare+0x10f>
	node = sys_slist_peek_tail(&arp_table);
    be27:	8b 1d 80 42 40 00    	mov    0x404280,%ebx
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    be2d:	a1 7c 42 40 00       	mov    0x40427c,%eax
	if (!node) {
    be32:	85 db                	test   %ebx,%ebx
    be34:	75 18                	jne    be4e <net_arp_prepare+0x125>
    be36:	eb 2c                	jmp    be64 <net_arp_prepare+0x13b>
	sys_slist_remove(&arp_free_entries, NULL, node);
    be38:	89 f1                	mov    %esi,%ecx
    be3a:	31 d2                	xor    %edx,%edx
    be3c:	b8 8c 42 40 00       	mov    $0x40428c,%eax
    be41:	89 f3                	mov    %esi,%ebx
    be43:	e8 10 fc ff ff       	call   ba58 <sys_slist_remove>
			if (!entry) {
    be48:	eb 1a                	jmp    be64 <net_arp_prepare+0x13b>
    be4a:	89 c6                	mov    %eax,%esi
    be4c:	8b 00                	mov    (%eax),%eax
    be4e:	85 c0                	test   %eax,%eax
    be50:	74 12                	je     be64 <net_arp_prepare+0x13b>
    be52:	39 c3                	cmp    %eax,%ebx
    be54:	75 f4                	jne    be4a <net_arp_prepare+0x121>
    be56:	89 d9                	mov    %ebx,%ecx
    be58:	89 f2                	mov    %esi,%edx
    be5a:	b8 7c 42 40 00       	mov    $0x40427c,%eax
    be5f:	e8 f4 fb ff ff       	call   ba58 <sys_slist_remove>
		req = arp_prepare(net_pkt_iface(pkt), addr, entry, pkt,
    be64:	8b 47 24             	mov    0x24(%edi),%eax
	if (current_ip) {
    be67:	89 fe                	mov    %edi,%esi
		req = arp_prepare(net_pkt_iface(pkt), addr, entry, pkt,
    be69:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (current_ip) {
    be6c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    be70:	75 1b                	jne    be8d <net_arp_prepare+0x164>
		pkt = net_pkt_alloc_with_buffer(iface,
    be72:	6a 64                	push   $0x64
    be74:	6a 00                	push   $0x0
    be76:	6a 00                	push   $0x0
    be78:	6a 1c                	push   $0x1c
    be7a:	50                   	push   %eax
    be7b:	e8 35 44 00 00       	call   102b5 <net_pkt_alloc_with_buffer>
    be80:	83 c4 14             	add    $0x14,%esp
    be83:	89 c6                	mov    %eax,%esi
		if (!pkt) {
    be85:	85 c0                	test   %eax,%eax
    be87:	0f 84 10 ff ff ff    	je     bd9d <net_arp_prepare+0x74>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
    be8d:	8b 46 14             	mov    0x14(%esi),%eax
    be90:	6a 1c                	push   $0x1c
    be92:	83 c0 08             	add    $0x8,%eax
    be95:	50                   	push   %eax
    be96:	e8 60 fb ff ff       	call   b9fb <net_buf_simple_add>
    be9b:	58                   	pop    %eax
    be9c:	8b 46 14             	mov    0x14(%esi),%eax
    be9f:	5a                   	pop    %edx
	if (entry) {
    bea0:	85 db                	test   %ebx,%ebx
    bea2:	8b 40 08             	mov    0x8(%eax),%eax
    bea5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    bea8:	0f 84 91 00 00 00    	je     bf3f <net_arp_prepare+0x216>
		entry->pending = net_pkt_ref(pending);
    beae:	57                   	push   %edi
    beaf:	e8 16 3f 00 00       	call   fdca <net_pkt_ref>
    beb4:	59                   	pop    %ecx
    beb5:	89 43 14             	mov    %eax,0x14(%ebx)
		entry->iface = net_pkt_iface(pkt);
    beb8:	8b 46 24             	mov    0x24(%esi),%eax
		net_ipaddr_copy(&entry->ip, next_addr);
    bebb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		entry->iface = net_pkt_iface(pkt);
    bebe:	89 43 0c             	mov    %eax,0xc(%ebx)
			(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    bec1:	8b 00                	mov    (%eax),%eax
		net_ipaddr_copy(&entry->ip, next_addr);
    bec3:	8b 11                	mov    (%ecx),%edx
    bec5:	89 53 10             	mov    %edx,0x10(%ebx)
			(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    bec8:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
    becb:	89 46 2c             	mov    %eax,0x2c(%esi)
	parent->next = child;
    bece:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_APPEND(slist, snode)
    bed4:	a1 88 42 40 00       	mov    0x404288,%eax
    bed9:	85 c0                	test   %eax,%eax
    bedb:	75 0e                	jne    beeb <net_arp_prepare+0x1c2>
	list->tail = node;
    bedd:	89 1d 88 42 40 00    	mov    %ebx,0x404288
	list->head = node;
    bee3:	89 1d 84 42 40 00    	mov    %ebx,0x404284
    bee9:	eb 08                	jmp    bef3 <net_arp_prepare+0x1ca>
	parent->next = child;
    beeb:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    beed:	89 1d 88 42 40 00    	mov    %ebx,0x404288
    bef3:	e8 19 8a 01 00       	call   24911 <z_impl_k_uptime_get>
	entry->req_start = k_uptime_get();
    bef8:	89 53 08             	mov    %edx,0x8(%ebx)
    befb:	89 43 04             	mov    %eax,0x4(%ebx)
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
    befe:	68 cc 06 40 00       	push   $0x4006cc
    bf03:	e8 31 88 01 00       	call   24739 <z_timeout_remaining>
{
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    bf08:	ba e8 03 00 00       	mov    $0x3e8,%edx
    bf0d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    bf14:	f7 ea                	imul   %edx
    bf16:	6a 64                	push   $0x64
    bf18:	52                   	push   %edx
    bf19:	50                   	push   %eax
    bf1a:	e8 ce 52 ff ff       	call   11ed <__udivdi3>
    bf1f:	83 c4 10             	add    $0x10,%esp
	if (!k_delayed_work_remaining_get(&arp_request_timer)) {
    bf22:	85 c0                	test   %eax,%eax
    bf24:	75 24                	jne    bf4a <net_arp_prepare+0x221>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    bf26:	68 d0 07 00 00       	push   $0x7d0
    bf2b:	68 c0 06 40 00       	push   $0x4006c0
    bf30:	68 60 41 40 00       	push   $0x404160
    bf35:	e8 9b 85 01 00       	call   244d5 <k_delayed_work_submit_to_queue>
    bf3a:	83 c4 0c             	add    $0xc,%esp
    bf3d:	eb 0b                	jmp    bf4a <net_arp_prepare+0x221>
			(u8_t *)net_if_get_link_addr(iface)->addr;
    bf3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf42:	8b 00                	mov    (%eax),%eax
    bf44:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
    bf47:	89 46 2c             	mov    %eax,0x2c(%esi)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
    bf4a:	c6 46 30 06          	movb   $0x6,0x30(%esi)
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)net_eth_broadcast_addr();
    bf4e:	e8 6b 08 00 00       	call   c7be <net_eth_broadcast_addr>
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    bf53:	c6 46 38 06          	movb   $0x6,0x38(%esi)
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)net_eth_broadcast_addr();
    bf57:	89 46 34             	mov    %eax,0x34(%esi)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    bf5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
    bf5d:	83 c0 12             	add    $0x12,%eax
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    bf60:	c7 40 ee 00 01 08 00 	movl   $0x80100,-0x12(%eax)
	hdr->hwlen = sizeof(struct net_eth_addr);
    bf67:	c7 40 f2 06 04 00 01 	movl   $0x1000406,-0xe(%eax)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
    bf6e:	6a 06                	push   $0x6
    bf70:	6a 00                	push   $0x0
    bf72:	50                   	push   %eax
    bf73:	e8 28 ea ff ff       	call   a9a0 <memset>
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    bf78:	8b 45 0c             	mov    0xc(%ebp),%eax
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
    bf7b:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    bf7e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    bf81:	8b 00                	mov    (%eax),%eax
    bf83:	89 41 18             	mov    %eax,0x18(%ecx)
	memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
    bf86:	6a 06                	push   $0x6
    bf88:	ff 76 2c             	pushl  0x2c(%esi)
    bf8b:	89 c8                	mov    %ecx,%eax
    bf8d:	83 c0 08             	add    $0x8,%eax
    bf90:	50                   	push   %eax
    bf91:	e8 9b e9 ff ff       	call   a931 <memcpy>
    bf96:	83 c4 0c             	add    $0xc,%esp
	if (entry) {
    bf99:	85 db                	test   %ebx,%ebx
    bf9b:	74 11                	je     bfae <net_arp_prepare+0x285>
		my_addr = if_get_addr(entry->iface, current_ip);
    bf9d:	8b 43 0c             	mov    0xc(%ebx),%eax
    bfa0:	8b 55 10             	mov    0x10(%ebp),%edx
    bfa3:	8b 40 08             	mov    0x8(%eax),%eax
    bfa6:	e8 46 fb ff ff       	call   baf1 <if_get_addr.isra.14>
    bfab:	89 45 10             	mov    %eax,0x10(%ebp)
	if (my_addr) {
    bfae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    bfb2:	74 0d                	je     bfc1 <net_arp_prepare+0x298>
		net_ipaddr_copy(&hdr->src_ipaddr, my_addr);
    bfb4:	8b 45 10             	mov    0x10(%ebp),%eax
    bfb7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    bfba:	8b 00                	mov    (%eax),%eax
    bfbc:	89 41 0e             	mov    %eax,0xe(%ecx)
    bfbf:	eb 30                	jmp    bff1 <net_arp_prepare+0x2c8>
		(void)memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
    bfc1:	6a 04                	push   $0x4
    bfc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bfc6:	6a 00                	push   $0x0
    bfc8:	83 c0 0e             	add    $0xe,%eax
    bfcb:	50                   	push   %eax
    bfcc:	e8 cf e9 ff ff       	call   a9a0 <memset>
    bfd1:	83 c4 0c             	add    $0xc,%esp
    bfd4:	eb 1b                	jmp    bff1 <net_arp_prepare+0x2c8>
		(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    bfd6:	8b 43 0c             	mov    0xc(%ebx),%eax
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&entry->eth;
    bfd9:	83 c3 14             	add    $0x14,%ebx
	return pkt;
    bfdc:	89 fe                	mov    %edi,%esi
		(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    bfde:	8b 00                	mov    (%eax),%eax
    bfe0:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
    bfe3:	c6 47 30 06          	movb   $0x6,0x30(%edi)
	net_pkt_lladdr_src(pkt)->addr =
    bfe7:	89 47 2c             	mov    %eax,0x2c(%edi)
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&entry->eth;
    bfea:	89 5f 34             	mov    %ebx,0x34(%edi)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    bfed:	c6 47 38 06          	movb   $0x6,0x38(%edi)
}
    bff1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    bff4:	89 f0                	mov    %esi,%eax
    bff6:	5b                   	pop    %ebx
    bff7:	5e                   	pop    %esi
    bff8:	5f                   	pop    %edi
    bff9:	5d                   	pop    %ebp
    bffa:	c3                   	ret    

0000bffb <net_arp_input>:
	return true;
}

enum net_verdict net_arp_input(struct net_pkt *pkt,
			       struct net_eth_hdr *eth_hdr)
{
    bffb:	55                   	push   %ebp
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
    bffc:	31 d2                	xor    %edx,%edx
    bffe:	89 e5                	mov    %esp,%ebp
    c000:	57                   	push   %edi
    c001:	56                   	push   %esi
    c002:	53                   	push   %ebx
    c003:	83 ec 10             	sub    $0x10,%esp
    c006:	8b 75 08             	mov    0x8(%ebp),%esi
    c009:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
    c00c:	8b 4e 14             	mov    0x14(%esi),%ecx
    c00f:	89 c8                	mov    %ecx,%eax

	while (buf) {
    c011:	85 c0                	test   %eax,%eax
    c013:	74 0a                	je     c01f <__data_size+0x1f>
		bytes += buf->len;
    c015:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
		buf = buf->frags;
    c019:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    c01b:	01 da                	add    %ebx,%edx
		buf = buf->frags;
    c01d:	eb f2                	jmp    c011 <__data_size+0x11>
	return pkt->frags->data;
    c01f:	8b 59 08             	mov    0x8(%ecx),%ebx
    c022:	89 f8                	mov    %edi,%eax
    c024:	29 d8                	sub    %ebx,%eax
    c026:	83 c0 1c             	add    $0x1c,%eax
    c029:	39 d0                	cmp    %edx,%eax
    c02b:	76 0a                	jbe    c037 <__data_size+0x37>
				    (net_pkt_ip_data(pkt) - (u8_t *)eth_hdr))) {
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes) %p",
			net_pkt_get_len(pkt), sizeof(struct net_arp_hdr) -
			(net_pkt_ip_data(pkt) - (u8_t *)eth_hdr), pkt);
		return NET_DROP;
    c02d:	b8 02 00 00 00       	mov    $0x2,%eax
    c032:	e9 23 02 00 00       	jmp    c25a <__data_size+0x25a>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
    c037:	66 81 3b 00 01       	cmpw   $0x100,(%ebx)
    c03c:	75 ef                	jne    c02d <__data_size+0x2d>
    c03e:	66 83 7b 02 08       	cmpw   $0x8,0x2(%ebx)
    c043:	75 e8                	jne    c02d <__data_size+0x2d>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
    c045:	80 7b 04 06          	cmpb   $0x6,0x4(%ebx)
    c049:	75 e2                	jne    c02d <__data_size+0x2d>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
    c04b:	80 7b 05 04          	cmpb   $0x4,0x5(%ebx)
    c04f:	75 dc                	jne    c02d <__data_size+0x2d>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
    c051:	80 7b 0e 7f          	cmpb   $0x7f,0xe(%ebx)
    c055:	74 d6                	je     c02d <__data_size+0x2d>
	arp_hdr = NET_ARP_HDR(pkt);
	if (!arp_hdr_check(arp_hdr)) {
		return NET_DROP;
	}

	switch (ntohs(arp_hdr->opcode)) {
    c057:	66 8b 43 06          	mov    0x6(%ebx),%ax
    c05b:	86 e0                	xchg   %ah,%al
    c05d:	66 83 f8 01          	cmp    $0x1,%ax
    c061:	74 0f                	je     c072 <__data_size+0x72>
    c063:	66 83 f8 02          	cmp    $0x2,%ax
    c067:	0f 84 a0 01 00 00    	je     c20d <__data_size+0x20d>
    c06d:	e9 df 01 00 00       	jmp    c251 <__data_size+0x251>
	case NET_ARP_REQUEST:
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS)) {
			if (memcmp(&eth_hdr->dst,
				   net_eth_broadcast_addr(),
    c072:	e8 47 07 00 00       	call   c7be <net_eth_broadcast_addr>
			if (memcmp(&eth_hdr->dst,
    c077:	6a 06                	push   $0x6
    c079:	50                   	push   %eax
    c07a:	57                   	push   %edi
    c07b:	e8 46 e8 ff ff       	call   a8c6 <memcmp>
    c080:	83 c4 0c             	add    $0xc,%esp
    c083:	85 c0                	test   %eax,%eax
    c085:	75 43                	jne    c0ca <__data_size+0xca>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_hwaddr,
				   net_eth_broadcast_addr(),
    c087:	e8 32 07 00 00       	call   c7be <net_eth_broadcast_addr>
			    memcmp(&arp_hdr->dst_hwaddr,
    c08c:	6a 06                	push   $0x6
    c08e:	50                   	push   %eax
    c08f:	8d 43 12             	lea    0x12(%ebx),%eax
    c092:	50                   	push   %eax
    c093:	e8 2e e8 ff ff       	call   a8c6 <memcmp>
    c098:	83 c4 0c             	add    $0xc,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
    c09b:	85 c0                	test   %eax,%eax
    c09d:	75 2b                	jne    c0ca <__data_size+0xca>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
    c09f:	8d 53 0e             	lea    0xe(%ebx),%edx
    c0a2:	6a 04                	push   $0x4
    c0a4:	52                   	push   %edx
    c0a5:	8d 43 18             	lea    0x18(%ebx),%eax
    c0a8:	89 55 f0             	mov    %edx,-0x10(%ebp)
    c0ab:	50                   	push   %eax
    c0ac:	e8 15 e8 ff ff       	call   a8c6 <memcmp>
    c0b1:	83 c4 0c             	add    $0xc,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
    c0b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c0b7:	85 c0                	test   %eax,%eax
    c0b9:	75 0f                	jne    c0ca <__data_size+0xca>
				   sizeof(struct in_addr)) == 0) {
				/* If the IP address is in our cache,
				 * then update it here.
				 */
				arp_update(net_pkt_iface(pkt),
    c0bb:	8b 46 24             	mov    0x24(%esi),%eax
    c0be:	6a 00                	push   $0x0
    c0c0:	8d 4b 08             	lea    0x8(%ebx),%ecx
    c0c3:	6a 01                	push   $0x1
    c0c5:	e9 70 01 00 00       	jmp    c23a <__data_size+0x23a>
		}

		/* Discard ARP request if Ethernet address is broadcast
		 * and Source IP address is Multicast address.
		 */
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
    c0ca:	e8 ef 06 00 00       	call   c7be <net_eth_broadcast_addr>
    c0cf:	6a 06                	push   $0x6
    c0d1:	50                   	push   %eax
    c0d2:	57                   	push   %edi
    c0d3:	e8 ee e7 ff ff       	call   a8c6 <memcmp>
    c0d8:	83 c4 0c             	add    $0xc,%esp
    c0db:	85 c0                	test   %eax,%eax
    c0dd:	75 15                	jne    c0f4 <__data_size+0xf4>
 *
 * @return True if address is multicast address, False otherwise.
 */
static inline bool net_ipv4_is_addr_mcast(const struct in_addr *addr)
{
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
    c0df:	8b 43 0e             	mov    0xe(%ebx),%eax
    c0e2:	0f c8                	bswap  %eax
    c0e4:	25 00 00 00 e0       	and    $0xe0000000,%eax
			   sizeof(struct net_eth_addr)) == 0 &&
    c0e9:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
    c0ee:	0f 84 39 ff ff ff    	je     c02d <__data_size+0x2d>
			NET_DBG("DROP: eth addr is bcast, src addr is mcast");
			return NET_DROP;
		}

		/* Someone wants to know our ll address */
		addr = if_get_addr(net_pkt_iface(pkt), &arp_hdr->dst_ipaddr);
    c0f4:	8b 46 24             	mov    0x24(%esi),%eax
    c0f7:	8d 53 18             	lea    0x18(%ebx),%edx
    c0fa:	8b 40 08             	mov    0x8(%eax),%eax
    c0fd:	e8 ef f9 ff ff       	call   baf1 <if_get_addr.isra.14>
		if (!addr) {
    c102:	85 c0                	test   %eax,%eax
    c104:	0f 84 23 ff ff ff    	je     c02d <__data_size+0x2d>

		/* Update the ARP cache if the sender MAC address has
		 * changed. In this case the target MAC address is all zeros
		 * and the target IP address is our address.
		 */
		if (memcmp(&eth_hdr->src, &arp_hdr->src_hwaddr,
    c10a:	6a 06                	push   $0x6
    c10c:	8d 4b 08             	lea    0x8(%ebx),%ecx
    c10f:	8d 47 06             	lea    0x6(%edi),%eax
    c112:	51                   	push   %ecx
    c113:	50                   	push   %eax
    c114:	89 45 f0             	mov    %eax,-0x10(%ebp)
    c117:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    c11a:	e8 a7 e7 ff ff       	call   a8c6 <memcmp>
    c11f:	83 c4 0c             	add    $0xc,%esp
    c122:	85 c0                	test   %eax,%eax
    c124:	75 38                	jne    c15e <__data_size+0x15e>
	return false;
}

static inline bool net_eth_is_addr_unspecified(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0x00 &&
    c126:	80 7b 12 00          	cmpb   $0x0,0x12(%ebx)
    c12a:	75 32                	jne    c15e <__data_size+0x15e>
    c12c:	80 7b 13 00          	cmpb   $0x0,0x13(%ebx)
    c130:	75 2c                	jne    c15e <__data_size+0x15e>
	    addr->addr[1] == 0x00 &&
    c132:	80 7b 14 00          	cmpb   $0x0,0x14(%ebx)
    c136:	75 26                	jne    c15e <__data_size+0x15e>
	    addr->addr[2] == 0x00 &&
    c138:	80 7b 15 00          	cmpb   $0x0,0x15(%ebx)
    c13c:	75 20                	jne    c15e <__data_size+0x15e>
	    addr->addr[3] == 0x00 &&
    c13e:	80 7b 16 00          	cmpb   $0x0,0x16(%ebx)
    c142:	75 1a                	jne    c15e <__data_size+0x15e>
	    addr->addr[4] == 0x00 &&
    c144:	80 7b 17 00          	cmpb   $0x0,0x17(%ebx)
    c148:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    c14b:	75 11                	jne    c15e <__data_size+0x15e>
						 &arp_hdr->src_ipaddr)),
				log_strdup(net_sprint_ll_addr(
						 (u8_t *)&arp_hdr->src_hwaddr,
						 arp_hdr->hwlen)));

			arp_update(net_pkt_iface(pkt),
    c14d:	8b 46 24             	mov    0x24(%esi),%eax
    c150:	6a 01                	push   $0x1
    c152:	6a 00                	push   $0x0
    c154:	8d 53 0e             	lea    0xe(%ebx),%edx
    c157:	e8 a3 fa ff ff       	call   bbff <arp_update>
    c15c:	59                   	pop    %ecx
    c15d:	5b                   	pop    %ebx
				   &arp_hdr->src_hwaddr,
				   false, true);
		}

		/* Send reply */
		reply = arp_prepare_reply(net_pkt_iface(pkt), pkt, eth_hdr);
    c15e:	8b 7e 24             	mov    0x24(%esi),%edi
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
    c161:	6a 64                	push   $0x64
    c163:	6a 00                	push   $0x0
    c165:	6a 00                	push   $0x0
    c167:	6a 1c                	push   $0x1c
    c169:	57                   	push   %edi
    c16a:	e8 46 41 00 00       	call   102b5 <net_pkt_alloc_with_buffer>
    c16f:	83 c4 14             	add    $0x14,%esp
    c172:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
    c174:	85 c0                	test   %eax,%eax
    c176:	0f 84 d5 00 00 00    	je     c251 <__data_size+0x251>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
    c17c:	8b 40 14             	mov    0x14(%eax),%eax
    c17f:	6a 1c                	push   $0x1c
    c181:	83 c0 08             	add    $0x8,%eax
    c184:	50                   	push   %eax
    c185:	e8 71 f8 ff ff       	call   b9fb <net_buf_simple_add>
    c18a:	58                   	pop    %eax
	return pkt->frags->data;
    c18b:	8b 43 14             	mov    0x14(%ebx),%eax
    c18e:	5a                   	pop    %edx
    c18f:	8b 50 08             	mov    0x8(%eax),%edx
    c192:	8b 46 14             	mov    0x14(%esi),%eax
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
    c195:	89 55 e8             	mov    %edx,-0x18(%ebp)
    c198:	8b 48 08             	mov    0x8(%eax),%ecx
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    c19b:	c7 02 00 01 08 00    	movl   $0x80100,(%edx)
	hdr->hwlen = sizeof(struct net_eth_addr);
    c1a1:	c7 42 04 06 04 00 02 	movl   $0x2000406,0x4(%edx)
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
    c1a8:	6a 06                	push   $0x6
    c1aa:	ff 75 f0             	pushl  -0x10(%ebp)
    c1ad:	8d 42 12             	lea    0x12(%edx),%eax
    c1b0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    c1b3:	50                   	push   %eax
    c1b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c1b7:	e8 75 e7 ff ff       	call   a931 <memcpy>
    c1bc:	83 c4 0c             	add    $0xc,%esp
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
    c1bf:	8b 07                	mov    (%edi),%eax
    c1c1:	6a 06                	push   $0x6
    c1c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c1c6:	ff 70 10             	pushl  0x10(%eax)
    c1c9:	8d 42 08             	lea    0x8(%edx),%eax
    c1cc:	89 55 f0             	mov    %edx,-0x10(%ebp)
    c1cf:	50                   	push   %eax
    c1d0:	e8 5c e7 ff ff       	call   a931 <memcpy>
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
    c1d5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    c1d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
    c1db:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
    c1de:	8b 41 0e             	mov    0xe(%ecx),%eax
    c1e1:	89 42 18             	mov    %eax,0x18(%edx)
	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
    c1e4:	8b 41 18             	mov    0x18(%ecx),%eax
    c1e7:	89 42 0e             	mov    %eax,0xe(%edx)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
    c1ea:	8b 07                	mov    (%edi),%eax
    c1ec:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
    c1ef:	c6 43 30 06          	movb   $0x6,0x30(%ebx)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
    c1f3:	89 43 2c             	mov    %eax,0x2c(%ebx)
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&hdr->dst_hwaddr.addr;
    c1f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c1f9:	89 43 34             	mov    %eax,0x34(%ebx)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    c1fc:	c6 43 38 06          	movb   $0x6,0x38(%ebx)
		if (reply) {
			net_if_queue_tx(net_pkt_iface(reply), reply);
    c200:	53                   	push   %ebx
    c201:	ff 73 24             	pushl  0x24(%ebx)
    c204:	e8 44 1d 00 00       	call   df4d <net_if_queue_tx>
    c209:	5b                   	pop    %ebx
    c20a:	5f                   	pop    %edi
    c20b:	eb 44                	jmp    c251 <__data_size+0x251>
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
    c20d:	6a 00                	push   $0x0
			NET_DBG("Cannot send ARP reply");
		}
		break;

	case NET_ARP_REPLY:
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
    c20f:	8d 7b 18             	lea    0x18(%ebx),%edi
    c212:	57                   	push   %edi
    c213:	e8 c4 32 00 00       	call   f4dc <net_if_ipv4_addr_lookup>
    c218:	5a                   	pop    %edx
    c219:	85 c0                	test   %eax,%eax
    c21b:	59                   	pop    %ecx
    c21c:	0f 95 c2             	setne  %dl
	if (!ret) {
    c21f:	75 2c                	jne    c24d <__data_size+0x24d>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    c221:	e8 86 52 00 00       	call   114ac <net_ipv4_broadcast_address>
    c226:	8b 00                	mov    (%eax),%eax
    c228:	39 43 18             	cmp    %eax,0x18(%ebx)
    c22b:	75 14                	jne    c241 <__data_size+0x241>
			arp_update(net_pkt_iface(pkt),
    c22d:	8b 46 24             	mov    0x24(%esi),%eax
    c230:	6a 00                	push   $0x0
    c232:	8d 4b 08             	lea    0x8(%ebx),%ecx
    c235:	8d 53 0e             	lea    0xe(%ebx),%edx
    c238:	6a 00                	push   $0x0
    c23a:	e8 c0 f9 ff ff       	call   bbff <arp_update>
    c23f:	eb c8                	jmp    c209 <__data_size+0x209>
	return net_if_ipv4_is_addr_bcast(iface, addr);
    c241:	57                   	push   %edi
    c242:	6a 00                	push   $0x0
    c244:	e8 1b 31 00 00       	call   f364 <net_if_ipv4_is_addr_bcast>
    c249:	5a                   	pop    %edx
    c24a:	88 c2                	mov    %al,%dl
    c24c:	59                   	pop    %ecx
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
    c24d:	84 d2                	test   %dl,%dl
    c24f:	75 dc                	jne    c22d <__data_size+0x22d>
		}

		break;
	}

	net_pkt_unref(pkt);
    c251:	56                   	push   %esi
    c252:	e8 aa 3b 00 00       	call   fe01 <net_pkt_unref>
    c257:	58                   	pop    %eax

	return NET_OK;
    c258:	31 c0                	xor    %eax,%eax
}
    c25a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c25d:	5b                   	pop    %ebx
    c25e:	5e                   	pop    %esi
    c25f:	5f                   	pop    %edi
    c260:	5d                   	pop    %ebp
    c261:	c3                   	ret    

0000c262 <net_arp_clear_cache>:

void net_arp_clear_cache(struct net_if *iface)
{
    c262:	55                   	push   %ebp
    c263:	89 e5                	mov    %esp,%ebp
    c265:	57                   	push   %edi
    c266:	56                   	push   %esi
    c267:	53                   	push   %ebx
    c268:	51                   	push   %ecx
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
    c269:	8b 1d 7c 42 40 00    	mov    0x40427c,%ebx
{
    c26f:	8b 75 08             	mov    0x8(%ebp),%esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
    c272:	85 db                	test   %ebx,%ebx
    c274:	75 0c                	jne    c282 <net_arp_clear_cache+0x20>

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    c276:	8b 1d 84 42 40 00    	mov    0x404284,%ebx
    c27c:	85 db                	test   %ebx,%ebx
    c27e:	75 68                	jne    c2e8 <net_arp_clear_cache+0x86>
    c280:	eb 55                	jmp    c2d7 <net_arp_clear_cache+0x75>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c282:	8b 3b                	mov    (%ebx),%edi
    c284:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (iface && iface != entry->iface) {
    c28b:	85 f6                	test   %esi,%esi
    c28d:	74 05                	je     c294 <net_arp_clear_cache+0x32>
    c28f:	39 73 0c             	cmp    %esi,0xc(%ebx)
    c292:	75 36                	jne    c2ca <net_arp_clear_cache+0x68>
		arp_entry_cleanup(entry, false);
    c294:	31 d2                	xor    %edx,%edx
    c296:	89 d8                	mov    %ebx,%eax
    c298:	e8 0e f8 ff ff       	call   baab <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
    c29d:	b8 7c 42 40 00       	mov    $0x40427c,%eax
    c2a2:	89 d9                	mov    %ebx,%ecx
    c2a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c2a7:	e8 ac f7 ff ff       	call   ba58 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    c2ac:	a1 8c 42 40 00       	mov    0x40428c,%eax
	parent->next = child;
    c2b1:	89 03                	mov    %eax,(%ebx)
	list->head = node;
    c2b3:	89 1d 8c 42 40 00    	mov    %ebx,0x40428c
Z_GENLIST_PREPEND(slist, snode)
    c2b9:	83 3d 90 42 40 00 00 	cmpl   $0x0,0x404290
    c2c0:	75 0b                	jne    c2cd <net_arp_clear_cache+0x6b>
	list->tail = node;
    c2c2:	89 1d 90 42 40 00    	mov    %ebx,0x404290
    c2c8:	eb 03                	jmp    c2cd <net_arp_clear_cache+0x6b>
			prev = &entry->node;
    c2ca:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
    c2cd:	85 ff                	test   %edi,%edi
    c2cf:	74 a5                	je     c276 <net_arp_clear_cache+0x14>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c2d1:	89 fb                	mov    %edi,%ebx
    c2d3:	8b 3f                	mov    (%edi),%edi
    c2d5:	eb b4                	jmp    c28b <net_arp_clear_cache+0x29>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
		k_delayed_work_cancel(&arp_request_timer);
    c2d7:	c7 45 08 c0 06 40 00 	movl   $0x4006c0,0x8(%ebp)
	}
}
    c2de:	5a                   	pop    %edx
    c2df:	5b                   	pop    %ebx
    c2e0:	5e                   	pop    %esi
    c2e1:	5f                   	pop    %edi
    c2e2:	5d                   	pop    %ebp
		k_delayed_work_cancel(&arp_request_timer);
    c2e3:	e9 bf 82 01 00       	jmp    245a7 <k_delayed_work_cancel>
    c2e8:	8b 3b                	mov    (%ebx),%edi
    c2ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (iface && iface != entry->iface) {
    c2f1:	85 f6                	test   %esi,%esi
    c2f3:	74 05                	je     c2fa <net_arp_clear_cache+0x98>
    c2f5:	39 73 0c             	cmp    %esi,0xc(%ebx)
    c2f8:	75 39                	jne    c333 <net_arp_clear_cache+0xd1>
		arp_entry_cleanup(entry, true);
    c2fa:	ba 01 00 00 00       	mov    $0x1,%edx
    c2ff:	89 d8                	mov    %ebx,%eax
    c301:	e8 a5 f7 ff ff       	call   baab <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
    c306:	b8 84 42 40 00       	mov    $0x404284,%eax
    c30b:	89 d9                	mov    %ebx,%ecx
    c30d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c310:	e8 43 f7 ff ff       	call   ba58 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    c315:	a1 8c 42 40 00       	mov    0x40428c,%eax
	parent->next = child;
    c31a:	89 03                	mov    %eax,(%ebx)
	list->head = node;
    c31c:	89 1d 8c 42 40 00    	mov    %ebx,0x40428c
Z_GENLIST_PREPEND(slist, snode)
    c322:	83 3d 90 42 40 00 00 	cmpl   $0x0,0x404290
    c329:	75 0b                	jne    c336 <net_arp_clear_cache+0xd4>
	list->tail = node;
    c32b:	89 1d 90 42 40 00    	mov    %ebx,0x404290
    c331:	eb 03                	jmp    c336 <net_arp_clear_cache+0xd4>
			prev = &entry->node;
    c333:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    c336:	85 ff                	test   %edi,%edi
    c338:	74 06                	je     c340 <net_arp_clear_cache+0xde>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c33a:	89 fb                	mov    %edi,%ebx
    c33c:	8b 3f                	mov    (%edi),%edi
    c33e:	eb b1                	jmp    c2f1 <net_arp_clear_cache+0x8f>
	if (sys_slist_is_empty(&arp_pending_entries)) {
    c340:	83 3d 84 42 40 00 00 	cmpl   $0x0,0x404284
    c347:	74 8e                	je     c2d7 <net_arp_clear_cache+0x75>
}
    c349:	58                   	pop    %eax
    c34a:	5b                   	pop    %ebx
    c34b:	5e                   	pop    %esi
    c34c:	5f                   	pop    %edi
    c34d:	5d                   	pop    %ebp
    c34e:	c3                   	ret    

0000c34f <net_arp_foreach>:

int net_arp_foreach(net_arp_cb_t cb, void *user_data)
{
    c34f:	55                   	push   %ebp
    c350:	89 e5                	mov    %esp,%ebp
    c352:	56                   	push   %esi
    c353:	53                   	push   %ebx
    c354:	31 f6                	xor    %esi,%esi
	int ret = 0;
	struct arp_entry *entry;

	SYS_SLIST_FOR_EACH_CONTAINER(&arp_table, entry, node) {
    c356:	8b 1d 7c 42 40 00    	mov    0x40427c,%ebx
    c35c:	85 db                	test   %ebx,%ebx
    c35e:	74 0e                	je     c36e <net_arp_foreach+0x1f>
		ret++;
		cb(entry, user_data);
    c360:	ff 75 0c             	pushl  0xc(%ebp)
		ret++;
    c363:	46                   	inc    %esi
		cb(entry, user_data);
    c364:	53                   	push   %ebx
    c365:	ff 55 08             	call   *0x8(%ebp)
    c368:	58                   	pop    %eax
    c369:	8b 1b                	mov    (%ebx),%ebx
    c36b:	5a                   	pop    %edx
	return node->next;
    c36c:	eb ee                	jmp    c35c <net_arp_foreach+0xd>
	}

	return ret;
}
    c36e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c371:	89 f0                	mov    %esi,%eax
    c373:	5b                   	pop    %ebx
    c374:	5e                   	pop    %esi
    c375:	5d                   	pop    %ebp
    c376:	c3                   	ret    

0000c377 <net_arp_init>:

void net_arp_init(void)
{
	int i;

	if (arp_cache_initialized) {
    c377:	80 3d 58 45 40 00 00 	cmpb   $0x0,0x404558
    c37e:	75 6d                	jne    c3ed <net_arp_init+0x76>
{
    c380:	55                   	push   %ebp
	list->head = NULL;
    c381:	c7 05 84 42 40 00 00 	movl   $0x0,0x404284
    c388:	00 00 00 
    c38b:	89 e5                	mov    %esp,%ebp
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free */
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
	}

	k_delayed_work_init(&arp_request_timer, arp_request_timeout);
    c38d:	68 3b bb 00 00       	push   $0xbb3b
    c392:	68 c0 06 40 00       	push   $0x4006c0
	list->tail = NULL;
    c397:	c7 05 88 42 40 00 00 	movl   $0x0,0x404288
    c39e:	00 00 00 
	list->head = NULL;
    c3a1:	c7 05 7c 42 40 00 00 	movl   $0x0,0x40427c
    c3a8:	00 00 00 
	list->tail = NULL;
    c3ab:	c7 05 80 42 40 00 00 	movl   $0x0,0x404280
    c3b2:	00 00 00 
	parent->next = child;
    c3b5:	c7 05 e0 06 40 00 00 	movl   $0x0,0x4006e0
    c3bc:	00 00 00 
	list->tail = node;
    c3bf:	c7 05 90 42 40 00 e0 	movl   $0x4006e0,0x404290
    c3c6:	06 40 00 
	parent->next = child;
    c3c9:	c7 05 fc 06 40 00 e0 	movl   $0x4006e0,0x4006fc
    c3d0:	06 40 00 
	list->head = node;
    c3d3:	c7 05 8c 42 40 00 fc 	movl   $0x4006fc,0x40428c
    c3da:	06 40 00 
    c3dd:	e8 c3 80 01 00       	call   244a5 <k_delayed_work_init>
    c3e2:	58                   	pop    %eax
    c3e3:	5a                   	pop    %edx

	arp_cache_initialized = true;
    c3e4:	c6 05 58 45 40 00 01 	movb   $0x1,0x404558
}
    c3eb:	c9                   	leave  
    c3ec:	c3                   	ret    
    c3ed:	c3                   	ret    

0000c3ee <net_eth_get_hw_capabilities>:
	return iface->if_dev->dev;
    c3ee:	8b 00                	mov    (%eax),%eax
    c3f0:	8b 10                	mov    (%eax),%edx
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		net_if_get_device(iface)->driver_api;

	if (!eth->get_capabilities) {
    c3f2:	8b 42 04             	mov    0x4(%edx),%eax
    c3f5:	8b 40 0c             	mov    0xc(%eax),%eax
    c3f8:	85 c0                	test   %eax,%eax
    c3fa:	74 09                	je     c405 <net_eth_get_hw_capabilities+0x17>
{
    c3fc:	55                   	push   %ebp
    c3fd:	89 e5                	mov    %esp,%ebp
		return 0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
    c3ff:	52                   	push   %edx
    c400:	ff d0                	call   *%eax
    c402:	5a                   	pop    %edx
}
    c403:	c9                   	leave  
    c404:	c3                   	ret    
		return 0;
    c405:	31 c0                	xor    %eax,%eax
}
    c407:	c3                   	ret    

0000c408 <ethernet_flags>:

	return 0;
}

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
    c408:	55                   	push   %ebp
    c409:	89 e5                	mov    %esp,%ebp
	return iface->if_dev->l2_data;
    c40b:	8b 45 08             	mov    0x8(%ebp),%eax
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
}
    c40e:	5d                   	pop    %ebp
    c40f:	8b 00                	mov    (%eax),%eax
	return ctx->ethernet_l2_flags;
    c411:	8b 40 08             	mov    0x8(%eax),%eax
    c414:	8a 40 10             	mov    0x10(%eax),%al
}
    c417:	c3                   	ret    

0000c418 <ethernet_enable>:
{
    c418:	55                   	push   %ebp
    c419:	89 e5                	mov    %esp,%ebp
    c41b:	56                   	push   %esi
    c41c:	53                   	push   %ebx
    c41d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!state) {
    c420:	80 7d 0c 00          	cmpb   $0x0,0xc(%ebp)
	return iface->if_dev->dev;
    c424:	8b 03                	mov    (%ebx),%eax
    c426:	8b 10                	mov    (%eax),%edx
	const struct ethernet_api *eth =
    c428:	8b 72 04             	mov    0x4(%edx),%esi
	if (!state) {
    c42b:	75 14                	jne    c441 <ethernet_enable+0x29>
		net_arp_clear_cache(iface);
    c42d:	53                   	push   %ebx
    c42e:	e8 2f fe ff ff       	call   c262 <net_arp_clear_cache>
		if (eth->stop) {
    c433:	8b 46 08             	mov    0x8(%esi),%eax
		net_arp_clear_cache(iface);
    c436:	5a                   	pop    %edx
		if (eth->stop) {
    c437:	85 c0                	test   %eax,%eax
    c439:	74 11                	je     c44c <ethernet_enable+0x34>
    c43b:	8b 13                	mov    (%ebx),%edx
			eth->stop(net_if_get_device(iface));
    c43d:	ff 32                	pushl  (%edx)
    c43f:	eb 08                	jmp    c449 <ethernet_enable+0x31>
		if (eth->start) {
    c441:	8b 46 04             	mov    0x4(%esi),%eax
    c444:	85 c0                	test   %eax,%eax
    c446:	74 04                	je     c44c <ethernet_enable+0x34>
			eth->start(net_if_get_device(iface));
    c448:	52                   	push   %edx
    c449:	ff d0                	call   *%eax
    c44b:	58                   	pop    %eax
}
    c44c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c44f:	31 c0                	xor    %eax,%eax
    c451:	5b                   	pop    %ebx
    c452:	5e                   	pop    %esi
    c453:	5d                   	pop    %ebp
    c454:	c3                   	ret    

0000c455 <ethernet_recv>:
{
    c455:	55                   	push   %ebp
    c456:	89 e5                	mov    %esp,%ebp
    c458:	57                   	push   %edi
    c459:	56                   	push   %esi
    c45a:	53                   	push   %ebx
    c45b:	51                   	push   %ecx
    c45c:	8b 75 0c             	mov    0xc(%ebp),%esi
    c45f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c462:	8b 46 14             	mov    0x14(%esi),%eax
    c465:	8b 58 08             	mov    0x8(%eax),%ebx
	u16_t type = ntohs(hdr->type);
    c468:	66 8b 43 0c          	mov    0xc(%ebx),%ax
    c46c:	86 e0                	xchg   %ah,%al
	switch (type) {
    c46e:	66 3d 06 08          	cmp    $0x806,%ax
	u16_t type = ntohs(hdr->type);
    c472:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	switch (type) {
    c476:	74 17                	je     c48f <ethernet_recv+0x3a>
    c478:	66 3d dd 86          	cmp    $0x86dd,%ax
    c47c:	74 24                	je     c4a2 <ethernet_recv+0x4d>
	return NET_DROP;
    c47e:	b8 02 00 00 00       	mov    $0x2,%eax
	switch (type) {
    c483:	66 81 7d f2 00 08    	cmpw   $0x800,-0xe(%ebp)
    c489:	0f 85 24 01 00 00    	jne    c5b3 <ethernet_recv+0x15e>
	pkt->family = family;
    c48f:	8a 46 3f             	mov    0x3f(%esi),%al
		family = AF_INET;
    c492:	bf 01 00 00 00       	mov    $0x1,%edi
    c497:	83 e0 f1             	and    $0xfffffff1,%eax
    c49a:	83 c8 02             	or     $0x2,%eax
    c49d:	88 46 3f             	mov    %al,0x3f(%esi)
		break;
    c4a0:	eb 11                	jmp    c4b3 <ethernet_recv+0x5e>
    c4a2:	8a 46 3f             	mov    0x3f(%esi),%al
		family = AF_INET6;
    c4a5:	bf 02 00 00 00       	mov    $0x2,%edi
    c4aa:	83 e0 f1             	and    $0xfffffff1,%eax
    c4ad:	83 c8 04             	or     $0x4,%eax
    c4b0:	88 46 3f             	mov    %al,0x3f(%esi)
	lladdr->addr = hdr->src.addr;
    c4b3:	8d 43 06             	lea    0x6(%ebx),%eax
	lladdr->len = sizeof(struct net_eth_addr);
    c4b6:	66 c7 46 30 06 03    	movw   $0x306,0x30(%esi)
	lladdr->addr = hdr->src.addr;
    c4bc:	89 46 2c             	mov    %eax,0x2c(%esi)
	lladdr->addr = hdr->dst.addr;
    c4bf:	89 5e 34             	mov    %ebx,0x34(%esi)
	lladdr->len = sizeof(struct net_eth_addr);
    c4c2:	66 c7 46 38 06 03    	movw   $0x306,0x38(%esi)
	if (addr->addr[0] == 0xff &&
    c4c8:	8a 03                	mov    (%ebx),%al
    c4ca:	3c ff                	cmp    $0xff,%al
    c4cc:	75 25                	jne    c4f3 <ethernet_recv+0x9e>
    c4ce:	80 7b 01 ff          	cmpb   $0xff,0x1(%ebx)
    c4d2:	75 39                	jne    c50d <ethernet_recv+0xb8>
	    addr->addr[1] == 0xff &&
    c4d4:	80 7b 02 ff          	cmpb   $0xff,0x2(%ebx)
    c4d8:	75 33                	jne    c50d <ethernet_recv+0xb8>
	    addr->addr[2] == 0xff &&
    c4da:	80 7b 03 ff          	cmpb   $0xff,0x3(%ebx)
    c4de:	75 2d                	jne    c50d <ethernet_recv+0xb8>
	    addr->addr[3] == 0xff &&
    c4e0:	80 7b 04 ff          	cmpb   $0xff,0x4(%ebx)
    c4e4:	75 27                	jne    c50d <ethernet_recv+0xb8>
	    addr->addr[4] == 0xff &&
    c4e6:	80 7b 05 ff          	cmpb   $0xff,0x5(%ebx)
    c4ea:	75 21                	jne    c50d <ethernet_recv+0xb8>
	ethernet_update_rx_stats(iface, pkt, net_pkt_get_len(pkt));
    c4ec:	8b 46 14             	mov    0x14(%esi),%eax
    c4ef:	89 c1                	mov    %eax,%ecx
    c4f1:	eb 45                	jmp    c538 <ethernet_recv+0xe3>
	if (addr->addr[0] == 0x33 &&
    c4f3:	3c 33                	cmp    $0x33,%al
    c4f5:	75 06                	jne    c4fd <ethernet_recv+0xa8>
    c4f7:	80 7b 01 33          	cmpb   $0x33,0x1(%ebx)
    c4fb:	eb ed                	jmp    c4ea <ethernet_recv+0x95>
	if (addr->addr[0] == 0x01 &&
    c4fd:	fe c8                	dec    %al
    c4ff:	75 0c                	jne    c50d <ethernet_recv+0xb8>
    c501:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
    c505:	75 06                	jne    c50d <ethernet_recv+0xb8>
	    addr->addr[1] == 0x00 &&
    c507:	80 7b 02 5e          	cmpb   $0x5e,0x2(%ebx)
    c50b:	eb dd                	jmp    c4ea <ethernet_recv+0x95>
	    !net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr)) {
    c50d:	8b 01                	mov    (%ecx),%eax
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
    c50f:	83 f8 f0             	cmp    $0xfffffff0,%eax
    c512:	75 0a                	jne    c51e <ethernet_recv+0xc9>
	return NET_DROP;
    c514:	b8 02 00 00 00       	mov    $0x2,%eax
    c519:	e9 95 00 00 00       	jmp    c5b3 <ethernet_recv+0x15e>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
    c51e:	80 78 14 06          	cmpb   $0x6,0x14(%eax)
    c522:	75 f0                	jne    c514 <ethernet_recv+0xbf>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
    c524:	6a 06                	push   $0x6
    c526:	53                   	push   %ebx
    c527:	ff 70 10             	pushl  0x10(%eax)
    c52a:	e8 97 e3 ff ff       	call   a8c6 <memcmp>
    c52f:	83 c4 0c             	add    $0xc,%esp
		    (struct net_eth_addr *)lladdr->addr) &&
    c532:	85 c0                	test   %eax,%eax
    c534:	74 b6                	je     c4ec <ethernet_recv+0x97>
    c536:	eb dc                	jmp    c514 <ethernet_recv+0xbf>
	while (buf) {
    c538:	85 c9                	test   %ecx,%ecx
    c53a:	74 04                	je     c540 <ethernet_recv+0xeb>
		buf = buf->frags;
    c53c:	8b 09                	mov    (%ecx),%ecx
    c53e:	eb f8                	jmp    c538 <ethernet_recv+0xe3>
	net_buf_pull(pkt->frags, hdr_len);
    c540:	6a 0e                	push   $0xe
    c542:	83 c0 08             	add    $0x8,%eax
    c545:	50                   	push   %eax
    c546:	e8 e1 f4 ff ff       	call   ba2c <net_buf_simple_pull>
	if (family == AF_INET && type == NET_ETH_PTYPE_ARP) {
    c54b:	66 4f                	dec    %di
	net_buf_pull(pkt->frags, hdr_len);
    c54d:	58                   	pop    %eax
    c54e:	5a                   	pop    %edx
	if (family == AF_INET && type == NET_ETH_PTYPE_ARP) {
    c54f:	75 1a                	jne    c56b <ethernet_recv+0x116>
    c551:	66 81 7d f2 06 08    	cmpw   $0x806,-0xe(%ebp)
    c557:	75 12                	jne    c56b <ethernet_recv+0x116>
		return net_arp_input(pkt, hdr);
    c559:	89 5d 0c             	mov    %ebx,0xc(%ebp)
    c55c:	89 75 08             	mov    %esi,0x8(%ebp)
}
    c55f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c562:	5b                   	pop    %ebx
    c563:	5e                   	pop    %esi
    c564:	5f                   	pop    %edi
    c565:	5d                   	pop    %ebp
		return net_arp_input(pkt, hdr);
    c566:	e9 90 fa ff ff       	jmp    bffb <net_arp_input>
	return pkt->family;
    c56b:	8a 46 3f             	mov    0x3f(%esi),%al
    c56e:	8b 4e 14             	mov    0x14(%esi),%ecx
    c571:	d0 e8                	shr    %al
    c573:	83 e0 07             	and    $0x7,%eax
    c576:	8b 59 08             	mov    0x8(%ecx),%ebx
	if (net_pkt_family(pkt) == AF_INET) {
    c579:	fe c8                	dec    %al
    c57b:	75 08                	jne    c585 <ethernet_recv+0x130>
		len = ntohs(NET_IPV4_HDR(pkt)->len);
    c57d:	66 8b 43 02          	mov    0x2(%ebx),%ax
    c581:	86 e0                	xchg   %ah,%al
    c583:	eb 09                	jmp    c58e <ethernet_recv+0x139>
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
    c585:	66 8b 43 04          	mov    0x4(%ebx),%ax
    c589:	86 e0                	xchg   %ah,%al
    c58b:	83 c0 28             	add    $0x28,%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
    c58e:	66 83 f8 2d          	cmp    $0x2d,%ax
    c592:	76 13                	jbe    c5a7 <ethernet_recv+0x152>
	return NET_CONTINUE;
    c594:	b8 01 00 00 00       	mov    $0x1,%eax
    c599:	eb 18                	jmp    c5b3 <ethernet_recv+0x15e>
				frag->len = len;
    c59b:	66 89 41 0c          	mov    %ax,0xc(%ecx)
				len = 0U;
    c59f:	31 c0                	xor    %eax,%eax
		for (frag = pkt->frags; frag; frag = frag->frags) {
    c5a1:	8b 09                	mov    (%ecx),%ecx
    c5a3:	85 c9                	test   %ecx,%ecx
    c5a5:	74 ed                	je     c594 <ethernet_recv+0x13f>
			if (frag->len < len) {
    c5a7:	8b 51 0c             	mov    0xc(%ecx),%edx
    c5aa:	66 39 d0             	cmp    %dx,%ax
    c5ad:	76 ec                	jbe    c59b <ethernet_recv+0x146>
				len -= frag->len;
    c5af:	29 d0                	sub    %edx,%eax
    c5b1:	eb ee                	jmp    c5a1 <ethernet_recv+0x14c>
}
    c5b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c5b6:	5b                   	pop    %ebx
    c5b7:	5e                   	pop    %esi
    c5b8:	5f                   	pop    %edi
    c5b9:	5d                   	pop    %ebp
    c5ba:	c3                   	ret    

0000c5bb <ethernet_send>:
{
    c5bb:	55                   	push   %ebp
    c5bc:	89 e5                	mov    %esp,%ebp
    c5be:	57                   	push   %edi
    c5bf:	56                   	push   %esi
    c5c0:	53                   	push   %ebx
    c5c1:	83 ec 08             	sub    $0x8,%esp
    c5c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    c5ca:	8b 00                	mov    (%eax),%eax
	const struct ethernet_api *api = net_if_get_device(iface)->driver_api;
    c5cc:	8b 00                	mov    (%eax),%eax
    c5ce:	8b 40 04             	mov    0x4(%eax),%eax
    c5d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c5d4:	8a 43 3f             	mov    0x3f(%ebx),%al
    c5d7:	88 c2                	mov    %al,%dl
    c5d9:	d0 ea                	shr    %dl
    c5db:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    c5de:	80 fa 01             	cmp    $0x1,%dl
    c5e1:	75 7b                	jne    c65e <ethernet_send+0xa3>
	return pkt->frags->data;
    c5e3:	8b 43 14             	mov    0x14(%ebx),%eax
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
    c5e6:	8b 7b 24             	mov    0x24(%ebx),%edi
    c5e9:	8b 70 08             	mov    0x8(%eax),%esi
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    c5ec:	e8 bb 4e 00 00       	call   114ac <net_ipv4_broadcast_address>
    c5f1:	8b 00                	mov    (%eax),%eax
    c5f3:	39 46 10             	cmp    %eax,0x10(%esi)
    c5f6:	0f 84 a9 01 00 00    	je     c7a5 <ethernet_send+0x1ea>
				   &NET_IPV4_HDR(pkt)->dst) ||
    c5fc:	83 c6 10             	add    $0x10,%esi
	return net_if_ipv4_is_addr_bcast(iface, addr);
    c5ff:	56                   	push   %esi
    c600:	57                   	push   %edi
    c601:	e8 5e 2d 00 00       	call   f364 <net_if_ipv4_is_addr_bcast>
    c606:	5a                   	pop    %edx
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
    c607:	84 c0                	test   %al,%al
    c609:	59                   	pop    %ecx
    c60a:	0f 85 95 01 00 00    	jne    c7a5 <ethernet_send+0x1ea>
    c610:	8b 43 14             	mov    0x14(%ebx),%eax
    c613:	8b 40 08             	mov    0x8(%eax),%eax
				   &NET_IPV4_HDR(pkt)->dst) ||
    c616:	80 78 10 e0          	cmpb   $0xe0,0x10(%eax)
    c61a:	0f 84 85 01 00 00    	je     c7a5 <ethernet_send+0x1ea>
		arp_pkt = net_arp_prepare(pkt, &NET_IPV4_HDR(pkt)->dst, NULL);
    c620:	6a 00                	push   $0x0
    c622:	83 c0 10             	add    $0x10,%eax
    c625:	50                   	push   %eax
    c626:	53                   	push   %ebx
    c627:	e8 fd f6 ff ff       	call   bd29 <net_arp_prepare>
    c62c:	83 c4 0c             	add    $0xc,%esp
    c62f:	89 c6                	mov    %eax,%esi
		if (!arp_pkt) {
    c631:	85 c0                	test   %eax,%eax
    c633:	75 0a                	jne    c63f <ethernet_send+0x84>
			ret = -ENOMEM;
    c635:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
    c63a:	e9 75 01 00 00       	jmp    c7b4 <ethernet_send+0x1f9>
		if (pkt != arp_pkt) {
    c63f:	39 c3                	cmp    %eax,%ebx
    c641:	0f 84 60 01 00 00    	je     c7a7 <ethernet_send+0x1ec>
			net_pkt_unref(pkt);
    c647:	53                   	push   %ebx
    c648:	e8 b4 37 00 00       	call   fe01 <net_pkt_unref>
    c64d:	58                   	pop    %eax
	pkt->family = family;
    c64e:	8a 46 3f             	mov    0x3f(%esi),%al
    c651:	83 e0 f1             	and    $0xfffffff1,%eax
    c654:	89 f3                	mov    %esi,%ebx
    c656:	83 c8 02             	or     $0x2,%eax
    c659:	88 46 3f             	mov    %al,0x3f(%esi)
    c65c:	eb 14                	jmp    c672 <ethernet_send+0xb7>
		ptype = htons(NET_ETH_PTYPE_IPV6);
    c65e:	66 c7 45 f2 86 dd    	movw   $0xdd86,-0xe(%ebp)
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    c664:	80 fa 02             	cmp    $0x2,%dl
    c667:	74 0f                	je     c678 <ethernet_send+0xbd>
    c669:	83 e0 f1             	and    $0xfffffff1,%eax
    c66c:	83 c8 02             	or     $0x2,%eax
    c66f:	88 43 3f             	mov    %al,0x3f(%ebx)
		ptype = htons(NET_ETH_PTYPE_ARP);
    c672:	66 c7 45 f2 08 06    	movw   $0x608,-0xe(%ebp)
	if (!net_pkt_lladdr_dst(pkt)->addr) {
    c678:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
    c67c:	75 0b                	jne    c689 <ethernet_send+0xce>
		net_pkt_lladdr_dst(pkt)->addr = (u8_t *)broadcast_eth_addr.addr;
    c67e:	c7 43 34 fc 5f 02 00 	movl   $0x25ffc,0x34(%ebx)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    c685:	c6 43 38 06          	movb   $0x6,0x38(%ebx)
	hdr_frag = net_pkt_get_frag(pkt, NET_BUF_TIMEOUT);
    c689:	6a 64                	push   $0x64
    c68b:	53                   	push   %ebx
    c68c:	e8 18 37 00 00       	call   fda9 <net_pkt_get_frag>
    c691:	5e                   	pop    %esi
	if (!hdr_frag) {
    c692:	85 c0                	test   %eax,%eax
	hdr_frag = net_pkt_get_frag(pkt, NET_BUF_TIMEOUT);
    c694:	5f                   	pop    %edi
    c695:	89 c7                	mov    %eax,%edi
	if (!hdr_frag) {
    c697:	74 9c                	je     c635 <ethernet_send+0x7a>
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
    c699:	8b 70 08             	mov    0x8(%eax),%esi
	return pkt->family;
    c69c:	8a 43 3f             	mov    0x3f(%ebx),%al
    c69f:	d0 e8                	shr    %al
    c6a1:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET &&
    c6a4:	3c 01                	cmp    $0x1,%al
    c6a6:	75 2c                	jne    c6d4 <ethernet_send+0x119>
	return pkt->frags->data;
    c6a8:	8b 43 14             	mov    0x14(%ebx),%eax
    c6ab:	8b 40 08             	mov    0x8(%eax),%eax
    c6ae:	80 78 10 e0          	cmpb   $0xe0,0x10(%eax)
    c6b2:	75 52                	jne    c706 <ethernet_send+0x14b>
		dst->addr[0] = 0x01;
    c6b4:	66 c7 06 01 00       	movw   $0x1,(%esi)
		dst->addr[2] = 0x5e;
    c6b9:	c6 46 02 5e          	movb   $0x5e,0x2(%esi)
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
    c6bd:	8a 50 12             	mov    0x12(%eax),%dl
		dst->addr[3] = NET_IPV4_HDR(pkt)->dst.s4_addr[1];
    c6c0:	8a 48 11             	mov    0x11(%eax),%cl
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
    c6c3:	88 56 04             	mov    %dl,0x4(%esi)
		dst->addr[3] &= 0x7f;
    c6c6:	83 e1 7f             	and    $0x7f,%ecx
		dst->addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
    c6c9:	8a 40 13             	mov    0x13(%eax),%al
		dst->addr[3] &= 0x7f;
    c6cc:	88 4e 03             	mov    %cl,0x3(%esi)
		dst->addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
    c6cf:	88 46 05             	mov    %al,0x5(%esi)
		return true;
    c6d2:	eb 40                	jmp    c714 <ethernet_send+0x159>
	if (net_pkt_family(pkt) == AF_INET6 &&
    c6d4:	3c 02                	cmp    $0x2,%al
    c6d6:	75 2e                	jne    c706 <ethernet_send+0x14b>
    c6d8:	8b 43 14             	mov    0x14(%ebx),%eax
	    net_ipv6_is_addr_mcast(&NET_IPV6_HDR(pkt)->dst)) {
    c6db:	8b 40 08             	mov    0x8(%eax),%eax
	if (net_pkt_family(pkt) == AF_INET6 &&
    c6de:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
    c6e2:	75 22                	jne    c706 <ethernet_send+0x14b>
		memcpy(dst, (u8_t *)multicast_eth_addr.addr,
    c6e4:	6a 02                	push   $0x2
    c6e6:	68 04 60 02 00       	push   $0x26004
    c6eb:	56                   	push   %esi
    c6ec:	e8 40 e2 ff ff       	call   a931 <memcpy>
    c6f1:	8b 43 14             	mov    0x14(%ebx),%eax
    c6f4:	83 c4 0c             	add    $0xc,%esp
		memcpy((u8_t *)dst + 2,
    c6f7:	8b 40 08             	mov    0x8(%eax),%eax
    c6fa:	6a 04                	push   $0x4
    c6fc:	83 c0 24             	add    $0x24,%eax
    c6ff:	50                   	push   %eax
    c700:	8d 46 02             	lea    0x2(%esi),%eax
    c703:	50                   	push   %eax
    c704:	eb 06                	jmp    c70c <ethernet_send+0x151>
			memcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,
    c706:	6a 06                	push   $0x6
    c708:	ff 73 34             	pushl  0x34(%ebx)
    c70b:	56                   	push   %esi
    c70c:	e8 20 e2 ff ff       	call   a931 <memcpy>
    c711:	83 c4 0c             	add    $0xc,%esp
		memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
    c714:	6a 06                	push   $0x6
    c716:	8d 46 06             	lea    0x6(%esi),%eax
    c719:	ff 73 2c             	pushl  0x2c(%ebx)
    c71c:	50                   	push   %eax
    c71d:	e8 0f e2 ff ff       	call   a931 <memcpy>
    c722:	83 c4 0c             	add    $0xc,%esp
		hdr->type = ptype;
    c725:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
    c729:	66 89 46 0c          	mov    %ax,0xc(%esi)
		net_buf_add(hdr_frag, sizeof(struct net_eth_hdr));
    c72d:	8d 47 08             	lea    0x8(%edi),%eax
    c730:	6a 0e                	push   $0xe
    c732:	50                   	push   %eax
    c733:	e8 c3 f2 ff ff       	call   b9fb <net_buf_simple_add>
    c738:	5a                   	pop    %edx
    c739:	59                   	pop    %ecx
	net_pkt_frag_insert(pkt, hdr_frag);
    c73a:	57                   	push   %edi
    c73b:	53                   	push   %ebx
    c73c:	e8 0d 37 00 00       	call   fe4e <net_pkt_frag_insert>
    c741:	5e                   	pop    %esi
    c742:	5f                   	pop    %edi
	net_pkt_cursor_init(pkt);
    c743:	53                   	push   %ebx
    c744:	e8 24 38 00 00       	call   ff6d <net_pkt_cursor_init>
    c749:	8b 45 08             	mov    0x8(%ebp),%eax
	ret = api->send(net_if_get_device(iface), pkt);
    c74c:	89 1c 24             	mov    %ebx,(%esp)
    c74f:	8b 00                	mov    (%eax),%eax
    c751:	ff 30                	pushl  (%eax)
    c753:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c756:	ff 50 18             	call   *0x18(%eax)
    c759:	5a                   	pop    %edx
    c75a:	89 c6                	mov    %eax,%esi
    c75c:	59                   	pop    %ecx
	buf = pkt->buffer;
    c75d:	8b 43 14             	mov    0x14(%ebx),%eax
	if (ret != 0) {
    c760:	85 f6                	test   %esi,%esi
    c762:	74 13                	je     c777 <ethernet_send+0x1bc>
	pkt->buffer = buf->frags;
    c764:	8b 10                	mov    (%eax),%edx
    c766:	89 53 14             	mov    %edx,0x14(%ebx)
	buf->frags = NULL;
    c769:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	net_pkt_frag_unref(buf);
    c76f:	50                   	push   %eax
    c770:	e8 7b 36 00 00       	call   fdf0 <net_pkt_frag_unref>
    c775:	eb 2b                	jmp    c7a2 <ethernet_send+0x1e7>
	ret = net_pkt_get_len(pkt);
    c777:	89 c2                	mov    %eax,%edx
	size_t bytes = 0;
    c779:	31 f6                	xor    %esi,%esi
	while (buf) {
    c77b:	85 d2                	test   %edx,%edx
    c77d:	74 0a                	je     c789 <ethernet_send+0x1ce>
		bytes += buf->len;
    c77f:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
    c783:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
    c785:	01 ce                	add    %ecx,%esi
		buf = buf->frags;
    c787:	eb f2                	jmp    c77b <ethernet_send+0x1c0>
	pkt->buffer = buf->frags;
    c789:	8b 10                	mov    (%eax),%edx
    c78b:	89 53 14             	mov    %edx,0x14(%ebx)
	buf->frags = NULL;
    c78e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	net_pkt_frag_unref(buf);
    c794:	50                   	push   %eax
    c795:	e8 56 36 00 00       	call   fdf0 <net_pkt_frag_unref>
	net_pkt_unref(pkt);
    c79a:	89 1c 24             	mov    %ebx,(%esp)
    c79d:	e8 5f 36 00 00       	call   fe01 <net_pkt_unref>
    c7a2:	58                   	pop    %eax
	return ret;
    c7a3:	eb 0f                	jmp    c7b4 <ethernet_send+0x1f9>
			ret = -ENOMEM;
    c7a5:	89 de                	mov    %ebx,%esi
			ptype = htons(NET_ETH_PTYPE_ARP);
    c7a7:	89 f3                	mov    %esi,%ebx
			ptype = htons(NET_ETH_PTYPE_IP);
    c7a9:	66 c7 45 f2 08 00    	movw   $0x8,-0xe(%ebp)
    c7af:	e9 c4 fe ff ff       	jmp    c678 <ethernet_send+0xbd>
}
    c7b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c7b7:	89 f0                	mov    %esi,%eax
    c7b9:	5b                   	pop    %ebx
    c7ba:	5e                   	pop    %esi
    c7bb:	5f                   	pop    %edi
    c7bc:	5d                   	pop    %ebp
    c7bd:	c3                   	ret    

0000c7be <net_eth_broadcast_addr>:
}
    c7be:	b8 fc 5f 02 00       	mov    $0x25ffc,%eax
    c7c3:	c3                   	ret    

0000c7c4 <ethernet_init>:
	return net_mgmt(NET_REQUEST_ETHERNET_SET_PROMISC_MODE, iface,
			&params, sizeof(struct ethernet_req_params));
}

void ethernet_init(struct net_if *iface)
{
    c7c4:	55                   	push   %ebp
    c7c5:	89 e5                	mov    %esp,%ebp
    c7c7:	53                   	push   %ebx
    c7c8:	8b 45 08             	mov    0x8(%ebp),%eax
	return iface->if_dev->l2_data;
    c7cb:	8b 10                	mov    (%eax),%edx
    c7cd:	8b 5a 08             	mov    0x8(%edx),%ebx
	int i;
#endif

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
    c7d0:	c6 43 10 01          	movb   $0x1,0x10(%ebx)

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
    c7d4:	e8 15 fc ff ff       	call   c3ee <net_eth_get_hw_capabilities>
    c7d9:	0f ba e0 0a          	bt     $0xa,%eax
    c7dd:	73 04                	jae    c7e3 <ethernet_init+0x1f>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
    c7df:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
			break;
		}
	}
#endif

	net_arp_init();
    c7e3:	e8 8f fb ff ff       	call   c377 <net_arp_init>

	ctx->is_init = true;
    c7e8:	c6 43 11 01          	movb   $0x1,0x11(%ebx)
}
    c7ec:	5b                   	pop    %ebx
    c7ed:	5d                   	pop    %ebp
    c7ee:	c3                   	ret    

0000c7ef <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
    c7ef:	8b 00                	mov    (%eax),%eax
    c7f1:	0f c8                	bswap  %eax
    c7f3:	25 00 00 00 e0       	and    $0xe0000000,%eax
    c7f8:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
    c7fd:	0f 94 c0             	sete   %al
}
    c800:	c3                   	ret    

0000c801 <net_ipv6_is_addr_unspecified>:
 */
static inline bool net_ipv6_is_addr_unspecified(const struct in6_addr *addr)
{
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    c801:	31 d2                	xor    %edx,%edx
    c803:	83 38 00             	cmpl   $0x0,(%eax)
    c806:	75 15                	jne    c81d <net_ipv6_is_addr_unspecified+0x1c>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    c808:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    c80c:	75 0f                	jne    c81d <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    c80e:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    c812:	75 09                	jne    c81d <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    c814:	31 d2                	xor    %edx,%edx
    c816:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    c81a:	0f 94 c2             	sete   %dl
    c81d:	88 d0                	mov    %dl,%al
    c81f:	83 e0 01             	and    $0x1,%eax
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
}
    c822:	c3                   	ret    

0000c823 <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol ip_proto,
			   u16_t local_port,
			   const struct sockaddr *local_addr)

{
    c823:	55                   	push   %ebp
    c824:	89 e5                	mov    %esp,%ebp
    c826:	57                   	push   %edi
    c827:	56                   	push   %esi
    c828:	89 c7                	mov    %eax,%edi
    c82a:	53                   	push   %ebx
    c82b:	89 ce                	mov    %ecx,%esi
    c82d:	53                   	push   %ebx
    c82e:	31 db                	xor    %ebx,%ebx
	int i;

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
    c830:	f6 83 d2 07 40 00 01 	testb  $0x1,0x4007d2(%ebx)
    c837:	75 12                	jne    c84b <check_used_port+0x28>
    c839:	81 c3 98 00 00 00    	add    $0x98,%ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    c83f:	81 fb f8 02 00 00    	cmp    $0x2f8,%ebx
    c845:	75 e9                	jne    c830 <check_used_port+0xd>
				return -EEXIST;
			}
		}
	}

	return 0;
    c847:	31 c0                	xor    %eax,%eax
    c849:	eb 47                	jmp    c892 <check_used_port+0x6f>
		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
    c84b:	0f b7 83 d0 07 40 00 	movzwl 0x4007d0(%ebx),%eax
    c852:	39 f8                	cmp    %edi,%eax
    c854:	75 e3                	jne    c839 <check_used_port+0x16>
    c856:	66 39 93 66 07 40 00 	cmp    %dx,0x400766(%ebx)
    c85d:	75 da                	jne    c839 <check_used_port+0x16>
		if (local_addr->sa_family == AF_INET6) {
    c85f:	66 83 3e 02          	cmpw   $0x2,(%esi)
    c863:	8b 83 68 07 40 00    	mov    0x400768(%ebx),%eax
    c869:	75 20                	jne    c88b <check_used_port+0x68>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    c86b:	6a 10                	push   $0x10
				    &((struct sockaddr_in6 *)
    c86d:	8d 4e 04             	lea    0x4(%esi),%ecx
    c870:	51                   	push   %ecx
    c871:	89 55 f0             	mov    %edx,-0x10(%ebp)
    c874:	50                   	push   %eax
    c875:	e8 4c e0 ff ff       	call   a8c6 <memcmp>
    c87a:	83 c4 0c             	add    $0xc,%esp
			if (net_ipv6_addr_cmp(
    c87d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c880:	85 c0                	test   %eax,%eax
    c882:	75 b5                	jne    c839 <check_used_port+0x16>
				return -EEXIST;
    c884:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
    c889:	eb 07                	jmp    c892 <check_used_port+0x6f>
			if (net_ipv4_addr_cmp(
    c88b:	8b 00                	mov    (%eax),%eax
    c88d:	39 46 04             	cmp    %eax,0x4(%esi)
    c890:	eb f0                	jmp    c882 <check_used_port+0x5f>
}
    c892:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c895:	5b                   	pop    %ebx
    c896:	5e                   	pop    %esi
    c897:	5f                   	pop    %edi
    c898:	5d                   	pop    %ebp
    c899:	c3                   	ret    

0000c89a <find_available_port>:

static u16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
    c89a:	55                   	push   %ebp
    c89b:	89 e5                	mov    %esp,%ebp
    c89d:	57                   	push   %edi
    c89e:	56                   	push   %esi
    c89f:	89 c7                	mov    %eax,%edi
    c8a1:	53                   	push   %ebx
    c8a2:	89 d6                	mov    %edx,%esi
	u16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
    c8a4:	e8 63 cd ff ff       	call   960c <sys_rand32_get>
		if (local_port <= 1023) {
			/* 0 - 1023 ports are reserved */
			continue;
		}
	} while (check_used_port(
    c8a9:	89 f1                	mov    %esi,%ecx
		local_port = sys_rand32_get() | 0x8000;
    c8ab:	89 c3                	mov    %eax,%ebx
    c8ad:	66 81 cb 00 80       	or     $0x8000,%bx
	} while (check_used_port(
    c8b2:	0f b7 87 90 00 00 00 	movzwl 0x90(%edi),%eax
    c8b9:	86 fb                	xchg   %bh,%bl
    c8bb:	0f b7 d3             	movzwl %bx,%edx
    c8be:	e8 60 ff ff ff       	call   c823 <check_used_port>
				net_context_get_ip_proto(context),
				htons(local_port), addr) == -EEXIST);
    c8c3:	83 f8 ef             	cmp    $0xffffffef,%eax
    c8c6:	74 dc                	je     c8a4 <find_available_port+0xa>

	return htons(local_port);
}
    c8c8:	89 d8                	mov    %ebx,%eax
    c8ca:	5b                   	pop    %ebx
    c8cb:	5e                   	pop    %esi
    c8cc:	5f                   	pop    %edi
    c8cd:	5d                   	pop    %ebp
    c8ce:	c3                   	ret    

0000c8cf <k_mutex_lock.constprop.33>:
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    c8cf:	55                   	push   %ebp
    c8d0:	89 e5                	mov    %esp,%ebp
    c8d2:	6a ff                	push   $0xffffffff
    c8d4:	50                   	push   %eax
    c8d5:	e8 09 6b 01 00       	call   233e3 <z_impl_k_mutex_lock>
    c8da:	5a                   	pop    %edx
    c8db:	59                   	pop    %ecx
    c8dc:	c9                   	leave  
    c8dd:	c3                   	ret    

0000c8de <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
    c8de:	55                   	push   %ebp
    c8df:	ba 40 07 40 00       	mov    $0x400740,%edx
    c8e4:	89 e5                	mov    %esp,%ebp
    c8e6:	57                   	push   %edi
    c8e7:	56                   	push   %esi
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    c8e8:	31 c0                	xor    %eax,%eax
{
    c8ea:	53                   	push   %ebx
    c8eb:	51                   	push   %ecx
    c8ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
    c8ef:	8b 75 0c             	mov    0xc(%ebp),%esi
		if (!net_context_is_used(&contexts[i])) {
    c8f2:	69 d8 98 00 00 00    	imul   $0x98,%eax,%ebx
    c8f8:	f6 82 92 00 00 00 01 	testb  $0x1,0x92(%edx)
    c8ff:	74 05                	je     c906 <net_context_packet_received+0x28>
		if (contexts[i].conn_handler == conn_handler) {
    c901:	3b 4a 48             	cmp    0x48(%edx),%ecx
    c904:	74 28                	je     c92e <net_context_packet_received+0x50>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    c906:	40                   	inc    %eax
    c907:	81 c2 98 00 00 00    	add    $0x98,%edx
    c90d:	83 f8 05             	cmp    $0x5,%eax
    c910:	75 e0                	jne    c8f2 <net_context_packet_received+0x14>
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
    c912:	b8 08 00 00 00       	mov    $0x8,%eax
    c917:	e8 b3 ff ff ff       	call   c8cf <k_mutex_lock.constprop.33>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
    c91c:	ff 76 24             	pushl  0x24(%esi)
    c91f:	e8 57 2f 00 00       	call   f87b <net_if_get_by_iface>
    c924:	5a                   	pop    %edx
    c925:	c6 05 94 00 00 00 00 	movb   $0x0,0x94
    c92c:	0f 0b                	ud2    
    c92e:	8d bb 48 07 40 00    	lea    0x400748(%ebx),%edi
    c934:	89 55 f0             	mov    %edx,-0x10(%ebp)
    c937:	89 f8                	mov    %edi,%eax
    c939:	e8 91 ff ff ff       	call   c8cf <k_mutex_lock.constprop.33>
    c93e:	ff 76 24             	pushl  0x24(%esi)
    c941:	e8 35 2f 00 00       	call   f87b <net_if_get_by_iface>
    c946:	5a                   	pop    %edx
    c947:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c94a:	88 82 94 00 00 00    	mov    %al,0x94(%edx)
	pkt->context = ctx;
    c950:	89 56 20             	mov    %edx,0x20(%esi)
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
    c953:	8b 8b 8c 07 40 00    	mov    0x40078c(%ebx),%ecx
	enum net_verdict verdict = NET_DROP;
    c959:	b8 02 00 00 00       	mov    $0x2,%eax
	if (!context->recv_cb) {
    c95e:	85 c9                	test   %ecx,%ecx
    c960:	74 21                	je     c983 <net_context_packet_received+0xa5>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_recv(net_pkt_iface(pkt),
					  net_pkt_remaining_data(pkt));
	}

	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
    c962:	ff 75 18             	pushl  0x18(%ebp)

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	k_sem_give(&context->recv_data_wait);
    c965:	81 c3 98 07 40 00    	add    $0x400798,%ebx
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
    c96b:	6a 00                	push   $0x0
    c96d:	ff 75 14             	pushl  0x14(%ebp)
    c970:	ff 75 10             	pushl  0x10(%ebp)
    c973:	56                   	push   %esi
    c974:	52                   	push   %edx
    c975:	ff d1                	call   *%ecx
    c977:	83 c4 18             	add    $0x18,%esp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    c97a:	53                   	push   %ebx
    c97b:	e8 59 76 01 00       	call   23fd9 <z_impl_k_sem_give>
    c980:	59                   	pop    %ecx
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

	verdict = NET_OK;
    c981:	31 c0                	xor    %eax,%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    c983:	57                   	push   %edi
    c984:	89 45 f0             	mov    %eax,-0x10(%ebp)
    c987:	e8 4e 6b 01 00       	call   234da <z_impl_k_mutex_unlock>
    c98c:	58                   	pop    %eax

unlock:
	k_mutex_unlock(&context->lock);

	return verdict;
    c98d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c990:	8d 65 f4             	lea    -0xc(%ebp),%esp
    c993:	5b                   	pop    %ebx
    c994:	5e                   	pop    %esi
    c995:	5f                   	pop    %edi
    c996:	5d                   	pop    %ebp
    c997:	c3                   	ret    

0000c998 <net_context_get>:
{
    c998:	55                   	push   %ebp
    c999:	89 e5                	mov    %esp,%ebp
    c99b:	57                   	push   %edi
    c99c:	56                   	push   %esi
    c99d:	53                   	push   %ebx
		return -EPFNOSUPPORT;
    c99e:	bb d2 ff ff ff       	mov    $0xffffffd2,%ebx
{
    c9a3:	83 ec 08             	sub    $0x8,%esp
    c9a6:	8b 55 08             	mov    0x8(%ebp),%edx
    c9a9:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (!IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == AF_CAN) {
    c9ac:	66 83 fa 04          	cmp    $0x4,%dx
    c9b0:	0f 84 9e 01 00 00    	je     cb54 <net_context_get+0x1bc>
	if (type == SOCK_RAW) {
    c9b6:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
    c9ba:	74 17                	je     c9d3 <net_context_get+0x3b>
		if (family == AF_PACKET || family == AF_CAN) {
    c9bc:	8d 42 fd             	lea    -0x3(%edx),%eax
	if (type == SOCK_STREAM) {
    c9bf:	66 83 f8 01          	cmp    $0x1,%ax
    c9c3:	0f 86 86 01 00 00    	jbe    cb4f <net_context_get+0x1b7>
    c9c9:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    c9cd:	0f 84 7c 01 00 00    	je     cb4f <net_context_get+0x1b7>
	if (ip_proto == IPPROTO_TCP) {
    c9d3:	66 83 ff 06          	cmp    $0x6,%di
		return -EPROTONOSUPPORT;
    c9d7:	bb d5 ff ff ff       	mov    $0xffffffd5,%ebx
	if (ip_proto == IPPROTO_TCP) {
    c9dc:	0f 84 72 01 00 00    	je     cb54 <net_context_get+0x1bc>
	if (family != AF_INET && family != AF_INET6 && family != AF_PACKET &&
    c9e2:	8d 42 ff             	lea    -0x1(%edx),%eax
		return -EAFNOSUPPORT;
    c9e5:	bb d1 ff ff ff       	mov    $0xffffffd1,%ebx
	if (family != AF_INET && family != AF_INET6 && family != AF_PACKET &&
    c9ea:	66 83 f8 03          	cmp    $0x3,%ax
    c9ee:	0f 87 60 01 00 00    	ja     cb54 <net_context_get+0x1bc>
	if (type != SOCK_DGRAM && type != SOCK_STREAM && type != SOCK_RAW) {
    c9f4:	8b 45 0c             	mov    0xc(%ebp),%eax
		return -EPROTOTYPE;
    c9f7:	bb d7 ff ff ff       	mov    $0xffffffd7,%ebx
	if (type != SOCK_DGRAM && type != SOCK_STREAM && type != SOCK_RAW) {
    c9fc:	48                   	dec    %eax
    c9fd:	83 f8 02             	cmp    $0x2,%eax
    ca00:	0f 87 4e 01 00 00    	ja     cb54 <net_context_get+0x1bc>
	if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
    ca06:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
    ca0a:	74 0f                	je     ca1b <net_context_get+0x83>
    ca0c:	66 83 ff 11          	cmp    $0x11,%di
		return -EPROTONOSUPPORT;
    ca10:	bb d5 ff ff ff       	mov    $0xffffffd5,%ebx
	if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
    ca15:	0f 85 39 01 00 00    	jne    cb54 <net_context_get+0x1bc>
    ca1b:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -EINVAL;
    ca1e:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if (!context) {
    ca23:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    ca27:	0f 84 27 01 00 00    	je     cb54 <net_context_get+0x1bc>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    ca2d:	6a ff                	push   $0xffffffff
    ca2f:	be 40 07 40 00       	mov    $0x400740,%esi
    ca34:	68 20 07 40 00       	push   $0x400720
    ca39:	e8 04 76 01 00       	call   24042 <z_impl_k_sem_take>
    ca3e:	59                   	pop    %ecx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    ca3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ca46:	5b                   	pop    %ebx
    ca47:	8b 55 ec             	mov    -0x14(%ebp),%edx
		if (net_context_is_used(&contexts[i])) {
    ca4a:	69 5d f0 98 00 00 00 	imul   $0x98,-0x10(%ebp),%ebx
    ca51:	f6 86 92 00 00 00 01 	testb  $0x1,0x92(%esi)
    ca58:	74 19                	je     ca73 <net_context_get+0xdb>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    ca5a:	ff 45 f0             	incl   -0x10(%ebp)
    ca5d:	81 c6 98 00 00 00    	add    $0x98,%esi
    ca63:	83 7d f0 05          	cmpl   $0x5,-0x10(%ebp)
    ca67:	75 e1                	jne    ca4a <net_context_get+0xb2>
	int i, ret = -ENOENT;
    ca69:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
    ca6e:	e9 cf 00 00 00       	jmp    cb42 <net_context_get+0x1aa>
		contexts[i].iface = -1;
    ca73:	8d 8b 40 07 40 00    	lea    0x400740(%ebx),%ecx
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    ca79:	b8 01 00 00 00       	mov    $0x1,%eax
    ca7e:	c6 81 94 00 00 00 ff 	movb   $0xff,0x94(%ecx)
		contexts[i].flags = 0;
    ca85:	66 c7 81 92 00 00 00 	movw   $0x0,0x92(%ecx)
    ca8c:	00 00 
    ca8e:	87 83 44 07 40 00    	xchg   %eax,0x400744(%ebx)
		flag = family << 3;
    ca94:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
	context->flags |= flag;
    ca9b:	0f b6 c0             	movzbl %al,%eax
    ca9e:	66 09 81 92 00 00 00 	or     %ax,0x92(%ecx)
		flag = type << 6;
    caa5:	8b 45 0c             	mov    0xc(%ebp),%eax
    caa8:	c1 e0 06             	shl    $0x6,%eax
		flag = family << 3;
    caab:	89 55 ec             	mov    %edx,-0x14(%ebp)
	context->flags |= flag;
    caae:	66 09 86 92 00 00 00 	or     %ax,0x92(%esi)
	context->proto = proto;
    cab5:	66 89 b9 90 00 00 00 	mov    %di,0x90(%ecx)
		(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
    cabc:	6a 18                	push   $0x18
    cabe:	8d 83 70 07 40 00    	lea    0x400770(%ebx),%eax
    cac4:	6a 00                	push   $0x0
		(void)memset(&contexts[i].local, 0,
    cac6:	8d bb 64 07 40 00    	lea    0x400764(%ebx),%edi
		(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
    cacc:	50                   	push   %eax
    cacd:	e8 ce de ff ff       	call   a9a0 <memset>
    cad2:	83 c4 0c             	add    $0xc,%esp
		(void)memset(&contexts[i].local, 0,
    cad5:	6a 0c                	push   $0xc
    cad7:	6a 00                	push   $0x0
    cad9:	57                   	push   %edi
    cada:	e8 c1 de ff ff       	call   a9a0 <memset>
		if (family == AF_INET6) {
    cadf:	8b 55 ec             	mov    -0x14(%ebp),%edx
		(void)memset(&contexts[i].local, 0,
    cae2:	83 c4 0c             	add    $0xc,%esp
		if (family == AF_INET6) {
    cae5:	66 83 fa 02          	cmp    $0x2,%dx
    cae9:	75 51                	jne    cb3c <net_context_get+0x1a4>
			addr6->sin6_port = find_available_port(&contexts[i],
    caeb:	89 fa                	mov    %edi,%edx
    caed:	89 f0                	mov    %esi,%eax
    caef:	e8 a6 fd ff ff       	call   c89a <find_available_port>
			if (!addr6->sin6_port) {
    caf4:	66 85 c0             	test   %ax,%ax
			addr6->sin6_port = find_available_port(&contexts[i],
    caf7:	66 89 47 02          	mov    %ax,0x2(%edi)
			if (!addr6->sin6_port) {
    cafb:	74 38                	je     cb35 <net_context_get+0x19d>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    cafd:	6a ff                	push   $0xffffffff
		k_sem_init(&contexts[i].recv_data_wait, 1, UINT_MAX);
    caff:	8d 83 98 07 40 00    	lea    0x400798(%ebx),%eax
    cb05:	6a 01                	push   $0x1
		k_mutex_init(&contexts[i].lock);
    cb07:	81 c3 48 07 40 00    	add    $0x400748,%ebx
    cb0d:	50                   	push   %eax
    cb0e:	e8 95 74 01 00       	call   23fa8 <z_impl_k_sem_init>
    cb13:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
    cb16:	53                   	push   %ebx
    cb17:	e8 9d 68 01 00       	call   233b9 <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
    cb1c:	69 45 f0 98 00 00 00 	imul   $0x98,-0x10(%ebp),%eax
    cb23:	5a                   	pop    %edx
		ret = 0;
    cb24:	31 db                	xor    %ebx,%ebx
		contexts[i].flags |= NET_CONTEXT_IN_USE;
    cb26:	66 83 88 d2 07 40 00 	orw    $0x1,0x4007d2(%eax)
    cb2d:	01 
		*context = &contexts[i];
    cb2e:	8b 45 14             	mov    0x14(%ebp),%eax
    cb31:	89 30                	mov    %esi,(%eax)
		break;
    cb33:	eb 0d                	jmp    cb42 <net_context_get+0x1aa>
				ret = -EADDRINUSE;
    cb35:	bb d0 ff ff ff       	mov    $0xffffffd0,%ebx
    cb3a:	eb 06                	jmp    cb42 <net_context_get+0x1aa>
		if (family == AF_INET) {
    cb3c:	66 4a                	dec    %dx
    cb3e:	75 bd                	jne    cafd <net_context_get+0x165>
    cb40:	eb a9                	jmp    caeb <net_context_get+0x153>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    cb42:	68 20 07 40 00       	push   $0x400720
    cb47:	e8 8d 74 01 00       	call   23fd9 <z_impl_k_sem_give>
    cb4c:	58                   	pop    %eax
	return ret;
    cb4d:	eb 05                	jmp    cb54 <net_context_get+0x1bc>
		return -EPROTOTYPE;
    cb4f:	bb d7 ff ff ff       	mov    $0xffffffd7,%ebx
}
    cb54:	8d 65 f4             	lea    -0xc(%ebp),%esp
    cb57:	89 d8                	mov    %ebx,%eax
    cb59:	5b                   	pop    %ebx
    cb5a:	5e                   	pop    %esi
    cb5b:	5f                   	pop    %edi
    cb5c:	5d                   	pop    %ebp
    cb5d:	c3                   	ret    

0000cb5e <net_context_ref>:
{
    cb5e:	55                   	push   %ebp
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    cb5f:	b8 01 00 00 00       	mov    $0x1,%eax
    cb64:	89 e5                	mov    %esp,%ebp
    cb66:	8b 55 08             	mov    0x8(%ebp),%edx
    cb69:	f0 0f c1 42 04       	lock xadd %eax,0x4(%edx)
	return old_rc + 1;
    cb6e:	40                   	inc    %eax
}
    cb6f:	5d                   	pop    %ebp
    cb70:	c3                   	ret    

0000cb71 <net_context_unref>:
{
    cb71:	55                   	push   %ebp
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    cb72:	83 c8 ff             	or     $0xffffffff,%eax
    cb75:	89 e5                	mov    %esp,%ebp
    cb77:	56                   	push   %esi
    cb78:	53                   	push   %ebx
    cb79:	8b 5d 08             	mov    0x8(%ebp),%ebx
    cb7c:	f0 0f c1 43 04       	lock xadd %eax,0x4(%ebx)
	if (old_rc != 1) {
    cb81:	83 f8 01             	cmp    $0x1,%eax
    cb84:	74 03                	je     cb89 <net_context_unref+0x18>
		return old_rc - 1;
    cb86:	48                   	dec    %eax
    cb87:	eb 30                	jmp    cbb9 <net_context_unref+0x48>
	k_mutex_lock(&context->lock, K_FOREVER);
    cb89:	8d 73 08             	lea    0x8(%ebx),%esi
    cb8c:	89 f0                	mov    %esi,%eax
    cb8e:	e8 3c fd ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	if (context->conn_handler) {
    cb93:	8b 43 48             	mov    0x48(%ebx),%eax
    cb96:	85 c0                	test   %eax,%eax
    cb98:	74 0e                	je     cba8 <net_context_unref+0x37>
		net_conn_unregister(context->conn_handler);
    cb9a:	50                   	push   %eax
    cb9b:	e8 ae 96 00 00       	call   1624e <net_conn_unregister>
    cba0:	5a                   	pop    %edx
		context->conn_handler = NULL;
    cba1:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
	context->flags &= ~NET_CONTEXT_IN_USE;
    cba8:	66 83 a3 92 00 00 00 	andw   $0xfff8,0x92(%ebx)
    cbaf:	f8 
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    cbb0:	56                   	push   %esi
    cbb1:	e8 24 69 01 00       	call   234da <z_impl_k_mutex_unlock>
    cbb6:	58                   	pop    %eax
    cbb7:	31 c0                	xor    %eax,%eax
}
    cbb9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cbbc:	5b                   	pop    %ebx
    cbbd:	5e                   	pop    %esi
    cbbe:	5d                   	pop    %ebp
    cbbf:	c3                   	ret    

0000cbc0 <net_context_put>:
{
    cbc0:	55                   	push   %ebp
    cbc1:	89 e5                	mov    %esp,%ebp
    cbc3:	56                   	push   %esi
    cbc4:	53                   	push   %ebx
    cbc5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!PART_OF_ARRAY(contexts, context)) {
    cbc8:	85 db                	test   %ebx,%ebx
    cbca:	0f 94 c2             	sete   %dl
    cbcd:	81 fb 40 07 40 00    	cmp    $0x400740,%ebx
    cbd3:	0f 92 c0             	setb   %al
    cbd6:	08 c2                	or     %al,%dl
    cbd8:	75 3a                	jne    cc14 <net_context_put+0x54>
    cbda:	81 fb 38 0a 40 00    	cmp    $0x400a38,%ebx
    cbe0:	73 32                	jae    cc14 <net_context_put+0x54>
	k_mutex_lock(&context->lock, K_FOREVER);
    cbe2:	8d 73 08             	lea    0x8(%ebx),%esi
    cbe5:	89 f0                	mov    %esi,%eax
    cbe7:	e8 e3 fc ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	context->connect_cb = NULL;
    cbec:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
	context->recv_cb = NULL;
    cbf3:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
	context->send_cb = NULL;
    cbfa:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
	net_context_unref(context);
    cc01:	53                   	push   %ebx
    cc02:	e8 6a ff ff ff       	call   cb71 <net_context_unref>
    cc07:	89 34 24             	mov    %esi,(%esp)
    cc0a:	e8 cb 68 01 00       	call   234da <z_impl_k_mutex_unlock>
    cc0f:	58                   	pop    %eax
	return ret;
    cc10:	31 c0                	xor    %eax,%eax
    cc12:	eb 05                	jmp    cc19 <net_context_put+0x59>
		return -EINVAL;
    cc14:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    cc19:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc1c:	5b                   	pop    %ebx
    cc1d:	5e                   	pop    %esi
    cc1e:	5d                   	pop    %ebp
    cc1f:	c3                   	ret    

0000cc20 <net_context_bind>:
{
    cc20:	55                   	push   %ebp
		return -EISCONN;
    cc21:	ba c8 ff ff ff       	mov    $0xffffffc8,%edx
{
    cc26:	89 e5                	mov    %esp,%ebp
    cc28:	57                   	push   %edi
    cc29:	56                   	push   %esi
    cc2a:	53                   	push   %ebx
    cc2b:	83 ec 08             	sub    $0x8,%esp
    cc2e:	8b 75 08             	mov    0x8(%ebp),%esi
    cc31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    cc34:	8b 45 10             	mov    0x10(%ebp),%eax
	if (context->conn_handler) {
    cc37:	83 7e 48 00          	cmpl   $0x0,0x48(%esi)
    cc3b:	0f 85 af 02 00 00    	jne    cef0 <net_context_bind+0x2d0>
	if (addr->sa_family == AF_INET6) {
    cc41:	66 8b 0b             	mov    (%ebx),%cx
    cc44:	66 83 f9 02          	cmp    $0x2,%cx
    cc48:	0f 85 33 01 00 00    	jne    cd81 <net_context_bind+0x161>
		struct net_if *iface = NULL;
    cc4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return -EINVAL;
    cc55:	ba ea ff ff ff       	mov    $0xffffffea,%edx
		if (addrlen < sizeof(struct sockaddr_in6)) {
    cc5a:	83 f8 17             	cmp    $0x17,%eax
    cc5d:	0f 86 8d 02 00 00    	jbe    cef0 <net_context_bind+0x2d0>
	return addr->s6_addr[0] == 0xFF;
    cc63:	8d 7b 04             	lea    0x4(%ebx),%edi
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
    cc66:	80 7b 04 ff          	cmpb   $0xff,0x4(%ebx)
    cc6a:	75 18                	jne    cc84 <net_context_bind+0x64>
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
    cc6c:	8d 45 f0             	lea    -0x10(%ebp),%eax
    cc6f:	50                   	push   %eax
    cc70:	57                   	push   %edi
    cc71:	e8 59 1d 00 00       	call   e9cf <net_if_ipv6_maddr_lookup>
    cc76:	59                   	pop    %ecx
			if (!maddr) {
    cc77:	85 c0                	test   %eax,%eax
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
    cc79:	5a                   	pop    %edx
			ptr = &maddr->address.in6_addr;
    cc7a:	8d 50 04             	lea    0x4(%eax),%edx
			if (!maddr) {
    cc7d:	75 3d                	jne    ccbc <net_context_bind+0x9c>
    cc7f:	e9 3b 01 00 00       	jmp    cdbf <net_context_bind+0x19f>
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
    cc84:	89 f8                	mov    %edi,%eax
    cc86:	e8 76 fb ff ff       	call   c801 <net_ipv6_is_addr_unspecified>
    cc8b:	84 c0                	test   %al,%al
    cc8d:	74 16                	je     cca5 <net_context_bind+0x85>
				&net_sin6(&context->remote)->sin6_addr);
    cc8f:	8d 46 34             	lea    0x34(%esi),%eax
			iface = net_if_ipv6_select_src_iface(
    cc92:	50                   	push   %eax
    cc93:	e8 93 25 00 00       	call   f22b <net_if_ipv6_select_src_iface>
    cc98:	5a                   	pop    %edx
    cc99:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ptr = (struct in6_addr *)net_ipv6_unspecified_address();
    cc9c:	e8 94 50 00 00       	call   11d35 <net_ipv6_unspecified_address>
    cca1:	89 c2                	mov    %eax,%edx
    cca3:	eb 17                	jmp    ccbc <net_context_bind+0x9c>
			ifaddr = net_if_ipv6_addr_lookup(&addr6->sin6_addr,
    cca5:	8d 45 f0             	lea    -0x10(%ebp),%eax
    cca8:	50                   	push   %eax
    cca9:	57                   	push   %edi
    ccaa:	e8 91 13 00 00       	call   e040 <net_if_ipv6_addr_lookup>
    ccaf:	5a                   	pop    %edx
			if (!ifaddr) {
    ccb0:	85 c0                	test   %eax,%eax
			ifaddr = net_if_ipv6_addr_lookup(&addr6->sin6_addr,
    ccb2:	59                   	pop    %ecx
			if (!ifaddr) {
    ccb3:	0f 84 06 01 00 00    	je     cdbf <net_context_bind+0x19f>
			ptr = &ifaddr->address.in6_addr;
    ccb9:	8d 50 04             	lea    0x4(%eax),%edx
		if (!iface) {
    ccbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ccbf:	85 c0                	test   %eax,%eax
    ccc1:	75 31                	jne    ccf4 <net_context_bind+0xd4>
			return -EADDRNOTAVAIL;
    ccc3:	ba cf ff ff ff       	mov    $0xffffffcf,%edx
			NET_ERR("Cannot bind to %s",
    ccc8:	f6 05 78 a8 40 00 07 	testb  $0x7,0x40a878
    cccf:	0f 84 1b 02 00 00    	je     cef0 <net_context_bind+0x2d0>
    ccd5:	bb 74 51 02 00       	mov    $0x25174,%ebx
    ccda:	57                   	push   %edi
    ccdb:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    cce1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    cce4:	c1 eb 03             	shr    $0x3,%ebx
    cce7:	6a 02                	push   $0x2
    cce9:	c1 e3 06             	shl    $0x6,%ebx
    ccec:	83 cb 01             	or     $0x1,%ebx
    ccef:	e9 36 01 00 00       	jmp    ce2a <net_context_bind+0x20a>
    ccf4:	89 55 ec             	mov    %edx,-0x14(%ebp)
	context->iface = net_if_get_by_iface(iface);
    ccf7:	50                   	push   %eax
    ccf8:	e8 7e 2b 00 00       	call   f87b <net_if_get_by_iface>
    ccfd:	59                   	pop    %ecx
		net_sin6_ptr(&context->local)->sin6_addr = ptr;
    ccfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    cd01:	88 86 94 00 00 00    	mov    %al,0x94(%esi)
    cd07:	89 56 28             	mov    %edx,0x28(%esi)
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
    cd0a:	66 c7 46 24 02 00    	movw   $0x2,0x24(%esi)
		if (addr6->sin6_port) {
    cd10:	0f b7 53 02          	movzwl 0x2(%ebx),%edx
    cd14:	66 85 d2             	test   %dx,%dx
    cd17:	74 59                	je     cd72 <net_context_bind+0x152>
			ret = check_used_port(AF_INET6, addr6->sin6_port,
    cd19:	89 d9                	mov    %ebx,%ecx
    cd1b:	b8 02 00 00 00       	mov    $0x2,%eax
    cd20:	e8 fe fa ff ff       	call   c823 <check_used_port>
    cd25:	89 c2                	mov    %eax,%edx
			if (!ret) {
    cd27:	85 c0                	test   %eax,%eax
    cd29:	75 0d                	jne    cd38 <net_context_bind+0x118>
				net_sin6_ptr(&context->local)->sin6_port =
    cd2b:	66 8b 43 02          	mov    0x2(%ebx),%ax
    cd2f:	66 89 46 26          	mov    %ax,0x26(%esi)
    cd33:	e9 b8 01 00 00       	jmp    cef0 <net_context_bind+0x2d0>
				NET_ERR("Port %d is in use!",
    cd38:	f6 05 78 a8 40 00 07 	testb  $0x7,0x40a878
    cd3f:	0f 84 ab 01 00 00    	je     cef0 <net_context_bind+0x2d0>
    cd45:	89 45 ec             	mov    %eax,-0x14(%ebp)
    cd48:	b8 74 51 02 00       	mov    $0x25174,%eax
    cd4d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    cd52:	66 8b 4b 02          	mov    0x2(%ebx),%cx
    cd56:	c1 e8 03             	shr    $0x3,%eax
    cd59:	c1 e0 06             	shl    $0x6,%eax
    cd5c:	83 c8 01             	or     $0x1,%eax
    cd5f:	50                   	push   %eax
    cd60:	89 c8                	mov    %ecx,%eax
    cd62:	86 e0                	xchg   %ah,%al
    cd64:	0f b7 c0             	movzwl %ax,%eax
    cd67:	50                   	push   %eax
    cd68:	68 26 79 02 00       	push   $0x27926
    cd6d:	e9 cf 00 00 00       	jmp    ce41 <net_context_bind+0x221>
			addr6->sin6_port =
    cd72:	66 8b 46 26          	mov    0x26(%esi),%ax
		return 0;
    cd76:	31 d2                	xor    %edx,%edx
			addr6->sin6_port =
    cd78:	66 89 43 02          	mov    %ax,0x2(%ebx)
    cd7c:	e9 6f 01 00 00       	jmp    cef0 <net_context_bind+0x2d0>
	if (addr->sa_family == AF_INET) {
    cd81:	66 49                	dec    %cx
	return -EINVAL;
    cd83:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (addr->sa_family == AF_INET) {
    cd88:	0f 85 62 01 00 00    	jne    cef0 <net_context_bind+0x2d0>
		struct net_if *iface = NULL;
    cd8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
    cd95:	83 f8 07             	cmp    $0x7,%eax
    cd98:	0f 86 52 01 00 00    	jbe    cef0 <net_context_bind+0x2d0>
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
    cd9e:	8d 7b 04             	lea    0x4(%ebx),%edi
    cda1:	89 f8                	mov    %edi,%eax
    cda3:	e8 47 fa ff ff       	call   c7ef <net_ipv4_is_addr_mcast>
    cda8:	84 c0                	test   %al,%al
    cdaa:	74 1d                	je     cdc9 <net_context_bind+0x1a9>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
    cdac:	8d 45 f0             	lea    -0x10(%ebp),%eax
    cdaf:	50                   	push   %eax
    cdb0:	57                   	push   %edi
    cdb1:	e8 4a 28 00 00       	call   f600 <net_if_ipv4_maddr_lookup>
    cdb6:	59                   	pop    %ecx
			if (!maddr) {
    cdb7:	85 c0                	test   %eax,%eax
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
    cdb9:	5a                   	pop    %edx
			ptr = &maddr->address.in_addr;
    cdba:	8d 50 04             	lea    0x4(%eax),%edx
			if (!maddr) {
    cdbd:	75 39                	jne    cdf8 <net_context_bind+0x1d8>
				return -ENOENT;
    cdbf:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    cdc4:	e9 27 01 00 00       	jmp    cef0 <net_context_bind+0x2d0>
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
    cdc9:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    cdcd:	75 16                	jne    cde5 <net_context_bind+0x1c5>
				&net_sin(&context->remote)->sin_addr);
    cdcf:	8d 46 34             	lea    0x34(%esi),%eax
			iface = net_if_ipv4_select_src_iface(
    cdd2:	50                   	push   %eax
    cdd3:	e8 ca 25 00 00       	call   f3a2 <net_if_ipv4_select_src_iface>
    cdd8:	5a                   	pop    %edx
    cdd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
    cddc:	e8 c5 46 00 00       	call   114a6 <net_ipv4_unspecified_address>
    cde1:	89 c2                	mov    %eax,%edx
    cde3:	eb 13                	jmp    cdf8 <net_context_bind+0x1d8>
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
    cde5:	8d 45 f0             	lea    -0x10(%ebp),%eax
    cde8:	50                   	push   %eax
    cde9:	57                   	push   %edi
    cdea:	e8 ed 26 00 00       	call   f4dc <net_if_ipv4_addr_lookup>
    cdef:	5a                   	pop    %edx
			if (!ifaddr) {
    cdf0:	85 c0                	test   %eax,%eax
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
    cdf2:	59                   	pop    %ecx
			if (!ifaddr) {
    cdf3:	74 ca                	je     cdbf <net_context_bind+0x19f>
			ptr = &ifaddr->address.in_addr;
    cdf5:	8d 50 04             	lea    0x4(%eax),%edx
		if (!iface) {
    cdf8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cdfc:	75 50                	jne    ce4e <net_context_bind+0x22e>
			return -EADDRNOTAVAIL;
    cdfe:	ba cf ff ff ff       	mov    $0xffffffcf,%edx
			NET_ERR("Cannot bind to %s",
    ce03:	f6 05 78 a8 40 00 07 	testb  $0x7,0x40a878
    ce0a:	0f 84 e0 00 00 00    	je     cef0 <net_context_bind+0x2d0>
    ce10:	bb 74 51 02 00       	mov    $0x25174,%ebx
    ce15:	57                   	push   %edi
    ce16:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    ce1c:	89 55 ec             	mov    %edx,-0x14(%ebp)
    ce1f:	c1 eb 03             	shr    $0x3,%ebx
    ce22:	6a 01                	push   $0x1
    ce24:	c1 e3 06             	shl    $0x6,%ebx
    ce27:	83 cb 01             	or     $0x1,%ebx
    ce2a:	e8 6f 3c 00 00       	call   10a9e <net_sprint_addr>
    ce2f:	59                   	pop    %ecx
    ce30:	5e                   	pop    %esi
    ce31:	50                   	push   %eax
    ce32:	e8 24 6a ff ff       	call   385b <log_strdup>
    ce37:	66 89 1c 24          	mov    %bx,(%esp)
    ce3b:	50                   	push   %eax
    ce3c:	68 14 79 02 00       	push   $0x27914
    ce41:	e8 69 66 ff ff       	call   34af <log_1>
    ce46:	83 c4 0c             	add    $0xc,%esp
    ce49:	e9 9f 00 00 00       	jmp    ceed <net_context_bind+0x2cd>
		k_mutex_lock(&context->lock, K_FOREVER);
    ce4e:	8d 7e 08             	lea    0x8(%esi),%edi
    ce51:	89 55 ec             	mov    %edx,-0x14(%ebp)
    ce54:	89 f8                	mov    %edi,%eax
    ce56:	e8 74 fa ff ff       	call   c8cf <k_mutex_lock.constprop.33>
    ce5b:	ff 75 f0             	pushl  -0x10(%ebp)
    ce5e:	e8 18 2a 00 00       	call   f87b <net_if_get_by_iface>
    ce63:	5a                   	pop    %edx
		net_sin_ptr(&context->local)->sin_addr = ptr;
    ce64:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ce67:	88 86 94 00 00 00    	mov    %al,0x94(%esi)
    ce6d:	89 56 28             	mov    %edx,0x28(%esi)
		if (addr4->sin_port) {
    ce70:	0f b7 53 02          	movzwl 0x2(%ebx),%edx
    ce74:	66 85 d2             	test   %dx,%dx
		net_sin_ptr(&context->local)->sin_family = AF_INET;
    ce77:	66 c7 46 24 01 00    	movw   $0x1,0x24(%esi)
		if (addr4->sin_port) {
    ce7d:	74 5a                	je     ced9 <net_context_bind+0x2b9>
			ret = check_used_port(AF_INET, addr4->sin_port,
    ce7f:	89 d9                	mov    %ebx,%ecx
    ce81:	b8 01 00 00 00       	mov    $0x1,%eax
    ce86:	e8 98 f9 ff ff       	call   c823 <check_used_port>
    ce8b:	89 c2                	mov    %eax,%edx
			if (!ret) {
    ce8d:	85 c0                	test   %eax,%eax
    ce8f:	75 0a                	jne    ce9b <net_context_bind+0x27b>
				net_sin_ptr(&context->local)->sin_port =
    ce91:	66 8b 43 02          	mov    0x2(%ebx),%ax
    ce95:	66 89 46 26          	mov    %ax,0x26(%esi)
    ce99:	eb 48                	jmp    cee3 <net_context_bind+0x2c3>
				NET_ERR("Port %d is in use!",
    ce9b:	f6 05 78 a8 40 00 07 	testb  $0x7,0x40a878
    cea2:	74 3f                	je     cee3 <net_context_bind+0x2c3>
    cea4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    cea7:	b8 74 51 02 00       	mov    $0x25174,%eax
    ceac:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    ceb1:	66 8b 4b 02          	mov    0x2(%ebx),%cx
    ceb5:	c1 e8 03             	shr    $0x3,%eax
    ceb8:	c1 e0 06             	shl    $0x6,%eax
    cebb:	83 c8 01             	or     $0x1,%eax
    cebe:	50                   	push   %eax
    cebf:	89 c8                	mov    %ecx,%eax
    cec1:	86 e0                	xchg   %ah,%al
    cec3:	0f b7 c0             	movzwl %ax,%eax
    cec6:	50                   	push   %eax
    cec7:	68 26 79 02 00       	push   $0x27926
    cecc:	e8 de 65 ff ff       	call   34af <log_1>
    ced1:	83 c4 0c             	add    $0xc,%esp
    ced4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ced7:	eb 0a                	jmp    cee3 <net_context_bind+0x2c3>
			addr4->sin_port =
    ced9:	66 8b 46 26          	mov    0x26(%esi),%ax
		ret = 0;
    cedd:	31 d2                	xor    %edx,%edx
			addr4->sin_port =
    cedf:	66 89 43 02          	mov    %ax,0x2(%ebx)
    cee3:	57                   	push   %edi
    cee4:	89 55 ec             	mov    %edx,-0x14(%ebp)
    cee7:	e8 ee 65 01 00       	call   234da <z_impl_k_mutex_unlock>
    ceec:	58                   	pop    %eax
    ceed:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
    cef0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    cef3:	89 d0                	mov    %edx,%eax
    cef5:	5b                   	pop    %ebx
    cef6:	5e                   	pop    %esi
    cef7:	5f                   	pop    %edi
    cef8:	5d                   	pop    %ebp
    cef9:	c3                   	ret    

0000cefa <bind_default>:
{
    cefa:	55                   	push   %ebp
    cefb:	89 e5                	mov    %esp,%ebp
    cefd:	56                   	push   %esi
    cefe:	53                   	push   %ebx
    ceff:	89 c3                	mov    %eax,%ebx
    cf01:	83 ec 18             	sub    $0x18,%esp
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    cf04:	0f b7 90 92 00 00 00 	movzwl 0x92(%eax),%edx
    cf0b:	c1 ea 03             	shr    $0x3,%edx
    cf0e:	83 e2 07             	and    $0x7,%edx
	if (family == AF_INET6) {
    cf11:	66 83 fa 02          	cmp    $0x2,%dx
    cf15:	75 36                	jne    cf4d <bind_default+0x53>
			return 0;
    cf17:	31 c0                	xor    %eax,%eax
		if (net_sin6_ptr(&context->local)->sin6_addr) {
    cf19:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    cf1d:	75 68                	jne    cf87 <bind_default+0x8d>
		addr6.sin6_family = AF_INET6;
    cf1f:	66 c7 45 e0 02 00    	movw   $0x2,-0x20(%ebp)
		memcpy(&addr6.sin6_addr, net_ipv6_unspecified_address(),
    cf25:	e8 0b 4e 00 00       	call   11d35 <net_ipv6_unspecified_address>
    cf2a:	6a 10                	push   $0x10
    cf2c:	8d 75 e0             	lea    -0x20(%ebp),%esi
    cf2f:	50                   	push   %eax
    cf30:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    cf33:	50                   	push   %eax
    cf34:	e8 f8 d9 ff ff       	call   a931 <memcpy>
    cf39:	83 c4 0c             	add    $0xc,%esp
			find_available_port(context,
    cf3c:	89 f2                	mov    %esi,%edx
    cf3e:	89 d8                	mov    %ebx,%eax
    cf40:	e8 55 f9 ff ff       	call   c89a <find_available_port>
		return net_context_bind(context, (struct sockaddr *)&addr6,
    cf45:	6a 18                	push   $0x18
		addr6.sin6_port =
    cf47:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
		return net_context_bind(context, (struct sockaddr *)&addr6,
    cf4b:	eb 30                	jmp    cf7d <bind_default+0x83>
	if (family == AF_INET) {
    cf4d:	66 4a                	dec    %dx
	return -EINVAL;
    cf4f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (family == AF_INET) {
    cf54:	75 31                	jne    cf87 <bind_default+0x8d>
			return 0;
    cf56:	31 c0                	xor    %eax,%eax
		if (net_sin_ptr(&context->local)->sin_addr) {
    cf58:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    cf5c:	75 29                	jne    cf87 <bind_default+0x8d>
			find_available_port(context,
    cf5e:	8d 75 e0             	lea    -0x20(%ebp),%esi
    cf61:	89 d8                	mov    %ebx,%eax
    cf63:	89 f2                	mov    %esi,%edx
		addr4.sin_family = AF_INET;
    cf65:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%ebp)
		addr4.sin_addr.s_addr = INADDR_ANY;
    cf6b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			find_available_port(context,
    cf72:	e8 23 f9 ff ff       	call   c89a <find_available_port>
		return net_context_bind(context, (struct sockaddr *)&addr4,
    cf77:	6a 08                	push   $0x8
		addr4.sin_port =
    cf79:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
		return net_context_bind(context, (struct sockaddr *)&addr4,
    cf7d:	56                   	push   %esi
    cf7e:	53                   	push   %ebx
    cf7f:	e8 9c fc ff ff       	call   cc20 <net_context_bind>
    cf84:	83 c4 0c             	add    $0xc,%esp
}
    cf87:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cf8a:	5b                   	pop    %ebx
    cf8b:	5e                   	pop    %esi
    cf8c:	5d                   	pop    %ebp
    cf8d:	c3                   	ret    

0000cf8e <net_context_listen>:
{
    cf8e:	55                   	push   %ebp
    cf8f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    cf94:	89 e5                	mov    %esp,%ebp
    cf96:	53                   	push   %ebx
    cf97:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!net_context_is_used(context)) {
    cf9a:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
    cfa1:	74 16                	je     cfb9 <net_context_listen+0x2b>
	k_mutex_lock(&context->lock, K_FOREVER);
    cfa3:	83 c3 08             	add    $0x8,%ebx
    cfa6:	89 d8                	mov    %ebx,%eax
    cfa8:	e8 22 f9 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
    cfad:	53                   	push   %ebx
    cfae:	e8 27 65 01 00       	call   234da <z_impl_k_mutex_unlock>
    cfb3:	58                   	pop    %eax
	return -EOPNOTSUPP;
    cfb4:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
}
    cfb9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    cfbc:	c9                   	leave  
    cfbd:	c3                   	ret    

0000cfbe <net_context_create_ipv4_new>:
{
    cfbe:	55                   	push   %ebp
    cfbf:	89 e5                	mov    %esp,%ebp
    cfc1:	57                   	push   %edi
    cfc2:	56                   	push   %esi
    cfc3:	8b 55 10             	mov    0x10(%ebp),%edx
    cfc6:	53                   	push   %ebx
    cfc7:	8b 7d 08             	mov    0x8(%ebp),%edi
    cfca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    cfcd:	8b 75 14             	mov    0x14(%ebp),%esi
	if (!src) {
    cfd0:	85 d2                	test   %edx,%edx
    cfd2:	75 03                	jne    cfd7 <net_context_create_ipv4_new+0x19>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
    cfd4:	8b 57 28             	mov    0x28(%edi),%edx
	if (net_ipv4_is_addr_unspecified(src)
    cfd7:	83 3a 00             	cmpl   $0x0,(%edx)
    cfda:	74 0b                	je     cfe7 <net_context_create_ipv4_new+0x29>
	    || net_ipv4_is_addr_mcast(src)) {
    cfdc:	89 d0                	mov    %edx,%eax
    cfde:	e8 0c f8 ff ff       	call   c7ef <net_ipv4_is_addr_mcast>
    cfe3:	84 c0                	test   %al,%al
    cfe5:	74 12                	je     cff9 <net_context_create_ipv4_new+0x3b>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
    cfe7:	56                   	push   %esi
    cfe8:	ff 73 24             	pushl  0x24(%ebx)
    cfeb:	e8 42 24 00 00       	call   f432 <net_if_ipv4_select_src_addr>
    cff0:	5a                   	pop    %edx
    cff1:	89 c2                	mov    %eax,%edx
    cff3:	59                   	pop    %ecx
		if (net_ipv4_is_addr_unspecified(src)) {
    cff4:	83 38 00             	cmpl   $0x0,(%eax)
    cff7:	74 1e                	je     d017 <net_context_create_ipv4_new+0x59>
	pkt->ipv4_ttl = ttl;
    cff9:	8a 87 95 00 00 00    	mov    0x95(%edi),%al
    cfff:	88 43 41             	mov    %al,0x41(%ebx)
	return net_ipv4_create(pkt, src, dst);
    d002:	89 75 10             	mov    %esi,0x10(%ebp)
    d005:	89 5d 08             	mov    %ebx,0x8(%ebp)
    d008:	89 55 0c             	mov    %edx,0xc(%ebp)
}
    d00b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d00e:	5b                   	pop    %ebx
    d00f:	5e                   	pop    %esi
    d010:	5f                   	pop    %edi
    d011:	5d                   	pop    %ebp
	return net_ipv4_create(pkt, src, dst);
    d012:	e9 67 43 00 00       	jmp    1137e <net_ipv4_create>
}
    d017:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d01a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    d01f:	5b                   	pop    %ebx
    d020:	5e                   	pop    %esi
    d021:	5f                   	pop    %edi
    d022:	5d                   	pop    %ebp
    d023:	c3                   	ret    

0000d024 <net_context_create_ipv6_new>:
{
    d024:	55                   	push   %ebp
    d025:	89 e5                	mov    %esp,%ebp
    d027:	57                   	push   %edi
    d028:	56                   	push   %esi
    d029:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d02c:	53                   	push   %ebx
    d02d:	8b 7d 08             	mov    0x8(%ebp),%edi
    d030:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    d033:	8b 75 14             	mov    0x14(%ebp),%esi
	if (!src) {
    d036:	85 c9                	test   %ecx,%ecx
    d038:	75 03                	jne    d03d <net_context_create_ipv6_new+0x19>
		src = ((struct sockaddr_in6_ptr *)&context->local)->sin6_addr;
    d03a:	8b 4f 28             	mov    0x28(%edi),%ecx
	if (net_ipv6_is_addr_unspecified(src)
    d03d:	89 c8                	mov    %ecx,%eax
    d03f:	e8 bd f7 ff ff       	call   c801 <net_ipv6_is_addr_unspecified>
    d044:	84 c0                	test   %al,%al
    d046:	75 05                	jne    d04d <net_context_create_ipv6_new+0x29>
	    || net_ipv6_is_addr_mcast(src)) {
    d048:	80 39 ff             	cmpb   $0xff,(%ecx)
    d04b:	75 0d                	jne    d05a <net_context_create_ipv6_new+0x36>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
    d04d:	56                   	push   %esi
    d04e:	ff 73 24             	pushl  0x24(%ebx)
    d051:	e8 35 21 00 00       	call   f18b <net_if_ipv6_select_src_addr>
    d056:	5a                   	pop    %edx
    d057:	59                   	pop    %ecx
    d058:	89 c1                	mov    %eax,%ecx
	pkt->ipv6_hop_limit = hop_limit;
    d05a:	8a 87 95 00 00 00    	mov    0x95(%edi),%al
    d060:	88 43 41             	mov    %al,0x41(%ebx)
	return net_ipv6_create(pkt, src, dst);
    d063:	89 75 10             	mov    %esi,0x10(%ebp)
    d066:	89 5d 08             	mov    %ebx,0x8(%ebp)
    d069:	89 4d 0c             	mov    %ecx,0xc(%ebp)
}
    d06c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d06f:	5b                   	pop    %ebx
    d070:	5e                   	pop    %esi
    d071:	5f                   	pop    %edi
    d072:	5d                   	pop    %ebp
	return net_ipv6_create(pkt, src, dst);
    d073:	e9 c3 4c 00 00       	jmp    11d3b <net_ipv6_create>

0000d078 <context_sendto.constprop.30>:
static int context_sendto(struct net_context *context,
    d078:	55                   	push   %ebp
    d079:	89 e5                	mov    %esp,%ebp
    d07b:	57                   	push   %edi
    d07c:	56                   	push   %esi
    d07d:	53                   	push   %ebx
    d07e:	83 ec 10             	sub    $0x10,%esp
	if (!net_context_is_used(context)) {
    d081:	66 8b b0 92 00 00 00 	mov    0x92(%eax),%si
static int context_sendto(struct net_context *context,
    d088:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!net_context_is_used(context)) {
    d08b:	f7 c6 01 00 00 00    	test   $0x1,%esi
    d091:	0f 84 dc 01 00 00    	je     d273 <context_sendto.constprop.30+0x1fb>
    d097:	89 c3                	mov    %eax,%ebx
	if (!dst_addr &&
    d099:	85 ff                	test   %edi,%edi
		return -EDESTADDRREQ;
    d09b:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
	if (!dst_addr &&
    d0a0:	0f 84 d9 01 00 00    	je     d27f <context_sendto.constprop.30+0x207>
    d0a6:	66 c1 ee 03          	shr    $0x3,%si
    d0aa:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    d0ad:	83 e6 07             	and    $0x7,%esi
    d0b0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    d0b3:	66 83 fe 01          	cmp    $0x1,%si
    d0b7:	75 1f                	jne    d0d8 <context_sendto.constprop.30+0x60>
			return -EINVAL;
    d0b9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (addrlen < sizeof(struct sockaddr_in)) {
    d0be:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
    d0c2:	0f 86 b7 01 00 00    	jbe    d27f <context_sendto.constprop.30+0x207>
		return -EDESTADDRREQ;
    d0c8:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
		if (!addr4->sin_addr.s_addr) {
    d0cd:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
    d0d1:	75 30                	jne    d103 <context_sendto.constprop.30+0x8b>
    d0d3:	e9 a7 01 00 00       	jmp    d27f <context_sendto.constprop.30+0x207>
		if (addrlen < sizeof(struct sockaddr_in6)) {
    d0d8:	83 7d 0c 17          	cmpl   $0x17,0xc(%ebp)
    d0dc:	0f 86 98 01 00 00    	jbe    d27a <context_sendto.constprop.30+0x202>
    d0e2:	66 83 fe 02          	cmp    $0x2,%si
    d0e6:	0f 85 8e 01 00 00    	jne    d27a <context_sendto.constprop.30+0x202>
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
    d0ec:	8d 47 04             	lea    0x4(%edi),%eax
    d0ef:	e8 0d f7 ff ff       	call   c801 <net_ipv6_is_addr_unspecified>
    d0f4:	88 c2                	mov    %al,%dl
		return -EDESTADDRREQ;
    d0f6:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
    d0fb:	84 d2                	test   %dl,%dl
    d0fd:	0f 85 7c 01 00 00    	jne    d27f <context_sendto.constprop.30+0x207>
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
    d103:	0f b7 93 90 00 00 00 	movzwl 0x90(%ebx),%edx
	return net_if_get_by_index(context->iface);
    d10a:	0f be 83 94 00 00 00 	movsbl 0x94(%ebx),%eax
    d111:	89 55 f0             	mov    %edx,-0x10(%ebp)
    d114:	50                   	push   %eax
    d115:	e8 41 27 00 00       	call   f85b <net_if_get_by_index>
    d11a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d11d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
    d124:	52                   	push   %edx
    d125:	0f b7 f6             	movzwl %si,%esi
    d128:	56                   	push   %esi
    d129:	ff 75 e8             	pushl  -0x18(%ebp)
    d12c:	50                   	push   %eax
    d12d:	e8 83 31 00 00       	call   102b5 <net_pkt_alloc_with_buffer>
    d132:	89 c6                	mov    %eax,%esi
    d134:	83 c4 14             	add    $0x14,%esp
		return -ENOMEM;
    d137:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (pkt) {
    d13c:	85 f6                	test   %esi,%esi
    d13e:	0f 84 3b 01 00 00    	je     d27f <context_sendto.constprop.30+0x207>
	tmp_len = net_pkt_available_payload_buffer(
    d144:	0f b7 83 90 00 00 00 	movzwl 0x90(%ebx),%eax
	pkt->context = ctx;
    d14b:	89 5e 20             	mov    %ebx,0x20(%esi)
    d14e:	50                   	push   %eax
    d14f:	56                   	push   %esi
    d150:	e8 83 2d 00 00       	call   fed8 <net_pkt_available_payload_buffer>
    d155:	5a                   	pop    %edx
    d156:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context->send_cb = cb;
    d159:	8b 45 10             	mov    0x10(%ebp),%eax
	tmp_len = net_pkt_available_payload_buffer(
    d15c:	59                   	pop    %ecx
	context->send_cb = cb;
    d15d:	89 43 50             	mov    %eax,0x50(%ebx)
	context->user_data = user_data;
    d160:	8b 45 14             	mov    0x14(%ebp),%eax
    d163:	89 03                	mov    %eax,(%ebx)
		ret = -EPROTONOSUPPORT;
    d165:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
    d16a:	66 83 bb 90 00 00 00 	cmpw   $0x11,0x90(%ebx)
    d171:	11 
    d172:	0f 85 ec 00 00 00    	jne    d264 <context_sendto.constprop.30+0x1ec>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    d178:	0f b7 93 92 00 00 00 	movzwl 0x92(%ebx),%edx
    d17f:	c1 ea 03             	shr    $0x3,%edx
    d182:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    d185:	66 83 fa 01          	cmp    $0x1,%dx
    d189:	75 17                	jne    d1a2 <context_sendto.constprop.30+0x12a>
		dst_port = addr4->sin_port;
    d18b:	66 8b 47 02          	mov    0x2(%edi),%ax
						  NULL, &addr4->sin_addr);
    d18f:	83 c7 04             	add    $0x4,%edi
		ret = net_context_create_ipv4_new(context, pkt,
    d192:	57                   	push   %edi
		dst_port = addr4->sin_port;
    d193:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
		ret = net_context_create_ipv4_new(context, pkt,
    d197:	6a 00                	push   $0x0
    d199:	56                   	push   %esi
    d19a:	53                   	push   %ebx
    d19b:	e8 1e fe ff ff       	call   cfbe <net_context_create_ipv4_new>
    d1a0:	eb 24                	jmp    d1c6 <context_sendto.constprop.30+0x14e>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    d1a2:	66 83 fa 02          	cmp    $0x2,%dx
	int ret = -EINVAL;
    d1a6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    d1ab:	0f 85 b3 00 00 00    	jne    d264 <context_sendto.constprop.30+0x1ec>
		dst_port = addr6->sin6_port;
    d1b1:	66 8b 47 02          	mov    0x2(%edi),%ax
						  NULL, &addr6->sin6_addr);
    d1b5:	83 c7 04             	add    $0x4,%edi
		ret = net_context_create_ipv6_new(context, pkt,
    d1b8:	57                   	push   %edi
		dst_port = addr6->sin6_port;
    d1b9:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
		ret = net_context_create_ipv6_new(context, pkt,
    d1bd:	6a 00                	push   $0x0
    d1bf:	56                   	push   %esi
    d1c0:	53                   	push   %ebx
    d1c1:	e8 5e fe ff ff       	call   d024 <net_context_create_ipv6_new>
    d1c6:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
    d1c9:	85 c0                	test   %eax,%eax
    d1cb:	0f 88 93 00 00 00    	js     d264 <context_sendto.constprop.30+0x1ec>
    d1d1:	8b 7d e8             	mov    -0x18(%ebp),%edi
    d1d4:	3b 7d f0             	cmp    -0x10(%ebp),%edi
    d1d7:	76 03                	jbe    d1dc <context_sendto.constprop.30+0x164>
    d1d9:	8b 7d f0             	mov    -0x10(%ebp),%edi
	ret = bind_default(context);
    d1dc:	89 d8                	mov    %ebx,%eax
    d1de:	e8 17 fd ff ff       	call   cefa <bind_default>
	if (ret) {
    d1e3:	85 c0                	test   %eax,%eax
    d1e5:	75 52                	jne    d239 <context_sendto.constprop.30+0x1c1>
	ret = net_udp_create(pkt,
    d1e7:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    d1eb:	50                   	push   %eax
    d1ec:	0f b7 43 26          	movzwl 0x26(%ebx),%eax
    d1f0:	50                   	push   %eax
    d1f1:	56                   	push   %esi
    d1f2:	e8 3c 96 00 00       	call   16833 <net_udp_create>
    d1f7:	83 c4 0c             	add    $0xc,%esp
	if (ret) {
    d1fa:	85 c0                	test   %eax,%eax
    d1fc:	75 3b                	jne    d239 <context_sendto.constprop.30+0x1c1>
	ret = net_pkt_write(pkt, buf, len);
    d1fe:	57                   	push   %edi
    d1ff:	ff 75 e4             	pushl  -0x1c(%ebp)
    d202:	56                   	push   %esi
    d203:	e8 0f 33 00 00       	call   10517 <net_pkt_write>
    d208:	83 c4 0c             	add    $0xc,%esp
	if (ret) {
    d20b:	85 c0                	test   %eax,%eax
    d20d:	75 2a                	jne    d239 <context_sendto.constprop.30+0x1c1>
	net_pkt_cursor_init(pkt);
    d20f:	56                   	push   %esi
    d210:	e8 58 2d 00 00       	call   ff6d <net_pkt_cursor_init>
    d215:	58                   	pop    %eax
    d216:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
    d21d:	c1 e8 03             	shr    $0x3,%eax
    d220:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    d223:	66 83 f8 01          	cmp    $0x1,%ax
    d227:	75 16                	jne    d23f <context_sendto.constprop.30+0x1c7>
		net_ipv4_finalize(pkt, net_context_get_ip_proto(context));
    d229:	0f b6 83 90 00 00 00 	movzbl 0x90(%ebx),%eax
    d230:	50                   	push   %eax
    d231:	56                   	push   %esi
    d232:	e8 cf 41 00 00       	call   11406 <net_ipv4_finalize>
    d237:	eb 1a                	jmp    d253 <context_sendto.constprop.30+0x1db>
		if (ret < 0) {
    d239:	85 c0                	test   %eax,%eax
    d23b:	79 d2                	jns    d20f <context_sendto.constprop.30+0x197>
    d23d:	eb 25                	jmp    d264 <context_sendto.constprop.30+0x1ec>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
    d23f:	66 83 f8 02          	cmp    $0x2,%ax
    d243:	75 10                	jne    d255 <context_sendto.constprop.30+0x1dd>
		net_ipv6_finalize(pkt, net_context_get_ip_proto(context));
    d245:	0f b6 83 90 00 00 00 	movzbl 0x90(%ebx),%eax
    d24c:	50                   	push   %eax
    d24d:	56                   	push   %esi
    d24e:	e8 98 4b 00 00       	call   11deb <net_ipv6_finalize>
    d253:	59                   	pop    %ecx
    d254:	5b                   	pop    %ebx
		ret = net_send_data(pkt);
    d255:	56                   	push   %esi
    d256:	e8 f2 05 00 00       	call   d84d <net_send_data>
    d25b:	5a                   	pop    %edx
	if (ret < 0) {
    d25c:	85 c0                	test   %eax,%eax
    d25e:	78 04                	js     d264 <context_sendto.constprop.30+0x1ec>
	return len;
    d260:	89 f8                	mov    %edi,%eax
    d262:	eb 1b                	jmp    d27f <context_sendto.constprop.30+0x207>
	net_pkt_unref(pkt);
    d264:	56                   	push   %esi
    d265:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d268:	e8 94 2b 00 00       	call   fe01 <net_pkt_unref>
    d26d:	58                   	pop    %eax
	return ret;
    d26e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d271:	eb 0c                	jmp    d27f <context_sendto.constprop.30+0x207>
		return -EBADF;
    d273:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    d278:	eb 05                	jmp    d27f <context_sendto.constprop.30+0x207>
			return -EINVAL;
    d27a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    d27f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d282:	5b                   	pop    %ebx
    d283:	5e                   	pop    %esi
    d284:	5f                   	pop    %edi
    d285:	5d                   	pop    %ebp
    d286:	c3                   	ret    

0000d287 <net_context_connect>:
{
    d287:	55                   	push   %ebp
    d288:	89 e5                	mov    %esp,%ebp
    d28a:	57                   	push   %edi
    d28b:	56                   	push   %esi
    d28c:	53                   	push   %ebx
    d28d:	52                   	push   %edx
    d28e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    d291:	8b 7d 0c             	mov    0xc(%ebp),%edi
	k_mutex_lock(&context->lock, K_FOREVER);
    d294:	8d 73 08             	lea    0x8(%ebx),%esi
    d297:	89 f0                	mov    %esi,%eax
    d299:	e8 31 f6 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	if (!net_context_is_used(context)) {
    d29e:	66 8b 8b 92 00 00 00 	mov    0x92(%ebx),%cx
		ret = -EBADF;
    d2a5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
	if (!net_context_is_used(context)) {
    d2aa:	f6 c1 01             	test   $0x1,%cl
    d2ad:	0f 84 55 01 00 00    	je     d408 <net_context_connect+0x181>
    d2b3:	89 ca                	mov    %ecx,%edx
		ret = -EINVAL;
    d2b5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    d2ba:	66 c1 ea 03          	shr    $0x3,%dx
    d2be:	83 e2 07             	and    $0x7,%edx
	if (addr->sa_family != net_context_get_family(context)) {
    d2c1:	66 39 17             	cmp    %dx,(%edi)
    d2c4:	0f 85 3e 01 00 00    	jne    d408 <net_context_connect+0x181>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
    d2ca:	83 f1 06             	xor    $0x6,%ecx
		ret = -EOPNOTSUPP;
    d2cd:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
    d2d2:	80 e1 06             	and    $0x6,%cl
    d2d5:	0f 84 2d 01 00 00    	je     d408 <net_context_connect+0x181>
	if (net_context_get_family(context) == AF_INET6) {
    d2db:	66 83 fa 02          	cmp    $0x2,%dx
    d2df:	0f 85 86 00 00 00    	jne    d36b <net_context_connect+0xe4>
		ret = -EINVAL;
    d2e5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (addrlen < sizeof(struct sockaddr_in6)) {
    d2ea:	83 7d 10 17          	cmpl   $0x17,0x10(%ebp)
    d2ee:	0f 86 14 01 00 00    	jbe    d408 <net_context_connect+0x181>
		if (net_context_get_ip_proto(context) == IPPROTO_TCP &&
    d2f4:	66 83 bb 90 00 00 00 	cmpw   $0x6,0x90(%ebx)
    d2fb:	06 
    d2fc:	75 0f                	jne    d30d <net_context_connect+0x86>
			ret = -EADDRNOTAVAIL;
    d2fe:	b8 cf ff ff ff       	mov    $0xffffffcf,%eax
		if (net_context_get_ip_proto(context) == IPPROTO_TCP &&
    d303:	80 7b 34 ff          	cmpb   $0xff,0x34(%ebx)
    d307:	0f 84 fb 00 00 00    	je     d408 <net_context_connect+0x181>
		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
    d30d:	6a 10                	push   $0x10
    d30f:	8d 47 04             	lea    0x4(%edi),%eax
    d312:	8d 53 34             	lea    0x34(%ebx),%edx
    d315:	50                   	push   %eax
    d316:	52                   	push   %edx
    d317:	89 55 f0             	mov    %edx,-0x10(%ebp)
    d31a:	e8 12 d6 ff ff       	call   a931 <memcpy>
		addr6->sin6_port = net_sin6(addr)->sin6_port;
    d31f:	66 8b 47 02          	mov    0x2(%edi),%ax
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
    d323:	8b 55 f0             	mov    -0x10(%ebp),%edx
		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
    d326:	83 c4 0c             	add    $0xc,%esp
		addr6->sin6_port = net_sin6(addr)->sin6_port;
    d329:	66 89 43 32          	mov    %ax,0x32(%ebx)
		addr6->sin6_family = AF_INET6;
    d32d:	66 c7 43 30 02 00    	movw   $0x2,0x30(%ebx)
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
    d333:	89 d0                	mov    %edx,%eax
    d335:	e8 c7 f4 ff ff       	call   c801 <net_ipv6_is_addr_unspecified>
    d33a:	84 c0                	test   %al,%al
    d33c:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
    d343:	75 05                	jne    d34a <net_context_connect+0xc3>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
    d345:	80 cc 01             	or     $0x1,%ah
    d348:	eb 03                	jmp    d34d <net_context_connect+0xc6>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
    d34a:	80 e4 fe             	and    $0xfe,%ah
    d34d:	66 89 83 92 00 00 00 	mov    %ax,0x92(%ebx)
		ret = bind_default(context);
    d354:	89 d8                	mov    %ebx,%eax
    d356:	e8 9f fb ff ff       	call   cefa <bind_default>
		if (ret) {
    d35b:	85 c0                	test   %eax,%eax
    d35d:	0f 85 a5 00 00 00    	jne    d408 <net_context_connect+0x181>
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
    d363:	66 c7 43 24 02 00    	movw   $0x2,0x24(%ebx)
 * @return Pointer to IPv6 socket address
 */
static inline
struct sockaddr_in6_ptr *net_sin6_ptr(const struct sockaddr_ptr *addr)
{
	return (struct sockaddr_in6_ptr *)addr;
    d369:	eb 5f                	jmp    d3ca <net_context_connect+0x143>
		if (addrlen < sizeof(struct sockaddr_in)) {
    d36b:	66 4a                	dec    %dx
    d36d:	0f 85 90 00 00 00    	jne    d403 <net_context_connect+0x17c>
    d373:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    d377:	0f 86 86 00 00 00    	jbe    d403 <net_context_connect+0x17c>
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
    d37d:	6a 04                	push   $0x4
    d37f:	8d 47 04             	lea    0x4(%edi),%eax
    d382:	50                   	push   %eax
    d383:	8d 43 34             	lea    0x34(%ebx),%eax
    d386:	50                   	push   %eax
    d387:	e8 a5 d5 ff ff       	call   a931 <memcpy>
		addr4->sin_port = net_sin(addr)->sin_port;
    d38c:	66 8b 47 02          	mov    0x2(%edi),%ax
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
    d390:	83 c4 0c             	add    $0xc,%esp
		addr4->sin_port = net_sin(addr)->sin_port;
    d393:	66 89 43 32          	mov    %ax,0x32(%ebx)
		addr4->sin_family = AF_INET;
    d397:	66 c7 43 30 01 00    	movw   $0x1,0x30(%ebx)
		if (addr4->sin_addr.s_addr) {
    d39d:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
    d3a1:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
    d3a8:	74 05                	je     d3af <net_context_connect+0x128>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
    d3aa:	80 cc 01             	or     $0x1,%ah
    d3ad:	eb 03                	jmp    d3b2 <net_context_connect+0x12b>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
    d3af:	80 e4 fe             	and    $0xfe,%ah
    d3b2:	66 89 83 92 00 00 00 	mov    %ax,0x92(%ebx)
		ret = bind_default(context);
    d3b9:	89 d8                	mov    %ebx,%eax
    d3bb:	e8 3a fb ff ff       	call   cefa <bind_default>
		if (ret) {
    d3c0:	85 c0                	test   %eax,%eax
    d3c2:	75 44                	jne    d408 <net_context_connect+0x181>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
    d3c4:	66 c7 43 24 01 00    	movw   $0x1,0x24(%ebx)
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
    d3ca:	0f b7 93 92 00 00 00 	movzwl 0x92(%ebx),%edx
    d3d1:	c1 ea 06             	shr    $0x6,%edx
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
    d3d4:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
    d3d9:	83 e2 03             	and    $0x3,%edx
	switch (net_context_get_type(context)) {
    d3dc:	83 fa 01             	cmp    $0x1,%edx
    d3df:	74 27                	je     d408 <net_context_connect+0x181>
		ret = -ENOTSUP;
    d3e1:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	switch (net_context_get_type(context)) {
    d3e6:	83 fa 02             	cmp    $0x2,%edx
    d3e9:	75 1d                	jne    d408 <net_context_connect+0x181>
		ret = 0;
    d3eb:	31 c0                	xor    %eax,%eax
		if (cb) {
    d3ed:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d3f1:	74 15                	je     d408 <net_context_connect+0x181>
			cb(context, 0, user_data);
    d3f3:	ff 75 1c             	pushl  0x1c(%ebp)
    d3f6:	6a 00                	push   $0x0
    d3f8:	53                   	push   %ebx
    d3f9:	ff 55 14             	call   *0x14(%ebp)
    d3fc:	83 c4 0c             	add    $0xc,%esp
		ret = 0;
    d3ff:	31 c0                	xor    %eax,%eax
    d401:	eb 05                	jmp    d408 <net_context_connect+0x181>
		ret = -EINVAL;
    d403:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    d408:	56                   	push   %esi
    d409:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d40c:	e8 c9 60 01 00       	call   234da <z_impl_k_mutex_unlock>
    d411:	58                   	pop    %eax
}
    d412:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d415:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d418:	5b                   	pop    %ebx
    d419:	5e                   	pop    %esi
    d41a:	5f                   	pop    %edi
    d41b:	5d                   	pop    %ebp
    d41c:	c3                   	ret    

0000d41d <net_context_accept>:
{
    d41d:	55                   	push   %ebp
    d41e:	89 e5                	mov    %esp,%ebp
    d420:	57                   	push   %edi
    d421:	56                   	push   %esi
    d422:	8b 75 08             	mov    0x8(%ebp),%esi
    d425:	53                   	push   %ebx
    d426:	bb f7 ff ff ff       	mov    $0xfffffff7,%ebx
	if (!net_context_is_used(context)) {
    d42b:	f6 86 92 00 00 00 01 	testb  $0x1,0x92(%esi)
    d432:	74 41                	je     d475 <net_context_accept+0x58>
	k_mutex_lock(&context->lock, K_FOREVER);
    d434:	8d 7e 08             	lea    0x8(%esi),%edi
    d437:	89 f8                	mov    %edi,%eax
    d439:	e8 91 f4 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
    d43e:	66 8b 86 92 00 00 00 	mov    0x92(%esi),%ax
    d445:	89 c2                	mov    %eax,%edx
    d447:	83 f2 06             	xor    $0x6,%edx
    d44a:	80 e2 06             	and    $0x6,%dl
    d44d:	74 0e                	je     d45d <net_context_accept+0x40>
    d44f:	c1 e8 06             	shr    $0x6,%eax
		ret = -EINVAL;
    d452:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
    d457:	83 e0 03             	and    $0x3,%eax
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
    d45a:	48                   	dec    %eax
    d45b:	75 11                	jne    d46e <net_context_accept+0x51>
		ret = net_tcp_accept(context, cb, user_data);
    d45d:	31 db                	xor    %ebx,%ebx
    d45f:	66 83 be 90 00 00 00 	cmpw   $0x6,0x90(%esi)
    d466:	06 
    d467:	0f 95 c3             	setne  %bl
    d46a:	4b                   	dec    %ebx
    d46b:	83 e3 d5             	and    $0xffffffd5,%ebx
    d46e:	57                   	push   %edi
    d46f:	e8 66 60 01 00       	call   234da <z_impl_k_mutex_unlock>
    d474:	58                   	pop    %eax
}
    d475:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d478:	89 d8                	mov    %ebx,%eax
    d47a:	5b                   	pop    %ebx
    d47b:	5e                   	pop    %esi
    d47c:	5f                   	pop    %edi
    d47d:	5d                   	pop    %ebp
    d47e:	c3                   	ret    

0000d47f <net_context_send>:
{
    d47f:	55                   	push   %ebp
    d480:	89 e5                	mov    %esp,%ebp
    d482:	56                   	push   %esi
    d483:	53                   	push   %ebx
    d484:	52                   	push   %edx
    d485:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
    d488:	8d 73 08             	lea    0x8(%ebx),%esi
    d48b:	89 f0                	mov    %esi,%eax
    d48d:	e8 3d f4 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
		ret = -EDESTADDRREQ;
    d492:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
    d497:	0f b7 93 92 00 00 00 	movzwl 0x92(%ebx),%edx
    d49e:	f6 c6 01             	test   $0x1,%dh
    d4a1:	74 40                	je     d4e3 <net_context_send+0x64>
    d4a3:	66 83 7b 32 00       	cmpw   $0x0,0x32(%ebx)
    d4a8:	74 39                	je     d4e3 <net_context_send+0x64>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    d4aa:	c1 ea 03             	shr    $0x3,%edx
		addrlen = sizeof(struct sockaddr_in);
    d4ad:	b8 08 00 00 00       	mov    $0x8,%eax
    d4b2:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    d4b5:	66 83 fa 01          	cmp    $0x1,%dx
    d4b9:	74 0d                	je     d4c8 <net_context_send+0x49>
		addrlen = 0;
    d4bb:	31 c0                	xor    %eax,%eax
    d4bd:	66 83 fa 02          	cmp    $0x2,%dx
    d4c1:	0f 95 c0             	setne  %al
    d4c4:	48                   	dec    %eax
    d4c5:	83 e0 18             	and    $0x18,%eax
	ret = context_sendto(context, buf, len, &context->remote,
    d4c8:	ff 75 1c             	pushl  0x1c(%ebp)
    d4cb:	ff 75 14             	pushl  0x14(%ebp)
    d4ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d4d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    d4d4:	50                   	push   %eax
    d4d5:	8d 43 30             	lea    0x30(%ebx),%eax
    d4d8:	50                   	push   %eax
    d4d9:	89 d8                	mov    %ebx,%eax
    d4db:	e8 98 fb ff ff       	call   d078 <context_sendto.constprop.30>
    d4e0:	83 c4 10             	add    $0x10,%esp
    d4e3:	56                   	push   %esi
    d4e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d4e7:	e8 ee 5f 01 00       	call   234da <z_impl_k_mutex_unlock>
    d4ec:	58                   	pop    %eax
}
    d4ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4f0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d4f3:	5b                   	pop    %ebx
    d4f4:	5e                   	pop    %esi
    d4f5:	5d                   	pop    %ebp
    d4f6:	c3                   	ret    

0000d4f7 <net_context_sendto>:
{
    d4f7:	55                   	push   %ebp
    d4f8:	89 e5                	mov    %esp,%ebp
    d4fa:	56                   	push   %esi
    d4fb:	53                   	push   %ebx
    d4fc:	50                   	push   %eax
    d4fd:	8b 75 08             	mov    0x8(%ebp),%esi
	k_mutex_lock(&context->lock, K_FOREVER);
    d500:	8d 5e 08             	lea    0x8(%esi),%ebx
    d503:	89 d8                	mov    %ebx,%eax
    d505:	e8 c5 f3 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
    d50a:	8b 55 0c             	mov    0xc(%ebp),%edx
    d50d:	ff 75 24             	pushl  0x24(%ebp)
    d510:	ff 75 1c             	pushl  0x1c(%ebp)
    d513:	ff 75 18             	pushl  0x18(%ebp)
    d516:	ff 75 14             	pushl  0x14(%ebp)
    d519:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d51c:	89 f0                	mov    %esi,%eax
    d51e:	e8 55 fb ff ff       	call   d078 <context_sendto.constprop.30>
    d523:	83 c4 10             	add    $0x10,%esp
    d526:	53                   	push   %ebx
    d527:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d52a:	e8 ab 5f 01 00       	call   234da <z_impl_k_mutex_unlock>
}
    d52f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d532:	5a                   	pop    %edx
    d533:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d536:	5b                   	pop    %ebx
    d537:	5e                   	pop    %esi
    d538:	5d                   	pop    %ebp
    d539:	c3                   	ret    

0000d53a <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     s32_t timeout,
		     void *user_data)
{
    d53a:	55                   	push   %ebp
    d53b:	89 e5                	mov    %esp,%ebp
    d53d:	57                   	push   %edi
    d53e:	56                   	push   %esi
    d53f:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
    d544:	53                   	push   %ebx
    d545:	83 ec 30             	sub    $0x30,%esp
    d548:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
    d54b:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
    d552:	0f 84 49 01 00 00    	je     d6a1 <net_context_recv+0x167>
		return -EBADF;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
    d558:	8d 43 08             	lea    0x8(%ebx),%eax
		ret = recv_udp(context, cb, timeout, user_data);
		break;
#endif /* CONFIG_NET_UDP */

	case IPPROTO_TCP:
		ret = net_tcp_recv(context, cb, user_data);
    d55b:	be d7 ff ff ff       	mov    $0xffffffd7,%esi
	k_mutex_lock(&context->lock, K_FOREVER);
    d560:	89 45 c8             	mov    %eax,-0x38(%ebp)
    d563:	e8 67 f3 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
	switch (net_context_get_ip_proto(context)) {
    d568:	66 83 bb 90 00 00 00 	cmpw   $0x11,0x90(%ebx)
    d56f:	11 
    d570:	0f 85 22 01 00 00    	jne    d698 <net_context_recv+0x15e>
	struct sockaddr local_addr = {
    d576:	31 c0                	xor    %eax,%eax
    d578:	8d 7d de             	lea    -0x22(%ebp),%edi
    d57b:	b9 16 00 00 00       	mov    $0x16,%ecx
    d580:	f3 aa                	rep stos %al,%es:(%edi)
    d582:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
    d589:	c1 e8 03             	shr    $0x3,%eax
    d58c:	83 e0 07             	and    $0x7,%eax
    d58f:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
	if (context->conn_handler) {
    d593:	8b 43 48             	mov    0x48(%ebx),%eax
    d596:	85 c0                	test   %eax,%eax
    d598:	74 0e                	je     d5a8 <net_context_recv+0x6e>
		net_conn_unregister(context->conn_handler);
    d59a:	50                   	push   %eax
    d59b:	e8 ae 8c 00 00       	call   1624e <net_conn_unregister>
    d5a0:	5e                   	pop    %esi
		context->conn_handler = NULL;
    d5a1:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
	ret = bind_default(context);
    d5a8:	89 d8                	mov    %ebx,%eax
    d5aa:	e8 4b f9 ff ff       	call   cefa <bind_default>
    d5af:	89 c6                	mov    %eax,%esi
	if (ret) {
    d5b1:	85 c0                	test   %eax,%eax
    d5b3:	0f 85 af 00 00 00    	jne    d668 <net_context_recv+0x12e>
	if (net_context_get_family(context) == AF_INET6) {
    d5b9:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
    d5c0:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
    d5c4:	66 c1 e8 03          	shr    $0x3,%ax
    d5c8:	83 e0 07             	and    $0x7,%eax
    d5cb:	66 83 f8 02          	cmp    $0x2,%ax
    d5cf:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
    d5d3:	75 2b                	jne    d600 <net_context_recv+0xc6>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
    d5d5:	8b 73 28             	mov    0x28(%ebx),%esi
    d5d8:	85 f6                	test   %esi,%esi
    d5da:	74 1a                	je     d5f6 <net_context_recv+0xbc>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
    d5dc:	8d 7d cc             	lea    -0x34(%ebp),%edi
    d5df:	b9 04 00 00 00       	mov    $0x4,%ecx
    d5e4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d5e6:	8d 7d e0             	lea    -0x20(%ebp),%edi
    d5e9:	8d 75 cc             	lea    -0x34(%ebp),%esi
    d5ec:	b9 04 00 00 00       	mov    $0x4,%ecx
    d5f1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			laddr = &local_addr;
    d5f3:	8d 75 dc             	lea    -0x24(%ebp),%esi
			net_sin6((struct sockaddr *)&context->local)->sin6_port;
    d5f6:	66 8b 43 26          	mov    0x26(%ebx),%ax
		net_sin6(&local_addr)->sin6_port =
    d5fa:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    d5fe:	eb 20                	jmp    d620 <net_context_recv+0xe6>
	if (net_context_get_family(context) == AF_INET) {
    d600:	66 83 7d c6 01       	cmpw   $0x1,-0x3a(%ebp)
    d605:	75 15                	jne    d61c <net_context_recv+0xe2>
		if (net_sin_ptr(&context->local)->sin_addr) {
    d607:	8b 73 28             	mov    0x28(%ebx),%esi
    d60a:	85 f6                	test   %esi,%esi
    d60c:	74 08                	je     d616 <net_context_recv+0xdc>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
    d60e:	8b 06                	mov    (%esi),%eax
			laddr = &local_addr;
    d610:	8d 75 dc             	lea    -0x24(%ebp),%esi
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
    d613:	89 45 e0             	mov    %eax,-0x20(%ebp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
    d616:	66 8b 43 26          	mov    0x26(%ebx),%ax
    d61a:	eb 04                	jmp    d620 <net_context_recv+0xe6>
	u16_t lport = 0U;
    d61c:	31 c0                	xor    %eax,%eax
	struct sockaddr *laddr = NULL;
    d61e:	31 f6                	xor    %esi,%esi
	context->recv_cb = cb;
    d620:	8b 55 0c             	mov    0xc(%ebp),%edx
	ret = net_conn_register(net_context_get_ip_proto(context),
    d623:	86 e0                	xchg   %ah,%al
	context->recv_cb = cb;
    d625:	89 53 4c             	mov    %edx,0x4c(%ebx)
				ntohs(net_sin(&context->remote)->sin_port),
    d628:	66 8b 53 32          	mov    0x32(%ebx),%dx
    d62c:	86 f2                	xchg   %dh,%dl
	ret = net_conn_register(net_context_get_ip_proto(context),
    d62e:	31 c9                	xor    %ecx,%ecx
    d630:	8d 7b 48             	lea    0x48(%ebx),%edi
    d633:	66 f7 45 c4 00 01    	testw  $0x100,-0x3c(%ebp)
    d639:	0f b7 c0             	movzwl %ax,%eax
    d63c:	0f b7 d2             	movzwl %dx,%edx
    d63f:	74 03                	je     d644 <net_context_recv+0x10a>
    d641:	8d 4b 30             	lea    0x30(%ebx),%ecx
    d644:	57                   	push   %edi
    d645:	ff 75 14             	pushl  0x14(%ebp)
    d648:	68 de c8 00 00       	push   $0xc8de
    d64d:	50                   	push   %eax
    d64e:	52                   	push   %edx
    d64f:	56                   	push   %esi
    d650:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
    d654:	51                   	push   %ecx
    d655:	50                   	push   %eax
    d656:	0f b7 83 90 00 00 00 	movzwl 0x90(%ebx),%eax
    d65d:	50                   	push   %eax
    d65e:	e8 24 8c 00 00       	call   16287 <net_conn_register>
    d663:	83 c4 24             	add    $0x24,%esp
    d666:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (timeout) {
    d668:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d66c:	74 2a                	je     d698 <net_context_recv+0x15e>
    d66e:	85 f6                	test   %esi,%esi
    d670:	78 26                	js     d698 <net_context_recv+0x15e>
	sem->count = 0;
    d672:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
		 */
		k_sem_reset(&context->recv_data_wait);

		k_mutex_unlock(&context->lock);

		ret = k_sem_take(&context->recv_data_wait, timeout);
    d679:	83 c3 58             	add    $0x58,%ebx
    d67c:	ff 75 c8             	pushl  -0x38(%ebp)
    d67f:	e8 56 5e 01 00       	call   234da <z_impl_k_mutex_unlock>
    d684:	5a                   	pop    %edx
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d685:	ff 75 10             	pushl  0x10(%ebp)
    d688:	53                   	push   %ebx
    d689:	e8 b4 69 01 00       	call   24042 <z_impl_k_sem_take>
    d68e:	59                   	pop    %ecx

		k_mutex_lock(&context->lock, K_FOREVER);
    d68f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    d692:	5b                   	pop    %ebx
    d693:	e8 37 f2 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    d698:	ff 75 c8             	pushl  -0x38(%ebp)
    d69b:	e8 3a 5e 01 00       	call   234da <z_impl_k_mutex_unlock>
    d6a0:	58                   	pop    %eax

unlock:
	k_mutex_unlock(&context->lock);

	return ret;
}
    d6a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d6a4:	89 f0                	mov    %esi,%eax
    d6a6:	5b                   	pop    %ebx
    d6a7:	5e                   	pop    %esi
    d6a8:	5f                   	pop    %edi
    d6a9:	5d                   	pop    %ebp
    d6aa:	c3                   	ret    

0000d6ab <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				s32_t delta)
{
    d6ab:	55                   	push   %ebp
    d6ac:	89 e5                	mov    %esp,%ebp
    d6ae:	53                   	push   %ebx
	int ret;

	k_mutex_lock(&context->lock, K_FOREVER);
    d6af:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b2:	8d 58 08             	lea    0x8(%eax),%ebx
    d6b5:	89 d8                	mov    %ebx,%eax
    d6b7:	e8 13 f2 ff ff       	call   c8cf <k_mutex_lock.constprop.33>
    d6bc:	53                   	push   %ebx
    d6bd:	e8 18 5e 01 00       	call   234da <z_impl_k_mutex_unlock>
    d6c2:	58                   	pop    %eax
	ret = net_tcp_update_recv_wnd(context, delta);

	k_mutex_unlock(&context->lock);

	return ret;
}
    d6c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    d6c6:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
    d6cb:	c9                   	leave  
    d6cc:	c3                   	ret    

0000d6cd <net_context_foreach>:

	return ret;
}

void net_context_foreach(net_context_cb_t cb, void *user_data)
{
    d6cd:	55                   	push   %ebp
    d6ce:	89 e5                	mov    %esp,%ebp
    d6d0:	57                   	push   %edi
    d6d1:	56                   	push   %esi
    d6d2:	53                   	push   %ebx
    d6d3:	53                   	push   %ebx
    d6d4:	bb 40 07 40 00       	mov    $0x400740,%ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d6d9:	6a ff                	push   $0xffffffff
    d6db:	8b 75 08             	mov    0x8(%ebp),%esi
    d6de:	68 20 07 40 00       	push   $0x400720
    d6e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
    d6e6:	e8 57 69 01 00       	call   24042 <z_impl_k_sem_take>
    d6eb:	58                   	pop    %eax
    d6ec:	5a                   	pop    %edx
	int i;

	k_sem_take(&contexts_lock, K_FOREVER);

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
    d6ed:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
    d6f4:	74 1d                	je     d713 <net_context_foreach+0x46>
			continue;
		}

		k_mutex_lock(&contexts[i].lock, K_FOREVER);
    d6f6:	8d 53 08             	lea    0x8(%ebx),%edx
    d6f9:	89 d0                	mov    %edx,%eax
    d6fb:	89 55 f0             	mov    %edx,-0x10(%ebp)
    d6fe:	e8 cc f1 ff ff       	call   c8cf <k_mutex_lock.constprop.33>

		cb(&contexts[i], user_data);
    d703:	57                   	push   %edi
    d704:	53                   	push   %ebx
    d705:	ff d6                	call   *%esi
    d707:	58                   	pop    %eax
    d708:	5a                   	pop    %edx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    d709:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d70c:	52                   	push   %edx
    d70d:	e8 c8 5d 01 00       	call   234da <z_impl_k_mutex_unlock>
    d712:	59                   	pop    %ecx
    d713:	81 c3 98 00 00 00    	add    $0x98,%ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    d719:	81 fb 38 0a 40 00    	cmp    $0x400a38,%ebx
    d71f:	75 cc                	jne    d6ed <net_context_foreach+0x20>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    d721:	c7 45 08 20 07 40 00 	movl   $0x400720,0x8(%ebp)

		k_mutex_unlock(&contexts[i].lock);
	}

	k_sem_give(&contexts_lock);
}
    d728:	8d 65 f4             	lea    -0xc(%ebp),%esp
    d72b:	5b                   	pop    %ebx
    d72c:	5e                   	pop    %esi
    d72d:	5f                   	pop    %edi
    d72e:	5d                   	pop    %ebp
    d72f:	e9 a5 68 01 00       	jmp    23fd9 <z_impl_k_sem_give>

0000d734 <net_context_init>:

void net_context_init(void)
{
    d734:	55                   	push   %ebp
    d735:	89 e5                	mov    %esp,%ebp
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    d737:	6a ff                	push   $0xffffffff
    d739:	6a 01                	push   $0x1
    d73b:	68 20 07 40 00       	push   $0x400720
    d740:	e8 63 68 01 00       	call   23fa8 <z_impl_k_sem_init>
    d745:	83 c4 0c             	add    $0xc,%esp
	k_sem_init(&contexts_lock, 1, UINT_MAX);
}
    d748:	c9                   	leave  
    d749:	c3                   	ret    

0000d74a <net_ipv6_is_addr_loopback>:
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    d74a:	31 d2                	xor    %edx,%edx
    d74c:	83 38 00             	cmpl   $0x0,(%eax)
    d74f:	75 18                	jne    d769 <net_ipv6_is_addr_loopback+0x1f>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
    d751:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    d755:	75 12                	jne    d769 <net_ipv6_is_addr_loopback+0x1f>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
    d757:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    d75b:	75 0c                	jne    d769 <net_ipv6_is_addr_loopback+0x1f>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
    d75d:	31 d2                	xor    %edx,%edx
    d75f:	81 78 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%eax)
    d766:	0f 94 c2             	sete   %dl
    d769:	88 d0                	mov    %dl,%al
    d76b:	83 e0 01             	and    $0x1,%eax
}
    d76e:	c3                   	ret    

0000d76f <process_data>:
		locally_routed = true;
	}
#endif

	/* If there is no data, then drop the packet. */
	if (!pkt->frags) {
    d76f:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
    d773:	74 59                	je     d7ce <process_data+0x5f>
{
    d775:	55                   	push   %ebp
		net_stats_update_processing_error(net_pkt_iface(pkt));

		return NET_DROP;
	}

	if (!is_loopback && !locally_routed) {
    d776:	84 d2                	test   %dl,%dl
{
    d778:	89 e5                	mov    %esp,%ebp
    d77a:	56                   	push   %esi
    d77b:	53                   	push   %ebx
    d77c:	89 d6                	mov    %edx,%esi
    d77e:	89 c3                	mov    %eax,%ebx
	if (!is_loopback && !locally_routed) {
    d780:	74 21                	je     d7a3 <process_data+0x34>
	}

	/* L2 has modified the buffer starting point, it is easier
	 * to re-initialize the cursor rather than updating it.
	 */
	net_pkt_cursor_init(pkt);
    d782:	53                   	push   %ebx
    d783:	e8 e5 27 00 00       	call   ff6d <net_pkt_cursor_init>
    d788:	58                   	pop    %eax
	return pkt->frags->data;
    d789:	8b 43 14             	mov    0x14(%ebx),%eax

	/* IP version and header length. */
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
    d78c:	8b 40 08             	mov    0x8(%eax),%eax
    d78f:	8a 00                	mov    (%eax),%al
    d791:	83 e0 f0             	and    $0xfffffff0,%eax
    d794:	3c 40                	cmp    $0x40,%al
    d796:	74 2d                	je     d7c5 <process_data+0x56>
    d798:	3c 60                	cmp    $0x60,%al
    d79a:	74 19                	je     d7b5 <process_data+0x46>
	NET_DBG("Unknown IP family packet (0x%x)",
		NET_IPV6_HDR(pkt)->vtc & 0xf0);
	net_stats_update_ip_errors_protoerr(net_pkt_iface(pkt));
	net_stats_update_ip_errors_vhlerr(net_pkt_iface(pkt));

	return NET_DROP;
    d79c:	b8 02 00 00 00       	mov    $0x2,%eax
    d7a1:	eb 31                	jmp    d7d4 <process_data+0x65>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
    d7a3:	53                   	push   %ebx
    d7a4:	ff 73 24             	pushl  0x24(%ebx)
    d7a7:	e8 9d 1e 00 00       	call   f649 <net_if_recv_data>
    d7ac:	5a                   	pop    %edx
		if (ret != NET_CONTINUE) {
    d7ad:	83 f8 01             	cmp    $0x1,%eax
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
    d7b0:	59                   	pop    %ecx
		if (ret != NET_CONTINUE) {
    d7b1:	75 21                	jne    d7d4 <process_data+0x65>
    d7b3:	eb cd                	jmp    d782 <process_data+0x13>
		return net_ipv6_input(pkt, is_loopback);
    d7b5:	89 f0                	mov    %esi,%eax
    d7b7:	0f b6 f0             	movzbl %al,%esi
    d7ba:	56                   	push   %esi
    d7bb:	53                   	push   %ebx
    d7bc:	e8 e0 46 00 00       	call   11ea1 <net_ipv6_input>
    d7c1:	59                   	pop    %ecx
    d7c2:	5b                   	pop    %ebx
    d7c3:	eb 0f                	jmp    d7d4 <process_data+0x65>
		return net_ipv4_input(pkt);
    d7c5:	53                   	push   %ebx
    d7c6:	e8 e7 3c 00 00       	call   114b2 <net_ipv4_input>
    d7cb:	5a                   	pop    %edx
    d7cc:	eb 06                	jmp    d7d4 <process_data+0x65>
		return NET_DROP;
    d7ce:	b8 02 00 00 00       	mov    $0x2,%eax
}
    d7d3:	c3                   	ret    
    d7d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d7d7:	5b                   	pop    %ebx
    d7d8:	5e                   	pop    %esi
    d7d9:	5d                   	pop    %ebp
    d7da:	c3                   	ret    

0000d7db <net_init>:

	NET_DBG("Network L3 init done");
}

static int net_init(struct device *unused)
{
    d7db:	55                   	push   %ebp
    d7dc:	89 e5                	mov    %esp,%ebp

	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
    d7de:	e8 33 2e 00 00       	call   10616 <net_pkt_init>

	net_context_init();
    d7e3:	e8 4c ff ff ff       	call   d734 <net_context_init>
	net_icmpv4_init();
    d7e8:	e8 54 3b 00 00       	call   11341 <net_icmpv4_init>
	net_icmpv6_init();
    d7ed:	e8 8a 43 00 00       	call   11b7c <net_icmpv6_init>
	net_ipv6_init();
    d7f2:	e8 8a 4a 00 00       	call   12281 <net_ipv6_init>
	net_conn_init();
    d7f7:	e8 36 90 00 00       	call   16832 <net_conn_init>
	net_route_init();
    d7fc:	e8 4f 72 00 00       	call   14a50 <net_route_init>

	l3_init();

	net_mgmt_event_init();
    d801:	e8 98 6d 00 00       	call   1459e <net_mgmt_event_init>
	net_if_init();
    d806:	e8 93 21 00 00       	call   f99e <net_if_init>
	net_tc_rx_init();
    d80b:	e8 df 2e 00 00       	call   106ef <net_tc_rx_init>
	net_if_post_init();
    d810:	e8 f2 22 00 00       	call   fb07 <net_if_post_init>
	if (status) {
		return status;
	}
#endif

	net_shell_init();
    d815:	e8 84 89 00 00       	call   1619e <net_shell_init>

	return status;
}
    d81a:	31 c0                	xor    %eax,%eax
    d81c:	5d                   	pop    %ebp
    d81d:	c3                   	ret    

0000d81e <process_rx_packet>:
{
    d81e:	55                   	push   %ebp
    d81f:	89 e5                	mov    %esp,%ebp
    d821:	53                   	push   %ebx
    d822:	8b 45 08             	mov    0x8(%ebp),%eax
	pkt = CONTAINER_OF(work, struct net_pkt, work);
    d825:	8d 58 fc             	lea    -0x4(%eax),%ebx
	pkt_len = net_pkt_get_len(pkt);
    d828:	8b 40 10             	mov    0x10(%eax),%eax
	while (buf) {
    d82b:	85 c0                	test   %eax,%eax
    d82d:	74 04                	je     d833 <process_rx_packet+0x15>
		buf = buf->frags;
    d82f:	8b 00                	mov    (%eax),%eax
    d831:	eb f8                	jmp    d82b <process_rx_packet+0xd>
	switch (process_data(pkt, is_loopback)) {
    d833:	31 d2                	xor    %edx,%edx
    d835:	89 d8                	mov    %ebx,%eax
    d837:	e8 33 ff ff ff       	call   d76f <process_data>
    d83c:	85 c0                	test   %eax,%eax
    d83e:	74 0a                	je     d84a <process_rx_packet+0x2c>
		net_pkt_unref(pkt);
    d840:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    d843:	5b                   	pop    %ebx
    d844:	5d                   	pop    %ebp
		net_pkt_unref(pkt);
    d845:	e9 b7 25 00 00       	jmp    fe01 <net_pkt_unref>
}
    d84a:	5b                   	pop    %ebx
    d84b:	5d                   	pop    %ebp
    d84c:	c3                   	ret    

0000d84d <net_send_data>:
{
    d84d:	55                   	push   %ebp
		return -ENODATA;
    d84e:	ba b2 ff ff ff       	mov    $0xffffffb2,%edx
{
    d853:	89 e5                	mov    %esp,%ebp
    d855:	57                   	push   %edi
    d856:	56                   	push   %esi
    d857:	53                   	push   %ebx
    d858:	83 ec 40             	sub    $0x40,%esp
    d85b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!pkt || !pkt->frags) {
    d85e:	85 db                	test   %ebx,%ebx
    d860:	0f 84 d5 01 00 00    	je     da3b <net_send_data+0x1ee>
    d866:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    d86a:	0f 84 cb 01 00 00    	je     da3b <net_send_data+0x1ee>
		return -EINVAL;
    d870:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (!net_pkt_iface(pkt)) {
    d875:	83 7b 24 00          	cmpl   $0x0,0x24(%ebx)
    d879:	0f 84 bc 01 00 00    	je     da3b <net_send_data+0x1ee>
	net_pkt_trim_buffer(pkt);
    d87f:	53                   	push   %ebx
    d880:	e8 a0 26 00 00       	call   ff25 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
    d885:	89 1c 24             	mov    %ebx,(%esp)
    d888:	e8 e0 26 00 00       	call   ff6d <net_pkt_cursor_init>
	return pkt->family;
    d88d:	8a 43 3f             	mov    0x3f(%ebx),%al
    d890:	5e                   	pop    %esi
    d891:	d0 e8                	shr    %al
    d893:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET6) {
    d896:	3c 02                	cmp    $0x2,%al
    d898:	0f 85 ce 00 00 00    	jne    d96c <net_send_data+0x11f>
		if (net_ipv6_addr_cmp(&NET_IPV6_HDR(pkt)->dst,
    d89e:	e8 92 44 00 00       	call   11d35 <net_ipv6_unspecified_address>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    d8a3:	6a 10                	push   $0x10
    d8a5:	50                   	push   %eax
	return pkt->frags->data;
    d8a6:	8b 43 14             	mov    0x14(%ebx),%eax
    d8a9:	8b 40 08             	mov    0x8(%eax),%eax
    d8ac:	83 c0 18             	add    $0x18,%eax
    d8af:	50                   	push   %eax
    d8b0:	e8 11 d0 ff ff       	call   a8c6 <memcmp>
    d8b5:	83 c4 0c             	add    $0xc,%esp
    d8b8:	85 c0                	test   %eax,%eax
    d8ba:	75 0a                	jne    d8c6 <net_send_data+0x79>
			return -EADDRNOTAVAIL;
    d8bc:	ba cf ff ff ff       	mov    $0xffffffcf,%edx
    d8c1:	e9 75 01 00 00       	jmp    da3b <net_send_data+0x1ee>
    d8c6:	8b 43 14             	mov    0x14(%ebx),%eax
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->dst) ||
    d8c9:	8b 48 08             	mov    0x8(%eax),%ecx
    d8cc:	83 c1 18             	add    $0x18,%ecx
    d8cf:	89 c8                	mov    %ecx,%eax
    d8d1:	e8 74 fe ff ff       	call   d74a <net_ipv6_is_addr_loopback>
    d8d6:	84 c0                	test   %al,%al
    d8d8:	74 59                	je     d933 <net_send_data+0xe6>
    d8da:	8b 43 14             	mov    0x14(%ebx),%eax
			net_ipaddr_copy(&addr, &NET_IPV6_HDR(pkt)->src);
    d8dd:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    d8e0:	b9 04 00 00 00       	mov    $0x4,%ecx
    d8e5:	8b 40 08             	mov    0x8(%eax),%eax
    d8e8:	8d 70 08             	lea    0x8(%eax),%esi
    d8eb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d8ed:	8d 7d b4             	lea    -0x4c(%ebp),%edi
    d8f0:	8d 75 e4             	lea    -0x1c(%ebp),%esi
    d8f3:	b9 04 00 00 00       	mov    $0x4,%ecx
    d8f8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			net_ipaddr_copy(&NET_IPV6_HDR(pkt)->src,
    d8fa:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    d8fd:	8d 70 18             	lea    0x18(%eax),%esi
    d900:	b9 04 00 00 00       	mov    $0x4,%ecx
    d905:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d907:	8d 78 08             	lea    0x8(%eax),%edi
    d90a:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    d90d:	b9 04 00 00 00       	mov    $0x4,%ecx
    d912:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			net_ipaddr_copy(&NET_IPV6_HDR(pkt)->dst, &addr);
    d914:	8d 7d c4             	lea    -0x3c(%ebp),%edi
    d917:	8d 75 b4             	lea    -0x4c(%ebp),%esi
    d91a:	b9 04 00 00 00       	mov    $0x4,%ecx
    d91f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    d921:	8d 78 18             	lea    0x18(%eax),%edi
    d924:	8d 75 c4             	lea    -0x3c(%ebp),%esi
    d927:	b9 04 00 00 00       	mov    $0x4,%ecx
    d92c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (status < 0) {
    d92e:	e9 ef 00 00 00       	jmp    da22 <net_send_data+0x1d5>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
    d933:	6a 00                	push   $0x0
    d935:	51                   	push   %ecx
    d936:	e8 05 07 00 00       	call   e040 <net_if_ipv6_addr_lookup>
    d93b:	5a                   	pop    %edx
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->dst) ||
    d93c:	85 c0                	test   %eax,%eax
    d93e:	59                   	pop    %ecx
    d93f:	75 99                	jne    d8da <net_send_data+0x8d>
    d941:	8b 43 14             	mov    0x14(%ebx),%eax
    d944:	8b 40 08             	mov    0x8(%eax),%eax
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
    d947:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
    d94b:	75 0a                	jne    d957 <net_send_data+0x10a>
    d94d:	80 78 19 01          	cmpb   $0x1,0x19(%eax)
    d951:	0f 84 cb 00 00 00    	je     da22 <net_send_data+0x1d5>
		if (net_ipv6_is_addr_loopback(&NET_IPV6_HDR(pkt)->src)) {
    d957:	83 c0 08             	add    $0x8,%eax
    d95a:	e8 eb fd ff ff       	call   d74a <net_ipv6_is_addr_loopback>
    d95f:	84 c0                	test   %al,%al
    d961:	0f 84 a2 00 00 00    	je     da09 <net_send_data+0x1bc>
    d967:	e9 50 ff ff ff       	jmp    d8bc <net_send_data+0x6f>
	if (net_pkt_family(pkt) == AF_INET) {
    d96c:	fe c8                	dec    %al
    d96e:	0f 85 95 00 00 00    	jne    da09 <net_send_data+0x1bc>
		if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
    d974:	e8 2d 3b 00 00       	call   114a6 <net_ipv4_unspecified_address>
    d979:	8b 53 14             	mov    0x14(%ebx),%edx
    d97c:	8b 72 08             	mov    0x8(%edx),%esi
    d97f:	8b 00                	mov    (%eax),%eax
    d981:	39 46 10             	cmp    %eax,0x10(%esi)
    d984:	0f 84 32 ff ff ff    	je     d8bc <net_send_data+0x6f>
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
    d98a:	80 7e 10 7f          	cmpb   $0x7f,0x10(%esi)
    d98e:	75 14                	jne    d9a4 <net_send_data+0x157>
    d990:	8b 43 14             	mov    0x14(%ebx),%eax
    d993:	8b 40 08             	mov    0x8(%eax),%eax
			net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
    d996:	8b 50 0c             	mov    0xc(%eax),%edx
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
    d999:	8b 48 10             	mov    0x10(%eax),%ecx
    d99c:	89 48 0c             	mov    %ecx,0xc(%eax)
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
    d99f:	89 50 10             	mov    %edx,0x10(%eax)
	if (status < 0) {
    d9a2:	eb 7e                	jmp    da22 <net_send_data+0x1d5>
		    (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
    d9a4:	8b 7b 24             	mov    0x24(%ebx),%edi
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    d9a7:	e8 00 3b 00 00       	call   114ac <net_ipv4_broadcast_address>
    d9ac:	8b 00                	mov    (%eax),%eax
    d9ae:	39 46 10             	cmp    %eax,0x10(%esi)
    d9b1:	74 46                	je     d9f9 <net_send_data+0x1ac>
				     &NET_IPV4_HDR(pkt)->dst) == false &&
    d9b3:	83 c6 10             	add    $0x10,%esi
	return net_if_ipv4_is_addr_bcast(iface, addr);
    d9b6:	56                   	push   %esi
    d9b7:	57                   	push   %edi
    d9b8:	e8 a7 19 00 00       	call   f364 <net_if_ipv4_is_addr_bcast>
    d9bd:	5e                   	pop    %esi
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
    d9be:	84 c0                	test   %al,%al
    d9c0:	5f                   	pop    %edi
    d9c1:	75 36                	jne    d9f9 <net_send_data+0x1ac>
    d9c3:	8b 43 14             	mov    0x14(%ebx),%eax
    d9c6:	8b 78 08             	mov    0x8(%eax),%edi
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
    d9c9:	6a 00                	push   $0x0
		     net_ipv4_is_my_addr(&NET_IPV4_HDR(pkt)->dst))) {
    d9cb:	8d 77 10             	lea    0x10(%edi),%esi
    d9ce:	56                   	push   %esi
    d9cf:	e8 08 1b 00 00       	call   f4dc <net_if_ipv4_addr_lookup>
    d9d4:	5a                   	pop    %edx
    d9d5:	85 c0                	test   %eax,%eax
    d9d7:	59                   	pop    %ecx
    d9d8:	0f 95 c2             	setne  %dl
	if (!ret) {
    d9db:	75 18                	jne    d9f5 <net_send_data+0x1a8>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    d9dd:	e8 ca 3a 00 00       	call   114ac <net_ipv4_broadcast_address>
    d9e2:	8b 00                	mov    (%eax),%eax
    d9e4:	39 47 10             	cmp    %eax,0x10(%edi)
    d9e7:	74 a7                	je     d990 <net_send_data+0x143>
	return net_if_ipv4_is_addr_bcast(iface, addr);
    d9e9:	56                   	push   %esi
    d9ea:	6a 00                	push   $0x0
    d9ec:	e8 73 19 00 00       	call   f364 <net_if_ipv4_is_addr_bcast>
    d9f1:	5e                   	pop    %esi
    d9f2:	88 c2                	mov    %al,%dl
    d9f4:	5f                   	pop    %edi
				     &NET_IPV4_HDR(pkt)->dst) == false &&
    d9f5:	84 d2                	test   %dl,%dl
    d9f7:	75 97                	jne    d990 <net_send_data+0x143>
    d9f9:	8b 43 14             	mov    0x14(%ebx),%eax
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->src)) {
    d9fc:	8b 40 08             	mov    0x8(%eax),%eax
    d9ff:	80 78 0c 7f          	cmpb   $0x7f,0xc(%eax)
    da03:	0f 84 b3 fe ff ff    	je     d8bc <net_send_data+0x6f>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
    da09:	53                   	push   %ebx
    da0a:	ff 73 24             	pushl  0x24(%ebx)
    da0d:	e8 23 1d 00 00       	call   f735 <net_if_send_data>
    da12:	5a                   	pop    %edx
    da13:	83 f8 02             	cmp    $0x2,%eax
    da16:	59                   	pop    %ecx
		return -EIO;
    da17:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
    da1c:	74 1d                	je     da3b <net_send_data+0x1ee>
	return 0;
    da1e:	31 d2                	xor    %edx,%edx
    da20:	eb 19                	jmp    da3b <net_send_data+0x1ee>
	switch (process_data(pkt, is_loopback)) {
    da22:	ba 01 00 00 00       	mov    $0x1,%edx
    da27:	89 d8                	mov    %ebx,%eax
    da29:	e8 41 fd ff ff       	call   d76f <process_data>
    da2e:	85 c0                	test   %eax,%eax
    da30:	74 ec                	je     da1e <net_send_data+0x1d1>
		net_pkt_unref(pkt);
    da32:	53                   	push   %ebx
    da33:	e8 c9 23 00 00       	call   fe01 <net_pkt_unref>
    da38:	5b                   	pop    %ebx
		break;
    da39:	eb e3                	jmp    da1e <net_send_data+0x1d1>
}
    da3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    da3e:	89 d0                	mov    %edx,%eax
    da40:	5b                   	pop    %ebx
    da41:	5e                   	pop    %esi
    da42:	5f                   	pop    %edi
    da43:	5d                   	pop    %ebp
    da44:	c3                   	ret    

0000da45 <net_recv_data>:
{
    da45:	55                   	push   %ebp
    da46:	89 e5                	mov    %esp,%ebp
    da48:	56                   	push   %esi
    da49:	53                   	push   %ebx
    da4a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    da4d:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!pkt || !iface) {
    da50:	85 db                	test   %ebx,%ebx
    da52:	74 6e                	je     dac2 <net_recv_data+0x7d>
    da54:	85 f6                	test   %esi,%esi
    da56:	74 6a                	je     dac2 <net_recv_data+0x7d>
		return -ENODATA;
    da58:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
	if (!pkt->frags) {
    da5d:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    da61:	74 64                	je     dac7 <net_recv_data+0x82>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    da63:	8b 06                	mov    (%esi),%eax
    da65:	8b 50 0c             	mov    0xc(%eax),%edx
		return -ENETDOWN;
    da68:	b8 c2 ff ff ff       	mov    $0xffffffc2,%eax
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    da6d:	80 e2 01             	and    $0x1,%dl
    da70:	74 55                	je     dac7 <net_recv_data+0x82>
	pkt->overwrite = overwrite;
    da72:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	net_pkt_cursor_init(pkt);
    da76:	53                   	push   %ebx
    da77:	e8 f1 24 00 00       	call   ff6d <net_pkt_cursor_init>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    da7c:	8b 06                	mov    (%esi),%eax
	pkt->iface = iface;
    da7e:	89 73 24             	mov    %esi,0x24(%ebx)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    da81:	8a 40 15             	mov    0x15(%eax),%al
    da84:	88 43 31             	mov    %al,0x31(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    da87:	8b 06                	mov    (%esi),%eax
    da89:	8a 40 15             	mov    0x15(%eax),%al
    da8c:	88 43 39             	mov    %al,0x39(%ebx)
	u8_t tc = net_rx_priority2tc(prio);
    da8f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    da96:	e8 f8 2b 00 00       	call   10693 <net_rx_priority2tc>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    da9b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	net_tc_submit_to_rx_queue(tc, pkt);
    daa2:	0f b6 c0             	movzbl %al,%eax
    daa5:	c7 43 08 1e d8 00 00 	movl   $0xd81e,0x8(%ebx)
    daac:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    dab3:	89 1c 24             	mov    %ebx,(%esp)
    dab6:	50                   	push   %eax
    dab7:	e8 a3 2b 00 00       	call   1065f <net_tc_submit_to_rx_queue>
    dabc:	58                   	pop    %eax
    dabd:	5a                   	pop    %edx
	return 0;
    dabe:	31 c0                	xor    %eax,%eax
    dac0:	eb 05                	jmp    dac7 <net_recv_data+0x82>
		return -EINVAL;
    dac2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    dac7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    daca:	5b                   	pop    %ebx
    dacb:	5e                   	pop    %esi
    dacc:	5d                   	pop    %ebp
    dacd:	c3                   	ret    

0000dace <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    dace:	55                   	push   %ebp
    dacf:	89 e5                	mov    %esp,%ebp
    dad1:	53                   	push   %ebx
    dad2:	8b 08                	mov    (%eax),%ecx
    dad4:	31 db                	xor    %ebx,%ebx
    dad6:	85 c9                	test   %ecx,%ecx
    dad8:	74 30                	je     db0a <sys_slist_find_and_remove+0x3c>
    dada:	39 d1                	cmp    %edx,%ecx
    dadc:	75 26                	jne    db04 <sys_slist_find_and_remove+0x36>
Z_GENLIST_REMOVE(slist, snode)
    dade:	8b 0a                	mov    (%edx),%ecx
    dae0:	85 db                	test   %ebx,%ebx
    dae2:	75 0c                	jne    daf0 <sys_slist_find_and_remove+0x22>
	list->head = node;
    dae4:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
    dae6:	3b 50 04             	cmp    0x4(%eax),%edx
    dae9:	75 0f                	jne    dafa <sys_slist_find_and_remove+0x2c>
	list->tail = node;
    daeb:	89 48 04             	mov    %ecx,0x4(%eax)
    daee:	eb 0a                	jmp    dafa <sys_slist_find_and_remove+0x2c>
	parent->next = child;
    daf0:	89 0b                	mov    %ecx,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
    daf2:	3b 50 04             	cmp    0x4(%eax),%edx
    daf5:	75 03                	jne    dafa <sys_slist_find_and_remove+0x2c>
	list->tail = node;
    daf7:	89 58 04             	mov    %ebx,0x4(%eax)
	parent->next = child;
    dafa:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    db00:	b0 01                	mov    $0x1,%al
    db02:	eb 08                	jmp    db0c <sys_slist_find_and_remove+0x3e>
    db04:	89 cb                	mov    %ecx,%ebx
    db06:	8b 09                	mov    (%ecx),%ecx
    db08:	eb cc                	jmp    dad6 <sys_slist_find_and_remove+0x8>
    db0a:	31 c0                	xor    %eax,%eax
    db0c:	5b                   	pop    %ebx
    db0d:	5d                   	pop    %ebp
    db0e:	c3                   	ret    

0000db0f <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
    db0f:	8b 00                	mov    (%eax),%eax
    db11:	0f c8                	bswap  %eax
    db13:	25 00 00 00 e0       	and    $0xe0000000,%eax
    db18:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
    db1d:	0f 94 c0             	sete   %al
}
    db20:	c3                   	ret    

0000db21 <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xA9FE0000) == 0xA9FE0000;
    db21:	8b 00                	mov    (%eax),%eax
    db23:	0f c8                	bswap  %eax
    db25:	25 00 00 fe a9       	and    $0xa9fe0000,%eax
    db2a:	3d 00 00 fe a9       	cmp    $0xa9fe0000,%eax
    db2f:	0f 94 c0             	sete   %al
}
    db32:	c3                   	ret    

0000db33 <net_context_send_cb>:
#endif /* CONFIG_NET_IF_LOG_LEVEL >= LOG_LEVEL_DBG */

static inline void net_context_send_cb(struct net_context *context,
				       int status)
{
	if (!context) {
    db33:	85 c0                	test   %eax,%eax
    db35:	74 15                	je     db4c <net_context_send_cb+0x19>
		return;
	}

	if (context->send_cb) {
    db37:	8b 48 50             	mov    0x50(%eax),%ecx
    db3a:	85 c9                	test   %ecx,%ecx
    db3c:	74 0e                	je     db4c <net_context_send_cb+0x19>
{
    db3e:	55                   	push   %ebp
    db3f:	89 e5                	mov    %esp,%ebp
		context->send_cb(context, status, context->user_data);
    db41:	ff 30                	pushl  (%eax)
    db43:	52                   	push   %edx
    db44:	50                   	push   %eax
    db45:	ff d1                	call   *%ecx
    db47:	83 c4 0c             	add    $0xc,%esp
		net_stats_update_tcp_seg_sent(net_context_get_iface(context));
	} else
#endif
	{
	}
}
    db4a:	c9                   	leave  
    db4b:	c3                   	ret    
    db4c:	c3                   	ret    

0000db4d <get_ipaddr_diff>:
}

#if defined(CONFIG_NET_IPV4) || defined(CONFIG_NET_IPV6)
/* Return how many bits are shared between two IP addresses */
static u8_t get_ipaddr_diff(const u8_t *src, const u8_t *dst, int addr_len)
{
    db4d:	55                   	push   %ebp
    db4e:	89 e5                	mov    %esp,%ebp
    db50:	57                   	push   %edi
    db51:	56                   	push   %esi
	u8_t j, k, xor;
	u8_t len = 0U;

	for (j = 0U; j < addr_len; j++) {
    db52:	31 f6                	xor    %esi,%esi
{
    db54:	53                   	push   %ebx
	u8_t len = 0U;
    db55:	31 db                	xor    %ebx,%ebx
{
    db57:	83 ec 0c             	sub    $0xc,%esp
    db5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    db5d:	89 55 e8             	mov    %edx,-0x18(%ebp)
		if (src[j] == dst[j]) {
    db60:	89 f0                	mov    %esi,%eax
    db62:	0f b6 f8             	movzbl %al,%edi
    db65:	8b 45 ec             	mov    -0x14(%ebp),%eax
    db68:	8a 04 38             	mov    (%eax,%edi,1),%al
    db6b:	88 45 f3             	mov    %al,-0xd(%ebp)
    db6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db71:	8a 04 38             	mov    (%eax,%edi,1),%al
    db74:	88 c2                	mov    %al,%dl
    db76:	38 45 f3             	cmp    %al,-0xd(%ebp)
    db79:	75 0f                	jne    db8a <get_ipaddr_diff+0x3d>
	for (j = 0U; j < addr_len; j++) {
    db7b:	46                   	inc    %esi
    db7c:	83 c3 08             	add    $0x8,%ebx
    db7f:	89 f0                	mov    %esi,%eax
    db81:	0f b6 f8             	movzbl %al,%edi
    db84:	39 cf                	cmp    %ecx,%edi
    db86:	7c d8                	jl     db60 <get_ipaddr_diff+0x13>
    db88:	eb 15                	jmp    db9f <get_ipaddr_diff+0x52>
			len += 8;
		} else {
			xor = src[j] ^ dst[j];
    db8a:	88 d1                	mov    %dl,%cl
    db8c:	8a 45 f3             	mov    -0xd(%ebp),%al
    db8f:	31 c8                	xor    %ecx,%eax
			for (k = 0U; k < 8; k++) {
    db91:	8d 53 08             	lea    0x8(%ebx),%edx
				if (!(xor & 0x80)) {
    db94:	84 c0                	test   %al,%al
    db96:	78 07                	js     db9f <get_ipaddr_diff+0x52>
					len++;
    db98:	43                   	inc    %ebx
					xor <<= 1;
    db99:	01 c0                	add    %eax,%eax
			for (k = 0U; k < 8; k++) {
    db9b:	38 da                	cmp    %bl,%dl
    db9d:	75 f5                	jne    db94 <get_ipaddr_diff+0x47>
			break;
		}
	}

	return len;
}
    db9f:	83 c4 0c             	add    $0xc,%esp
    dba2:	88 d8                	mov    %bl,%al
    dba4:	5b                   	pop    %ebx
    dba5:	5e                   	pop    %esi
    dba6:	5f                   	pop    %edi
    dba7:	5d                   	pop    %ebp
    dba8:	c3                   	ret    

0000dba9 <ipv6_router_expired>:
	return NULL;
}

#if defined(CONFIG_NET_IPV6)
static void ipv6_router_expired(struct k_work *work)
{
    dba9:	55                   	push   %ebp
    dbaa:	89 e5                	mov    %esp,%ebp
    dbac:	8b 45 08             	mov    0x8(%ebp),%eax
						    lifetime);

	NET_DBG("IPv6 router %s is expired",
		log_strdup(net_sprint_ipv6_addr(&router->address.in6_addr)));

	router->is_used = false;
    dbaf:	80 60 38 fe          	andb   $0xfe,0x38(%eax)
}
    dbb3:	5d                   	pop    %ebp
    dbb4:	c3                   	ret    

0000dbb5 <ipv4_maddr_find>:
#if defined(CONFIG_NET_IPV4)
static struct net_if_mcast_addr *ipv4_maddr_find(struct net_if *iface,
						 bool is_used,
						 const struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    dbb5:	8b 40 08             	mov    0x8(%eax),%eax
	int i;

	if (!ipv4) {
    dbb8:	85 c0                	test   %eax,%eax
    dbba:	74 67                	je     dc23 <ipv4_maddr_find+0x6e>
{
    dbbc:	55                   	push   %ebp
    dbbd:	89 e5                	mov    %esp,%ebp
    dbbf:	53                   	push   %ebx
    dbc0:	8a 98 ec 00 00 00    	mov    0xec(%eax),%bl
    dbc6:	83 e3 01             	and    $0x1,%ebx
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_MADDR; i++) {
		if ((is_used && !ipv4->mcast[i].is_used) ||
    dbc9:	84 d2                	test   %dl,%dl
    dbcb:	75 14                	jne    dbe1 <ipv4_maddr_find+0x2c>
		    (!is_used && ipv4->mcast[i].is_used)) {
    dbcd:	84 db                	test   %bl,%bl
    dbcf:	75 14                	jne    dbe5 <ipv4_maddr_find+0x30>
			continue;
		}

		if (addr) {
    dbd1:	85 c9                	test   %ecx,%ecx
    dbd3:	74 2d                	je     dc02 <ipv4_maddr_find+0x4d>
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
    dbd5:	8b 19                	mov    (%ecx),%ebx
    dbd7:	39 98 dc 00 00 00    	cmp    %ebx,0xdc(%eax)
    dbdd:	74 23                	je     dc02 <ipv4_maddr_find+0x4d>
    dbdf:	eb 04                	jmp    dbe5 <ipv4_maddr_find+0x30>
		if ((is_used && !ipv4->mcast[i].is_used) ||
    dbe1:	84 db                	test   %bl,%bl
    dbe3:	75 ec                	jne    dbd1 <ipv4_maddr_find+0x1c>
    dbe5:	8a 98 04 01 00 00    	mov    0x104(%eax),%bl
    dbeb:	83 e3 01             	and    $0x1,%ebx
    dbee:	84 d2                	test   %dl,%dl
    dbf0:	74 06                	je     dbf8 <ipv4_maddr_find+0x43>
    dbf2:	84 db                	test   %bl,%bl
    dbf4:	75 06                	jne    dbfc <ipv4_maddr_find+0x47>
    dbf6:	eb 26                	jmp    dc1e <ipv4_maddr_find+0x69>
		    (!is_used && ipv4->mcast[i].is_used)) {
    dbf8:	84 db                	test   %bl,%bl
    dbfa:	75 22                	jne    dc1e <ipv4_maddr_find+0x69>
		if (addr) {
    dbfc:	85 c9                	test   %ecx,%ecx
    dbfe:	75 06                	jne    dc06 <ipv4_maddr_find+0x51>
    dc00:	eb 0e                	jmp    dc10 <ipv4_maddr_find+0x5b>
    dc02:	31 d2                	xor    %edx,%edx
    dc04:	eb 0f                	jmp    dc15 <ipv4_maddr_find+0x60>
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
    dc06:	8b 09                	mov    (%ecx),%ecx
    dc08:	39 88 f4 00 00 00    	cmp    %ecx,0xf4(%eax)
    dc0e:	75 0e                	jne    dc1e <ipv4_maddr_find+0x69>
    dc10:	ba 18 00 00 00       	mov    $0x18,%edx
					       addr)) {
				continue;
			}
		}

		return &ipv4->mcast[i];
    dc15:	8d 84 10 d8 00 00 00 	lea    0xd8(%eax,%edx,1),%eax
    dc1c:	eb 02                	jmp    dc20 <ipv4_maddr_find+0x6b>
		return NULL;
    dc1e:	31 c0                	xor    %eax,%eax
	}

	return NULL;
}
    dc20:	5b                   	pop    %ebx
    dc21:	5d                   	pop    %ebp
    dc22:	c3                   	ret    
    dc23:	c3                   	ret    

0000dc24 <atomic_test_bit>:
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    dc24:	88 d1                	mov    %dl,%cl
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    dc26:	8b 00                	mov    (%eax),%eax
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    dc28:	d3 f8                	sar    %cl,%eax
    dc2a:	83 e0 01             	and    $0x1,%eax
}
    dc2d:	c3                   	ret    

0000dc2e <net_ipv6_is_prefix>:
	if (length > 128) {
    dc2e:	80 f9 80             	cmp    $0x80,%cl
    dc31:	77 61                	ja     dc94 <net_ipv6_is_prefix+0x66>
{
    dc33:	55                   	push   %ebp
    dc34:	89 e5                	mov    %esp,%ebp
    dc36:	57                   	push   %edi
    dc37:	56                   	push   %esi
    dc38:	89 d7                	mov    %edx,%edi
    dc3a:	53                   	push   %ebx
    dc3b:	53                   	push   %ebx
    dc3c:	89 c3                	mov    %eax,%ebx
	u8_t bytes = length / 8;
    dc3e:	88 c8                	mov    %cl,%al
    dc40:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    dc43:	c0 e8 03             	shr    $0x3,%al
	if (memcmp(addr1, addr2, bytes)) {
    dc46:	0f b6 f0             	movzbl %al,%esi
    dc49:	56                   	push   %esi
    dc4a:	52                   	push   %edx
    dc4b:	53                   	push   %ebx
    dc4c:	e8 75 cc ff ff       	call   a8c6 <memcmp>
    dc51:	83 c4 0c             	add    $0xc,%esp
    dc54:	85 c0                	test   %eax,%eax
    dc56:	74 04                	je     dc5c <net_ipv6_is_prefix+0x2e>
		return false;
    dc58:	31 c0                	xor    %eax,%eax
    dc5a:	eb 30                	jmp    dc8c <net_ipv6_is_prefix+0x5e>
	u8_t bits = 128 - length;
    dc5c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		return true;
    dc5f:	b0 01                	mov    $0x1,%al
	u8_t bits = 128 - length;
    dc61:	88 ca                	mov    %cl,%dl
    dc63:	f7 da                	neg    %edx
	if (!remain) {
    dc65:	80 e2 07             	and    $0x7,%dl
    dc68:	74 22                	je     dc8c <net_ipv6_is_prefix+0x5e>
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    dc6a:	0f b6 c2             	movzbl %dl,%eax
    dc6d:	b9 08 00 00 00       	mov    $0x8,%ecx
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    dc72:	8a 1c 33             	mov    (%ebx,%esi,1),%bl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    dc75:	29 c1                	sub    %eax,%ecx
    dc77:	b8 ff 00 00 00       	mov    $0xff,%eax
    dc7c:	d3 e0                	shl    %cl,%eax
    dc7e:	34 ff                	xor    $0xff,%al
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    dc80:	32 1c 37             	xor    (%edi,%esi,1),%bl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
    dc83:	88 d1                	mov    %dl,%cl
    dc85:	d3 e0                	shl    %cl,%eax
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
    dc87:	84 c3                	test   %al,%bl
    dc89:	0f 94 c0             	sete   %al
}
    dc8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    dc8f:	5b                   	pop    %ebx
    dc90:	5e                   	pop    %esi
    dc91:	5f                   	pop    %edi
    dc92:	5d                   	pop    %ebp
    dc93:	c3                   	ret    
		return false;
    dc94:	31 c0                	xor    %eax,%eax
}
    dc96:	c3                   	ret    

0000dc97 <net_ipv6_addr_cmp>:
{
    dc97:	55                   	push   %ebp
    dc98:	89 e5                	mov    %esp,%ebp
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    dc9a:	6a 10                	push   $0x10
    dc9c:	52                   	push   %edx
    dc9d:	50                   	push   %eax
    dc9e:	e8 23 cc ff ff       	call   a8c6 <memcmp>
    dca3:	83 c4 0c             	add    $0xc,%esp
    dca6:	85 c0                	test   %eax,%eax
}
    dca8:	c9                   	leave  
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    dca9:	0f 94 c0             	sete   %al
}
    dcac:	c3                   	ret    

0000dcad <k_delayed_work_submit>:
{
    dcad:	55                   	push   %ebp
    dcae:	89 e5                	mov    %esp,%ebp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    dcb0:	52                   	push   %edx
    dcb1:	50                   	push   %eax
    dcb2:	68 60 41 40 00       	push   $0x404160
    dcb7:	e8 19 68 01 00       	call   244d5 <k_delayed_work_submit_to_queue>
    dcbc:	83 c4 0c             	add    $0xc,%esp
}
    dcbf:	c9                   	leave  
    dcc0:	c3                   	ret    

0000dcc1 <net_mgmt_event_notify>:
#ifdef CONFIG_NET_MGMT_EVENT
void net_mgmt_event_notify_with_info(u32_t mgmt_event, struct net_if *iface,
				     void *info, size_t length);

static inline void net_mgmt_event_notify(u32_t mgmt_event, struct net_if *iface)
{
    dcc1:	55                   	push   %ebp
    dcc2:	89 e5                	mov    %esp,%ebp
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
    dcc4:	6a 00                	push   $0x0
    dcc6:	6a 00                	push   $0x0
    dcc8:	52                   	push   %edx
    dcc9:	50                   	push   %eax
    dcca:	e8 f4 67 00 00       	call   144c3 <net_mgmt_event_notify_with_info>
    dccf:	83 c4 10             	add    $0x10,%esp
}
    dcd2:	c9                   	leave  
    dcd3:	c3                   	ret    

0000dcd4 <address_lifetime_timeout>:
{
    dcd4:	55                   	push   %ebp
    dcd5:	89 e5                	mov    %esp,%ebp
    dcd7:	57                   	push   %edi
    dcd8:	56                   	push   %esi
    dcd9:	53                   	push   %ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
    dcda:	31 db                	xor    %ebx,%ebx
{
    dcdc:	83 ec 0c             	sub    $0xc,%esp
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
    dcdf:	e8 0e 6c 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
    dce4:	8b 35 ac 42 40 00    	mov    0x4042ac,%esi
    dcea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    dced:	85 f6                	test   %esi,%esi
    dcef:	74 14                	je     dd05 <address_lifetime_timeout+0x31>
    dcf1:	89 f3                	mov    %esi,%ebx
    dcf3:	83 eb 14             	sub    $0x14,%ebx
    dcf6:	74 0b                	je     dd03 <address_lifetime_timeout+0x2f>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    dcf8:	8b 36                	mov    (%esi),%esi
    dcfa:	85 f6                	test   %esi,%esi
    dcfc:	74 07                	je     dd05 <address_lifetime_timeout+0x31>
    dcfe:	83 ee 14             	sub    $0x14,%esi
    dd01:	eb 02                	jmp    dd05 <address_lifetime_timeout+0x31>
    dd03:	31 f6                	xor    %esi,%esi
    dd05:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    dd09:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
    dd10:	83 cf ff             	or     $0xffffffff,%edi
    dd13:	85 db                	test   %ebx,%ebx
    dd15:	0f 84 87 00 00 00    	je     dda2 <address_lifetime_timeout+0xce>
	if (counter > 0) {
    dd1b:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    dd1f:	75 2b                	jne    dd4c <address_lifetime_timeout+0x78>
	if ((s32_t)((start + (u32_t)timeout) - current_time) > 0) {
    dd21:	8b 43 18             	mov    0x18(%ebx),%eax
    dd24:	2b 45 f0             	sub    -0x10(%ebp),%eax
    dd27:	03 43 1c             	add    0x1c(%ebx),%eax
    dd2a:	85 c0                	test   %eax,%eax
    dd2c:	0f 8f 9f 00 00 00    	jg     ddd1 <address_lifetime_timeout+0xfd>
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
    dd32:	c6 43 45 02          	movb   $0x2,0x45(%ebx)
	ifaddr->lifetime.timer_timeout = 0;
    dd36:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	sys_slist_find_and_remove(&active_address_lifetime_timers,
    dd3d:	8d 53 14             	lea    0x14(%ebx),%edx
    dd40:	b8 ac 42 40 00       	mov    $0x4042ac,%eax
    dd45:	e8 84 fd ff ff       	call   dace <sys_slist_find_and_remove>
		if (!is_timeout) {
    dd4a:	eb 39                	jmp    dd85 <address_lifetime_timeout+0xb1>
	if (current_time == NET_TIMEOUT_MAX_VALUE) {
    dd4c:	81 7d f0 9b ff ff 7f 	cmpl   $0x7fffff9b,-0x10(%ebp)
    dd53:	75 0b                	jne    dd60 <address_lifetime_timeout+0x8c>
    dd55:	e8 98 6b 01 00       	call   248f2 <z_impl_k_uptime_get_32>
		ifaddr->lifetime.wrap_counter--;
    dd5a:	ff 4b 20             	decl   0x20(%ebx)
		ifaddr->lifetime.timer_start = k_uptime_get_32();
    dd5d:	89 43 18             	mov    %eax,0x18(%ebx)
		*next_wakeup = NET_TIMEOUT_MAX_VALUE;
    dd60:	b9 9b ff ff 7f       	mov    $0x7fffff9b,%ecx
	if (ifaddr->lifetime.wrap_counter > 0) {
    dd65:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    dd69:	7f 03                	jg     dd6e <address_lifetime_timeout+0x9a>
		*next_wakeup = ifaddr->lifetime.timer_timeout;
    dd6b:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
			if (next_timeout < timeout_update) {
    dd6e:	3b 4d ec             	cmp    -0x14(%ebp),%ecx
    dd71:	ba 00 00 00 00       	mov    $0x0,%edx
    dd76:	89 d0                	mov    %edx,%eax
    dd78:	19 f8                	sbb    %edi,%eax
    dd7a:	73 09                	jae    dd85 <address_lifetime_timeout+0xb1>
    dd7c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    dd7f:	31 ff                	xor    %edi,%edi
				found = true;
    dd81:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
		if (current == next) {
    dd85:	39 de                	cmp    %ebx,%esi
    dd87:	74 19                	je     dda2 <address_lifetime_timeout+0xce>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
    dd89:	31 c0                	xor    %eax,%eax
    dd8b:	85 f6                	test   %esi,%esi
    dd8d:	74 0a                	je     dd99 <address_lifetime_timeout+0xc5>
    dd8f:	8b 46 14             	mov    0x14(%esi),%eax
    dd92:	85 c0                	test   %eax,%eax
    dd94:	74 03                	je     dd99 <address_lifetime_timeout+0xc5>
    dd96:	83 e8 14             	sub    $0x14,%eax
    dd99:	89 f3                	mov    %esi,%ebx
    dd9b:	89 c6                	mov    %eax,%esi
    dd9d:	e9 71 ff ff ff       	jmp    dd13 <address_lifetime_timeout+0x3f>
	if (found) {
    dda2:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
    dda6:	74 37                	je     dddf <address_lifetime_timeout+0x10b>
		k_delayed_work_submit(&address_lifetime_timer, timeout_update);
    dda8:	b8 9b ff ff 7f       	mov    $0x7fffff9b,%eax
    ddad:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ddb0:	39 d0                	cmp    %edx,%eax
    ddb2:	b8 00 00 00 00       	mov    $0x0,%eax
    ddb7:	19 f8                	sbb    %edi,%eax
    ddb9:	73 05                	jae    ddc0 <address_lifetime_timeout+0xec>
    ddbb:	ba 9b ff ff 7f       	mov    $0x7fffff9b,%edx
}
    ddc0:	83 c4 0c             	add    $0xc,%esp
		k_delayed_work_submit(&address_lifetime_timer, timeout_update);
    ddc3:	b8 20 0d 40 00       	mov    $0x400d20,%eax
}
    ddc8:	5b                   	pop    %ebx
    ddc9:	5e                   	pop    %esi
    ddca:	5f                   	pop    %edi
    ddcb:	5d                   	pop    %ebp
		k_delayed_work_submit(&address_lifetime_timer, timeout_update);
    ddcc:	e9 dc fe ff ff       	jmp    dcad <k_delayed_work_submit>
	if (current_time == NET_TIMEOUT_MAX_VALUE) {
    ddd1:	81 7d f0 9b ff ff 7f 	cmpl   $0x7fffff9b,-0x10(%ebp)
    ddd8:	75 91                	jne    dd6b <address_lifetime_timeout+0x97>
    ddda:	e9 76 ff ff ff       	jmp    dd55 <address_lifetime_timeout+0x81>
}
    dddf:	83 c4 0c             	add    $0xc,%esp
    dde2:	5b                   	pop    %ebx
    dde3:	5e                   	pop    %esi
    dde4:	5f                   	pop    %edi
    dde5:	5d                   	pop    %ebp
    dde6:	c3                   	ret    

0000dde7 <net_if_ipv6_get_best_match.isra.16>:
static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
    dde7:	55                   	push   %ebp
    dde8:	89 e5                	mov    %esp,%ebp
    ddea:	57                   	push   %edi
    ddeb:	56                   	push   %esi
		return NULL;
    ddec:	31 ff                	xor    %edi,%edi
static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
    ddee:	53                   	push   %ebx
    ddef:	83 ec 10             	sub    $0x10,%esp
	if (!ipv6) {
    ddf2:	85 c0                	test   %eax,%eax
    ddf4:	74 6c                	je     de62 <net_if_ipv6_get_best_match.isra.16+0x7b>
    ddf6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    ddf9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ddfc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ddff:	8d 58 04             	lea    0x4(%eax),%ebx
	struct in6_addr *src = NULL;
    de02:	31 ff                	xor    %edi,%edi
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    de04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
    de0b:	6b 75 f0 48          	imul   $0x48,-0x10(%ebp),%esi
    de0f:	03 75 ec             	add    -0x14(%ebp),%esi
    de12:	8b 46 44             	mov    0x44(%esi),%eax
    de15:	25 00 ff 00 02       	and    $0x200ff00,%eax
    de1a:	3d 00 01 00 02       	cmp    $0x2000100,%eax
    de1f:	75 35                	jne    de56 <net_if_ipv6_get_best_match.isra.16+0x6f>
    de21:	66 83 7b fc 02       	cmpw   $0x2,-0x4(%ebx)
    de26:	75 2e                	jne    de56 <net_if_ipv6_get_best_match.isra.16+0x6f>
	    addr->address.family == AF_INET6 &&
    de28:	66 81 3b fe 80       	cmpw   $0x80fe,(%ebx)
    de2d:	74 27                	je     de56 <net_if_ipv6_get_best_match.isra.16+0x6f>
	return get_ipaddr_diff((const u8_t *)src, (const u8_t *)dst, 16);
    de2f:	89 da                	mov    %ebx,%edx
    de31:	b9 10 00 00 00       	mov    $0x10,%ecx
    de36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    de39:	e8 0f fd ff ff       	call   db4d <get_ipaddr_diff>
		if (len >= *best_so_far) {
    de3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    de41:	38 02                	cmp    %al,(%edx)
    de43:	77 11                	ja     de56 <net_if_ipv6_get_best_match.isra.16+0x6f>
			if (ipv6->unicast[i].is_mesh_local && len < 64) {
    de45:	f6 46 47 04          	testb  $0x4,0x47(%esi)
    de49:	74 04                	je     de4f <net_if_ipv6_get_best_match.isra.16+0x68>
    de4b:	3c 3f                	cmp    $0x3f,%al
    de4d:	76 07                	jbe    de56 <net_if_ipv6_get_best_match.isra.16+0x6f>
			*best_so_far = len;
    de4f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    de52:	89 df                	mov    %ebx,%edi
    de54:	88 01                	mov    %al,(%ecx)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    de56:	ff 45 f0             	incl   -0x10(%ebp)
    de59:	83 c3 48             	add    $0x48,%ebx
    de5c:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    de60:	75 a9                	jne    de0b <net_if_ipv6_get_best_match.isra.16+0x24>
}
    de62:	83 c4 10             	add    $0x10,%esp
    de65:	89 f8                	mov    %edi,%eax
    de67:	5b                   	pop    %ebx
    de68:	5e                   	pop    %esi
    de69:	5f                   	pop    %edi
    de6a:	5d                   	pop    %ebp
    de6b:	c3                   	ret    

0000de6c <net_if_ipv4_get_best_match.isra.17>:
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
    de6c:	55                   	push   %ebp
    de6d:	89 e5                	mov    %esp,%ebp
    de6f:	57                   	push   %edi
    de70:	56                   	push   %esi
		return NULL;
    de71:	31 f6                	xor    %esi,%esi
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
    de73:	53                   	push   %ebx
    de74:	83 ec 0c             	sub    $0xc,%esp
	if (!ipv4) {
    de77:	85 c0                	test   %eax,%eax
    de79:	74 5a                	je     ded5 <net_if_ipv4_get_best_match.isra.17+0x69>
    de7b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    de7e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    de81:	89 c3                	mov    %eax,%ebx
	struct in_addr *src = NULL;
    de83:	31 f6                	xor    %esi,%esi
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    de85:	31 ff                	xor    %edi,%edi
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
    de87:	6b c7 48             	imul   $0x48,%edi,%eax
    de8a:	8b 54 03 44          	mov    0x44(%ebx,%eax,1),%edx
    de8e:	81 e2 00 ff 00 02    	and    $0x200ff00,%edx
    de94:	81 fa 00 01 00 02    	cmp    $0x2000100,%edx
    de9a:	75 33                	jne    decf <net_if_ipv4_get_best_match.isra.17+0x63>
    de9c:	66 83 3c 03 01       	cmpw   $0x1,(%ebx,%eax,1)
    dea1:	75 2c                	jne    decf <net_if_ipv4_get_best_match.isra.17+0x63>
    dea3:	8d 44 03 04          	lea    0x4(%ebx,%eax,1),%eax
    dea7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
    deaa:	e8 72 fc ff ff       	call   db21 <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
    deaf:	84 c0                	test   %al,%al
    deb1:	75 1c                	jne    decf <net_if_ipv4_get_best_match.isra.17+0x63>
	return get_ipaddr_diff((const u8_t *)src, (const u8_t *)dst, 4);
    deb3:	b9 04 00 00 00       	mov    $0x4,%ecx
    deb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    debb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    debe:	e8 8a fc ff ff       	call   db4d <get_ipaddr_diff>
		if (len >= *best_so_far) {
    dec3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    dec6:	38 01                	cmp    %al,(%ecx)
    dec8:	77 05                	ja     decf <net_if_ipv4_get_best_match.isra.17+0x63>
			*best_so_far = len;
    deca:	88 01                	mov    %al,(%ecx)
			src = &ipv4->unicast[i].address.in_addr;
    decc:	8b 75 f0             	mov    -0x10(%ebp),%esi
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    decf:	47                   	inc    %edi
    ded0:	83 ff 03             	cmp    $0x3,%edi
    ded3:	75 b2                	jne    de87 <net_if_ipv4_get_best_match.isra.17+0x1b>
}
    ded5:	83 c4 0c             	add    $0xc,%esp
    ded8:	89 f0                	mov    %esi,%eax
    deda:	5b                   	pop    %ebx
    dedb:	5e                   	pop    %esi
    dedc:	5f                   	pop    %edi
    dedd:	5d                   	pop    %ebp
    dede:	c3                   	ret    

0000dedf <need_calc_checksum.part.19>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
		link->cb(iface, lladdr, status);
	}
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
    dedf:	55                   	push   %ebp
    dee0:	89 e5                	mov    %esp,%ebp
    dee2:	53                   	push   %ebx
	return iface->if_dev->dev;
    dee3:	8b 00                	mov    (%eax),%eax
    dee5:	89 d3                	mov    %edx,%ebx
    dee7:	8b 08                	mov    (%eax),%ecx
	if (!eth->get_capabilities) {
    dee9:	8b 41 04             	mov    0x4(%ecx),%eax
    deec:	8b 40 0c             	mov    0xc(%eax),%eax
    deef:	85 c0                	test   %eax,%eax
    def1:	74 06                	je     def9 <need_calc_checksum.part.19+0x1a>
	return eth->get_capabilities(net_if_get_device(iface));
    def3:	51                   	push   %ecx
    def4:	ff d0                	call   *%eax
    def6:	5a                   	pop    %edx
    def7:	eb 02                	jmp    defb <need_calc_checksum.part.19+0x1c>
		return 0;
    def9:	31 c0                	xor    %eax,%eax
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
    defb:	85 c3                	test   %eax,%ebx
#else
	return true;
#endif
}
    defd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return !(net_eth_get_hw_capabilities(iface) & caps);
    df00:	0f 94 c0             	sete   %al
}
    df03:	c9                   	leave  
    df04:	c3                   	ret    

0000df05 <net_if_ipv6_start_dad>:
{
    df05:	55                   	push   %ebp
    df06:	89 e5                	mov    %esp,%ebp
    df08:	56                   	push   %esi
    df09:	53                   	push   %ebx
    df0a:	89 c6                	mov    %eax,%esi
 */
static inline bool net_if_is_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return atomic_test_bit(iface->if_dev->flags, NET_IF_UP);
    df0c:	8b 00                	mov    (%eax),%eax
	ifaddr->addr_state = NET_ADDR_TENTATIVE;
    df0e:	c6 42 45 00          	movb   $0x0,0x45(%edx)
    df12:	83 c0 0c             	add    $0xc,%eax
{
    df15:	89 d3                	mov    %edx,%ebx
    df17:	31 d2                	xor    %edx,%edx
    df19:	e8 06 fd ff ff       	call   dc24 <atomic_test_bit>
	if (net_if_is_up(iface)) {
    df1e:	84 c0                	test   %al,%al
    df20:	74 24                	je     df46 <net_if_ipv6_start_dad+0x41>
		if (!net_ipv6_start_dad(iface, ifaddr)) {
    df22:	53                   	push   %ebx
		ifaddr->dad_count = 1;
    df23:	c6 43 46 01          	movb   $0x1,0x46(%ebx)
		if (!net_ipv6_start_dad(iface, ifaddr)) {
    df27:	56                   	push   %esi
    df28:	e8 68 5a 00 00       	call   13995 <net_ipv6_start_dad>
    df2d:	5a                   	pop    %edx
    df2e:	85 c0                	test   %eax,%eax
    df30:	59                   	pop    %ecx
    df31:	75 13                	jne    df46 <net_if_ipv6_start_dad+0x41>
}
    df33:	8d 65 f8             	lea    -0x8(%ebp),%esp
			k_delayed_work_submit(&ifaddr->dad_timer, DAD_TIMEOUT);
    df36:	8d 43 24             	lea    0x24(%ebx),%eax
    df39:	ba 64 00 00 00       	mov    $0x64,%edx
}
    df3e:	5b                   	pop    %ebx
    df3f:	5e                   	pop    %esi
    df40:	5d                   	pop    %ebp
			k_delayed_work_submit(&ifaddr->dad_timer, DAD_TIMEOUT);
    df41:	e9 67 fd ff ff       	jmp    dcad <k_delayed_work_submit>
}
    df46:	8d 65 f8             	lea    -0x8(%ebp),%esp
    df49:	5b                   	pop    %ebx
    df4a:	5e                   	pop    %esi
    df4b:	5d                   	pop    %ebp
    df4c:	c3                   	ret    

0000df4d <net_if_queue_tx>:
{
    df4d:	55                   	push   %ebp
    df4e:	89 e5                	mov    %esp,%ebp
    df50:	53                   	push   %ebx
	u8_t tc = net_tx_priority2tc(prio);
    df51:	6a 00                	push   $0x0
{
    df53:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	u8_t tc = net_tx_priority2tc(prio);
    df56:	e8 1f 27 00 00       	call   1067a <net_tx_priority2tc>
    df5b:	5a                   	pop    %edx
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    df5c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    df63:	c7 43 08 87 f6 00 00 	movl   $0xf687,0x8(%ebx)
    df6a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	net_tc_submit_to_tx_queue(tc, pkt);
    df71:	0f b6 c0             	movzbl %al,%eax
    df74:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
    df77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_tc_submit_to_tx_queue(tc, pkt);
    df7a:	89 45 08             	mov    %eax,0x8(%ebp)
}
    df7d:	c9                   	leave  
	net_tc_submit_to_tx_queue(tc, pkt);
    df7e:	e9 c1 26 00 00       	jmp    10644 <net_tc_submit_to_tx_queue>

0000df83 <net_if_get_default>:
	return iface ? iface : __net_if_start;
    df83:	b8 a0 aa 40 00       	mov    $0x40aaa0,%eax
	if (__net_if_start == __net_if_end) {
    df88:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    df8d:	75 02                	jne    df91 <net_if_get_default+0xe>
		return NULL;
    df8f:	31 c0                	xor    %eax,%eax
}
    df91:	c3                   	ret    

0000df92 <net_if_config_ipv6_get>:
{
    df92:	55                   	push   %ebp
    df93:	89 e5                	mov    %esp,%ebp
    df95:	8b 55 08             	mov    0x8(%ebp),%edx
    df98:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (iface->config.ip.ipv6) {
    df9b:	8b 4a 04             	mov    0x4(%edx),%ecx
    df9e:	85 c9                	test   %ecx,%ecx
    dfa0:	74 08                	je     dfaa <net_if_config_ipv6_get+0x18>
		if (ipv6) {
    dfa2:	85 c0                	test   %eax,%eax
    dfa4:	74 24                	je     dfca <net_if_config_ipv6_get+0x38>
			*ipv6 = iface->config.ip.ipv6;
    dfa6:	89 08                	mov    %ecx,(%eax)
    dfa8:	eb 20                	jmp    dfca <net_if_config_ipv6_get+0x38>
		if (ipv6_addresses[i].iface) {
    dfaa:	83 3d e8 0c 40 00 00 	cmpl   $0x0,0x400ce8
    dfb1:	75 1b                	jne    dfce <net_if_config_ipv6_get+0x3c>
		iface->config.ip.ipv6 = &ipv6_addresses[i].ipv6;
    dfb3:	c7 42 04 60 0b 40 00 	movl   $0x400b60,0x4(%edx)
		if (ipv6) {
    dfba:	85 c0                	test   %eax,%eax
		ipv6_addresses[i].iface = iface;
    dfbc:	89 15 e8 0c 40 00    	mov    %edx,0x400ce8
		if (ipv6) {
    dfc2:	74 06                	je     dfca <net_if_config_ipv6_get+0x38>
			*ipv6 = &ipv6_addresses[i].ipv6;
    dfc4:	c7 00 60 0b 40 00    	movl   $0x400b60,(%eax)
    dfca:	31 c0                	xor    %eax,%eax
    dfcc:	eb 05                	jmp    dfd3 <net_if_config_ipv6_get+0x41>
	return -ESRCH;
    dfce:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    dfd3:	5d                   	pop    %ebp
    dfd4:	c3                   	ret    

0000dfd5 <net_if_start_rs>:
{
    dfd5:	55                   	push   %ebp
    dfd6:	89 e5                	mov    %esp,%ebp
    dfd8:	53                   	push   %ebx
    dfd9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    dfdc:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    dfdf:	85 db                	test   %ebx,%ebx
    dfe1:	74 1f                	je     e002 <net_if_start_rs+0x2d>
	if (!net_ipv6_start_rs(iface)) {
    dfe3:	50                   	push   %eax
    dfe4:	e8 05 5e 00 00       	call   13dee <net_ipv6_start_rs>
    dfe9:	5a                   	pop    %edx
    dfea:	85 c0                	test   %eax,%eax
    dfec:	75 14                	jne    e002 <net_if_start_rs+0x2d>
		k_delayed_work_submit(&ipv6->rs_timer, RS_TIMEOUT);
    dfee:	8d 83 58 01 00 00    	lea    0x158(%ebx),%eax
    dff4:	ba e8 03 00 00       	mov    $0x3e8,%edx
}
    dff9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    dffc:	c9                   	leave  
		k_delayed_work_submit(&ipv6->rs_timer, RS_TIMEOUT);
    dffd:	e9 ab fc ff ff       	jmp    dcad <k_delayed_work_submit>
}
    e002:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e005:	c9                   	leave  
    e006:	c3                   	ret    

0000e007 <rs_timeout>:
{
    e007:	55                   	push   %ebp
    e008:	89 e5                	mov    %esp,%ebp
    e00a:	8b 45 08             	mov    0x8(%ebp),%eax
	ipv6->rs_count++;
    e00d:	8a 50 2e             	mov    0x2e(%eax),%dl
	struct net_if_ipv6 *ipv6 = CONTAINER_OF(work,
    e010:	8d 88 a8 fe ff ff    	lea    -0x158(%eax),%ecx
	ipv6->rs_count++;
    e016:	42                   	inc    %edx
    e017:	88 50 2e             	mov    %dl,0x2e(%eax)
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e01a:	b8 a0 aa 40 00       	mov    $0x40aaa0,%eax
    e01f:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    e024:	74 18                	je     e03e <rs_timeout+0x37>
		if (iface->config.ip.ipv6 == ipv6) {
    e026:	39 48 04             	cmp    %ecx,0x4(%eax)
    e029:	75 0e                	jne    e039 <rs_timeout+0x32>
	if (ipv6->rs_count < RS_COUNT) {
    e02b:	80 fa 02             	cmp    $0x2,%dl
    e02e:	77 0e                	ja     e03e <rs_timeout+0x37>
		net_if_start_rs(iface);
    e030:	89 45 08             	mov    %eax,0x8(%ebp)
}
    e033:	5d                   	pop    %ebp
		net_if_start_rs(iface);
    e034:	e9 9c ff ff ff       	jmp    dfd5 <net_if_start_rs>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e039:	83 c0 20             	add    $0x20,%eax
    e03c:	eb e1                	jmp    e01f <rs_timeout+0x18>
}
    e03e:	5d                   	pop    %ebp
    e03f:	c3                   	ret    

0000e040 <net_if_ipv6_addr_lookup>:
{
    e040:	55                   	push   %ebp
    e041:	89 e5                	mov    %esp,%ebp
    e043:	57                   	push   %edi
    e044:	56                   	push   %esi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e045:	be a0 aa 40 00       	mov    $0x40aaa0,%esi
{
    e04a:	53                   	push   %ebx
    e04b:	83 ec 08             	sub    $0x8,%esp
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e04e:	81 fe c0 aa 40 00    	cmp    $0x40aac0,%esi
    e054:	74 5d                	je     e0b3 <net_if_ipv6_addr_lookup+0x73>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e056:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
    e059:	85 db                	test   %ebx,%ebx
    e05b:	75 05                	jne    e062 <net_if_ipv6_addr_lookup+0x22>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e05d:	83 c6 20             	add    $0x20,%esi
    e060:	eb ec                	jmp    e04e <net_if_ipv6_addr_lookup+0xe>
    e062:	89 df                	mov    %ebx,%edi
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e064:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			if (!ipv6->unicast[i].is_used ||
    e06b:	6b 45 f0 48          	imul   $0x48,-0x10(%ebp),%eax
    e06f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e072:	f6 44 03 47 02       	testb  $0x2,0x47(%ebx,%eax,1)
    e077:	74 2c                	je     e0a5 <net_if_ipv6_addr_lookup+0x65>
    e079:	66 83 3f 02          	cmpw   $0x2,(%edi)
    e07d:	75 26                	jne    e0a5 <net_if_ipv6_addr_lookup+0x65>
			if (net_ipv6_is_prefix(
    e07f:	8d 57 04             	lea    0x4(%edi),%edx
    e082:	b9 80 00 00 00       	mov    $0x80,%ecx
    e087:	8b 45 08             	mov    0x8(%ebp),%eax
    e08a:	e8 9f fb ff ff       	call   dc2e <net_ipv6_is_prefix>
    e08f:	84 c0                	test   %al,%al
    e091:	74 12                	je     e0a5 <net_if_ipv6_addr_lookup+0x65>
				if (ret) {
    e093:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    e097:	74 05                	je     e09e <net_if_ipv6_addr_lookup+0x5e>
					*ret = iface;
    e099:	8b 45 0c             	mov    0xc(%ebp),%eax
    e09c:	89 30                	mov    %esi,(%eax)
				return &ipv6->unicast[i];
    e09e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e0a1:	01 d8                	add    %ebx,%eax
    e0a3:	eb 10                	jmp    e0b5 <net_if_ipv6_addr_lookup+0x75>
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e0a5:	ff 45 f0             	incl   -0x10(%ebp)
    e0a8:	83 c7 48             	add    $0x48,%edi
    e0ab:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    e0af:	75 ba                	jne    e06b <net_if_ipv6_addr_lookup+0x2b>
    e0b1:	eb aa                	jmp    e05d <net_if_ipv6_addr_lookup+0x1d>
	return NULL;
    e0b3:	31 c0                	xor    %eax,%eax
}
    e0b5:	5a                   	pop    %edx
    e0b6:	59                   	pop    %ecx
    e0b7:	5b                   	pop    %ebx
    e0b8:	5e                   	pop    %esi
    e0b9:	5f                   	pop    %edi
    e0ba:	5d                   	pop    %ebp
    e0bb:	c3                   	ret    

0000e0bc <dad_timeout>:
{
    e0bc:	55                   	push   %ebp
    e0bd:	89 e5                	mov    %esp,%ebp
    e0bf:	56                   	push   %esi
    e0c0:	53                   	push   %ebx
    e0c1:	51                   	push   %ecx
	struct net_if *iface = NULL;
    e0c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
{
    e0c9:	8b 45 08             	mov    0x8(%ebp),%eax
	ifaddr->addr_state = NET_ADDR_PREFERRED;
    e0cc:	c6 40 21 01          	movb   $0x1,0x21(%eax)
	tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr, &iface);
    e0d0:	8d 70 dc             	lea    -0x24(%eax),%esi
    e0d3:	8d 58 e0             	lea    -0x20(%eax),%ebx
    e0d6:	8d 45 f4             	lea    -0xc(%ebp),%eax
    e0d9:	50                   	push   %eax
    e0da:	53                   	push   %ebx
    e0db:	e8 60 ff ff ff       	call   e040 <net_if_ipv6_addr_lookup>
    e0e0:	5a                   	pop    %edx
	if (tmp == ifaddr) {
    e0e1:	39 f0                	cmp    %esi,%eax
	tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr, &iface);
    e0e3:	59                   	pop    %ecx
	if (tmp == ifaddr) {
    e0e4:	75 18                	jne    e0fe <dad_timeout+0x42>
		net_mgmt_event_notify(NET_EVENT_IPV6_DAD_SUCCEED, iface);
    e0e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e0e9:	b8 0d 00 60 f0       	mov    $0xf060000d,%eax
    e0ee:	e8 ce fb ff ff       	call   dcc1 <net_mgmt_event_notify>
		net_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);
    e0f3:	53                   	push   %ebx
    e0f4:	ff 75 f4             	pushl  -0xc(%ebp)
    e0f7:	e8 ae 45 00 00       	call   126aa <net_ipv6_nbr_rm>
    e0fc:	58                   	pop    %eax
    e0fd:	5a                   	pop    %edx
}
    e0fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e101:	5b                   	pop    %ebx
    e102:	5e                   	pop    %esi
    e103:	5d                   	pop    %ebp
    e104:	c3                   	ret    

0000e105 <net_if_ipv6_addr_lookup_by_iface>:
{
    e105:	55                   	push   %ebp
    e106:	89 e5                	mov    %esp,%ebp
    e108:	57                   	push   %edi
    e109:	56                   	push   %esi
    e10a:	53                   	push   %ebx
    e10b:	51                   	push   %ecx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e10c:	8b 45 08             	mov    0x8(%ebp),%eax
    e10f:	8b 78 04             	mov    0x4(%eax),%edi
	if (!ipv6) {
    e112:	85 ff                	test   %edi,%edi
    e114:	75 04                	jne    e11a <net_if_ipv6_addr_lookup_by_iface+0x15>
		return NULL;
    e116:	31 c0                	xor    %eax,%eax
    e118:	eb 3c                	jmp    e156 <net_if_ipv6_addr_lookup_by_iface+0x51>
    e11a:	89 fe                	mov    %edi,%esi
    e11c:	31 db                	xor    %ebx,%ebx
		if (!ipv6->unicast[i].is_used ||
    e11e:	6b c3 48             	imul   $0x48,%ebx,%eax
    e121:	01 f8                	add    %edi,%eax
    e123:	89 45 f0             	mov    %eax,-0x10(%ebp)
    e126:	f6 40 47 02          	testb  $0x2,0x47(%eax)
    e12a:	74 1f                	je     e14b <net_if_ipv6_addr_lookup_by_iface+0x46>
    e12c:	66 83 3e 02          	cmpw   $0x2,(%esi)
    e130:	75 19                	jne    e14b <net_if_ipv6_addr_lookup_by_iface+0x46>
		if (net_ipv6_is_prefix(
    e132:	8d 56 04             	lea    0x4(%esi),%edx
    e135:	b9 80 00 00 00       	mov    $0x80,%ecx
    e13a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e13d:	e8 ec fa ff ff       	call   dc2e <net_ipv6_is_prefix>
    e142:	84 c0                	test   %al,%al
    e144:	74 05                	je     e14b <net_if_ipv6_addr_lookup_by_iface+0x46>
			return &ipv6->unicast[i];
    e146:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e149:	eb 0b                	jmp    e156 <net_if_ipv6_addr_lookup_by_iface+0x51>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e14b:	43                   	inc    %ebx
    e14c:	83 c6 48             	add    $0x48,%esi
    e14f:	83 fb 03             	cmp    $0x3,%ebx
    e152:	75 ca                	jne    e11e <net_if_ipv6_addr_lookup_by_iface+0x19>
    e154:	eb c0                	jmp    e116 <net_if_ipv6_addr_lookup_by_iface+0x11>
}
    e156:	5a                   	pop    %edx
    e157:	5b                   	pop    %ebx
    e158:	5e                   	pop    %esi
    e159:	5f                   	pop    %edi
    e15a:	5d                   	pop    %ebp
    e15b:	c3                   	ret    

0000e15c <net_if_ipv6_addr_update_lifetime>:
{
    e15c:	55                   	push   %ebp
	u64_t expire_timeout = K_SECONDS((u64_t)vlifetime);
    e15d:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
{
    e162:	89 e5                	mov    %esp,%ebp
	u64_t expire_timeout = K_SECONDS((u64_t)vlifetime);
    e164:	89 c8                	mov    %ecx,%eax
{
    e166:	57                   	push   %edi
	u64_t expire_timeout = K_SECONDS((u64_t)vlifetime);
    e167:	f7 65 0c             	mull   0xc(%ebp)
{
    e16a:	56                   	push   %esi
	u64_t expire_timeout = K_SECONDS((u64_t)vlifetime);
    e16b:	89 d7                	mov    %edx,%edi
{
    e16d:	53                   	push   %ebx
    e16e:	8b 5d 08             	mov    0x8(%ebp),%ebx
Z_GENLIST_APPEND(slist, snode)
    e171:	8b 15 b0 42 40 00    	mov    0x4042b0,%edx
	u64_t expire_timeout = K_SECONDS((u64_t)vlifetime);
    e177:	89 c6                	mov    %eax,%esi
	ifaddr->addr_state = NET_ADDR_PREFERRED;
    e179:	c6 43 45 01          	movb   $0x1,0x45(%ebx)
	sys_slist_append(&active_address_lifetime_timers,
    e17d:	8d 43 14             	lea    0x14(%ebx),%eax
	parent->next = child;
    e180:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
Z_GENLIST_APPEND(slist, snode)
    e187:	85 d2                	test   %edx,%edx
    e189:	75 0c                	jne    e197 <net_if_ipv6_addr_update_lifetime+0x3b>
	list->tail = node;
    e18b:	a3 b0 42 40 00       	mov    %eax,0x4042b0
	list->head = node;
    e190:	a3 ac 42 40 00       	mov    %eax,0x4042ac
    e195:	eb 07                	jmp    e19e <net_if_ipv6_addr_update_lifetime+0x42>
	parent->next = child;
    e197:	89 02                	mov    %eax,(%edx)
	list->tail = node;
    e199:	a3 b0 42 40 00       	mov    %eax,0x4042b0
    e19e:	e8 4f 67 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	ifaddr->lifetime.timer_start = k_uptime_get_32();
    e1a3:	89 43 18             	mov    %eax,0x18(%ebx)
	ifaddr->lifetime.wrap_counter = expire_timeout /
    e1a6:	6a 00                	push   $0x0
    e1a8:	68 9b ff ff 7f       	push   $0x7fffff9b
    e1ad:	57                   	push   %edi
    e1ae:	56                   	push   %esi
    e1af:	e8 39 30 ff ff       	call   11ed <__udivdi3>
	ifaddr->lifetime.timer_timeout = expire_timeout -
    e1b4:	69 d0 9b ff ff 7f    	imul   $0x7fffff9b,%eax,%edx
	ifaddr->lifetime.wrap_counter = expire_timeout /
    e1ba:	83 c4 10             	add    $0x10,%esp
	ifaddr->lifetime.timer_timeout = expire_timeout -
    e1bd:	29 d6                	sub    %edx,%esi
    e1bf:	89 73 1c             	mov    %esi,0x1c(%ebx)
	ifaddr->lifetime.wrap_counter = expire_timeout /
    e1c2:	89 43 20             	mov    %eax,0x20(%ebx)
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
    e1c5:	68 2c 0d 40 00       	push   $0x400d2c
    e1ca:	e8 6a 65 01 00       	call   24739 <z_timeout_remaining>
    e1cf:	ba e8 03 00 00       	mov    $0x3e8,%edx
    e1d4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    e1db:	f7 ea                	imul   %edx
    e1dd:	6a 64                	push   $0x64
    e1df:	52                   	push   %edx
    e1e0:	50                   	push   %eax
    e1e1:	e8 07 30 ff ff       	call   11ed <__udivdi3>
    e1e6:	83 c4 10             	add    $0x10,%esp
    e1e9:	89 c6                	mov    %eax,%esi
	if (!remaining || (ifaddr->lifetime.wrap_counter == 0 &&
    e1eb:	85 c0                	test   %eax,%eax
    e1ed:	74 0b                	je     e1fa <net_if_ipv6_addr_update_lifetime+0x9e>
    e1ef:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    e1f3:	75 33                	jne    e228 <net_if_ipv6_addr_update_lifetime+0xcc>
    e1f5:	39 43 1c             	cmp    %eax,0x1c(%ebx)
    e1f8:	7d 2e                	jge    e228 <net_if_ipv6_addr_update_lifetime+0xcc>
		k_delayed_work_cancel(&address_lifetime_timer);
    e1fa:	68 20 0d 40 00       	push   $0x400d20
    e1ff:	e8 a3 63 01 00       	call   245a7 <k_delayed_work_cancel>
    e204:	58                   	pop    %eax
		if (ifaddr->lifetime.wrap_counter > 0 && remaining == 0) {
    e205:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    e209:	7e 09                	jle    e214 <net_if_ipv6_addr_update_lifetime+0xb8>
			k_delayed_work_submit(&address_lifetime_timer,
    e20b:	ba 9b ff ff 7f       	mov    $0x7fffff9b,%edx
		if (ifaddr->lifetime.wrap_counter > 0 && remaining == 0) {
    e210:	85 f6                	test   %esi,%esi
    e212:	74 03                	je     e217 <net_if_ipv6_addr_update_lifetime+0xbb>
			k_delayed_work_submit(&address_lifetime_timer,
    e214:	8b 53 1c             	mov    0x1c(%ebx),%edx
}
    e217:	8d 65 f4             	lea    -0xc(%ebp),%esp
			k_delayed_work_submit(&address_lifetime_timer,
    e21a:	b8 20 0d 40 00       	mov    $0x400d20,%eax
}
    e21f:	5b                   	pop    %ebx
    e220:	5e                   	pop    %esi
    e221:	5f                   	pop    %edi
    e222:	5d                   	pop    %ebp
			k_delayed_work_submit(&address_lifetime_timer,
    e223:	e9 85 fa ff ff       	jmp    dcad <k_delayed_work_submit>
}
    e228:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e22b:	5b                   	pop    %ebx
    e22c:	5e                   	pop    %esi
    e22d:	5f                   	pop    %edi
    e22e:	5d                   	pop    %ebp
    e22f:	c3                   	ret    

0000e230 <net_if_ipv6_addr_add>:
{
    e230:	55                   	push   %ebp
    e231:	89 e5                	mov    %esp,%ebp
    e233:	57                   	push   %edi
    e234:	56                   	push   %esi
    e235:	53                   	push   %ebx
    e236:	83 ec 30             	sub    $0x30,%esp
    e239:	8b 45 10             	mov    0x10(%ebp),%eax
    e23c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e23f:	8d 45 d0             	lea    -0x30(%ebp),%eax
    e242:	50                   	push   %eax
    e243:	ff 75 08             	pushl  0x8(%ebp)
    e246:	e8 47 fd ff ff       	call   df92 <net_if_config_ipv6_get>
    e24b:	5a                   	pop    %edx
    e24c:	85 c0                	test   %eax,%eax
    e24e:	59                   	pop    %ecx
    e24f:	79 07                	jns    e258 <net_if_ipv6_addr_add+0x28>
		return NULL;
    e251:	31 c0                	xor    %eax,%eax
    e253:	e9 33 02 00 00       	jmp    e48b <net_if_ipv6_addr_add+0x25b>
	ifaddr = ipv6_addr_find(iface, addr);
    e258:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e25b:	31 ff                	xor    %edi,%edi
	ifaddr = ipv6_addr_find(iface, addr);
    e25d:	8b 48 04             	mov    0x4(%eax),%ecx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e260:	8d 71 04             	lea    0x4(%ecx),%esi
		if (!ipv6->unicast[i].is_used) {
    e263:	6b df 48             	imul   $0x48,%edi,%ebx
    e266:	01 cb                	add    %ecx,%ebx
    e268:	f6 43 47 02          	testb  $0x2,0x47(%ebx)
    e26c:	74 1b                	je     e289 <net_if_ipv6_addr_add+0x59>
		if (net_ipv6_addr_cmp(
    e26e:	89 f2                	mov    %esi,%edx
    e270:	8b 45 0c             	mov    0xc(%ebp),%eax
    e273:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    e276:	e8 1c fa ff ff       	call   dc97 <net_ipv6_addr_cmp>
    e27b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    e27e:	84 c0                	test   %al,%al
    e280:	74 07                	je     e289 <net_if_ipv6_addr_add+0x59>
			return &ipv6->unicast[i];
    e282:	89 d8                	mov    %ebx,%eax
	if (ifaddr) {
    e284:	e9 02 02 00 00       	jmp    e48b <net_if_ipv6_addr_add+0x25b>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e289:	47                   	inc    %edi
    e28a:	83 c6 48             	add    $0x48,%esi
    e28d:	83 ff 03             	cmp    $0x3,%edi
    e290:	75 d1                	jne    e263 <net_if_ipv6_addr_add+0x33>
		if (ipv6->unicast[i].is_used) {
    e292:	8b 45 d0             	mov    -0x30(%ebp),%eax
    e295:	f6 40 47 02          	testb  $0x2,0x47(%eax)
    e299:	74 1b                	je     e2b6 <net_if_ipv6_addr_add+0x86>
    e29b:	f6 80 8f 00 00 00 02 	testb  $0x2,0x8f(%eax)
    e2a2:	74 1b                	je     e2bf <net_if_ipv6_addr_add+0x8f>
    e2a4:	f6 80 d7 00 00 00 02 	testb  $0x2,0xd7(%eax)
    e2ab:	75 a4                	jne    e251 <net_if_ipv6_addr_add+0x21>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e2ad:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    e2b4:	eb 10                	jmp    e2c6 <net_if_ipv6_addr_add+0x96>
    e2b6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    e2bd:	eb 07                	jmp    e2c6 <net_if_ipv6_addr_add+0x96>
    e2bf:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
    e2c6:	6b 4d c8 48          	imul   $0x48,-0x38(%ebp),%ecx
    e2ca:	89 4d cc             	mov    %ecx,-0x34(%ebp)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    e2cd:	8b 75 0c             	mov    0xc(%ebp),%esi
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
    e2d0:	8d 14 08             	lea    (%eax,%ecx,1),%edx
	ifaddr->addr_type = addr_type;
    e2d3:	8a 4d c4             	mov    -0x3c(%ebp),%cl
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    e2d6:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    e2d9:	89 55 c4             	mov    %edx,-0x3c(%ebp)
	ifaddr->is_used = true;
    e2dc:	8d 5a 40             	lea    0x40(%edx),%ebx
    e2df:	80 4b 07 02          	orb    $0x2,0x7(%ebx)
	ifaddr->addr_type = addr_type;
    e2e3:	88 4a 44             	mov    %cl,0x44(%edx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    e2e6:	b9 04 00 00 00       	mov    $0x4,%ecx
    e2eb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    e2ed:	8d 7a 04             	lea    0x4(%edx),%edi
    e2f0:	8d 75 d4             	lea    -0x2c(%ebp),%esi
    e2f3:	b9 04 00 00 00       	mov    $0x4,%ecx
	ifaddr->address.family = AF_INET6;
    e2f8:	66 c7 02 02 00       	movw   $0x2,(%edx)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
    e2fd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	k_delayed_work_init(&ifaddr->dad_timer, dad_timeout);
    e2ff:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    e302:	68 bc e0 00 00       	push   $0xe0bc
    e307:	8d 44 08 24          	lea    0x24(%eax,%ecx,1),%eax
    e30b:	50                   	push   %eax
    e30c:	e8 94 61 01 00       	call   244a5 <k_delayed_work_init>
    e311:	5e                   	pop    %esi
    e312:	8a 43 07             	mov    0x7(%ebx),%al
    e315:	5f                   	pop    %edi
	if (vlifetime) {
    e316:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    e319:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    e31d:	74 13                	je     e332 <net_if_ipv6_addr_add+0x102>
		ifaddr->is_infinite = false;
    e31f:	83 e0 fe             	and    $0xfffffffe,%eax
    e322:	88 43 07             	mov    %al,0x7(%ebx)
		net_if_ipv6_addr_update_lifetime(ifaddr, vlifetime);
    e325:	ff 75 14             	pushl  0x14(%ebp)
    e328:	52                   	push   %edx
    e329:	e8 2e fe ff ff       	call   e15c <net_if_ipv6_addr_update_lifetime>
    e32e:	59                   	pop    %ecx
    e32f:	5b                   	pop    %ebx
    e330:	eb 06                	jmp    e338 <net_if_ipv6_addr_add+0x108>
		ifaddr->is_infinite = true;
    e332:	83 c8 01             	or     $0x1,%eax
    e335:	88 43 07             	mov    %al,0x7(%ebx)
	return iface->if_dev->l2;
    e338:	8b 45 08             	mov    0x8(%ebp),%eax
    e33b:	8b 00                	mov    (%eax),%eax
	if (net_if_l2(iface)->get_flags) {
    e33d:	8b 40 04             	mov    0x4(%eax),%eax
    e340:	8b 40 0c             	mov    0xc(%eax),%eax
    e343:	85 c0                	test   %eax,%eax
    e345:	0f 84 1f 01 00 00    	je     e46a <net_if_ipv6_addr_add+0x23a>
		flags = net_if_l2(iface)->get_flags(iface);
    e34b:	ff 75 08             	pushl  0x8(%ebp)
		join_mcast_nodes(iface, &ipv6->unicast[i].address.in6_addr);
    e34e:	8b 75 d0             	mov    -0x30(%ebp),%esi
		flags = net_if_l2(iface)->get_flags(iface);
    e351:	ff d0                	call   *%eax
    e353:	5a                   	pop    %edx
    e354:	88 45 c4             	mov    %al,-0x3c(%ebp)
	if (flags & NET_L2_MULTICAST) {
    e357:	a8 01                	test   $0x1,%al
    e359:	0f 84 0b 01 00 00    	je     e46a <net_if_ipv6_addr_add+0x23a>
	ret = net_ipv6_mld_join(iface, &addr);
    e35f:	8d 55 e4             	lea    -0x1c(%ebp),%edx
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
    e362:	c7 45 e4 ff 02 00 00 	movl   $0x2ff,-0x1c(%ebp)
    e369:	52                   	push   %edx
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
    e36a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e371:	ff 75 08             	pushl  0x8(%ebp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
    e374:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
    e37b:	c7 45 f0 00 00 00 01 	movl   $0x1000000,-0x10(%ebp)
    e382:	e8 78 5e 00 00       	call   141ff <net_ipv6_mld_join>
    e387:	5b                   	pop    %ebx
    e388:	5f                   	pop    %edi
	if (ret < 0 && ret != -EALREADY) {
    e389:	85 c0                	test   %eax,%eax
	ret = net_ipv6_mld_join(iface, &addr);
    e38b:	89 c7                	mov    %eax,%edi
	if (ret < 0 && ret != -EALREADY) {
    e38d:	79 48                	jns    e3d7 <net_if_ipv6_addr_add+0x1a7>
    e38f:	83 f8 bb             	cmp    $0xffffffbb,%eax
    e392:	74 43                	je     e3d7 <net_if_ipv6_addr_add+0x1a7>
		NET_ERR("Cannot join all nodes address %s (%d)",
    e394:	f6 05 88 a8 40 00 07 	testb  $0x7,0x40a888
    e39b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    e39e:	74 37                	je     e3d7 <net_if_ipv6_addr_add+0x1a7>
    e3a0:	52                   	push   %edx
    e3a1:	bb 94 51 02 00       	mov    $0x25194,%ebx
    e3a6:	6a 02                	push   $0x2
    e3a8:	e8 f1 26 00 00       	call   10a9e <net_sprint_addr>
    e3ad:	5a                   	pop    %edx
    e3ae:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    e3b4:	c1 eb 03             	shr    $0x3,%ebx
    e3b7:	59                   	pop    %ecx
    e3b8:	c1 e3 06             	shl    $0x6,%ebx
    e3bb:	50                   	push   %eax
    e3bc:	e8 9a 54 ff ff       	call   385b <log_strdup>
    e3c1:	83 cb 01             	or     $0x1,%ebx
    e3c4:	66 89 1c 24          	mov    %bx,(%esp)
    e3c8:	57                   	push   %edi
    e3c9:	50                   	push   %eax
    e3ca:	68 4a 79 02 00       	push   $0x2794a
    e3cf:	e8 15 51 ff ff       	call   34e9 <log_2>
    e3d4:	83 c4 10             	add    $0x10,%esp
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
    e3d7:	f6 45 c4 02          	testb  $0x2,-0x3c(%ebp)
    e3db:	0f 85 89 00 00 00    	jne    e46a <net_if_ipv6_addr_add+0x23a>
	dst->s6_addr[13]  = src->s6_addr[13];
    e3e1:	6b 45 c8 48          	imul   $0x48,-0x38(%ebp),%eax
	dst->s6_addr[0]   = 0xFF;
    e3e5:	c7 45 e4 ff 02 00 00 	movl   $0x2ff,-0x1c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
    e3ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
    e3f3:	c7 45 ec 00 00 00 01 	movl   $0x1000000,-0x14(%ebp)
	dst->s6_addr[12]  = 0xFF;
    e3fa:	c6 45 f0 ff          	movb   $0xff,-0x10(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
    e3fe:	8a 44 06 11          	mov    0x11(%esi,%eax,1),%al
	ret = net_ipv6_mld_join(iface, &addr);
    e402:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    e405:	88 45 f1             	mov    %al,-0xf(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    e408:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e40b:	66 8b 44 06 12       	mov    0x12(%esi,%eax,1),%ax
    e410:	57                   	push   %edi
    e411:	ff 75 08             	pushl  0x8(%ebp)
    e414:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    e418:	e8 e2 5d 00 00       	call   141ff <net_ipv6_mld_join>
    e41d:	5b                   	pop    %ebx
	if (ret < 0 && ret != -EALREADY) {
    e41e:	85 c0                	test   %eax,%eax
	ret = net_ipv6_mld_join(iface, &addr);
    e420:	5e                   	pop    %esi
    e421:	89 c6                	mov    %eax,%esi
	if (ret < 0 && ret != -EALREADY) {
    e423:	79 45                	jns    e46a <net_if_ipv6_addr_add+0x23a>
    e425:	83 f8 bb             	cmp    $0xffffffbb,%eax
    e428:	74 40                	je     e46a <net_if_ipv6_addr_add+0x23a>
		NET_ERR("Cannot join solicit node address %s (%d)",
    e42a:	f6 05 88 a8 40 00 07 	testb  $0x7,0x40a888
    e431:	74 37                	je     e46a <net_if_ipv6_addr_add+0x23a>
    e433:	57                   	push   %edi
    e434:	bb 94 51 02 00       	mov    $0x25194,%ebx
    e439:	6a 02                	push   $0x2
    e43b:	e8 5e 26 00 00       	call   10a9e <net_sprint_addr>
    e440:	5a                   	pop    %edx
    e441:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    e447:	c1 eb 03             	shr    $0x3,%ebx
    e44a:	59                   	pop    %ecx
    e44b:	c1 e3 06             	shl    $0x6,%ebx
    e44e:	50                   	push   %eax
    e44f:	e8 07 54 ff ff       	call   385b <log_strdup>
    e454:	83 cb 01             	or     $0x1,%ebx
    e457:	66 89 1c 24          	mov    %bx,(%esp)
    e45b:	56                   	push   %esi
    e45c:	50                   	push   %eax
    e45d:	68 70 79 02 00       	push   $0x27970
    e462:	e8 82 50 ff ff       	call   34e9 <log_2>
    e467:	83 c4 10             	add    $0x10,%esp
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
    e46a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    e46d:	8b 45 08             	mov    0x8(%ebp),%eax
    e470:	03 55 d0             	add    -0x30(%ebp),%edx
    e473:	e8 8d fa ff ff       	call   df05 <net_if_ipv6_start_dad>
		net_mgmt_event_notify(NET_EVENT_IPV6_ADDR_ADD, iface);
    e478:	b8 01 00 60 f0       	mov    $0xf0600001,%eax
    e47d:	8b 55 08             	mov    0x8(%ebp),%edx
    e480:	e8 3c f8 ff ff       	call   dcc1 <net_mgmt_event_notify>
		return &ipv6->unicast[i];
    e485:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e488:	03 45 d0             	add    -0x30(%ebp),%eax
}
    e48b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e48e:	5b                   	pop    %ebx
    e48f:	5e                   	pop    %esi
    e490:	5f                   	pop    %edi
    e491:	5d                   	pop    %ebp
    e492:	c3                   	ret    

0000e493 <net_if_start_dad>:
{
    e493:	55                   	push   %ebp
	struct in6_addr addr = { };
    e494:	31 c0                	xor    %eax,%eax
{
    e496:	89 e5                	mov    %esp,%ebp
    e498:	57                   	push   %edi
    e499:	56                   	push   %esi
	struct in6_addr addr = { };
    e49a:	b9 04 00 00 00       	mov    $0x4,%ecx
{
    e49f:	53                   	push   %ebx
	struct in6_addr addr = { };
    e4a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
{
    e4a3:	83 ec 18             	sub    $0x18,%esp
	struct in6_addr addr = { };
    e4a6:	f3 ab                	rep stos %eax,%es:(%edi)
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e4a8:	8d 45 e0             	lea    -0x20(%ebp),%eax
{
    e4ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e4ae:	50                   	push   %eax
    e4af:	53                   	push   %ebx
    e4b0:	e8 dd fa ff ff       	call   df92 <net_if_config_ipv6_get>
    e4b5:	5f                   	pop    %edi
    e4b6:	85 c0                	test   %eax,%eax
    e4b8:	5a                   	pop    %edx
    e4b9:	79 32                	jns    e4ed <net_if_start_dad+0x5a>
		NET_WARN("Cannot do DAD IPv6 config is not valid.");
    e4bb:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    e4c2:	0f 84 3d 01 00 00    	je     e605 <net_if_start_dad+0x172>
    e4c8:	b8 94 51 02 00       	mov    $0x25194,%eax
    e4cd:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    e4d2:	c1 e8 03             	shr    $0x3,%eax
    e4d5:	c1 e0 06             	shl    $0x6,%eax
    e4d8:	83 c8 02             	or     $0x2,%eax
    e4db:	50                   	push   %eax
    e4dc:	68 99 79 02 00       	push   $0x27999
    e4e1:	e8 a4 4f ff ff       	call   348a <log_0>
    e4e6:	5b                   	pop    %ebx
    e4e7:	5e                   	pop    %esi
    e4e8:	e9 18 01 00 00       	jmp    e605 <net_if_start_dad+0x172>
	if (!ipv6) {
    e4ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e4f1:	0f 84 0e 01 00 00    	je     e605 <net_if_start_dad+0x172>
	net_ipv6_addr_create_iid(&addr, net_if_get_link_addr(iface));
    e4f7:	8b 33                	mov    (%ebx),%esi
    e4f9:	8d 7d e4             	lea    -0x1c(%ebp),%edi
	addr->s6_addr[0] = 0xfe;
    e4fc:	c7 45 e4 fe 80 00 00 	movl   $0x80fe,-0x1c(%ebp)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
    e503:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	switch (lladdr->len) {
    e50a:	8a 46 14             	mov    0x14(%esi),%al
    e50d:	3c 06                	cmp    $0x6,%al
    e50f:	74 2b                	je     e53c <net_if_start_dad+0xa9>
    e511:	3c 08                	cmp    $0x8,%al
    e513:	74 5b                	je     e570 <net_if_start_dad+0xdd>
    e515:	3c 02                	cmp    $0x2,%al
    e517:	75 6c                	jne    e585 <net_if_start_dad+0xf2>
		if (lladdr->type == NET_LINK_IEEE802154) {
    e519:	80 7e 15 01          	cmpb   $0x1,0x15(%esi)
    e51d:	75 66                	jne    e585 <net_if_start_dad+0xf2>
			addr->s6_addr[14] = lladdr->addr[0];
    e51f:	8b 46 10             	mov    0x10(%esi),%eax
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
    e522:	c7 45 ec 00 00 00 ff 	movl   $0xff000000,-0x14(%ebp)
			addr->s6_addr[12] = 0xfe;
    e529:	66 c7 45 f0 fe 00    	movw   $0xfe,-0x10(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
    e52f:	8a 10                	mov    (%eax),%dl
    e531:	88 55 f2             	mov    %dl,-0xe(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
    e534:	8a 40 01             	mov    0x1(%eax),%al
    e537:	88 45 f3             	mov    %al,-0xd(%ebp)
    e53a:	eb 49                	jmp    e585 <net_if_start_dad+0xf2>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
    e53c:	6a 03                	push   $0x3
    e53e:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e541:	ff 76 10             	pushl  0x10(%esi)
    e544:	50                   	push   %eax
    e545:	e8 e7 c3 ff ff       	call   a931 <memcpy>
    e54a:	83 c4 0c             	add    $0xc,%esp
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
    e54d:	8b 46 10             	mov    0x10(%esi),%eax
    e550:	83 c0 03             	add    $0x3,%eax
		addr->s6_addr[11] = 0xff;
    e553:	66 c7 45 ef ff fe    	movw   $0xfeff,-0x11(%ebp)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
    e559:	6a 03                	push   $0x3
    e55b:	50                   	push   %eax
    e55c:	8d 45 f1             	lea    -0xf(%ebp),%eax
    e55f:	50                   	push   %eax
    e560:	e8 cc c3 ff ff       	call   a931 <memcpy>
    e565:	83 c4 0c             	add    $0xc,%esp
		if (lladdr->type == NET_LINK_ETHERNET) {
    e568:	80 7e 15 03          	cmpb   $0x3,0x15(%esi)
    e56c:	75 17                	jne    e585 <net_if_start_dad+0xf2>
    e56e:	eb 11                	jmp    e581 <net_if_start_dad+0xee>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
    e570:	6a 08                	push   $0x8
    e572:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e575:	ff 76 10             	pushl  0x10(%esi)
    e578:	50                   	push   %eax
    e579:	e8 b3 c3 ff ff       	call   a931 <memcpy>
    e57e:	83 c4 0c             	add    $0xc,%esp
		addr->s6_addr[8] ^= 0x02;
    e581:	80 75 ec 02          	xorb   $0x2,-0x14(%ebp)
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
    e585:	6a 00                	push   $0x0
    e587:	6a 01                	push   $0x1
    e589:	57                   	push   %edi
    e58a:	53                   	push   %ebx
    e58b:	e8 a0 fc ff ff       	call   e230 <net_if_ipv6_addr_add>
    e590:	83 c4 10             	add    $0x10,%esp
    e593:	89 c6                	mov    %eax,%esi
	if (!ifaddr) {
    e595:	85 c0                	test   %eax,%eax
    e597:	75 47                	jne    e5e0 <net_if_start_dad+0x14d>
		NET_ERR("Cannot add %s address to interface %p, DAD fails",
    e599:	f6 05 88 a8 40 00 07 	testb  $0x7,0x40a888
    e5a0:	74 3e                	je     e5e0 <net_if_start_dad+0x14d>
    e5a2:	b8 94 51 02 00       	mov    $0x25194,%eax
    e5a7:	57                   	push   %edi
    e5a8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    e5ad:	6a 02                	push   $0x2
    e5af:	c1 e8 03             	shr    $0x3,%eax
    e5b2:	c1 e0 06             	shl    $0x6,%eax
    e5b5:	83 c8 01             	or     $0x1,%eax
    e5b8:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    e5bc:	e8 dd 24 00 00       	call   10a9e <net_sprint_addr>
    e5c1:	5a                   	pop    %edx
    e5c2:	59                   	pop    %ecx
    e5c3:	50                   	push   %eax
    e5c4:	e8 92 52 ff ff       	call   385b <log_strdup>
    e5c9:	66 8b 4d de          	mov    -0x22(%ebp),%cx
    e5cd:	66 89 0c 24          	mov    %cx,(%esp)
    e5d1:	53                   	push   %ebx
    e5d2:	50                   	push   %eax
    e5d3:	68 c1 79 02 00       	push   $0x279c1
    e5d8:	e8 0c 4f ff ff       	call   34e9 <log_2>
    e5dd:	83 c4 10             	add    $0x10,%esp
{
    e5e0:	31 ff                	xor    %edi,%edi
		if (!ipv6->unicast[i].is_used ||
    e5e2:	6b d7 48             	imul   $0x48,%edi,%edx
    e5e5:	03 55 e0             	add    -0x20(%ebp),%edx
    e5e8:	f6 42 47 02          	testb  $0x2,0x47(%edx)
    e5ec:	74 11                	je     e5ff <net_if_start_dad+0x16c>
    e5ee:	66 83 3a 02          	cmpw   $0x2,(%edx)
    e5f2:	75 0b                	jne    e5ff <net_if_start_dad+0x16c>
		    ipv6->unicast[i].address.family != AF_INET6 ||
    e5f4:	39 f2                	cmp    %esi,%edx
    e5f6:	74 07                	je     e5ff <net_if_start_dad+0x16c>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
    e5f8:	89 d8                	mov    %ebx,%eax
    e5fa:	e8 06 f9 ff ff       	call   df05 <net_if_ipv6_start_dad>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e5ff:	47                   	inc    %edi
    e600:	83 ff 03             	cmp    $0x3,%edi
    e603:	75 dd                	jne    e5e2 <net_if_start_dad+0x14f>
}
    e605:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e608:	5b                   	pop    %ebx
    e609:	5e                   	pop    %esi
    e60a:	5f                   	pop    %edi
    e60b:	5d                   	pop    %ebp
    e60c:	c3                   	ret    

0000e60d <net_if_ipv6_maddr_add>:
{
    e60d:	55                   	push   %ebp
    e60e:	89 e5                	mov    %esp,%ebp
    e610:	57                   	push   %edi
    e611:	56                   	push   %esi
    e612:	53                   	push   %ebx
    e613:	50                   	push   %eax
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e614:	8d 45 f0             	lea    -0x10(%ebp),%eax
    e617:	50                   	push   %eax
{
    e618:	8b 75 08             	mov    0x8(%ebp),%esi
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e61b:	56                   	push   %esi
{
    e61c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e61f:	e8 6e f9 ff ff       	call   df92 <net_if_config_ipv6_get>
    e624:	5a                   	pop    %edx
    e625:	59                   	pop    %ecx
		return NULL;
    e626:	31 d2                	xor    %edx,%edx
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    e628:	85 c0                	test   %eax,%eax
    e62a:	78 62                	js     e68e <net_if_ipv6_maddr_add+0x81>
	if (!net_ipv6_is_addr_mcast(addr)) {
    e62c:	80 3f ff             	cmpb   $0xff,(%edi)
    e62f:	75 5d                	jne    e68e <net_if_ipv6_maddr_add+0x81>
		if (ipv6->mcast[i].is_used) {
    e631:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e634:	f6 80 ec 00 00 00 01 	testb  $0x1,0xec(%eax)
    e63b:	74 10                	je     e64d <net_if_ipv6_maddr_add+0x40>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e63d:	bb 01 00 00 00       	mov    $0x1,%ebx
		if (ipv6->mcast[i].is_used) {
    e642:	f6 80 04 01 00 00 01 	testb  $0x1,0x104(%eax)
    e649:	74 04                	je     e64f <net_if_ipv6_maddr_add+0x42>
    e64b:	eb 41                	jmp    e68e <net_if_ipv6_maddr_add+0x81>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e64d:	31 db                	xor    %ebx,%ebx
		ipv6->mcast[i].is_used = true;
    e64f:	6b db 18             	imul   $0x18,%ebx,%ebx
    e652:	8d 14 18             	lea    (%eax,%ebx,1),%edx
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
    e655:	8d 84 18 dc 00 00 00 	lea    0xdc(%eax,%ebx,1),%eax
		ipv6->mcast[i].is_used = true;
    e65c:	80 8a ec 00 00 00 01 	orb    $0x1,0xec(%edx)
		ipv6->mcast[i].address.family = AF_INET6;
    e663:	66 c7 82 d8 00 00 00 	movw   $0x2,0xd8(%edx)
    e66a:	02 00 
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
    e66c:	6a 10                	push   $0x10
    e66e:	57                   	push   %edi
    e66f:	50                   	push   %eax
    e670:	e8 bc c2 ff ff       	call   a931 <memcpy>
		net_mgmt_event_notify(NET_EVENT_IPV6_MADDR_ADD, iface);
    e675:	89 f2                	mov    %esi,%edx
    e677:	b8 03 00 60 f0       	mov    $0xf0600003,%eax
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
    e67c:	83 c4 0c             	add    $0xc,%esp
		net_mgmt_event_notify(NET_EVENT_IPV6_MADDR_ADD, iface);
    e67f:	e8 3d f6 ff ff       	call   dcc1 <net_mgmt_event_notify>
		return &ipv6->mcast[i];
    e684:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e687:	8d 94 18 d8 00 00 00 	lea    0xd8(%eax,%ebx,1),%edx
}
    e68e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e691:	89 d0                	mov    %edx,%eax
    e693:	5b                   	pop    %ebx
    e694:	5e                   	pop    %esi
    e695:	5f                   	pop    %edi
    e696:	5d                   	pop    %ebp
    e697:	c3                   	ret    

0000e698 <net_if_ipv6_maddr_rm>:
{
    e698:	55                   	push   %ebp
    e699:	89 e5                	mov    %esp,%ebp
    e69b:	56                   	push   %esi
    e69c:	53                   	push   %ebx
    e69d:	8b 75 08             	mov    0x8(%ebp),%esi
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e6a0:	8b 5e 04             	mov    0x4(%esi),%ebx
	if (!ipv6) {
    e6a3:	85 db                	test   %ebx,%ebx
    e6a5:	75 04                	jne    e6ab <net_if_ipv6_maddr_rm+0x13>
		return false;
    e6a7:	31 c0                	xor    %eax,%eax
    e6a9:	eb 5a                	jmp    e705 <net_if_ipv6_maddr_rm+0x6d>
		if (!ipv6->mcast[i].is_used) {
    e6ab:	f6 83 ec 00 00 00 01 	testb  $0x1,0xec(%ebx)
    e6b2:	75 0b                	jne    e6bf <net_if_ipv6_maddr_rm+0x27>
    e6b4:	f6 83 04 01 00 00 01 	testb  $0x1,0x104(%ebx)
    e6bb:	75 18                	jne    e6d5 <net_if_ipv6_maddr_rm+0x3d>
    e6bd:	eb e8                	jmp    e6a7 <net_if_ipv6_maddr_rm+0xf>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
    e6bf:	8d 83 dc 00 00 00    	lea    0xdc(%ebx),%eax
    e6c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6c8:	e8 ca f5 ff ff       	call   dc97 <net_ipv6_addr_cmp>
    e6cd:	84 c0                	test   %al,%al
    e6cf:	74 e3                	je     e6b4 <net_if_ipv6_maddr_rm+0x1c>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e6d1:	31 c0                	xor    %eax,%eax
    e6d3:	eb 17                	jmp    e6ec <net_if_ipv6_maddr_rm+0x54>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
    e6d5:	8d 83 f4 00 00 00    	lea    0xf4(%ebx),%eax
    e6db:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6de:	e8 b4 f5 ff ff       	call   dc97 <net_ipv6_addr_cmp>
    e6e3:	84 c0                	test   %al,%al
    e6e5:	74 c0                	je     e6a7 <net_if_ipv6_maddr_rm+0xf>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
    e6e7:	b8 01 00 00 00       	mov    $0x1,%eax
		ipv6->mcast[i].is_used = false;
    e6ec:	6b c0 18             	imul   $0x18,%eax,%eax
		net_mgmt_event_notify(NET_EVENT_IPV6_MADDR_DEL, iface);
    e6ef:	89 f2                	mov    %esi,%edx
		ipv6->mcast[i].is_used = false;
    e6f1:	80 a4 03 ec 00 00 00 	andb   $0xfe,0xec(%ebx,%eax,1)
    e6f8:	fe 
		net_mgmt_event_notify(NET_EVENT_IPV6_MADDR_DEL, iface);
    e6f9:	b8 04 00 60 f0       	mov    $0xf0600004,%eax
    e6fe:	e8 be f5 ff ff       	call   dcc1 <net_mgmt_event_notify>
		return true;
    e703:	b0 01                	mov    $0x1,%al
}
    e705:	5b                   	pop    %ebx
    e706:	5e                   	pop    %esi
    e707:	5d                   	pop    %ebp
    e708:	c3                   	ret    

0000e709 <net_if_ipv6_addr_rm>:
{
    e709:	55                   	push   %ebp
    e70a:	89 e5                	mov    %esp,%ebp
    e70c:	57                   	push   %edi
    e70d:	56                   	push   %esi
    e70e:	31 f6                	xor    %esi,%esi
    e710:	53                   	push   %ebx
    e711:	83 ec 1c             	sub    $0x1c,%esp
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e714:	8b 45 08             	mov    0x8(%ebp),%eax
{
    e717:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e71a:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    e71d:	85 db                	test   %ebx,%ebx
    e71f:	75 24                	jne    e745 <net_if_ipv6_addr_rm+0x3c>
		return false;
    e721:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    e725:	e9 a5 00 00 00       	jmp    e7cf <net_if_ipv6_addr_rm+0xc6>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
    e72a:	8d 44 0b 04          	lea    0x4(%ebx,%ecx,1),%eax
    e72e:	89 fa                	mov    %edi,%edx
    e730:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    e733:	e8 5f f5 ff ff       	call   dc97 <net_ipv6_addr_cmp>
    e738:	88 45 e3             	mov    %al,-0x1d(%ebp)
    e73b:	84 c0                	test   %al,%al
    e73d:	75 18                	jne    e757 <net_if_ipv6_addr_rm+0x4e>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e73f:	46                   	inc    %esi
    e740:	83 fe 03             	cmp    $0x3,%esi
    e743:	74 dc                	je     e721 <net_if_ipv6_addr_rm+0x18>
		if (!ipv6->unicast[i].is_used) {
    e745:	6b ce 48             	imul   $0x48,%esi,%ecx
    e748:	8d 44 0b 40          	lea    0x40(%ebx,%ecx,1),%eax
    e74c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e74f:	f6 40 07 02          	testb  $0x2,0x7(%eax)
    e753:	74 ea                	je     e73f <net_if_ipv6_addr_rm+0x36>
    e755:	eb d3                	jmp    e72a <net_if_ipv6_addr_rm+0x21>
		if (!ipv6->unicast[i].is_infinite) {
    e757:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e75a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    e75d:	f6 40 07 01          	testb  $0x1,0x7(%eax)
    e761:	75 22                	jne    e785 <net_if_ipv6_addr_rm+0x7c>
			sys_slist_find_and_remove(
    e763:	8d 54 0b 14          	lea    0x14(%ebx,%ecx,1),%edx
    e767:	b8 ac 42 40 00       	mov    $0x4042ac,%eax
    e76c:	e8 5d f3 ff ff       	call   dace <sys_slist_find_and_remove>
			if (sys_slist_is_empty(
    e771:	83 3d ac 42 40 00 00 	cmpl   $0x0,0x4042ac
    e778:	75 0b                	jne    e785 <net_if_ipv6_addr_rm+0x7c>
				k_delayed_work_cancel(&address_lifetime_timer);
    e77a:	68 20 0d 40 00       	push   $0x400d20
    e77f:	e8 23 5e 01 00       	call   245a7 <k_delayed_work_cancel>
    e784:	59                   	pop    %ecx
		ipv6->unicast[i].is_used = false;
    e785:	6b c6 48             	imul   $0x48,%esi,%eax
	dst->s6_addr[0]   = 0xFF;
    e788:	c7 45 e4 ff 02 00 00 	movl   $0x2ff,-0x1c(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
    e78f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e796:	80 64 03 47 fd       	andb   $0xfd,0x47(%ebx,%eax,1)
	dst->s6_addr[13]  = src->s6_addr[13];
    e79b:	8a 47 0d             	mov    0xd(%edi),%al
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
    e79e:	c7 45 ec 00 00 00 01 	movl   $0x1000000,-0x14(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
    e7a5:	88 45 f1             	mov    %al,-0xf(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
    e7a8:	66 8b 47 0e          	mov    0xe(%edi),%ax
    e7ac:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		net_if_ipv6_maddr_rm(iface, &maddr);
    e7b0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    e7b3:	50                   	push   %eax
	dst->s6_addr[12]  = 0xFF;
    e7b4:	c6 45 f0 ff          	movb   $0xff,-0x10(%ebp)
    e7b8:	ff 75 08             	pushl  0x8(%ebp)
    e7bb:	e8 d8 fe ff ff       	call   e698 <net_if_ipv6_maddr_rm>
    e7c0:	58                   	pop    %eax
		net_mgmt_event_notify(NET_EVENT_IPV6_ADDR_DEL, iface);
    e7c1:	b8 02 00 60 f0       	mov    $0xf0600002,%eax
		net_if_ipv6_maddr_rm(iface, &maddr);
    e7c6:	5a                   	pop    %edx
		net_mgmt_event_notify(NET_EVENT_IPV6_ADDR_DEL, iface);
    e7c7:	8b 55 08             	mov    0x8(%ebp),%edx
    e7ca:	e8 f2 f4 ff ff       	call   dcc1 <net_mgmt_event_notify>
}
    e7cf:	8a 45 e3             	mov    -0x1d(%ebp),%al
    e7d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e7d5:	5b                   	pop    %ebx
    e7d6:	5e                   	pop    %esi
    e7d7:	5f                   	pop    %edi
    e7d8:	5d                   	pop    %ebp
    e7d9:	c3                   	ret    

0000e7da <net_if_ipv6_dad_failed>:
{
    e7da:	55                   	push   %ebp
    e7db:	89 e5                	mov    %esp,%ebp
    e7dd:	57                   	push   %edi
    e7de:	56                   	push   %esi
    e7df:	53                   	push   %ebx
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
    e7e0:	8d 45 08             	lea    0x8(%ebp),%eax
    e7e3:	50                   	push   %eax
{
    e7e4:	8b 75 0c             	mov    0xc(%ebp),%esi
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
    e7e7:	56                   	push   %esi
    e7e8:	e8 53 f8 ff ff       	call   e040 <net_if_ipv6_addr_lookup>
    e7ed:	59                   	pop    %ecx
	if (!ifaddr) {
    e7ee:	85 c0                	test   %eax,%eax
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
    e7f0:	5b                   	pop    %ebx
	if (!ifaddr) {
    e7f1:	75 45                	jne    e838 <net_if_ipv6_dad_failed+0x5e>
		NET_ERR("Cannot find %s address in interface %p",
    e7f3:	f6 05 88 a8 40 00 07 	testb  $0x7,0x40a888
    e7fa:	74 5e                	je     e85a <net_if_ipv6_dad_failed+0x80>
    e7fc:	56                   	push   %esi
    e7fd:	8b 7d 08             	mov    0x8(%ebp),%edi
    e800:	6a 02                	push   $0x2
    e802:	e8 97 22 00 00       	call   10a9e <net_sprint_addr>
    e807:	5e                   	pop    %esi
    e808:	bb 94 51 02 00       	mov    $0x25194,%ebx
    e80d:	5a                   	pop    %edx
    e80e:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    e814:	c1 eb 03             	shr    $0x3,%ebx
    e817:	50                   	push   %eax
    e818:	c1 e3 06             	shl    $0x6,%ebx
    e81b:	e8 3b 50 ff ff       	call   385b <log_strdup>
    e820:	83 cb 01             	or     $0x1,%ebx
    e823:	66 89 1c 24          	mov    %bx,(%esp)
    e827:	57                   	push   %edi
    e828:	50                   	push   %eax
    e829:	68 f2 79 02 00       	push   $0x279f2
    e82e:	e8 b6 4c ff ff       	call   34e9 <log_2>
    e833:	83 c4 10             	add    $0x10,%esp
    e836:	eb 22                	jmp    e85a <net_if_ipv6_dad_failed+0x80>
	k_delayed_work_cancel(&ifaddr->dad_timer);
    e838:	83 c0 24             	add    $0x24,%eax
    e83b:	50                   	push   %eax
    e83c:	e8 66 5d 01 00       	call   245a7 <k_delayed_work_cancel>
    e841:	58                   	pop    %eax
	net_mgmt_event_notify(NET_EVENT_IPV6_DAD_FAILED, iface);
    e842:	8b 55 08             	mov    0x8(%ebp),%edx
    e845:	b8 0e 00 60 f0       	mov    $0xf060000e,%eax
    e84a:	e8 72 f4 ff ff       	call   dcc1 <net_mgmt_event_notify>
	net_if_ipv6_addr_rm(iface, addr);
    e84f:	56                   	push   %esi
    e850:	ff 75 08             	pushl  0x8(%ebp)
    e853:	e8 b1 fe ff ff       	call   e709 <net_if_ipv6_addr_rm>
    e858:	5a                   	pop    %edx
    e859:	59                   	pop    %ecx
}
    e85a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e85d:	5b                   	pop    %ebx
    e85e:	5e                   	pop    %esi
    e85f:	5f                   	pop    %edi
    e860:	5d                   	pop    %ebp
    e861:	c3                   	ret    

0000e862 <remove_prefix_addresses>:
{
    e862:	55                   	push   %ebp
    e863:	89 e5                	mov    %esp,%ebp
    e865:	57                   	push   %edi
    e866:	56                   	push   %esi
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e867:	31 f6                	xor    %esi,%esi
{
    e869:	53                   	push   %ebx
    e86a:	89 d3                	mov    %edx,%ebx
    e86c:	83 ec 10             	sub    $0x10,%esp
    e86f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e872:	8a 45 08             	mov    0x8(%ebp),%al
    e875:	89 55 f0             	mov    %edx,-0x10(%ebp)
    e878:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    e87b:	88 45 e7             	mov    %al,-0x19(%ebp)
		if (!ipv6->unicast[i].is_used ||
    e87e:	6b c6 48             	imul   $0x48,%esi,%eax
    e881:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e884:	f6 44 02 47 02       	testb  $0x2,0x47(%edx,%eax,1)
    e889:	74 2c                	je     e8b7 <remove_prefix_addresses+0x55>
    e88b:	66 83 3b 02          	cmpw   $0x2,(%ebx)
    e88f:	75 26                	jne    e8b7 <remove_prefix_addresses+0x55>
		    ipv6->unicast[i].address.family != AF_INET6 ||
    e891:	80 7b 44 01          	cmpb   $0x1,0x44(%ebx)
    e895:	75 20                	jne    e8b7 <remove_prefix_addresses+0x55>
		if (net_ipv6_is_prefix(
    e897:	8d 7b 04             	lea    0x4(%ebx),%edi
    e89a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e89d:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
    e8a1:	89 fa                	mov    %edi,%edx
    e8a3:	e8 86 f3 ff ff       	call   dc2e <net_ipv6_is_prefix>
    e8a8:	84 c0                	test   %al,%al
    e8aa:	74 0b                	je     e8b7 <remove_prefix_addresses+0x55>
			net_if_ipv6_addr_rm(iface,
    e8ac:	57                   	push   %edi
    e8ad:	ff 75 ec             	pushl  -0x14(%ebp)
    e8b0:	e8 54 fe ff ff       	call   e709 <net_if_ipv6_addr_rm>
    e8b5:	58                   	pop    %eax
    e8b6:	5a                   	pop    %edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    e8b7:	46                   	inc    %esi
    e8b8:	83 c3 48             	add    $0x48,%ebx
    e8bb:	83 fe 03             	cmp    $0x3,%esi
    e8be:	75 be                	jne    e87e <remove_prefix_addresses+0x1c>
}
    e8c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e8c3:	5b                   	pop    %ebx
    e8c4:	5e                   	pop    %esi
    e8c5:	5f                   	pop    %edi
    e8c6:	5d                   	pop    %ebp
    e8c7:	c3                   	ret    

0000e8c8 <prefix_lifetime_timeout>:
{
    e8c8:	55                   	push   %ebp
    e8c9:	89 e5                	mov    %esp,%ebp
    e8cb:	57                   	push   %edi
    e8cc:	56                   	push   %esi
    e8cd:	53                   	push   %ebx
    e8ce:	83 ec 10             	sub    $0x10,%esp
    e8d1:	e8 1c 60 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
    e8d6:	8b 1d a4 42 40 00    	mov    0x4042a4,%ebx
    e8dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e8df:	85 db                	test   %ebx,%ebx
    e8e1:	0f 84 e0 00 00 00    	je     e9c7 <prefix_lifetime_timeout+0xff>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    e8e7:	8b 33                	mov    (%ebx),%esi
    e8e9:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
    e8f0:	83 cf ff             	or     $0xffffffff,%edi
    e8f3:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
			  ifprefix->lifetime.wrap_counter,
    e8f7:	8b 53 0c             	mov    0xc(%ebx),%edx
	if (check_timeout(ifprefix->lifetime.timer_start,
    e8fa:	8b 4b 08             	mov    0x8(%ebx),%ecx
	if (counter > 0) {
    e8fd:	85 d2                	test   %edx,%edx
    e8ff:	75 49                	jne    e94a <prefix_lifetime_timeout+0x82>
	if ((s32_t)((start + (u32_t)timeout) - current_time) > 0) {
    e901:	8b 43 04             	mov    0x4(%ebx),%eax
    e904:	2b 45 ec             	sub    -0x14(%ebp),%eax
    e907:	01 c8                	add    %ecx,%eax
    e909:	85 c0                	test   %eax,%eax
    e90b:	0f 8f ab 00 00 00    	jg     e9bc <prefix_lifetime_timeout+0xf4>
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
    e911:	8d 45 f0             	lea    -0x10(%ebp),%eax
	ifprefix->is_used = false;
    e914:	80 63 25 fd          	andb   $0xfd,0x25(%ebx)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
    e918:	50                   	push   %eax
    e919:	ff 73 20             	pushl  0x20(%ebx)
    e91c:	e8 71 f6 ff ff       	call   df92 <net_if_config_ipv6_get>
    e921:	5a                   	pop    %edx
    e922:	85 c0                	test   %eax,%eax
    e924:	59                   	pop    %ecx
    e925:	78 52                	js     e979 <prefix_lifetime_timeout+0xb1>
	remove_prefix_addresses(ifprefix->iface, ipv6, &ifprefix->prefix,
    e927:	0f b6 53 24          	movzbl 0x24(%ebx),%edx
    e92b:	8b 43 20             	mov    0x20(%ebx),%eax
    e92e:	8d 4b 10             	lea    0x10(%ebx),%ecx
    e931:	52                   	push   %edx
    e932:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e935:	e8 28 ff ff ff       	call   e862 <remove_prefix_addresses>
    e93a:	58                   	pop    %eax
	net_mgmt_event_notify(NET_EVENT_IPV6_PREFIX_DEL, ifprefix->iface);
    e93b:	8b 53 20             	mov    0x20(%ebx),%edx
    e93e:	b8 06 00 60 f0       	mov    $0xf0600006,%eax
    e943:	e8 79 f3 ff ff       	call   dcc1 <net_mgmt_event_notify>
		if (!is_timeout) {
    e948:	eb 2f                	jmp    e979 <prefix_lifetime_timeout+0xb1>
	if (current_time == NET_TIMEOUT_MAX_VALUE) {
    e94a:	81 7d ec 9b ff ff 7f 	cmpl   $0x7fffff9b,-0x14(%ebp)
    e951:	75 04                	jne    e957 <prefix_lifetime_timeout+0x8f>
		ifprefix->lifetime.wrap_counter--;
    e953:	4a                   	dec    %edx
    e954:	89 53 0c             	mov    %edx,0xc(%ebx)
	if (ifprefix->lifetime.wrap_counter > 0) {
    e957:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
    e95b:	7e 05                	jle    e962 <prefix_lifetime_timeout+0x9a>
    e95d:	b9 9b ff ff 7f       	mov    $0x7fffff9b,%ecx
			if (next_timeout < timeout_update) {
    e962:	3b 4d e8             	cmp    -0x18(%ebp),%ecx
    e965:	ba 00 00 00 00       	mov    $0x0,%edx
    e96a:	89 d0                	mov    %edx,%eax
    e96c:	19 f8                	sbb    %edi,%eax
    e96e:	73 09                	jae    e979 <prefix_lifetime_timeout+0xb1>
    e970:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    e973:	31 ff                	xor    %edi,%edi
				found = true;
    e975:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
		if (current == next) {
    e979:	39 de                	cmp    %ebx,%esi
    e97b:	74 15                	je     e992 <prefix_lifetime_timeout+0xca>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
    e97d:	31 c0                	xor    %eax,%eax
    e97f:	85 f6                	test   %esi,%esi
    e981:	74 02                	je     e985 <prefix_lifetime_timeout+0xbd>
    e983:	8b 06                	mov    (%esi),%eax
	return node->next;
    e985:	89 f3                	mov    %esi,%ebx
    e987:	85 f6                	test   %esi,%esi
    e989:	74 07                	je     e992 <prefix_lifetime_timeout+0xca>
    e98b:	89 c6                	mov    %eax,%esi
    e98d:	e9 65 ff ff ff       	jmp    e8f7 <prefix_lifetime_timeout+0x2f>
	if (found) {
    e992:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
    e996:	74 2f                	je     e9c7 <prefix_lifetime_timeout+0xff>
		k_delayed_work_submit(&prefix_lifetime_timer, timeout_update);
    e998:	b8 9b ff ff 7f       	mov    $0x7fffff9b,%eax
    e99d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9a0:	39 d0                	cmp    %edx,%eax
    e9a2:	b8 00 00 00 00       	mov    $0x0,%eax
    e9a7:	19 f8                	sbb    %edi,%eax
    e9a9:	73 05                	jae    e9b0 <prefix_lifetime_timeout+0xe8>
    e9ab:	ba 9b ff ff 7f       	mov    $0x7fffff9b,%edx
    e9b0:	b8 00 0d 40 00       	mov    $0x400d00,%eax
    e9b5:	e8 f3 f2 ff ff       	call   dcad <k_delayed_work_submit>
}
    e9ba:	eb 0b                	jmp    e9c7 <prefix_lifetime_timeout+0xff>
	if (current_time == NET_TIMEOUT_MAX_VALUE) {
    e9bc:	81 7d ec 9b ff ff 7f 	cmpl   $0x7fffff9b,-0x14(%ebp)
    e9c3:	75 9d                	jne    e962 <prefix_lifetime_timeout+0x9a>
    e9c5:	eb 8c                	jmp    e953 <prefix_lifetime_timeout+0x8b>
}
    e9c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e9ca:	5b                   	pop    %ebx
    e9cb:	5e                   	pop    %esi
    e9cc:	5f                   	pop    %edi
    e9cd:	5d                   	pop    %ebp
    e9ce:	c3                   	ret    

0000e9cf <net_if_ipv6_maddr_lookup>:
{
    e9cf:	55                   	push   %ebp
    e9d0:	89 e5                	mov    %esp,%ebp
    e9d2:	57                   	push   %edi
    e9d3:	56                   	push   %esi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e9d4:	be a0 aa 40 00       	mov    $0x40aaa0,%esi
{
    e9d9:	53                   	push   %ebx
    e9da:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e9dd:	81 fe c0 aa 40 00    	cmp    $0x40aac0,%esi
    e9e3:	0f 84 86 00 00 00    	je     ea6f <net_if_ipv6_maddr_lookup+0xa0>
		if (ret && *ret && iface != *ret) {
    e9e9:	85 ff                	test   %edi,%edi
    e9eb:	74 0f                	je     e9fc <net_if_ipv6_maddr_lookup+0x2d>
    e9ed:	8b 07                	mov    (%edi),%eax
    e9ef:	85 c0                	test   %eax,%eax
    e9f1:	74 09                	je     e9fc <net_if_ipv6_maddr_lookup+0x2d>
    e9f3:	39 f0                	cmp    %esi,%eax
    e9f5:	74 05                	je     e9fc <net_if_ipv6_maddr_lookup+0x2d>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    e9f7:	83 c6 20             	add    $0x20,%esi
    e9fa:	eb e1                	jmp    e9dd <net_if_ipv6_maddr_lookup+0xe>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    e9fc:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
    e9ff:	85 db                	test   %ebx,%ebx
    ea01:	74 f4                	je     e9f7 <net_if_ipv6_maddr_lookup+0x28>
			if (!ipv6->mcast[i].is_used ||
    ea03:	f6 83 ec 00 00 00 01 	testb  $0x1,0xec(%ebx)
    ea0a:	74 21                	je     ea2d <net_if_ipv6_maddr_lookup+0x5e>
    ea0c:	66 83 bb d8 00 00 00 	cmpw   $0x2,0xd8(%ebx)
    ea13:	02 
    ea14:	75 17                	jne    ea2d <net_if_ipv6_maddr_lookup+0x5e>
				    ipv6->mcast[i].address.in6_addr.s6_addr,
    ea16:	8d 93 dc 00 00 00    	lea    0xdc(%ebx),%edx
			if (net_ipv6_is_prefix(
    ea1c:	b9 80 00 00 00       	mov    $0x80,%ecx
    ea21:	8b 45 08             	mov    0x8(%ebp),%eax
    ea24:	e8 05 f2 ff ff       	call   dc2e <net_ipv6_is_prefix>
    ea29:	84 c0                	test   %al,%al
    ea2b:	75 31                	jne    ea5e <net_if_ipv6_maddr_lookup+0x8f>
			if (!ipv6->mcast[i].is_used ||
    ea2d:	f6 83 04 01 00 00 01 	testb  $0x1,0x104(%ebx)
    ea34:	74 c1                	je     e9f7 <net_if_ipv6_maddr_lookup+0x28>
    ea36:	66 83 bb f0 00 00 00 	cmpw   $0x2,0xf0(%ebx)
    ea3d:	02 
    ea3e:	75 b7                	jne    e9f7 <net_if_ipv6_maddr_lookup+0x28>
				    ipv6->mcast[i].address.in6_addr.s6_addr,
    ea40:	8d 93 f4 00 00 00    	lea    0xf4(%ebx),%edx
			if (net_ipv6_is_prefix(
    ea46:	b9 80 00 00 00       	mov    $0x80,%ecx
    ea4b:	8b 45 08             	mov    0x8(%ebp),%eax
    ea4e:	e8 db f1 ff ff       	call   dc2e <net_ipv6_is_prefix>
    ea53:	84 c0                	test   %al,%al
    ea55:	74 a0                	je     e9f7 <net_if_ipv6_maddr_lookup+0x28>
    ea57:	b8 18 00 00 00       	mov    $0x18,%eax
    ea5c:	eb 02                	jmp    ea60 <net_if_ipv6_maddr_lookup+0x91>
    ea5e:	31 c0                	xor    %eax,%eax
				if (ret) {
    ea60:	85 ff                	test   %edi,%edi
    ea62:	74 02                	je     ea66 <net_if_ipv6_maddr_lookup+0x97>
					*ret = iface;
    ea64:	89 37                	mov    %esi,(%edi)
				return &ipv6->mcast[i];
    ea66:	8d 84 03 d8 00 00 00 	lea    0xd8(%ebx,%eax,1),%eax
    ea6d:	eb 02                	jmp    ea71 <net_if_ipv6_maddr_lookup+0xa2>
	return NULL;
    ea6f:	31 c0                	xor    %eax,%eax
}
    ea71:	5b                   	pop    %ebx
    ea72:	5e                   	pop    %esi
    ea73:	5f                   	pop    %edi
    ea74:	5d                   	pop    %ebp
    ea75:	c3                   	ret    

0000ea76 <net_if_mcast_monitor>:
{
    ea76:	55                   	push   %ebp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    ea77:	a1 94 42 40 00       	mov    0x404294,%eax
{
    ea7c:	89 e5                	mov    %esp,%ebp
    ea7e:	57                   	push   %edi
    ea7f:	56                   	push   %esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    ea80:	85 c0                	test   %eax,%eax
{
    ea82:	53                   	push   %ebx
    ea83:	8b 75 08             	mov    0x8(%ebp),%esi
    ea86:	8a 5d 10             	mov    0x10(%ebp),%bl
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    ea89:	74 1f                	je     eaaa <net_if_mcast_monitor+0x34>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    ea8b:	8b 38                	mov    (%eax),%edi
		if (iface == mon->iface) {
    ea8d:	39 70 04             	cmp    %esi,0x4(%eax)
    ea90:	75 0e                	jne    eaa0 <net_if_mcast_monitor+0x2a>
			mon->cb(iface, addr, is_joined);
    ea92:	0f b6 d3             	movzbl %bl,%edx
    ea95:	52                   	push   %edx
    ea96:	ff 75 0c             	pushl  0xc(%ebp)
    ea99:	56                   	push   %esi
    ea9a:	ff 50 08             	call   *0x8(%eax)
    ea9d:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
    eaa0:	85 ff                	test   %edi,%edi
    eaa2:	74 06                	je     eaaa <net_if_mcast_monitor+0x34>
    eaa4:	89 f8                	mov    %edi,%eax
    eaa6:	8b 3f                	mov    (%edi),%edi
    eaa8:	eb e3                	jmp    ea8d <net_if_mcast_monitor+0x17>
}
    eaaa:	8d 65 f4             	lea    -0xc(%ebp),%esp
    eaad:	5b                   	pop    %ebx
    eaae:	5e                   	pop    %esi
    eaaf:	5f                   	pop    %edi
    eab0:	5d                   	pop    %ebp
    eab1:	c3                   	ret    

0000eab2 <net_if_ipv6_prefix_add>:
{
    eab2:	55                   	push   %ebp
    eab3:	89 e5                	mov    %esp,%ebp
    eab5:	57                   	push   %edi
    eab6:	56                   	push   %esi
    eab7:	53                   	push   %ebx
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    eab8:	8d 45 e0             	lea    -0x20(%ebp),%eax
{
    eabb:	83 ec 18             	sub    $0x18,%esp
    eabe:	8b 75 0c             	mov    0xc(%ebp),%esi
    eac1:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
    eac4:	50                   	push   %eax
    eac5:	ff 75 08             	pushl  0x8(%ebp)
    eac8:	e8 c5 f4 ff ff       	call   df92 <net_if_config_ipv6_get>
    eacd:	5a                   	pop    %edx
    eace:	85 c0                	test   %eax,%eax
    ead0:	59                   	pop    %ecx
    ead1:	79 07                	jns    eada <net_if_ipv6_prefix_add+0x28>
		return NULL;
    ead3:	31 c0                	xor    %eax,%eax
    ead5:	e9 f4 00 00 00       	jmp    ebce <net_if_ipv6_prefix_add+0x11c>
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    eada:	8b 45 08             	mov    0x8(%ebp),%eax
    eadd:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    eae0:	85 db                	test   %ebx,%ebx
    eae2:	75 09                	jne    eaed <net_if_ipv6_prefix_add+0x3b>
	if (!ipv6) {
    eae4:	8b 55 e0             	mov    -0x20(%ebp),%edx
    eae7:	85 d2                	test   %edx,%edx
    eae9:	75 5c                	jne    eb47 <net_if_ipv6_prefix_add+0x95>
    eaeb:	eb e6                	jmp    ead3 <net_if_ipv6_prefix_add+0x21>
		if (!ipv6->unicast[i].is_used) {
    eaed:	f6 43 47 02          	testb  $0x2,0x47(%ebx)
    eaf1:	74 1b                	je     eb0e <net_if_ipv6_prefix_add+0x5c>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
    eaf3:	8d 93 18 01 00 00    	lea    0x118(%ebx),%edx
    eaf9:	89 f0                	mov    %esi,%eax
    eafb:	e8 97 f1 ff ff       	call   dc97 <net_ipv6_addr_cmp>
    eb00:	84 c0                	test   %al,%al
    eb02:	74 0a                	je     eb0e <net_if_ipv6_prefix_add+0x5c>
    eb04:	89 f8                	mov    %edi,%eax
    eb06:	38 83 2c 01 00 00    	cmp    %al,0x12c(%ebx)
    eb0c:	74 2b                	je     eb39 <net_if_ipv6_prefix_add+0x87>
		if (!ipv6->unicast[i].is_used) {
    eb0e:	f6 83 8f 00 00 00 02 	testb  $0x2,0x8f(%ebx)
    eb15:	74 cd                	je     eae4 <net_if_ipv6_prefix_add+0x32>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
    eb17:	8d 93 40 01 00 00    	lea    0x140(%ebx),%edx
    eb1d:	89 f0                	mov    %esi,%eax
    eb1f:	e8 73 f1 ff ff       	call   dc97 <net_ipv6_addr_cmp>
    eb24:	84 c0                	test   %al,%al
    eb26:	74 bc                	je     eae4 <net_if_ipv6_prefix_add+0x32>
    eb28:	89 f8                	mov    %edi,%eax
    eb2a:	3a 83 54 01 00 00    	cmp    0x154(%ebx),%al
    eb30:	75 b2                	jne    eae4 <net_if_ipv6_prefix_add+0x32>
    eb32:	b8 28 00 00 00       	mov    $0x28,%eax
    eb37:	eb 02                	jmp    eb3b <net_if_ipv6_prefix_add+0x89>
    eb39:	31 c0                	xor    %eax,%eax
			return &ipv6->prefix[i];
    eb3b:	8d 84 03 08 01 00 00 	lea    0x108(%ebx,%eax,1),%eax
	if (ifprefix) {
    eb42:	e9 87 00 00 00       	jmp    ebce <net_if_ipv6_prefix_add+0x11c>
		if (ipv6->prefix[i].is_used) {
    eb47:	f6 82 2d 01 00 00 02 	testb  $0x2,0x12d(%edx)
    eb4e:	74 13                	je     eb63 <net_if_ipv6_prefix_add+0xb1>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    eb50:	b9 01 00 00 00       	mov    $0x1,%ecx
		if (ipv6->prefix[i].is_used) {
    eb55:	f6 82 55 01 00 00 02 	testb  $0x2,0x155(%edx)
    eb5c:	74 07                	je     eb65 <net_if_ipv6_prefix_add+0xb3>
    eb5e:	e9 70 ff ff ff       	jmp    ead3 <net_if_ipv6_prefix_add+0x21>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    eb63:	31 c9                	xor    %ecx,%ecx
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
    eb65:	6b c9 28             	imul   $0x28,%ecx,%ecx
	ifprefix->len = len;
    eb68:	89 fb                	mov    %edi,%ebx
	ifprefix->iface = iface;
    eb6a:	8b 7d 08             	mov    0x8(%ebp),%edi
    eb6d:	8d 81 08 01 00 00    	lea    0x108(%ecx),%eax
	ifprefix->is_used = true;
    eb73:	01 d1                	add    %edx,%ecx
    eb75:	89 45 dc             	mov    %eax,-0x24(%ebp)
    eb78:	8d 81 20 01 00 00    	lea    0x120(%ecx),%eax
    eb7e:	80 48 0d 02          	orb    $0x2,0xd(%eax)
	ifprefix->iface = iface;
    eb82:	89 b9 28 01 00 00    	mov    %edi,0x128(%ecx)
	ifprefix->len = len;
    eb88:	88 99 2c 01 00 00    	mov    %bl,0x12c(%ecx)
	net_ipaddr_copy(&ifprefix->prefix, addr);
    eb8e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    eb91:	b9 04 00 00 00       	mov    $0x4,%ecx
    eb96:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    eb98:	8b 75 dc             	mov    -0x24(%ebp),%esi
    eb9b:	b9 04 00 00 00       	mov    $0x4,%ecx
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
    eba0:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
	net_ipaddr_copy(&ifprefix->prefix, addr);
    eba4:	8d 7c 32 10          	lea    0x10(%edx,%esi,1),%edi
    eba8:	8d 75 e4             	lea    -0x1c(%ebp),%esi
    ebab:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
    ebad:	8a 50 0d             	mov    0xd(%eax),%dl
    ebb0:	0f 94 c1             	sete   %cl
    ebb3:	83 e2 fe             	and    $0xfffffffe,%edx
    ebb6:	09 ca                	or     %ecx,%edx
    ebb8:	88 50 0d             	mov    %dl,0xd(%eax)
		net_mgmt_event_notify(NET_EVENT_IPV6_PREFIX_ADD, iface);
    ebbb:	b8 05 00 60 f0       	mov    $0xf0600005,%eax
    ebc0:	8b 55 08             	mov    0x8(%ebp),%edx
    ebc3:	e8 f9 f0 ff ff       	call   dcc1 <net_mgmt_event_notify>
		return &ipv6->prefix[i];
    ebc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ebcb:	03 45 e0             	add    -0x20(%ebp),%eax
}
    ebce:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ebd1:	5b                   	pop    %ebx
    ebd2:	5e                   	pop    %esi
    ebd3:	5f                   	pop    %edi
    ebd4:	5d                   	pop    %ebp
    ebd5:	c3                   	ret    

0000ebd6 <net_if_ipv6_prefix_get>:
{
    ebd6:	55                   	push   %ebp
    ebd7:	89 e5                	mov    %esp,%ebp
    ebd9:	56                   	push   %esi
    ebda:	53                   	push   %ebx
    ebdb:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!iface) {
    ebde:	85 c0                	test   %eax,%eax
    ebe0:	75 0c                	jne    ebee <net_if_ipv6_prefix_get+0x18>
	if (__net_if_start == __net_if_end) {
    ebe2:	b8 a0 aa 40 00       	mov    $0x40aaa0,%eax
    ebe7:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    ebec:	74 6c                	je     ec5a <net_if_ipv6_prefix_get+0x84>
	ipv6 = iface->config.ip.ipv6;
    ebee:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    ebf1:	85 db                	test   %ebx,%ebx
    ebf3:	74 6c                	je     ec61 <net_if_ipv6_prefix_get+0x8b>
	struct net_if_ipv6_prefix *prefix = NULL;
    ebf5:	31 f6                	xor    %esi,%esi
		if (!ipv6->prefix[i].is_used) {
    ebf7:	f6 83 2d 01 00 00 02 	testb  $0x2,0x12d(%ebx)
    ebfe:	74 1f                	je     ec1f <net_if_ipv6_prefix_get+0x49>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ec00:	0f b6 8b 2c 01 00 00 	movzbl 0x12c(%ebx),%ecx
    ec07:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
    ec0d:	8b 55 0c             	mov    0xc(%ebp),%edx
    ec10:	e8 19 f0 ff ff       	call   dc2e <net_ipv6_is_prefix>
    ec15:	84 c0                	test   %al,%al
    ec17:	74 06                	je     ec1f <net_if_ipv6_prefix_get+0x49>
				prefix = &ipv6->prefix[i];
    ec19:	8d b3 08 01 00 00    	lea    0x108(%ebx),%esi
		if (!ipv6->prefix[i].is_used) {
    ec1f:	f6 83 55 01 00 00 02 	testb  $0x2,0x155(%ebx)
    ec26:	74 2e                	je     ec56 <net_if_ipv6_prefix_get+0x80>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ec28:	0f b6 8b 54 01 00 00 	movzbl 0x154(%ebx),%ecx
    ec2f:	8d 83 40 01 00 00    	lea    0x140(%ebx),%eax
    ec35:	8b 55 0c             	mov    0xc(%ebp),%edx
    ec38:	e8 f1 ef ff ff       	call   dc2e <net_ipv6_is_prefix>
    ec3d:	84 c0                	test   %al,%al
    ec3f:	74 15                	je     ec56 <net_if_ipv6_prefix_get+0x80>
			if (!prefix || prefix->len > ipv6->prefix[i].len) {
    ec41:	85 f6                	test   %esi,%esi
    ec43:	74 0b                	je     ec50 <net_if_ipv6_prefix_get+0x7a>
    ec45:	8a 83 54 01 00 00    	mov    0x154(%ebx),%al
    ec4b:	38 46 24             	cmp    %al,0x24(%esi)
    ec4e:	76 06                	jbe    ec56 <net_if_ipv6_prefix_get+0x80>
				prefix = &ipv6->prefix[i];
    ec50:	8d b3 30 01 00 00    	lea    0x130(%ebx),%esi
	struct net_if_ipv6_prefix *prefix = NULL;
    ec56:	89 f3                	mov    %esi,%ebx
    ec58:	eb 07                	jmp    ec61 <net_if_ipv6_prefix_get+0x8b>
	ipv6 = iface->config.ip.ipv6;
    ec5a:	a1 04 00 00 00       	mov    0x4,%eax
    ec5f:	0f 0b                	ud2    
}
    ec61:	89 d8                	mov    %ebx,%eax
    ec63:	5b                   	pop    %ebx
    ec64:	5e                   	pop    %esi
    ec65:	5d                   	pop    %ebp
    ec66:	c3                   	ret    

0000ec67 <net_if_ipv6_prefix_lookup>:
{
    ec67:	55                   	push   %ebp
    ec68:	89 e5                	mov    %esp,%ebp
    ec6a:	56                   	push   %esi
    ec6b:	53                   	push   %ebx
    ec6c:	8b 45 10             	mov    0x10(%ebp),%eax
    ec6f:	89 c6                	mov    %eax,%esi
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    ec71:	8b 45 08             	mov    0x8(%ebp),%eax
    ec74:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv6) {
    ec77:	85 db                	test   %ebx,%ebx
    ec79:	75 04                	jne    ec7f <net_if_ipv6_prefix_lookup+0x18>
		return NULL;
    ec7b:	31 c0                	xor    %eax,%eax
    ec7d:	eb 55                	jmp    ecd4 <net_if_ipv6_prefix_lookup+0x6d>
		if (!ipv6->prefix[i].is_used) {
    ec7f:	f6 83 2d 01 00 00 02 	testb  $0x2,0x12d(%ebx)
    ec86:	75 0b                	jne    ec93 <net_if_ipv6_prefix_lookup+0x2c>
    ec88:	f6 83 55 01 00 00 02 	testb  $0x2,0x155(%ebx)
    ec8f:	75 1d                	jne    ecae <net_if_ipv6_prefix_lookup+0x47>
    ec91:	eb e8                	jmp    ec7b <net_if_ipv6_prefix_lookup+0x14>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ec93:	89 f0                	mov    %esi,%eax
    ec95:	8b 55 0c             	mov    0xc(%ebp),%edx
    ec98:	0f b6 c8             	movzbl %al,%ecx
    ec9b:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
    eca1:	e8 88 ef ff ff       	call   dc2e <net_ipv6_is_prefix>
    eca6:	84 c0                	test   %al,%al
    eca8:	74 de                	je     ec88 <net_if_ipv6_prefix_lookup+0x21>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    ecaa:	31 c0                	xor    %eax,%eax
    ecac:	eb 1c                	jmp    ecca <net_if_ipv6_prefix_lookup+0x63>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ecae:	89 f0                	mov    %esi,%eax
    ecb0:	8b 55 0c             	mov    0xc(%ebp),%edx
    ecb3:	0f b6 c8             	movzbl %al,%ecx
    ecb6:	8d 83 40 01 00 00    	lea    0x140(%ebx),%eax
    ecbc:	e8 6d ef ff ff       	call   dc2e <net_ipv6_is_prefix>
    ecc1:	84 c0                	test   %al,%al
    ecc3:	74 b6                	je     ec7b <net_if_ipv6_prefix_lookup+0x14>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    ecc5:	b8 01 00 00 00       	mov    $0x1,%eax
			return &ipv6->prefix[i];
    ecca:	6b c0 28             	imul   $0x28,%eax,%eax
    eccd:	8d 84 03 08 01 00 00 	lea    0x108(%ebx,%eax,1),%eax
}
    ecd4:	5b                   	pop    %ebx
    ecd5:	5e                   	pop    %esi
    ecd6:	5d                   	pop    %ebp
    ecd7:	c3                   	ret    

0000ecd8 <net_if_ipv6_addr_onlink>:
{
    ecd8:	55                   	push   %ebp
    ecd9:	89 e5                	mov    %esp,%ebp
    ecdb:	57                   	push   %edi
    ecdc:	56                   	push   %esi
	for (tmp = __net_if_start; tmp != __net_if_end; tmp++) {
    ecdd:	be a0 aa 40 00       	mov    $0x40aaa0,%esi
{
    ece2:	53                   	push   %ebx
    ece3:	8b 7d 08             	mov    0x8(%ebp),%edi
	for (tmp = __net_if_start; tmp != __net_if_end; tmp++) {
    ece6:	81 fe c0 aa 40 00    	cmp    $0x40aac0,%esi
    ecec:	74 6e                	je     ed5c <net_if_ipv6_addr_onlink+0x84>
		if (iface && *iface && *iface != tmp) {
    ecee:	85 ff                	test   %edi,%edi
    ecf0:	74 0a                	je     ecfc <net_if_ipv6_addr_onlink+0x24>
    ecf2:	8b 07                	mov    (%edi),%eax
    ecf4:	85 c0                	test   %eax,%eax
    ecf6:	74 04                	je     ecfc <net_if_ipv6_addr_onlink+0x24>
    ecf8:	39 f0                	cmp    %esi,%eax
    ecfa:	75 5b                	jne    ed57 <net_if_ipv6_addr_onlink+0x7f>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
    ecfc:	8b 5e 04             	mov    0x4(%esi),%ebx
		if (!ipv6) {
    ecff:	85 db                	test   %ebx,%ebx
    ed01:	74 54                	je     ed57 <net_if_ipv6_addr_onlink+0x7f>
			if (ipv6->prefix[i].is_used &&
    ed03:	f6 83 2d 01 00 00 02 	testb  $0x2,0x12d(%ebx)
    ed0a:	75 0b                	jne    ed17 <net_if_ipv6_addr_onlink+0x3f>
    ed0c:	f6 83 55 01 00 00 02 	testb  $0x2,0x155(%ebx)
    ed13:	74 42                	je     ed57 <net_if_ipv6_addr_onlink+0x7f>
    ed15:	eb 21                	jmp    ed38 <net_if_ipv6_addr_onlink+0x60>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ed17:	0f b6 8b 2c 01 00 00 	movzbl 0x12c(%ebx),%ecx
    ed1e:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
    ed24:	8b 55 0c             	mov    0xc(%ebp),%edx
    ed27:	e8 02 ef ff ff       	call   dc2e <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
    ed2c:	84 c0                	test   %al,%al
    ed2e:	74 dc                	je     ed0c <net_if_ipv6_addr_onlink+0x34>
				if (iface) {
    ed30:	85 ff                	test   %edi,%edi
    ed32:	74 1f                	je     ed53 <net_if_ipv6_addr_onlink+0x7b>
					*iface = tmp;
    ed34:	89 37                	mov    %esi,(%edi)
    ed36:	eb 1b                	jmp    ed53 <net_if_ipv6_addr_onlink+0x7b>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
    ed38:	0f b6 8b 54 01 00 00 	movzbl 0x154(%ebx),%ecx
    ed3f:	8d 83 40 01 00 00    	lea    0x140(%ebx),%eax
    ed45:	8b 55 0c             	mov    0xc(%ebp),%edx
    ed48:	e8 e1 ee ff ff       	call   dc2e <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
    ed4d:	84 c0                	test   %al,%al
    ed4f:	74 06                	je     ed57 <net_if_ipv6_addr_onlink+0x7f>
    ed51:	eb dd                	jmp    ed30 <net_if_ipv6_addr_onlink+0x58>
				return true;
    ed53:	b0 01                	mov    $0x1,%al
    ed55:	eb 07                	jmp    ed5e <net_if_ipv6_addr_onlink+0x86>
	for (tmp = __net_if_start; tmp != __net_if_end; tmp++) {
    ed57:	83 c6 20             	add    $0x20,%esi
    ed5a:	eb 8a                	jmp    ece6 <net_if_ipv6_addr_onlink+0xe>
	return false;
    ed5c:	31 c0                	xor    %eax,%eax
}
    ed5e:	5b                   	pop    %ebx
    ed5f:	5e                   	pop    %esi
    ed60:	5f                   	pop    %edi
    ed61:	5d                   	pop    %ebp
    ed62:	c3                   	ret    

0000ed63 <net_if_ipv6_prefix_set_timer>:
{
    ed63:	55                   	push   %ebp
    ed64:	89 e5                	mov    %esp,%ebp
    ed66:	57                   	push   %edi
    ed67:	56                   	push   %esi
    ed68:	8b 75 0c             	mov    0xc(%ebp),%esi
    ed6b:	53                   	push   %ebx
	if (lifetime == 0xffffffff) {
    ed6c:	83 fe ff             	cmp    $0xffffffff,%esi
{
    ed6f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lifetime == 0xffffffff) {
    ed72:	0f 84 bc 00 00 00    	je     ee34 <net_if_ipv6_prefix_set_timer+0xd1>
	u64_t expire_timeout = K_SECONDS((u64_t)lifetime);
    ed78:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
	parent->next = child;
    ed7d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    ed83:	89 c8                	mov    %ecx,%eax
    ed85:	f7 e6                	mul    %esi
    ed87:	89 c6                	mov    %eax,%esi
Z_GENLIST_APPEND(slist, snode)
    ed89:	a1 a8 42 40 00       	mov    0x4042a8,%eax
    ed8e:	89 d7                	mov    %edx,%edi
    ed90:	85 c0                	test   %eax,%eax
    ed92:	75 0e                	jne    eda2 <net_if_ipv6_prefix_set_timer+0x3f>
	list->tail = node;
    ed94:	89 1d a8 42 40 00    	mov    %ebx,0x4042a8
	list->head = node;
    ed9a:	89 1d a4 42 40 00    	mov    %ebx,0x4042a4
    eda0:	eb 08                	jmp    edaa <net_if_ipv6_prefix_set_timer+0x47>
	parent->next = child;
    eda2:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    eda4:	89 1d a8 42 40 00    	mov    %ebx,0x4042a8
    edaa:	e8 43 5b 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	ifprefix->lifetime.timer_start = k_uptime_get_32();
    edaf:	89 43 04             	mov    %eax,0x4(%ebx)
	ifprefix->lifetime.wrap_counter = expire_timeout /
    edb2:	6a 00                	push   $0x0
    edb4:	68 9b ff ff 7f       	push   $0x7fffff9b
    edb9:	57                   	push   %edi
    edba:	56                   	push   %esi
    edbb:	e8 2d 24 ff ff       	call   11ed <__udivdi3>
	ifprefix->lifetime.timer_timeout = expire_timeout -
    edc0:	69 d0 9b ff ff 7f    	imul   $0x7fffff9b,%eax,%edx
	ifprefix->lifetime.wrap_counter = expire_timeout /
    edc6:	83 c4 10             	add    $0x10,%esp
	ifprefix->lifetime.timer_timeout = expire_timeout -
    edc9:	29 d6                	sub    %edx,%esi
    edcb:	89 73 08             	mov    %esi,0x8(%ebx)
	ifprefix->lifetime.wrap_counter = expire_timeout /
    edce:	89 43 0c             	mov    %eax,0xc(%ebx)
    edd1:	68 0c 0d 40 00       	push   $0x400d0c
    edd6:	e8 5e 59 01 00       	call   24739 <z_timeout_remaining>
    eddb:	ba e8 03 00 00       	mov    $0x3e8,%edx
    ede0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    ede7:	f7 ea                	imul   %edx
    ede9:	6a 64                	push   $0x64
    edeb:	52                   	push   %edx
    edec:	50                   	push   %eax
    eded:	e8 fb 23 ff ff       	call   11ed <__udivdi3>
    edf2:	83 c4 10             	add    $0x10,%esp
    edf5:	89 c6                	mov    %eax,%esi
	if (!remaining || (ifprefix->lifetime.wrap_counter == 0 &&
    edf7:	85 c0                	test   %eax,%eax
    edf9:	74 0b                	je     ee06 <net_if_ipv6_prefix_set_timer+0xa3>
    edfb:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
    edff:	75 33                	jne    ee34 <net_if_ipv6_prefix_set_timer+0xd1>
    ee01:	39 43 08             	cmp    %eax,0x8(%ebx)
    ee04:	7d 2e                	jge    ee34 <net_if_ipv6_prefix_set_timer+0xd1>
		k_delayed_work_cancel(&prefix_lifetime_timer);
    ee06:	68 00 0d 40 00       	push   $0x400d00
    ee0b:	e8 97 57 01 00       	call   245a7 <k_delayed_work_cancel>
    ee10:	58                   	pop    %eax
		if (ifprefix->lifetime.wrap_counter > 0 && remaining == 0) {
    ee11:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
    ee15:	7e 09                	jle    ee20 <net_if_ipv6_prefix_set_timer+0xbd>
			k_delayed_work_submit(&prefix_lifetime_timer,
    ee17:	ba 9b ff ff 7f       	mov    $0x7fffff9b,%edx
		if (ifprefix->lifetime.wrap_counter > 0 && remaining == 0) {
    ee1c:	85 f6                	test   %esi,%esi
    ee1e:	74 03                	je     ee23 <net_if_ipv6_prefix_set_timer+0xc0>
			k_delayed_work_submit(&prefix_lifetime_timer,
    ee20:	8b 53 08             	mov    0x8(%ebx),%edx
}
    ee23:	8d 65 f4             	lea    -0xc(%ebp),%esp
			k_delayed_work_submit(&prefix_lifetime_timer,
    ee26:	b8 00 0d 40 00       	mov    $0x400d00,%eax
}
    ee2b:	5b                   	pop    %ebx
    ee2c:	5e                   	pop    %esi
    ee2d:	5f                   	pop    %edi
    ee2e:	5d                   	pop    %ebp
			k_delayed_work_submit(&prefix_lifetime_timer,
    ee2f:	e9 79 ee ff ff       	jmp    dcad <k_delayed_work_submit>
}
    ee34:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ee37:	5b                   	pop    %ebx
    ee38:	5e                   	pop    %esi
    ee39:	5f                   	pop    %edi
    ee3a:	5d                   	pop    %ebp
    ee3b:	c3                   	ret    

0000ee3c <net_if_ipv6_prefix_unset_timer>:
{
    ee3c:	55                   	push   %ebp
    ee3d:	89 e5                	mov    %esp,%ebp
    ee3f:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!prefix->is_used) {
    ee42:	f6 42 25 02          	testb  $0x2,0x25(%edx)
    ee46:	74 19                	je     ee61 <net_if_ipv6_prefix_unset_timer+0x25>
	ifprefix->lifetime.timer_timeout = 0;
    ee48:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	ifprefix->lifetime.wrap_counter = 0;
    ee4f:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
    ee56:	b8 a4 42 40 00       	mov    $0x4042a4,%eax
}
    ee5b:	5d                   	pop    %ebp
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
    ee5c:	e9 6d ec ff ff       	jmp    dace <sys_slist_find_and_remove>
}
    ee61:	5d                   	pop    %ebp
    ee62:	c3                   	ret    

0000ee63 <net_if_ipv6_prefix_rm>:
{
    ee63:	55                   	push   %ebp
    ee64:	89 e5                	mov    %esp,%ebp
    ee66:	57                   	push   %edi
    ee67:	56                   	push   %esi
    ee68:	53                   	push   %ebx
    ee69:	52                   	push   %edx
    ee6a:	8b 7d 08             	mov    0x8(%ebp),%edi
    ee6d:	8b 45 10             	mov    0x10(%ebp),%eax
    ee70:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    ee73:	8b 5f 04             	mov    0x4(%edi),%ebx
	if (!ipv6) {
    ee76:	85 db                	test   %ebx,%ebx
    ee78:	75 07                	jne    ee81 <net_if_ipv6_prefix_rm+0x1e>
		return false;
    ee7a:	31 c0                	xor    %eax,%eax
    ee7c:	e9 96 00 00 00       	jmp    ef17 <net_if_ipv6_prefix_rm+0xb4>
		if (!ipv6->prefix[i].is_used) {
    ee81:	f6 83 2d 01 00 00 02 	testb  $0x2,0x12d(%ebx)
    ee88:	74 1d                	je     eea7 <net_if_ipv6_prefix_rm+0x44>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    ee8a:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
    ee90:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee93:	e8 ff ed ff ff       	call   dc97 <net_ipv6_addr_cmp>
    ee98:	84 c0                	test   %al,%al
    ee9a:	74 0b                	je     eea7 <net_if_ipv6_prefix_rm+0x44>
    ee9c:	8a 45 f0             	mov    -0x10(%ebp),%al
    ee9f:	3a 83 2c 01 00 00    	cmp    0x12c(%ebx),%al
    eea5:	74 32                	je     eed9 <net_if_ipv6_prefix_rm+0x76>
		if (!ipv6->prefix[i].is_used) {
    eea7:	f6 83 55 01 00 00 02 	testb  $0x2,0x155(%ebx)
    eeae:	74 ca                	je     ee7a <net_if_ipv6_prefix_rm+0x17>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    eeb0:	8d 83 40 01 00 00    	lea    0x140(%ebx),%eax
    eeb6:	8b 55 0c             	mov    0xc(%ebp),%edx
    eeb9:	e8 d9 ed ff ff       	call   dc97 <net_ipv6_addr_cmp>
    eebe:	84 c0                	test   %al,%al
    eec0:	74 b8                	je     ee7a <net_if_ipv6_prefix_rm+0x17>
    eec2:	8a 45 f0             	mov    -0x10(%ebp),%al
    eec5:	38 83 54 01 00 00    	cmp    %al,0x154(%ebx)
    eecb:	75 ad                	jne    ee7a <net_if_ipv6_prefix_rm+0x17>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
    eecd:	be 01 00 00 00       	mov    $0x1,%esi
    eed2:	ba 28 00 00 00       	mov    $0x28,%edx
    eed7:	eb 04                	jmp    eedd <net_if_ipv6_prefix_rm+0x7a>
    eed9:	31 f6                	xor    %esi,%esi
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
    eedb:	31 d2                	xor    %edx,%edx
		net_if_ipv6_prefix_unset_timer(&ipv6->prefix[i]);
    eedd:	8d 94 13 08 01 00 00 	lea    0x108(%ebx,%edx,1),%edx
    eee4:	52                   	push   %edx
    eee5:	e8 52 ff ff ff       	call   ee3c <net_if_ipv6_prefix_unset_timer>
		ipv6->prefix[i].is_used = false;
    eeea:	6b c6 28             	imul   $0x28,%esi,%eax
		remove_prefix_addresses(iface, ipv6, addr, len);
    eeed:	0f b6 75 f0          	movzbl -0x10(%ebp),%esi
		ipv6->prefix[i].is_used = false;
    eef1:	80 a4 03 2d 01 00 00 	andb   $0xfd,0x12d(%ebx,%eax,1)
    eef8:	fd 
		remove_prefix_addresses(iface, ipv6, addr, len);
    eef9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    eefc:	89 da                	mov    %ebx,%edx
    eefe:	89 f8                	mov    %edi,%eax
    ef00:	89 34 24             	mov    %esi,(%esp)
    ef03:	e8 5a f9 ff ff       	call   e862 <remove_prefix_addresses>
    ef08:	58                   	pop    %eax
		net_mgmt_event_notify(NET_EVENT_IPV6_PREFIX_DEL, iface);
    ef09:	89 fa                	mov    %edi,%edx
    ef0b:	b8 06 00 60 f0       	mov    $0xf0600006,%eax
    ef10:	e8 ac ed ff ff       	call   dcc1 <net_mgmt_event_notify>
		return true;
    ef15:	b0 01                	mov    $0x1,%al
}
    ef17:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ef1a:	5b                   	pop    %ebx
    ef1b:	5e                   	pop    %esi
    ef1c:	5f                   	pop    %edi
    ef1d:	5d                   	pop    %ebp
    ef1e:	c3                   	ret    

0000ef1f <net_if_ipv6_router_lookup>:
{
    ef1f:	55                   	push   %ebp
		if (!routers[i].is_used ||
    ef20:	f6 05 78 0d 40 00 01 	testb  $0x1,0x400d78
{
    ef27:	89 e5                	mov    %esp,%ebp
    ef29:	53                   	push   %ebx
    ef2a:	8b 5d 08             	mov    0x8(%ebp),%ebx
		if (!routers[i].is_used ||
    ef2d:	74 23                	je     ef52 <net_if_ipv6_router_lookup+0x33>
    ef2f:	66 83 3d 60 0d 40 00 	cmpw   $0x2,0x400d60
    ef36:	02 
    ef37:	75 19                	jne    ef52 <net_if_ipv6_router_lookup+0x33>
		    routers[i].address.family != AF_INET6 ||
    ef39:	3b 1d 74 0d 40 00    	cmp    0x400d74,%ebx
    ef3f:	75 11                	jne    ef52 <net_if_ipv6_router_lookup+0x33>
		if (net_ipv6_addr_cmp(&routers[i].address.in6_addr, addr)) {
    ef41:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef44:	b8 64 0d 40 00       	mov    $0x400d64,%eax
    ef49:	e8 49 ed ff ff       	call   dc97 <net_ipv6_addr_cmp>
    ef4e:	84 c0                	test   %al,%al
    ef50:	75 33                	jne    ef85 <net_if_ipv6_router_lookup+0x66>
		if (!routers[i].is_used ||
    ef52:	f6 05 b4 0d 40 00 01 	testb  $0x1,0x400db4
    ef59:	74 33                	je     ef8e <net_if_ipv6_router_lookup+0x6f>
    ef5b:	66 83 3d 9c 0d 40 00 	cmpw   $0x2,0x400d9c
    ef62:	02 
    ef63:	75 29                	jne    ef8e <net_if_ipv6_router_lookup+0x6f>
		    routers[i].address.family != AF_INET6 ||
    ef65:	39 1d b0 0d 40 00    	cmp    %ebx,0x400db0
    ef6b:	75 21                	jne    ef8e <net_if_ipv6_router_lookup+0x6f>
		if (net_ipv6_addr_cmp(&routers[i].address.in6_addr, addr)) {
    ef6d:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef70:	b8 a0 0d 40 00       	mov    $0x400da0,%eax
    ef75:	e8 1d ed ff ff       	call   dc97 <net_ipv6_addr_cmp>
    ef7a:	84 c0                	test   %al,%al
    ef7c:	74 10                	je     ef8e <net_if_ipv6_router_lookup+0x6f>
    ef7e:	b8 3c 00 00 00       	mov    $0x3c,%eax
    ef83:	eb 02                	jmp    ef87 <net_if_ipv6_router_lookup+0x68>
    ef85:	31 c0                	xor    %eax,%eax
			return &routers[i];
    ef87:	05 40 0d 40 00       	add    $0x400d40,%eax
    ef8c:	eb 02                	jmp    ef90 <net_if_ipv6_router_lookup+0x71>
	return NULL;
    ef8e:	31 c0                	xor    %eax,%eax
}
    ef90:	5b                   	pop    %ebx
    ef91:	5d                   	pop    %ebp
    ef92:	c3                   	ret    

0000ef93 <net_if_ipv6_router_find_default>:
{
    ef93:	55                   	push   %ebp
		if (!routers[i].is_used ||
    ef94:	a0 78 0d 40 00       	mov    0x400d78,%al
{
    ef99:	89 e5                	mov    %esp,%ebp
		if (!routers[i].is_used ||
    ef9b:	a8 01                	test   $0x1,%al
{
    ef9d:	8b 55 08             	mov    0x8(%ebp),%edx
		if (!routers[i].is_used ||
    efa0:	74 1a                	je     efbc <net_if_ipv6_router_find_default+0x29>
    efa2:	a8 02                	test   $0x2,%al
    efa4:	74 16                	je     efbc <net_if_ipv6_router_find_default+0x29>
		    !routers[i].is_default ||
    efa6:	66 83 3d 60 0d 40 00 	cmpw   $0x2,0x400d60
    efad:	02 
    efae:	75 0c                	jne    efbc <net_if_ipv6_router_find_default+0x29>
		if (iface && iface != routers[i].iface) {
    efb0:	85 d2                	test   %edx,%edx
    efb2:	74 2a                	je     efde <net_if_ipv6_router_find_default+0x4b>
    efb4:	3b 15 74 0d 40 00    	cmp    0x400d74,%edx
    efba:	74 22                	je     efde <net_if_ipv6_router_find_default+0x4b>
		if (!routers[i].is_used ||
    efbc:	8a 0d b4 0d 40 00    	mov    0x400db4,%cl
	return NULL;
    efc2:	31 c0                	xor    %eax,%eax
		if (!routers[i].is_used ||
    efc4:	f6 c1 01             	test   $0x1,%cl
    efc7:	74 30                	je     eff9 <net_if_ipv6_router_find_default+0x66>
    efc9:	80 e1 02             	and    $0x2,%cl
    efcc:	74 2b                	je     eff9 <net_if_ipv6_router_find_default+0x66>
		    !routers[i].is_default ||
    efce:	66 83 3d 9c 0d 40 00 	cmpw   $0x2,0x400d9c
    efd5:	02 
    efd6:	75 21                	jne    eff9 <net_if_ipv6_router_find_default+0x66>
		if (iface && iface != routers[i].iface) {
    efd8:	85 d2                	test   %edx,%edx
    efda:	75 0e                	jne    efea <net_if_ipv6_router_find_default+0x57>
    efdc:	eb 14                	jmp    eff2 <net_if_ipv6_router_find_default+0x5f>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    efde:	31 c0                	xor    %eax,%eax
		return &routers[i];
    efe0:	6b c0 3c             	imul   $0x3c,%eax,%eax
    efe3:	05 40 0d 40 00       	add    $0x400d40,%eax
    efe8:	eb 0f                	jmp    eff9 <net_if_ipv6_router_find_default+0x66>
		if (iface && iface != routers[i].iface) {
    efea:	39 15 b0 0d 40 00    	cmp    %edx,0x400db0
    eff0:	75 07                	jne    eff9 <net_if_ipv6_router_find_default+0x66>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    eff2:	b8 01 00 00 00       	mov    $0x1,%eax
    eff7:	eb e7                	jmp    efe0 <net_if_ipv6_router_find_default+0x4d>
}
    eff9:	5d                   	pop    %ebp
    effa:	c3                   	ret    

0000effb <net_if_ipv6_router_update_lifetime>:
{
    effb:	55                   	push   %ebp
    effc:	89 e5                	mov    %esp,%ebp
	k_delayed_work_submit(&router->lifetime, K_SECONDS(lifetime));
    effe:	69 55 0c e8 03 00 00 	imul   $0x3e8,0xc(%ebp),%edx
    f005:	8b 45 08             	mov    0x8(%ebp),%eax
}
    f008:	5d                   	pop    %ebp
	k_delayed_work_submit(&router->lifetime, K_SECONDS(lifetime));
    f009:	e9 9f ec ff ff       	jmp    dcad <k_delayed_work_submit>

0000f00e <net_if_ipv6_router_add>:
{
    f00e:	55                   	push   %ebp
    f00f:	89 e5                	mov    %esp,%ebp
    f011:	57                   	push   %edi
    f012:	56                   	push   %esi
    f013:	53                   	push   %ebx
    f014:	83 ec 14             	sub    $0x14,%esp
    f017:	8b 75 0c             	mov    0xc(%ebp),%esi
    f01a:	8b 55 10             	mov    0x10(%ebp),%edx
		if (routers[i].is_used) {
    f01d:	f6 05 78 0d 40 00 01 	testb  $0x1,0x400d78
    f024:	74 15                	je     f03b <net_if_ipv6_router_add+0x2d>
	return NULL;
    f026:	31 db                	xor    %ebx,%ebx
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    f028:	b8 01 00 00 00       	mov    $0x1,%eax
		if (routers[i].is_used) {
    f02d:	f6 05 b4 0d 40 00 01 	testb  $0x1,0x400db4
    f034:	74 07                	je     f03d <net_if_ipv6_router_add+0x2f>
    f036:	e9 93 00 00 00       	jmp    f0ce <net_if_ipv6_router_add+0xc0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    f03b:	31 c0                	xor    %eax,%eax
		net_if_router_init(&routers[i], iface, addr, lifetime);
    f03d:	6b c0 3c             	imul   $0x3c,%eax,%eax
	router->iface = iface;
    f040:	8b 7d 08             	mov    0x8(%ebp),%edi
	net_ipaddr_copy(&router->address.in6_addr, addr);
    f043:	b9 04 00 00 00       	mov    $0x4,%ecx
		net_if_router_init(&routers[i], iface, addr, lifetime);
    f048:	8d 98 40 0d 40 00    	lea    0x400d40(%eax),%ebx
	router->is_used = true;
    f04e:	80 88 78 0d 40 00 01 	orb    $0x1,0x400d78(%eax)
	router->iface = iface;
    f055:	89 7b 34             	mov    %edi,0x34(%ebx)
	net_ipaddr_copy(&router->address.in6_addr, addr);
    f058:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    f05b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    f05d:	8d 7b 24             	lea    0x24(%ebx),%edi
    f060:	8d 75 e4             	lea    -0x1c(%ebp),%esi
    f063:	b9 04 00 00 00       	mov    $0x4,%ecx
	router->address.family = AF_INET6;
    f068:	66 c7 43 20 02 00    	movw   $0x2,0x20(%ebx)
	if (lifetime) {
    f06e:	66 85 d2             	test   %dx,%dx
    f071:	8d 40 30             	lea    0x30(%eax),%eax
	net_ipaddr_copy(&router->address.in6_addr, addr);
    f074:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (lifetime) {
    f076:	74 37                	je     f0af <net_if_ipv6_router_add+0xa1>
		router->is_default = true;
    f078:	8a 88 48 0d 40 00    	mov    0x400d48(%eax),%cl
		k_delayed_work_init(&router->lifetime, ipv6_router_expired);
    f07e:	68 a9 db 00 00       	push   $0xdba9
		router->is_default = true;
    f083:	83 e1 f9             	and    $0xfffffff9,%ecx
		k_delayed_work_init(&router->lifetime, ipv6_router_expired);
    f086:	53                   	push   %ebx
		router->is_default = true;
    f087:	83 c9 02             	or     $0x2,%ecx
    f08a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    f08d:	88 88 48 0d 40 00    	mov    %cl,0x400d48(%eax)
		k_delayed_work_init(&router->lifetime, ipv6_router_expired);
    f093:	e8 0d 54 01 00       	call   244a5 <k_delayed_work_init>
    f098:	58                   	pop    %eax
		k_delayed_work_submit(&router->lifetime, K_SECONDS(lifetime));
    f099:	89 d8                	mov    %ebx,%eax
		k_delayed_work_init(&router->lifetime, ipv6_router_expired);
    f09b:	5a                   	pop    %edx
		k_delayed_work_submit(&router->lifetime, K_SECONDS(lifetime));
    f09c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f09f:	0f b7 d2             	movzwl %dx,%edx
    f0a2:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
    f0a8:	e8 00 ec ff ff       	call   dcad <k_delayed_work_submit>
		NET_DBG("Expiring %s in %u secs",
    f0ad:	eb 12                	jmp    f0c1 <net_if_ipv6_router_add+0xb3>
		router->is_default = false;
    f0af:	8a 90 48 0d 40 00    	mov    0x400d48(%eax),%dl
    f0b5:	83 e2 f9             	and    $0xfffffff9,%edx
    f0b8:	83 ca 04             	or     $0x4,%edx
    f0bb:	88 90 48 0d 40 00    	mov    %dl,0x400d48(%eax)
		net_mgmt_event_notify(NET_EVENT_IPV6_ROUTER_ADD, iface);
    f0c1:	8b 55 08             	mov    0x8(%ebp),%edx
    f0c4:	b8 09 00 60 f0       	mov    $0xf0600009,%eax
    f0c9:	e8 f3 eb ff ff       	call   dcc1 <net_mgmt_event_notify>
}
    f0ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f0d1:	89 d8                	mov    %ebx,%eax
    f0d3:	5b                   	pop    %ebx
    f0d4:	5e                   	pop    %esi
    f0d5:	5f                   	pop    %edi
    f0d6:	5d                   	pop    %ebp
    f0d7:	c3                   	ret    

0000f0d8 <net_if_ipv6_router_rm>:
{
    f0d8:	55                   	push   %ebp
		if (&routers[i] != router) {
    f0d9:	f6 05 78 0d 40 00 01 	testb  $0x1,0x400d78
{
    f0e0:	89 e5                	mov    %esp,%ebp
    f0e2:	56                   	push   %esi
    f0e3:	53                   	push   %ebx
    f0e4:	8b 45 08             	mov    0x8(%ebp),%eax
		if (&routers[i] != router) {
    f0e7:	74 07                	je     f0f0 <net_if_ipv6_router_rm+0x18>
    f0e9:	3d 40 0d 40 00       	cmp    $0x400d40,%eax
    f0ee:	74 17                	je     f107 <net_if_ipv6_router_rm+0x2f>
    f0f0:	f6 05 b4 0d 40 00 01 	testb  $0x1,0x400db4
    f0f7:	74 3b                	je     f134 <net_if_ipv6_router_rm+0x5c>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    f0f9:	bb 01 00 00 00       	mov    $0x1,%ebx
		if (&routers[i] != router) {
    f0fe:	3d 7c 0d 40 00       	cmp    $0x400d7c,%eax
    f103:	75 2f                	jne    f134 <net_if_ipv6_router_rm+0x5c>
    f105:	eb 02                	jmp    f109 <net_if_ipv6_router_rm+0x31>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
    f107:	31 db                	xor    %ebx,%ebx
		k_delayed_work_cancel(&routers[i].lifetime);
    f109:	6b db 3c             	imul   $0x3c,%ebx,%ebx
    f10c:	8d b3 40 0d 40 00    	lea    0x400d40(%ebx),%esi
    f112:	56                   	push   %esi
    f113:	e8 8f 54 01 00       	call   245a7 <k_delayed_work_cancel>
    f118:	58                   	pop    %eax
		net_mgmt_event_notify(NET_EVENT_IPV6_ROUTER_DEL,
    f119:	8b 93 74 0d 40 00    	mov    0x400d74(%ebx),%edx
    f11f:	b8 0a 00 60 f0       	mov    $0xf060000a,%eax
		routers[i].is_used = false;
    f124:	80 a3 78 0d 40 00 fe 	andb   $0xfe,0x400d78(%ebx)
		net_mgmt_event_notify(NET_EVENT_IPV6_ROUTER_DEL,
    f12b:	e8 91 eb ff ff       	call   dcc1 <net_mgmt_event_notify>
		return true;
    f130:	b0 01                	mov    $0x1,%al
    f132:	eb 02                	jmp    f136 <net_if_ipv6_router_rm+0x5e>
	return false;
    f134:	31 c0                	xor    %eax,%eax
}
    f136:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f139:	5b                   	pop    %ebx
    f13a:	5e                   	pop    %esi
    f13b:	5d                   	pop    %ebp
    f13c:	c3                   	ret    

0000f13d <net_if_ipv6_get_ll>:
{
    f13d:	55                   	push   %ebp
    f13e:	89 e5                	mov    %esp,%ebp
    f140:	56                   	push   %esi
    f141:	53                   	push   %ebx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    f142:	8b 45 08             	mov    0x8(%ebp),%eax
{
    f145:	8a 5d 0c             	mov    0xc(%ebp),%bl
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    f148:	8b 40 04             	mov    0x4(%eax),%eax
	if (!ipv6) {
    f14b:	85 c0                	test   %eax,%eax
    f14d:	74 38                	je     f187 <net_if_ipv6_get_ll+0x4a>
    f14f:	89 c2                	mov    %eax,%edx
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    f151:	31 c9                	xor    %ecx,%ecx
		if (!ipv6->unicast[i].is_used ||
    f153:	6b f1 48             	imul   $0x48,%ecx,%esi
    f156:	f6 44 30 47 02       	testb  $0x2,0x47(%eax,%esi,1)
    f15b:	74 1b                	je     f178 <net_if_ipv6_get_ll+0x3b>
    f15d:	80 fb ff             	cmp    $0xff,%bl
    f160:	74 05                	je     f167 <net_if_ipv6_get_ll+0x2a>
		    (addr_state != NET_ADDR_ANY_STATE &&
    f162:	38 5a 45             	cmp    %bl,0x45(%edx)
    f165:	75 11                	jne    f178 <net_if_ipv6_get_ll+0x3b>
		     ipv6->unicast[i].addr_state != addr_state) ||
    f167:	66 83 3a 02          	cmpw   $0x2,(%edx)
    f16b:	75 0b                	jne    f178 <net_if_ipv6_get_ll+0x3b>
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
    f16d:	8d 72 04             	lea    0x4(%edx),%esi
    f170:	66 81 7a 04 fe 80    	cmpw   $0x80fe,0x4(%edx)
    f176:	74 0d                	je     f185 <net_if_ipv6_get_ll+0x48>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
    f178:	41                   	inc    %ecx
    f179:	83 c2 48             	add    $0x48,%edx
    f17c:	83 f9 03             	cmp    $0x3,%ecx
    f17f:	75 d2                	jne    f153 <net_if_ipv6_get_ll+0x16>
		return NULL;
    f181:	31 c0                	xor    %eax,%eax
    f183:	eb 02                	jmp    f187 <net_if_ipv6_get_ll+0x4a>
    f185:	89 f0                	mov    %esi,%eax
}
    f187:	5b                   	pop    %ebx
    f188:	5e                   	pop    %esi
    f189:	5d                   	pop    %ebp
    f18a:	c3                   	ret    

0000f18b <net_if_ipv6_select_src_addr>:
{
    f18b:	55                   	push   %ebp
    f18c:	89 e5                	mov    %esp,%ebp
    f18e:	57                   	push   %edi
    f18f:	56                   	push   %esi
    f190:	53                   	push   %ebx
    f191:	50                   	push   %eax
	u8_t best_match = 0U;
    f192:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
{
    f196:	8b 75 0c             	mov    0xc(%ebp),%esi
    f199:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast(dst)) {
    f19c:	66 81 3e fe 80       	cmpw   $0x80fe,(%esi)
    f1a1:	74 30                	je     f1d3 <net_if_ipv6_select_src_addr+0x48>
    f1a3:	80 3e ff             	cmpb   $0xff,(%esi)
    f1a6:	74 2b                	je     f1d3 <net_if_ipv6_select_src_addr+0x48>
	struct in6_addr *src = NULL;
    f1a8:	31 db                	xor    %ebx,%ebx
		for (iface = __net_if_start;
    f1aa:	bf a0 aa 40 00       	mov    $0x40aaa0,%edi
    f1af:	85 c0                	test   %eax,%eax
    f1b1:	75 46                	jne    f1f9 <net_if_ipv6_select_src_addr+0x6e>
		     !dst_iface && iface != __net_if_end;
    f1b3:	81 ff c0 aa 40 00    	cmp    $0x40aac0,%edi
    f1b9:	74 4d                	je     f208 <net_if_ipv6_select_src_addr+0x7d>
			addr = net_if_ipv6_get_best_match(iface, dst,
    f1bb:	8b 47 04             	mov    0x4(%edi),%eax
    f1be:	8d 4d f3             	lea    -0xd(%ebp),%ecx
    f1c1:	89 f2                	mov    %esi,%edx
    f1c3:	e8 1f ec ff ff       	call   dde7 <net_if_ipv6_get_best_match.isra.16>
			if (addr) {
    f1c8:	85 c0                	test   %eax,%eax
    f1ca:	74 02                	je     f1ce <net_if_ipv6_select_src_addr+0x43>
    f1cc:	89 c3                	mov    %eax,%ebx
		     iface++) {
    f1ce:	83 c7 20             	add    $0x20,%edi
    f1d1:	eb e0                	jmp    f1b3 <net_if_ipv6_select_src_addr+0x28>
    f1d3:	be a0 aa 40 00       	mov    $0x40aaa0,%esi
		for (iface = __net_if_start;
    f1d8:	85 c0                	test   %eax,%eax
    f1da:	75 39                	jne    f215 <net_if_ipv6_select_src_addr+0x8a>
		     !dst_iface && iface != __net_if_end;
    f1dc:	81 fe c0 aa 40 00    	cmp    $0x40aac0,%esi
    f1e2:	74 28                	je     f20c <net_if_ipv6_select_src_addr+0x81>
			addr = net_if_ipv6_get_ll(iface, NET_ADDR_PREFERRED);
    f1e4:	6a 01                	push   $0x1
    f1e6:	56                   	push   %esi
    f1e7:	e8 51 ff ff ff       	call   f13d <net_if_ipv6_get_ll>
    f1ec:	5b                   	pop    %ebx
			if (addr) {
    f1ed:	85 c0                	test   %eax,%eax
			addr = net_if_ipv6_get_ll(iface, NET_ADDR_PREFERRED);
    f1ef:	5f                   	pop    %edi
    f1f0:	89 c3                	mov    %eax,%ebx
			if (addr) {
    f1f2:	75 2d                	jne    f221 <net_if_ipv6_select_src_addr+0x96>
		     iface++) {
    f1f4:	83 c6 20             	add    $0x20,%esi
    f1f7:	eb e3                	jmp    f1dc <net_if_ipv6_select_src_addr+0x51>
			src = net_if_ipv6_get_best_match(dst_iface, dst,
    f1f9:	8b 40 04             	mov    0x4(%eax),%eax
    f1fc:	8d 4d f3             	lea    -0xd(%ebp),%ecx
    f1ff:	89 f2                	mov    %esi,%edx
    f201:	e8 e1 eb ff ff       	call   dde7 <net_if_ipv6_get_best_match.isra.16>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
    f206:	89 c3                	mov    %eax,%ebx
	if (!src) {
    f208:	85 db                	test   %ebx,%ebx
    f20a:	75 15                	jne    f221 <net_if_ipv6_select_src_addr+0x96>
		return net_ipv6_unspecified_address();
    f20c:	e8 24 2b 00 00       	call   11d35 <net_ipv6_unspecified_address>
    f211:	89 c3                	mov    %eax,%ebx
    f213:	eb 0c                	jmp    f221 <net_if_ipv6_select_src_addr+0x96>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
    f215:	6a 01                	push   $0x1
    f217:	50                   	push   %eax
    f218:	e8 20 ff ff ff       	call   f13d <net_if_ipv6_get_ll>
    f21d:	5a                   	pop    %edx
    f21e:	59                   	pop    %ecx
    f21f:	eb e5                	jmp    f206 <net_if_ipv6_select_src_addr+0x7b>
}
    f221:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f224:	89 d8                	mov    %ebx,%eax
    f226:	5b                   	pop    %ebx
    f227:	5e                   	pop    %esi
    f228:	5f                   	pop    %edi
    f229:	5d                   	pop    %ebp
    f22a:	c3                   	ret    

0000f22b <net_if_ipv6_select_src_iface>:
{
    f22b:	55                   	push   %ebp
    f22c:	89 e5                	mov    %esp,%ebp
    f22e:	53                   	push   %ebx
    f22f:	53                   	push   %ebx
	src = net_if_ipv6_select_src_addr(NULL, dst);
    f230:	ff 75 08             	pushl  0x8(%ebp)
    f233:	6a 00                	push   $0x0
    f235:	e8 51 ff ff ff       	call   f18b <net_if_ipv6_select_src_addr>
    f23a:	5a                   	pop    %edx
    f23b:	89 c3                	mov    %eax,%ebx
    f23d:	59                   	pop    %ecx
	if (src == net_ipv6_unspecified_address()) {
    f23e:	e8 f2 2a 00 00       	call   11d35 <net_ipv6_unspecified_address>
    f243:	39 d8                	cmp    %ebx,%eax
    f245:	75 10                	jne    f257 <net_if_ipv6_select_src_iface+0x2c>
	return iface ? iface : __net_if_start;
    f247:	b8 a0 aa 40 00       	mov    $0x40aaa0,%eax
	if (__net_if_start == __net_if_end) {
    f24c:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    f251:	75 17                	jne    f26a <net_if_ipv6_select_src_iface+0x3f>
		return NULL;
    f253:	31 c0                	xor    %eax,%eax
    f255:	eb 13                	jmp    f26a <net_if_ipv6_select_src_iface+0x3f>
	if (!net_if_ipv6_addr_lookup(src, &iface)) {
    f257:	8d 45 f8             	lea    -0x8(%ebp),%eax
    f25a:	50                   	push   %eax
    f25b:	53                   	push   %ebx
    f25c:	e8 df ed ff ff       	call   e040 <net_if_ipv6_addr_lookup>
    f261:	5a                   	pop    %edx
    f262:	85 c0                	test   %eax,%eax
    f264:	59                   	pop    %ecx
    f265:	74 e0                	je     f247 <net_if_ipv6_select_src_iface+0x1c>
	return iface;
    f267:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    f26a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f26d:	c9                   	leave  
    f26e:	c3                   	ret    

0000f26f <net_if_ipv6_calc_reachable_time>:
{
    f26f:	55                   	push   %ebp
    f270:	89 e5                	mov    %esp,%ebp
    f272:	56                   	push   %esi
    f273:	53                   	push   %ebx
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
    f274:	8b 45 08             	mov    0x8(%ebp),%eax
    f277:	8b 98 78 01 00 00    	mov    0x178(%eax),%ebx
	       sys_rand32_get() % (max_reachable - min_reachable);
    f27d:	e8 8a a3 ff ff       	call   960c <sys_rand32_get>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
    f282:	89 de                	mov    %ebx,%esi
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
    f284:	8d 0c 5b             	lea    (%ebx,%ebx,2),%ecx
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
    f287:	d1 ee                	shr    %esi
	       sys_rand32_get() % (max_reachable - min_reachable);
    f289:	31 d2                	xor    %edx,%edx
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
    f28b:	d1 e9                	shr    %ecx
}
    f28d:	5b                   	pop    %ebx
	       sys_rand32_get() % (max_reachable - min_reachable);
    f28e:	29 f1                	sub    %esi,%ecx
    f290:	f7 f1                	div    %ecx
	return min_reachable +
    f292:	8d 04 32             	lea    (%edx,%esi,1),%eax
}
    f295:	5e                   	pop    %esi
    f296:	5d                   	pop    %ebp
    f297:	c3                   	ret    

0000f298 <net_if_config_ipv4_get>:
{
    f298:	55                   	push   %ebp
    f299:	89 e5                	mov    %esp,%ebp
    f29b:	8b 55 08             	mov    0x8(%ebp),%edx
    f29e:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (iface->config.ip.ipv4) {
    f2a1:	8b 4a 08             	mov    0x8(%edx),%ecx
    f2a4:	85 c9                	test   %ecx,%ecx
    f2a6:	74 08                	je     f2b0 <net_if_config_ipv4_get+0x18>
		if (ipv4) {
    f2a8:	85 c0                	test   %eax,%eax
    f2aa:	74 24                	je     f2d0 <net_if_config_ipv4_get+0x38>
			*ipv4 = iface->config.ip.ipv4;
    f2ac:	89 08                	mov    %ecx,(%eax)
    f2ae:	eb 20                	jmp    f2d0 <net_if_config_ipv4_get+0x38>
		if (ipv4_addresses[i].iface) {
    f2b0:	83 3d 54 0b 40 00 00 	cmpl   $0x0,0x400b54
    f2b7:	75 1b                	jne    f2d4 <net_if_config_ipv4_get+0x3c>
		iface->config.ip.ipv4 = &ipv4_addresses[i].ipv4;
    f2b9:	c7 42 08 40 0a 40 00 	movl   $0x400a40,0x8(%edx)
		if (ipv4) {
    f2c0:	85 c0                	test   %eax,%eax
		ipv4_addresses[i].iface = iface;
    f2c2:	89 15 54 0b 40 00    	mov    %edx,0x400b54
		if (ipv4) {
    f2c8:	74 06                	je     f2d0 <net_if_config_ipv4_get+0x38>
			*ipv4 = &ipv4_addresses[i].ipv4;
    f2ca:	c7 00 40 0a 40 00    	movl   $0x400a40,(%eax)
    f2d0:	31 c0                	xor    %eax,%eax
    f2d2:	eb 05                	jmp    f2d9 <net_if_config_ipv4_get+0x41>
	return -ESRCH;
    f2d4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    f2d9:	5d                   	pop    %ebp
    f2da:	c3                   	ret    

0000f2db <net_if_ipv4_addr_mask_cmp>:
{
    f2db:	55                   	push   %ebp
    f2dc:	89 e5                	mov    %esp,%ebp
    f2de:	57                   	push   %edi
    f2df:	56                   	push   %esi
    f2e0:	53                   	push   %ebx
    f2e1:	51                   	push   %ecx
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    f2e2:	8b 45 08             	mov    0x8(%ebp),%eax
    f2e5:	8b 50 08             	mov    0x8(%eax),%edx
		return false;
    f2e8:	31 c0                	xor    %eax,%eax
	if (!ipv4) {
    f2ea:	85 d2                	test   %edx,%edx
    f2ec:	74 39                	je     f327 <net_if_ipv4_addr_mask_cmp+0x4c>
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
    f2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2f1:	8b b2 0c 01 00 00    	mov    0x10c(%edx),%esi
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f2f7:	31 c9                	xor    %ecx,%ecx
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
    f2f9:	8b 38                	mov    (%eax),%edi
    f2fb:	21 f7                	and    %esi,%edi
    f2fd:	89 7d f0             	mov    %edi,-0x10(%ebp)
		if (!ipv4->unicast[i].is_used ||
    f300:	6b d9 48             	imul   $0x48,%ecx,%ebx
    f303:	8a 44 1a 47          	mov    0x47(%edx,%ebx,1),%al
    f307:	d0 e8                	shr    %al
    f309:	24 01                	and    $0x1,%al
    f30b:	74 12                	je     f31f <net_if_ipv4_addr_mask_cmp+0x44>
    f30d:	66 83 3c 1a 01       	cmpw   $0x1,(%edx,%ebx,1)
    f312:	75 0b                	jne    f31f <net_if_ipv4_addr_mask_cmp+0x44>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
    f314:	8b 7c 1a 04          	mov    0x4(%edx,%ebx,1),%edi
    f318:	21 f7                	and    %esi,%edi
    f31a:	3b 7d f0             	cmp    -0x10(%ebp),%edi
    f31d:	74 08                	je     f327 <net_if_ipv4_addr_mask_cmp+0x4c>
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f31f:	41                   	inc    %ecx
    f320:	83 f9 03             	cmp    $0x3,%ecx
    f323:	75 db                	jne    f300 <net_if_ipv4_addr_mask_cmp+0x25>
		return false;
    f325:	31 c0                	xor    %eax,%eax
}
    f327:	5a                   	pop    %edx
    f328:	5b                   	pop    %ebx
    f329:	5e                   	pop    %esi
    f32a:	5f                   	pop    %edi
    f32b:	5d                   	pop    %ebp
    f32c:	c3                   	ret    

0000f32d <ipv4_is_broadcast_address>:
{
    f32d:	55                   	push   %ebp
    f32e:	89 e5                	mov    %esp,%ebp
    f330:	56                   	push   %esi
    f331:	53                   	push   %ebx
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    f332:	8b 70 08             	mov    0x8(%eax),%esi
	if (!ipv4) {
    f335:	85 f6                	test   %esi,%esi
    f337:	74 22                	je     f35b <ipv4_is_broadcast_address+0x2e>
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
    f339:	52                   	push   %edx
    f33a:	89 d3                	mov    %edx,%ebx
    f33c:	50                   	push   %eax
    f33d:	e8 99 ff ff ff       	call   f2db <net_if_ipv4_addr_mask_cmp>
    f342:	5a                   	pop    %edx
    f343:	84 c0                	test   %al,%al
    f345:	59                   	pop    %ecx
    f346:	74 15                	je     f35d <ipv4_is_broadcast_address+0x30>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
    f348:	8b 86 0c 01 00 00    	mov    0x10c(%esi),%eax
    f34e:	8b 13                	mov    (%ebx),%edx
    f350:	f7 d0                	not    %eax
    f352:	21 c2                	and    %eax,%edx
    f354:	39 c2                	cmp    %eax,%edx
    f356:	0f 94 c0             	sete   %al
    f359:	eb 02                	jmp    f35d <ipv4_is_broadcast_address+0x30>
		return false;
    f35b:	31 c0                	xor    %eax,%eax
}
    f35d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f360:	5b                   	pop    %ebx
    f361:	5e                   	pop    %esi
    f362:	5d                   	pop    %ebp
    f363:	c3                   	ret    

0000f364 <net_if_ipv4_is_addr_bcast>:
{
    f364:	55                   	push   %ebp
    f365:	89 e5                	mov    %esp,%ebp
    f367:	56                   	push   %esi
    f368:	53                   	push   %ebx
    f369:	8b 45 08             	mov    0x8(%ebp),%eax
    f36c:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (iface) {
    f36f:	85 c0                	test   %eax,%eax
    f371:	74 0a                	je     f37d <net_if_ipv4_is_addr_bcast+0x19>
}
    f373:	5b                   	pop    %ebx
		return ipv4_is_broadcast_address(iface, addr);
    f374:	89 f2                	mov    %esi,%edx
}
    f376:	5e                   	pop    %esi
    f377:	5d                   	pop    %ebp
		return ipv4_is_broadcast_address(iface, addr);
    f378:	e9 b0 ff ff ff       	jmp    f32d <ipv4_is_broadcast_address>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f37d:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
    f382:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f388:	74 12                	je     f39c <net_if_ipv4_is_addr_bcast+0x38>
		ret = ipv4_is_broadcast_address(iface, addr);
    f38a:	89 f2                	mov    %esi,%edx
    f38c:	89 d8                	mov    %ebx,%eax
    f38e:	e8 9a ff ff ff       	call   f32d <ipv4_is_broadcast_address>
		if (ret) {
    f393:	84 c0                	test   %al,%al
    f395:	75 07                	jne    f39e <net_if_ipv4_is_addr_bcast+0x3a>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f397:	83 c3 20             	add    $0x20,%ebx
    f39a:	eb e6                	jmp    f382 <net_if_ipv4_is_addr_bcast+0x1e>
	return false;
    f39c:	31 c0                	xor    %eax,%eax
}
    f39e:	5b                   	pop    %ebx
    f39f:	5e                   	pop    %esi
    f3a0:	5d                   	pop    %ebp
    f3a1:	c3                   	ret    

0000f3a2 <net_if_ipv4_select_src_iface>:
{
    f3a2:	55                   	push   %ebp
    f3a3:	89 e5                	mov    %esp,%ebp
    f3a5:	53                   	push   %ebx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f3a6:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
    f3ab:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f3b1:	74 14                	je     f3c7 <net_if_ipv4_select_src_iface+0x25>
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
    f3b3:	ff 75 08             	pushl  0x8(%ebp)
    f3b6:	53                   	push   %ebx
    f3b7:	e8 1f ff ff ff       	call   f2db <net_if_ipv4_addr_mask_cmp>
    f3bc:	5a                   	pop    %edx
		if (ret) {
    f3bd:	84 c0                	test   %al,%al
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
    f3bf:	59                   	pop    %ecx
		if (ret) {
    f3c0:	75 14                	jne    f3d6 <net_if_ipv4_select_src_iface+0x34>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f3c2:	83 c3 20             	add    $0x20,%ebx
    f3c5:	eb e4                	jmp    f3ab <net_if_ipv4_select_src_iface+0x9>
	return iface ? iface : __net_if_start;
    f3c7:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
	if (__net_if_start == __net_if_end) {
    f3cc:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f3d2:	75 02                	jne    f3d6 <net_if_ipv4_select_src_iface+0x34>
		return NULL;
    f3d4:	31 db                	xor    %ebx,%ebx
}
    f3d6:	89 d8                	mov    %ebx,%eax
    f3d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f3db:	c9                   	leave  
    f3dc:	c3                   	ret    

0000f3dd <net_if_ipv4_get_ll>:
{
    f3dd:	55                   	push   %ebp
    f3de:	89 e5                	mov    %esp,%ebp
    f3e0:	57                   	push   %edi
    f3e1:	56                   	push   %esi
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    f3e2:	8b 45 08             	mov    0x8(%ebp),%eax
{
    f3e5:	53                   	push   %ebx
    f3e6:	8a 5d 0c             	mov    0xc(%ebp),%bl
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    f3e9:	8b 50 08             	mov    0x8(%eax),%edx
	if (!ipv4) {
    f3ec:	85 d2                	test   %edx,%edx
    f3ee:	74 3b                	je     f42b <net_if_ipv4_get_ll+0x4e>
    f3f0:	89 d1                	mov    %edx,%ecx
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f3f2:	31 f6                	xor    %esi,%esi
		if (!ipv4->unicast[i].is_used ||
    f3f4:	6b c6 48             	imul   $0x48,%esi,%eax
    f3f7:	f6 44 02 47 02       	testb  $0x2,0x47(%edx,%eax,1)
    f3fc:	74 1e                	je     f41c <net_if_ipv4_get_ll+0x3f>
    f3fe:	80 fb ff             	cmp    $0xff,%bl
    f401:	74 05                	je     f408 <net_if_ipv4_get_ll+0x2b>
		    (addr_state != NET_ADDR_ANY_STATE &&
    f403:	38 59 45             	cmp    %bl,0x45(%ecx)
    f406:	75 14                	jne    f41c <net_if_ipv4_get_ll+0x3f>
		     ipv4->unicast[i].addr_state != addr_state) ||
    f408:	66 83 39 01          	cmpw   $0x1,(%ecx)
    f40c:	75 0e                	jne    f41c <net_if_ipv4_get_ll+0x3f>
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
    f40e:	8d 79 04             	lea    0x4(%ecx),%edi
    f411:	89 f8                	mov    %edi,%eax
    f413:	e8 09 e7 ff ff       	call   db21 <net_ipv4_is_ll_addr>
    f418:	84 c0                	test   %al,%al
    f41a:	75 0d                	jne    f429 <net_if_ipv4_get_ll+0x4c>
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f41c:	46                   	inc    %esi
    f41d:	83 c1 48             	add    $0x48,%ecx
    f420:	83 fe 03             	cmp    $0x3,%esi
    f423:	75 cf                	jne    f3f4 <net_if_ipv4_get_ll+0x17>
		return NULL;
    f425:	31 d2                	xor    %edx,%edx
    f427:	eb 02                	jmp    f42b <net_if_ipv4_get_ll+0x4e>
    f429:	89 fa                	mov    %edi,%edx
}
    f42b:	5b                   	pop    %ebx
    f42c:	89 d0                	mov    %edx,%eax
    f42e:	5e                   	pop    %esi
    f42f:	5f                   	pop    %edi
    f430:	5d                   	pop    %ebp
    f431:	c3                   	ret    

0000f432 <net_if_ipv4_select_src_addr>:
{
    f432:	55                   	push   %ebp
    f433:	89 e5                	mov    %esp,%ebp
    f435:	57                   	push   %edi
    f436:	56                   	push   %esi
    f437:	53                   	push   %ebx
    f438:	50                   	push   %eax
	u8_t best_match = 0U;
    f439:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
{
    f43d:	8b 75 0c             	mov    0xc(%ebp),%esi
    f440:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
    f443:	89 f0                	mov    %esi,%eax
    f445:	e8 d7 e6 ff ff       	call   db21 <net_ipv4_is_ll_addr>
    f44a:	84 c0                	test   %al,%al
    f44c:	75 36                	jne    f484 <net_if_ipv4_select_src_addr+0x52>
    f44e:	89 f0                	mov    %esi,%eax
    f450:	e8 ba e6 ff ff       	call   db0f <net_ipv4_is_addr_mcast>
    f455:	84 c0                	test   %al,%al
    f457:	75 2b                	jne    f484 <net_if_ipv4_select_src_addr+0x52>
	struct in_addr *src = NULL;
    f459:	31 db                	xor    %ebx,%ebx
		for (iface = __net_if_start;
    f45b:	bf a0 aa 40 00       	mov    $0x40aaa0,%edi
    f460:	85 d2                	test   %edx,%edx
    f462:	75 46                	jne    f4aa <net_if_ipv4_select_src_addr+0x78>
		     !dst_iface && iface != __net_if_end;
    f464:	81 ff c0 aa 40 00    	cmp    $0x40aac0,%edi
    f46a:	74 4d                	je     f4b9 <net_if_ipv4_select_src_addr+0x87>
			addr = net_if_ipv4_get_best_match(iface, dst,
    f46c:	8b 47 08             	mov    0x8(%edi),%eax
    f46f:	8d 4d f3             	lea    -0xd(%ebp),%ecx
    f472:	89 f2                	mov    %esi,%edx
    f474:	e8 f3 e9 ff ff       	call   de6c <net_if_ipv4_get_best_match.isra.17>
			if (addr) {
    f479:	85 c0                	test   %eax,%eax
    f47b:	74 02                	je     f47f <net_if_ipv4_select_src_addr+0x4d>
    f47d:	89 c3                	mov    %eax,%ebx
		     iface++) {
    f47f:	83 c7 20             	add    $0x20,%edi
    f482:	eb e0                	jmp    f464 <net_if_ipv4_select_src_addr+0x32>
    f484:	be a0 aa 40 00       	mov    $0x40aaa0,%esi
		for (iface = __net_if_start;
    f489:	85 d2                	test   %edx,%edx
    f48b:	75 39                	jne    f4c6 <net_if_ipv4_select_src_addr+0x94>
		     !dst_iface && iface != __net_if_end;
    f48d:	81 fe c0 aa 40 00    	cmp    $0x40aac0,%esi
    f493:	74 28                	je     f4bd <net_if_ipv4_select_src_addr+0x8b>
			addr = net_if_ipv4_get_ll(iface, NET_ADDR_PREFERRED);
    f495:	6a 01                	push   $0x1
    f497:	56                   	push   %esi
    f498:	e8 40 ff ff ff       	call   f3dd <net_if_ipv4_get_ll>
    f49d:	5b                   	pop    %ebx
			if (addr) {
    f49e:	85 c0                	test   %eax,%eax
			addr = net_if_ipv4_get_ll(iface, NET_ADDR_PREFERRED);
    f4a0:	5f                   	pop    %edi
    f4a1:	89 c3                	mov    %eax,%ebx
			if (addr) {
    f4a3:	75 2d                	jne    f4d2 <net_if_ipv4_select_src_addr+0xa0>
		     iface++) {
    f4a5:	83 c6 20             	add    $0x20,%esi
    f4a8:	eb e3                	jmp    f48d <net_if_ipv4_select_src_addr+0x5b>
			src = net_if_ipv4_get_best_match(dst_iface, dst,
    f4aa:	8b 42 08             	mov    0x8(%edx),%eax
    f4ad:	8d 4d f3             	lea    -0xd(%ebp),%ecx
    f4b0:	89 f2                	mov    %esi,%edx
    f4b2:	e8 b5 e9 ff ff       	call   de6c <net_if_ipv4_get_best_match.isra.17>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
    f4b7:	89 c3                	mov    %eax,%ebx
	if (!src) {
    f4b9:	85 db                	test   %ebx,%ebx
    f4bb:	75 15                	jne    f4d2 <net_if_ipv4_select_src_addr+0xa0>
		return net_ipv4_unspecified_address();
    f4bd:	e8 e4 1f 00 00       	call   114a6 <net_ipv4_unspecified_address>
    f4c2:	89 c3                	mov    %eax,%ebx
    f4c4:	eb 0c                	jmp    f4d2 <net_if_ipv4_select_src_addr+0xa0>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
    f4c6:	6a 01                	push   $0x1
    f4c8:	52                   	push   %edx
    f4c9:	e8 0f ff ff ff       	call   f3dd <net_if_ipv4_get_ll>
    f4ce:	5a                   	pop    %edx
    f4cf:	59                   	pop    %ecx
    f4d0:	eb e5                	jmp    f4b7 <net_if_ipv4_select_src_addr+0x85>
}
    f4d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f4d5:	89 d8                	mov    %ebx,%eax
    f4d7:	5b                   	pop    %ebx
    f4d8:	5e                   	pop    %esi
    f4d9:	5f                   	pop    %edi
    f4da:	5d                   	pop    %ebp
    f4db:	c3                   	ret    

0000f4dc <net_if_ipv4_addr_lookup>:
{
    f4dc:	55                   	push   %ebp
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f4dd:	ba a0 aa 40 00       	mov    $0x40aaa0,%edx
{
    f4e2:	89 e5                	mov    %esp,%ebp
    f4e4:	57                   	push   %edi
    f4e5:	56                   	push   %esi
    f4e6:	53                   	push   %ebx
    f4e7:	51                   	push   %ecx
    f4e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f4ee:	81 fa c0 aa 40 00    	cmp    $0x40aac0,%edx
    f4f4:	74 3f                	je     f535 <net_if_ipv4_addr_lookup+0x59>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    f4f6:	8b 5a 08             	mov    0x8(%edx),%ebx
		if (!ipv4) {
    f4f9:	85 db                	test   %ebx,%ebx
    f4fb:	74 33                	je     f530 <net_if_ipv4_addr_lookup+0x54>
		for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f4fd:	31 c9                	xor    %ecx,%ecx
			if (!ipv4->unicast[i].is_used ||
    f4ff:	6b f1 48             	imul   $0x48,%ecx,%esi
    f502:	8d 04 33             	lea    (%ebx,%esi,1),%eax
    f505:	f6 40 47 02          	testb  $0x2,0x47(%eax)
    f509:	74 1f                	je     f52a <net_if_ipv4_addr_lookup+0x4e>
    f50b:	66 83 3c 33 01       	cmpw   $0x1,(%ebx,%esi,1)
    f510:	75 18                	jne    f52a <net_if_ipv4_addr_lookup+0x4e>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
    f512:	8b 7d 08             	mov    0x8(%ebp),%edi
    f515:	8b 3f                	mov    (%edi),%edi
    f517:	39 7c 33 04          	cmp    %edi,0x4(%ebx,%esi,1)
    f51b:	75 0d                	jne    f52a <net_if_ipv4_addr_lookup+0x4e>
				if (ret) {
    f51d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f521:	74 14                	je     f537 <net_if_ipv4_addr_lookup+0x5b>
					*ret = iface;
    f523:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    f526:	89 11                	mov    %edx,(%ecx)
				return &ipv4->unicast[i];
    f528:	eb 0d                	jmp    f537 <net_if_ipv4_addr_lookup+0x5b>
		for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f52a:	41                   	inc    %ecx
    f52b:	83 f9 03             	cmp    $0x3,%ecx
    f52e:	75 cf                	jne    f4ff <net_if_ipv4_addr_lookup+0x23>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f530:	83 c2 20             	add    $0x20,%edx
    f533:	eb b9                	jmp    f4ee <net_if_ipv4_addr_lookup+0x12>
	return NULL;
    f535:	31 c0                	xor    %eax,%eax
}
    f537:	5a                   	pop    %edx
    f538:	5b                   	pop    %ebx
    f539:	5e                   	pop    %esi
    f53a:	5f                   	pop    %edi
    f53b:	5d                   	pop    %ebp
    f53c:	c3                   	ret    

0000f53d <net_if_ipv4_addr_add>:
{
    f53d:	55                   	push   %ebp
    f53e:	89 e5                	mov    %esp,%ebp
    f540:	57                   	push   %edi
    f541:	56                   	push   %esi
		return NULL;
    f542:	31 ff                	xor    %edi,%edi
{
    f544:	53                   	push   %ebx
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
    f545:	8d 45 f0             	lea    -0x10(%ebp),%eax
{
    f548:	83 ec 08             	sub    $0x8,%esp
    f54b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    f54e:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
    f551:	50                   	push   %eax
{
    f552:	88 5d ef             	mov    %bl,-0x11(%ebp)
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
    f555:	ff 75 08             	pushl  0x8(%ebp)
    f558:	e8 3b fd ff ff       	call   f298 <net_if_config_ipv4_get>
    f55d:	5a                   	pop    %edx
    f55e:	85 c0                	test   %eax,%eax
    f560:	59                   	pop    %ecx
    f561:	0f 88 8f 00 00 00    	js     f5f6 <net_if_ipv4_addr_add+0xb9>
	ifaddr = ipv4_addr_find(iface, addr);
    f567:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f56a:	31 d2                	xor    %edx,%edx
	ifaddr = ipv4_addr_find(iface, addr);
    f56c:	8b 48 08             	mov    0x8(%eax),%ecx
		if (!ipv4->unicast[i].is_used) {
    f56f:	6b fa 48             	imul   $0x48,%edx,%edi
    f572:	8d 04 39             	lea    (%ecx,%edi,1),%eax
    f575:	f6 40 47 02          	testb  $0x2,0x47(%eax)
    f579:	74 0c                	je     f587 <net_if_ipv4_addr_add+0x4a>
		if (net_ipv4_addr_cmp(addr,
    f57b:	8b 7c 39 04          	mov    0x4(%ecx,%edi,1),%edi
    f57f:	39 3e                	cmp    %edi,(%esi)
    f581:	75 04                	jne    f587 <net_if_ipv4_addr_add+0x4a>
			return &ipv4->unicast[i];
    f583:	89 c7                	mov    %eax,%edi
	if (ifaddr) {
    f585:	eb 6f                	jmp    f5f6 <net_if_ipv4_addr_add+0xb9>
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f587:	42                   	inc    %edx
    f588:	83 fa 03             	cmp    $0x3,%edx
    f58b:	75 e2                	jne    f56f <net_if_ipv4_addr_add+0x32>
		struct net_if_addr *cur = &ipv4->unicast[i];
    f58d:	8b 55 f0             	mov    -0x10(%ebp),%edx
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f590:	31 c0                	xor    %eax,%eax
		if (addr_type == NET_ADDR_DHCP
    f592:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
    f596:	75 0a                	jne    f5a2 <net_if_ipv4_addr_add+0x65>
		    && cur->addr_type == NET_ADDR_OVERRIDABLE) {
    f598:	6b c8 48             	imul   $0x48,%eax,%ecx
    f59b:	80 7c 0a 44 04       	cmpb   $0x4,0x44(%edx,%ecx,1)
    f5a0:	74 14                	je     f5b6 <net_if_ipv4_addr_add+0x79>
		if (!ipv4->unicast[i].is_used) {
    f5a2:	6b c8 48             	imul   $0x48,%eax,%ecx
    f5a5:	f6 44 0a 47 02       	testb  $0x2,0x47(%edx,%ecx,1)
    f5aa:	74 0a                	je     f5b6 <net_if_ipv4_addr_add+0x79>
	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
    f5ac:	40                   	inc    %eax
    f5ad:	83 f8 03             	cmp    $0x3,%eax
    f5b0:	75 e0                	jne    f592 <net_if_ipv4_addr_add+0x55>
		return NULL;
    f5b2:	31 ff                	xor    %edi,%edi
    f5b4:	eb 40                	jmp    f5f6 <net_if_ipv4_addr_add+0xb9>
		struct net_if_addr *cur = &ipv4->unicast[i];
    f5b6:	6b c0 48             	imul   $0x48,%eax,%eax
	if (ifaddr) {
    f5b9:	01 c2                	add    %eax,%edx
    f5bb:	89 d7                	mov    %edx,%edi
    f5bd:	74 37                	je     f5f6 <net_if_ipv4_addr_add+0xb9>
		ifaddr->is_used = true;
    f5bf:	8d 52 40             	lea    0x40(%edx),%edx
    f5c2:	80 4a 07 02          	orb    $0x2,0x7(%edx)
		ifaddr->address.family = AF_INET;
    f5c6:	66 c7 07 01 00       	movw   $0x1,(%edi)
						addr->s4_addr32[0];
    f5cb:	8b 06                	mov    (%esi),%eax
		ifaddr->addr_type = addr_type;
    f5cd:	88 5f 44             	mov    %bl,0x44(%edi)
		ifaddr->address.in_addr.s4_addr32[0] =
    f5d0:	89 47 04             	mov    %eax,0x4(%edi)
		if (vlifetime) {
    f5d3:	8a 42 07             	mov    0x7(%edx),%al
    f5d6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    f5da:	0f 94 c1             	sete   %cl
    f5dd:	83 e0 fe             	and    $0xfffffffe,%eax
    f5e0:	09 c8                	or     %ecx,%eax
    f5e2:	88 42 07             	mov    %al,0x7(%edx)
		ifaddr->addr_state = NET_ADDR_PREFERRED;
    f5e5:	c6 47 45 01          	movb   $0x1,0x45(%edi)
		net_mgmt_event_notify(NET_EVENT_IPV4_ADDR_ADD, iface);
    f5e9:	8b 55 08             	mov    0x8(%ebp),%edx
    f5ec:	b8 01 00 04 f0       	mov    $0xf0040001,%eax
    f5f1:	e8 cb e6 ff ff       	call   dcc1 <net_mgmt_event_notify>
}
    f5f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f5f9:	89 f8                	mov    %edi,%eax
    f5fb:	5b                   	pop    %ebx
    f5fc:	5e                   	pop    %esi
    f5fd:	5f                   	pop    %edi
    f5fe:	5d                   	pop    %ebp
    f5ff:	c3                   	ret    

0000f600 <net_if_ipv4_maddr_lookup>:
{
    f600:	55                   	push   %ebp
    f601:	89 e5                	mov    %esp,%ebp
    f603:	56                   	push   %esi
    f604:	53                   	push   %ebx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f605:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
{
    f60a:	8b 75 0c             	mov    0xc(%ebp),%esi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f60d:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f613:	74 2e                	je     f643 <net_if_ipv4_maddr_lookup+0x43>
		if (ret && *ret && iface != *ret) {
    f615:	85 f6                	test   %esi,%esi
    f617:	74 0a                	je     f623 <net_if_ipv4_maddr_lookup+0x23>
    f619:	8b 06                	mov    (%esi),%eax
    f61b:	85 c0                	test   %eax,%eax
    f61d:	74 04                	je     f623 <net_if_ipv4_maddr_lookup+0x23>
    f61f:	39 d8                	cmp    %ebx,%eax
    f621:	75 1b                	jne    f63e <net_if_ipv4_maddr_lookup+0x3e>
		addr = ipv4_maddr_find(iface, true, maddr);
    f623:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f626:	ba 01 00 00 00       	mov    $0x1,%edx
    f62b:	89 d8                	mov    %ebx,%eax
    f62d:	e8 83 e5 ff ff       	call   dbb5 <ipv4_maddr_find>
		if (addr) {
    f632:	85 c0                	test   %eax,%eax
    f634:	74 08                	je     f63e <net_if_ipv4_maddr_lookup+0x3e>
			if (ret) {
    f636:	85 f6                	test   %esi,%esi
    f638:	74 0b                	je     f645 <net_if_ipv4_maddr_lookup+0x45>
				*ret = iface;
    f63a:	89 1e                	mov    %ebx,(%esi)
    f63c:	eb 07                	jmp    f645 <net_if_ipv4_maddr_lookup+0x45>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f63e:	83 c3 20             	add    $0x20,%ebx
    f641:	eb ca                	jmp    f60d <net_if_ipv4_maddr_lookup+0xd>
	return NULL;
    f643:	31 c0                	xor    %eax,%eax
}
    f645:	5b                   	pop    %ebx
    f646:	5e                   	pop    %esi
    f647:	5d                   	pop    %ebp
    f648:	c3                   	ret    

0000f649 <net_if_recv_data>:
{
    f649:	55                   	push   %ebp
    f64a:	89 e5                	mov    %esp,%ebp
    f64c:	8b 45 08             	mov    0x8(%ebp),%eax
}
    f64f:	5d                   	pop    %ebp
    f650:	8b 00                	mov    (%eax),%eax
	return net_if_l2(iface)->recv(iface, pkt);
    f652:	8b 40 04             	mov    0x4(%eax),%eax
    f655:	8b 00                	mov    (%eax),%eax
    f657:	ff e0                	jmp    *%eax

0000f659 <net_if_call_link_cb>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    f659:	a1 9c 42 40 00       	mov    0x40429c,%eax
    f65e:	85 c0                	test   %eax,%eax
    f660:	74 24                	je     f686 <net_if_call_link_cb+0x2d>
{
    f662:	55                   	push   %ebp
    f663:	89 e5                	mov    %esp,%ebp
    f665:	53                   	push   %ebx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    f666:	8b 18                	mov    (%eax),%ebx
		link->cb(iface, lladdr, status);
    f668:	ff 75 10             	pushl  0x10(%ebp)
    f66b:	ff 75 0c             	pushl  0xc(%ebp)
    f66e:	ff 75 08             	pushl  0x8(%ebp)
    f671:	ff 50 04             	call   *0x4(%eax)
    f674:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    f677:	85 db                	test   %ebx,%ebx
    f679:	74 06                	je     f681 <net_if_call_link_cb+0x28>
    f67b:	89 d8                	mov    %ebx,%eax
    f67d:	8b 1b                	mov    (%ebx),%ebx
    f67f:	eb e7                	jmp    f668 <net_if_call_link_cb+0xf>
}
    f681:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f684:	c9                   	leave  
    f685:	c3                   	ret    
    f686:	c3                   	ret    

0000f687 <process_tx_packet>:
{
    f687:	55                   	push   %ebp
    f688:	89 e5                	mov    %esp,%ebp
    f68a:	57                   	push   %edi
    f68b:	56                   	push   %esi
    f68c:	53                   	push   %ebx
    f68d:	83 ec 08             	sub    $0x8,%esp
    f690:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!pkt) {
    f693:	89 d8                	mov    %ebx,%eax
    f695:	83 e8 04             	sub    $0x4,%eax
    f698:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f69b:	0f 84 8c 00 00 00    	je     f72d <process_tx_packet+0xa6>
	net_if_tx(net_pkt_iface(pkt), pkt);
    f6a1:	8b 73 20             	mov    0x20(%ebx),%esi
	context = net_pkt_context(pkt);
    f6a4:	8b 43 1c             	mov    0x1c(%ebx),%eax
    f6a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f6aa:	31 d2                	xor    %edx,%edx
    f6ac:	8b 06                	mov    (%esi),%eax
    f6ae:	83 c0 0c             	add    $0xc,%eax
    f6b1:	e8 6e e5 ff ff       	call   dc24 <atomic_test_bit>
    f6b6:	84 c0                	test   %al,%al
    f6b8:	74 16                	je     f6d0 <process_tx_packet+0x49>
    f6ba:	8b 06                	mov    (%esi),%eax
		status = net_if_l2(iface)->send(iface, pkt);
    f6bc:	8b 40 04             	mov    0x4(%eax),%eax
    f6bf:	ff 75 f0             	pushl  -0x10(%ebp)
    f6c2:	56                   	push   %esi
    f6c3:	ff 50 04             	call   *0x4(%eax)
    f6c6:	5a                   	pop    %edx
    f6c7:	89 c7                	mov    %eax,%edi
    f6c9:	59                   	pop    %ecx
	if (status < 0) {
    f6ca:	85 c0                	test   %eax,%eax
    f6cc:	79 3b                	jns    f709 <process_tx_packet+0x82>
    f6ce:	eb 30                	jmp    f700 <process_tx_packet+0x79>
		status = -ENETDOWN;
    f6d0:	bf c2 ff ff ff       	mov    $0xffffffc2,%edi
		NET_WARN("iface %p is down", iface);
    f6d5:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    f6dc:	74 22                	je     f700 <process_tx_packet+0x79>
    f6de:	b8 94 51 02 00       	mov    $0x25194,%eax
    f6e3:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    f6e8:	c1 e8 03             	shr    $0x3,%eax
    f6eb:	c1 e0 06             	shl    $0x6,%eax
    f6ee:	83 c8 02             	or     $0x2,%eax
    f6f1:	50                   	push   %eax
    f6f2:	56                   	push   %esi
    f6f3:	68 19 7a 02 00       	push   $0x27a19
    f6f8:	e8 b2 3d ff ff       	call   34af <log_1>
    f6fd:	83 c4 0c             	add    $0xc,%esp
		net_pkt_unref(pkt);
    f700:	ff 75 f0             	pushl  -0x10(%ebp)
    f703:	e8 f9 06 00 00       	call   fe01 <net_pkt_unref>
    f708:	58                   	pop    %eax
	if (context) {
    f709:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f70d:	74 0a                	je     f719 <process_tx_packet+0x92>
		net_context_send_cb(context, status);
    f70f:	89 fa                	mov    %edi,%edx
    f711:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f714:	e8 1a e4 ff ff       	call   db33 <net_context_send_cb>
	if (dst->addr) {
    f719:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
    f71d:	74 0e                	je     f72d <process_tx_packet+0xa6>
		net_if_call_link_cb(iface, dst, status);
    f71f:	57                   	push   %edi
	return &pkt->lladdr_dst;
    f720:	83 c3 30             	add    $0x30,%ebx
    f723:	53                   	push   %ebx
    f724:	56                   	push   %esi
    f725:	e8 2f ff ff ff       	call   f659 <net_if_call_link_cb>
    f72a:	83 c4 0c             	add    $0xc,%esp
}
    f72d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f730:	5b                   	pop    %ebx
    f731:	5e                   	pop    %esi
    f732:	5f                   	pop    %edi
    f733:	5d                   	pop    %ebp
    f734:	c3                   	ret    

0000f735 <net_if_send_data>:
{
    f735:	55                   	push   %ebp
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f736:	31 d2                	xor    %edx,%edx
{
    f738:	89 e5                	mov    %esp,%ebp
    f73a:	57                   	push   %edi
    f73b:	56                   	push   %esi
    f73c:	53                   	push   %ebx
    f73d:	56                   	push   %esi
    f73e:	8b 7d 0c             	mov    0xc(%ebp),%edi
    f741:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_context *context = net_pkt_context(pkt);
    f744:	8b 47 20             	mov    0x20(%edi),%eax
    f747:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f74a:	8b 03                	mov    (%ebx),%eax
    f74c:	83 c0 0c             	add    $0xc,%eax
    f74f:	e8 d0 e4 ff ff       	call   dc24 <atomic_test_bit>
    f754:	84 c0                	test   %al,%al
    f756:	75 32                	jne    f78a <net_if_send_data+0x55>
		status = -ENETDOWN;
    f758:	be c2 ff ff ff       	mov    $0xffffffc2,%esi
		NET_WARN("iface %p is down", iface);
    f75d:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    f764:	74 78                	je     f7de <net_if_send_data+0xa9>
    f766:	b8 94 51 02 00       	mov    $0x25194,%eax
    f76b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    f770:	c1 e8 03             	shr    $0x3,%eax
    f773:	c1 e0 06             	shl    $0x6,%eax
    f776:	83 c8 02             	or     $0x2,%eax
    f779:	50                   	push   %eax
    f77a:	53                   	push   %ebx
    f77b:	68 19 7a 02 00       	push   $0x27a19
    f780:	e8 2a 3d ff ff       	call   34af <log_1>
    f785:	83 c4 0c             	add    $0xc,%esp
    f788:	eb 54                	jmp    f7de <net_if_send_data+0xa9>
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_POINTOPOINT) &&
    f78a:	8b 03                	mov    (%ebx),%eax
    f78c:	ba 01 00 00 00       	mov    $0x1,%edx
    f791:	83 c0 0c             	add    $0xc,%eax
    f794:	e8 8b e4 ff ff       	call   dc24 <atomic_test_bit>
    f799:	84 c0                	test   %al,%al
    f79b:	75 17                	jne    f7b4 <net_if_send_data+0x7f>
    f79d:	83 7f 2c 00          	cmpl   $0x0,0x2c(%edi)
    f7a1:	75 11                	jne    f7b4 <net_if_send_data+0x7f>
	return net_if_get_link_addr(pkt->iface);
    f7a3:	8b 47 24             	mov    0x24(%edi),%eax
    f7a6:	8b 00                	mov    (%eax),%eax
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
    f7a8:	8b 50 10             	mov    0x10(%eax),%edx
    f7ab:	89 57 2c             	mov    %edx,0x2c(%edi)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    f7ae:	8a 40 14             	mov    0x14(%eax),%al
    f7b1:	88 47 30             	mov    %al,0x30(%edi)
	return pkt->family;
    f7b4:	8a 47 3f             	mov    0x3f(%edi),%al
    f7b7:	d0 e8                	shr    %al
    f7b9:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET6) {
    f7bc:	3c 02                	cmp    $0x2,%al
    f7be:	74 0d                	je     f7cd <net_if_send_data+0x98>
		net_if_queue_tx(iface, pkt);
    f7c0:	57                   	push   %edi
    f7c1:	53                   	push   %ebx
    f7c2:	e8 86 e7 ff ff       	call   df4d <net_if_queue_tx>
    f7c7:	59                   	pop    %ecx
    f7c8:	31 c0                	xor    %eax,%eax
    f7ca:	5b                   	pop    %ebx
    f7cb:	eb 46                	jmp    f813 <net_if_send_data+0xde>
		verdict = net_ipv6_prepare_for_send(pkt);
    f7cd:	57                   	push   %edi
    f7ce:	e8 e1 41 00 00       	call   139b4 <net_ipv6_prepare_for_send>
    f7d3:	5a                   	pop    %edx
	if (verdict == NET_DROP) {
    f7d4:	83 f8 02             	cmp    $0x2,%eax
    f7d7:	75 36                	jne    f80f <net_if_send_data+0xda>
	int status = -EIO;
    f7d9:	be fb ff ff ff       	mov    $0xfffffffb,%esi
		if (context) {
    f7de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f7e2:	74 0a                	je     f7ee <net_if_send_data+0xb9>
			net_context_send_cb(context, status);
    f7e4:	89 f2                	mov    %esi,%edx
    f7e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f7e9:	e8 45 e3 ff ff       	call   db33 <net_context_send_cb>
		if (dst->addr) {
    f7ee:	b8 02 00 00 00       	mov    $0x2,%eax
    f7f3:	83 7f 34 00          	cmpl   $0x0,0x34(%edi)
    f7f7:	74 1a                	je     f813 <net_if_send_data+0xde>
			net_if_call_link_cb(iface, dst, status);
    f7f9:	56                   	push   %esi
	return &pkt->lladdr_dst;
    f7fa:	8d 4f 34             	lea    0x34(%edi),%ecx
    f7fd:	51                   	push   %ecx
    f7fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f801:	53                   	push   %ebx
    f802:	e8 52 fe ff ff       	call   f659 <net_if_call_link_cb>
    f807:	83 c4 0c             	add    $0xc,%esp
    f80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f80d:	eb 04                	jmp    f813 <net_if_send_data+0xde>
	} else if (verdict == NET_OK) {
    f80f:	85 c0                	test   %eax,%eax
    f811:	74 ad                	je     f7c0 <net_if_send_data+0x8b>
}
    f813:	8d 65 f4             	lea    -0xc(%ebp),%esp
    f816:	5b                   	pop    %ebx
    f817:	5e                   	pop    %esi
    f818:	5f                   	pop    %edi
    f819:	5d                   	pop    %ebp
    f81a:	c3                   	ret    

0000f81b <net_if_need_calc_tx_checksum>:

bool net_if_need_calc_tx_checksum(struct net_if *iface)
{
    f81b:	55                   	push   %ebp
    f81c:	89 e5                	mov    %esp,%ebp
    f81e:	8b 45 08             	mov    0x8(%ebp),%eax
    f821:	8b 10                	mov    (%eax),%edx
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
    f823:	81 7a 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%edx)
    f82a:	75 0b                	jne    f837 <net_if_need_calc_tx_checksum+0x1c>
    f82c:	ba 01 00 00 00       	mov    $0x1,%edx
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
}
    f831:	5d                   	pop    %ebp
    f832:	e9 a8 e6 ff ff       	jmp    dedf <need_calc_checksum.part.19>
    f837:	b0 01                	mov    $0x1,%al
    f839:	5d                   	pop    %ebp
    f83a:	c3                   	ret    

0000f83b <net_if_need_calc_rx_checksum>:

bool net_if_need_calc_rx_checksum(struct net_if *iface)
{
    f83b:	55                   	push   %ebp
    f83c:	89 e5                	mov    %esp,%ebp
    f83e:	8b 45 08             	mov    0x8(%ebp),%eax
    f841:	8b 10                	mov    (%eax),%edx
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
    f843:	81 7a 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%edx)
    f84a:	75 0b                	jne    f857 <net_if_need_calc_rx_checksum+0x1c>
    f84c:	ba 02 00 00 00       	mov    $0x2,%edx
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
}
    f851:	5d                   	pop    %ebp
    f852:	e9 88 e6 ff ff       	jmp    dedf <need_calc_checksum.part.19>
    f857:	b0 01                	mov    $0x1,%al
    f859:	5d                   	pop    %ebp
    f85a:	c3                   	ret    

0000f85b <net_if_get_by_index>:

struct net_if *net_if_get_by_index(int index)
{
    f85b:	55                   	push   %ebp
	if (index <= 0) {
		return NULL;
    f85c:	31 c0                	xor    %eax,%eax
{
    f85e:	89 e5                	mov    %esp,%ebp
    f860:	8b 55 08             	mov    0x8(%ebp),%edx
	if (index <= 0) {
    f863:	85 d2                	test   %edx,%edx
    f865:	7e 12                	jle    f879 <net_if_get_by_index+0x1e>
	}

	if (&__net_if_start[index - 1] >= __net_if_end) {
    f867:	c1 e2 05             	shl    $0x5,%edx
    f86a:	8d 82 80 aa 40 00    	lea    0x40aa80(%edx),%eax
    f870:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    f875:	72 02                	jb     f879 <net_if_get_by_index+0x1e>
		return NULL;
    f877:	31 c0                	xor    %eax,%eax
		NET_DBG("Index %d is too large", index);
		return NULL;
	}

	return &__net_if_start[index - 1];
}
    f879:	5d                   	pop    %ebp
    f87a:	c3                   	ret    

0000f87b <net_if_get_by_iface>:

int net_if_get_by_iface(struct net_if *iface)
{
    f87b:	55                   	push   %ebp
    f87c:	89 e5                	mov    %esp,%ebp
    f87e:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!(iface >= __net_if_start && iface < __net_if_end)) {
    f881:	3d a0 aa 40 00       	cmp    $0x40aaa0,%eax
    f886:	72 12                	jb     f89a <net_if_get_by_iface+0x1f>
    f888:	3d c0 aa 40 00       	cmp    $0x40aac0,%eax
    f88d:	73 0b                	jae    f89a <net_if_get_by_iface+0x1f>
		return -1;
	}

	return (iface - __net_if_start) + 1;
    f88f:	2d a0 aa 40 00       	sub    $0x40aaa0,%eax
    f894:	c1 f8 05             	sar    $0x5,%eax
    f897:	40                   	inc    %eax
    f898:	eb 03                	jmp    f89d <net_if_get_by_iface+0x22>
		return -1;
    f89a:	83 c8 ff             	or     $0xffffffff,%eax
}
    f89d:	5d                   	pop    %ebp
    f89e:	c3                   	ret    

0000f89f <net_if_foreach>:

void net_if_foreach(net_if_cb_t cb, void *user_data)
{
    f89f:	55                   	push   %ebp
    f8a0:	89 e5                	mov    %esp,%ebp
    f8a2:	53                   	push   %ebx
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f8a3:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
    f8a8:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f8ae:	74 0e                	je     f8be <net_if_foreach+0x1f>
		cb(iface, user_data);
    f8b0:	ff 75 0c             	pushl  0xc(%ebp)
    f8b3:	53                   	push   %ebx
    f8b4:	ff 55 08             	call   *0x8(%ebp)
    f8b7:	58                   	pop    %eax
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f8b8:	83 c3 20             	add    $0x20,%ebx
		cb(iface, user_data);
    f8bb:	5a                   	pop    %edx
    f8bc:	eb ea                	jmp    f8a8 <net_if_foreach+0x9>
	}
}
    f8be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f8c1:	c9                   	leave  
    f8c2:	c3                   	ret    

0000f8c3 <net_if_up>:

int net_if_up(struct net_if *iface)
{
    f8c3:	55                   	push   %ebp
	int status;

	NET_DBG("iface %p", iface);

	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f8c4:	31 d2                	xor    %edx,%edx
{
    f8c6:	89 e5                	mov    %esp,%ebp
    f8c8:	53                   	push   %ebx
    f8c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f8cc:	8b 03                	mov    (%ebx),%eax
    f8ce:	83 c0 0c             	add    $0xc,%eax
    f8d1:	e8 4e e3 ff ff       	call   dc24 <atomic_test_bit>
    f8d6:	88 c2                	mov    %al,%dl
		return 0;
    f8d8:	31 c0                	xor    %eax,%eax
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    f8da:	84 d2                	test   %dl,%dl
    f8dc:	75 3d                	jne    f91b <net_if_up+0x58>
    f8de:	8b 03                	mov    (%ebx),%eax
		goto done;
	}
#endif

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface)->enable) {
    f8e0:	8b 40 04             	mov    0x4(%eax),%eax
    f8e3:	8b 40 08             	mov    0x8(%eax),%eax
    f8e6:	85 c0                	test   %eax,%eax
    f8e8:	75 26                	jne    f910 <net_if_up+0x4d>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    f8ea:	8b 03                	mov    (%ebx),%eax
    f8ec:	f0 83 48 0c 01       	lock orl $0x1,0xc(%eax)

	atomic_set_bit(iface->if_dev->flags, NET_IF_UP);

#if defined(CONFIG_NET_IPV6_DAD)
	NET_DBG("Starting DAD for iface %p", iface);
	net_if_start_dad(iface);
    f8f1:	53                   	push   %ebx
    f8f2:	e8 9c eb ff ff       	call   e493 <net_if_start_dad>
			 &iface->config.ip.ipv6->mcast[0].address.in6_addr);
#endif /* CONFIG_NET_IPV6_DAD */

#if defined(CONFIG_NET_IPV6_ND)
	NET_DBG("Starting ND/RS for iface %p", iface);
	net_if_start_rs(iface);
    f8f7:	89 1c 24             	mov    %ebx,(%esp)
    f8fa:	e8 d6 e6 ff ff       	call   dfd5 <net_if_start_rs>
    f8ff:	58                   	pop    %eax

#if defined(CONFIG_NET_IPV4_AUTO)
	net_ipv4_autoconf_start(iface);
#endif

	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);
    f900:	89 da                	mov    %ebx,%edx
    f902:	b8 02 00 01 d0       	mov    $0xd0010002,%eax
    f907:	e8 b5 e3 ff ff       	call   dcc1 <net_mgmt_event_notify>
    f90c:	31 c0                	xor    %eax,%eax
    f90e:	eb 0b                	jmp    f91b <net_if_up+0x58>
	status = net_if_l2(iface)->enable(iface, true);
    f910:	6a 01                	push   $0x1
    f912:	53                   	push   %ebx
    f913:	ff d0                	call   *%eax
    f915:	5a                   	pop    %edx
	if (status < 0) {
    f916:	85 c0                	test   %eax,%eax
	status = net_if_l2(iface)->enable(iface, true);
    f918:	59                   	pop    %ecx
	if (status < 0) {
    f919:	79 cf                	jns    f8ea <net_if_up+0x27>

	return 0;
}
    f91b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f91e:	c9                   	leave  
    f91f:	c3                   	ret    

0000f920 <net_if_down>:

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);
}

int net_if_down(struct net_if *iface)
{
    f920:	55                   	push   %ebp
    f921:	89 e5                	mov    %esp,%ebp
    f923:	56                   	push   %esi
    f924:	53                   	push   %ebx
    f925:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
    f928:	8b 73 04             	mov    0x4(%ebx),%esi
	if (!ipv6) {
    f92b:	85 f6                	test   %esi,%esi
    f92d:	74 3a                	je     f969 <net_if_down+0x49>
		if (!ipv6->mcast[i].is_used ||
    f92f:	8a 86 ec 00 00 00    	mov    0xec(%esi),%al
    f935:	a8 01                	test   $0x1,%al
    f937:	74 13                	je     f94c <net_if_down+0x2c>
    f939:	a8 02                	test   $0x2,%al
    f93b:	74 0f                	je     f94c <net_if_down+0x2c>
		net_ipv6_mld_leave(iface, &ipv6->mcast[i].address.in6_addr);
    f93d:	8d 86 dc 00 00 00    	lea    0xdc(%esi),%eax
    f943:	50                   	push   %eax
    f944:	53                   	push   %ebx
    f945:	e8 39 49 00 00       	call   14283 <net_ipv6_mld_leave>
    f94a:	58                   	pop    %eax
    f94b:	5a                   	pop    %edx
		if (!ipv6->mcast[i].is_used ||
    f94c:	8a 86 04 01 00 00    	mov    0x104(%esi),%al
    f952:	a8 01                	test   $0x1,%al
    f954:	74 13                	je     f969 <net_if_down+0x49>
    f956:	a8 02                	test   $0x2,%al
    f958:	74 0f                	je     f969 <net_if_down+0x49>
		net_ipv6_mld_leave(iface, &ipv6->mcast[i].address.in6_addr);
    f95a:	81 c6 f4 00 00 00    	add    $0xf4,%esi
    f960:	56                   	push   %esi
    f961:	53                   	push   %ebx
    f962:	e8 1c 49 00 00       	call   14283 <net_ipv6_mld_leave>
    f967:	5e                   	pop    %esi
    f968:	58                   	pop    %eax
    f969:	8b 03                	mov    (%ebx),%eax
		goto done;
	}
#endif

	/* If the L2 does not support enable just clear the flag */
	if (!net_if_l2(iface)->enable) {
    f96b:	8b 40 04             	mov    0x4(%eax),%eax
    f96e:	8b 40 08             	mov    0x8(%eax),%eax
    f971:	85 c0                	test   %eax,%eax
    f973:	75 17                	jne    f98c <net_if_down+0x6c>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    f975:	8b 03                	mov    (%ebx),%eax
    f977:	f0 83 60 0c fe       	lock andl $0xfffffffe,0xc(%eax)
	}

done:
	atomic_clear_bit(iface->if_dev->flags, NET_IF_UP);

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);
    f97c:	b8 01 00 01 d0       	mov    $0xd0010001,%eax
    f981:	89 da                	mov    %ebx,%edx
    f983:	e8 39 e3 ff ff       	call   dcc1 <net_mgmt_event_notify>

	return 0;
    f988:	31 c0                	xor    %eax,%eax
    f98a:	eb 0b                	jmp    f997 <net_if_down+0x77>
	status = net_if_l2(iface)->enable(iface, false);
    f98c:	6a 00                	push   $0x0
    f98e:	53                   	push   %ebx
    f98f:	ff d0                	call   *%eax
    f991:	5a                   	pop    %edx
	if (status < 0) {
    f992:	85 c0                	test   %eax,%eax
	status = net_if_l2(iface)->enable(iface, false);
    f994:	59                   	pop    %ecx
	if (status < 0) {
    f995:	79 de                	jns    f975 <net_if_down+0x55>
}
    f997:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f99a:	5b                   	pop    %ebx
    f99b:	5e                   	pop    %esi
    f99c:	5d                   	pop    %ebp
    f99d:	c3                   	ret    

0000f99e <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP */

void net_if_init(void)
{
    f99e:	55                   	push   %ebp
    f99f:	89 e5                	mov    %esp,%ebp
    f9a1:	56                   	push   %esi
    f9a2:	53                   	push   %ebx
	int i;
#endif

	NET_DBG("");

	net_tc_tx_init();
    f9a3:	e8 f0 0c 00 00       	call   10698 <net_tc_tx_init>

#if defined(CONFIG_NET_IPV6)
	k_delayed_work_init(&address_lifetime_timer, address_lifetime_timeout);
    f9a8:	68 d4 dc 00 00       	push   $0xdcd4
    f9ad:	68 20 0d 40 00       	push   $0x400d20
    f9b2:	e8 ee 4a 01 00       	call   244a5 <k_delayed_work_init>
    f9b7:	5b                   	pop    %ebx
	k_delayed_work_init(&prefix_lifetime_timer, prefix_lifetime_timeout);
#endif

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
    f9b8:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
	k_delayed_work_init(&address_lifetime_timer, address_lifetime_timeout);
    f9bd:	5e                   	pop    %esi
	k_delayed_work_init(&prefix_lifetime_timer, prefix_lifetime_timeout);
    f9be:	68 c8 e8 00 00       	push   $0xe8c8
    f9c3:	68 00 0d 40 00       	push   $0x400d00
    f9c8:	e8 d8 4a 01 00       	call   244a5 <k_delayed_work_init>
    f9cd:	58                   	pop    %eax
    f9ce:	5a                   	pop    %edx
	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
    f9cf:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    f9d5:	74 10                	je     f9e7 <net_if_init+0x49>
	return iface->if_dev->dev;
    f9d7:	8b 03                	mov    (%ebx),%eax
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
    f9d9:	8b 00                	mov    (%eax),%eax
	api->init(iface);
    f9db:	8b 40 04             	mov    0x4(%eax),%eax
    f9de:	53                   	push   %ebx
	     iface++, if_count++) {
    f9df:	83 c3 20             	add    $0x20,%ebx
	api->init(iface);
    f9e2:	ff 10                	call   *(%eax)
    f9e4:	59                   	pop    %ecx
    f9e5:	eb e8                	jmp    f9cf <net_if_init+0x31>
    f9e7:	89 de                	mov    %ebx,%esi
    f9e9:	81 ee a0 aa 40 00    	sub    $0x40aaa0,%esi
    f9ef:	c1 ee 05             	shr    $0x5,%esi
		init_iface(iface);
	}

	if (iface == __net_if_start) {
    f9f2:	81 fb a0 aa 40 00    	cmp    $0x40aaa0,%ebx
    f9f8:	75 30                	jne    fa2a <net_if_init+0x8c>
		NET_ERR("There is no network interface to work with!");
    f9fa:	f6 05 88 a8 40 00 07 	testb  $0x7,0x40a888
    fa01:	0f 84 f9 00 00 00    	je     fb00 <net_if_init+0x162>
    fa07:	b8 94 51 02 00       	mov    $0x25194,%eax
    fa0c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
    fa11:	c1 e8 03             	shr    $0x3,%eax
    fa14:	c1 e0 06             	shl    $0x6,%eax
    fa17:	83 c8 01             	or     $0x1,%eax
    fa1a:	50                   	push   %eax
    fa1b:	68 2a 7a 02 00       	push   $0x27a2a
    fa20:	e8 65 3a ff ff       	call   348a <log_0>
    fa25:	e9 d4 00 00 00       	jmp    fafe <net_if_init+0x160>
		return;
	}

#if defined(CONFIG_NET_IPV4)
	if (if_count > ARRAY_SIZE(ipv4_addresses)) {
    fa2a:	83 fe 01             	cmp    $0x1,%esi
    fa2d:	7e 49                	jle    fa78 <net_if_init+0xda>
		NET_WARN("You have %lu IPv4 net_if addresses but %d "
    fa2f:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    fa36:	74 40                	je     fa78 <net_if_init+0xda>
    fa38:	bb 94 51 02 00       	mov    $0x25194,%ebx
    fa3d:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    fa43:	c1 eb 03             	shr    $0x3,%ebx
    fa46:	c1 e3 06             	shl    $0x6,%ebx
    fa49:	89 d8                	mov    %ebx,%eax
    fa4b:	83 c8 02             	or     $0x2,%eax
    fa4e:	50                   	push   %eax
    fa4f:	56                   	push   %esi
    fa50:	6a 01                	push   $0x1
    fa52:	68 56 7a 02 00       	push   $0x27a56
    fa57:	e8 8d 3a ff ff       	call   34e9 <log_2>
    fa5c:	83 c4 10             	add    $0x10,%esp
			 "network interfaces", ARRAY_SIZE(ipv4_addresses),
			 if_count);
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV4_COUNT "
    fa5f:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    fa66:	74 10                	je     fa78 <net_if_init+0xda>
    fa68:	83 cb 02             	or     $0x2,%ebx
    fa6b:	53                   	push   %ebx
    fa6c:	68 93 7a 02 00       	push   $0x27a93
    fa71:	e8 14 3a ff ff       	call   348a <log_0>
    fa76:	58                   	pop    %eax
    fa77:	5a                   	pop    %edx
			 "value.");
	}

	for (i = 0; i < ARRAY_SIZE(ipv4_addresses); i++) {
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
    fa78:	c6 05 50 0b 40 00 40 	movb   $0x40,0x400b50
	}
#endif

#if defined(CONFIG_NET_IPV6)
	if (if_count > ARRAY_SIZE(ipv6_addresses)) {
    fa7f:	83 fe 01             	cmp    $0x1,%esi
    fa82:	7e 49                	jle    facd <net_if_init+0x12f>
		NET_WARN("You have %lu IPv6 net_if addresses but %d "
    fa84:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    fa8b:	74 40                	je     facd <net_if_init+0x12f>
    fa8d:	bb 94 51 02 00       	mov    $0x25194,%ebx
    fa92:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
    fa98:	c1 eb 03             	shr    $0x3,%ebx
    fa9b:	c1 e3 06             	shl    $0x6,%ebx
    fa9e:	89 d8                	mov    %ebx,%eax
    faa0:	83 c8 02             	or     $0x2,%eax
    faa3:	50                   	push   %eax
    faa4:	56                   	push   %esi
    faa5:	6a 01                	push   $0x1
    faa7:	68 cb 7a 02 00       	push   $0x27acb
    faac:	e8 38 3a ff ff       	call   34e9 <log_2>
    fab1:	83 c4 10             	add    $0x10,%esp
			 "network interfaces", ARRAY_SIZE(ipv6_addresses),
			 if_count);
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV6_COUNT "
    fab4:	f6 05 88 a8 40 00 06 	testb  $0x6,0x40a888
    fabb:	74 10                	je     facd <net_if_init+0x12f>
    fabd:	83 cb 02             	or     $0x2,%ebx
    fac0:	53                   	push   %ebx
    fac1:	68 08 7b 02 00       	push   $0x27b08
    fac6:	e8 bf 39 ff ff       	call   348a <log_0>
    facb:	59                   	pop    %ecx
    facc:	5b                   	pop    %ebx
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
    facd:	68 60 0b 40 00       	push   $0x400b60
			 "value.");
	}

	for (i = 0; i < ARRAY_SIZE(ipv6_addresses); i++) {
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
    fad2:	c6 05 e4 0c 40 00 40 	movb   $0x40,0x400ce4
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
    fad9:	c7 05 d8 0c 40 00 30 	movl   $0x7530,0x400cd8
    fae0:	75 00 00 
    fae3:	e8 87 f7 ff ff       	call   f26f <net_if_ipv6_calc_reachable_time>

		net_if_ipv6_set_reachable_time(&ipv6_addresses[i].ipv6);

#if defined(CONFIG_NET_IPV6_ND)
		k_delayed_work_init(&ipv6_addresses[i].ipv6.rs_timer,
    fae8:	c7 04 24 07 e0 00 00 	movl   $0xe007,(%esp)
    faef:	a3 dc 0c 40 00       	mov    %eax,0x400cdc
    faf4:	68 b8 0c 40 00       	push   $0x400cb8
    faf9:	e8 a7 49 01 00       	call   244a5 <k_delayed_work_init>
    fafe:	58                   	pop    %eax
    faff:	5a                   	pop    %edx
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
    fb00:	8d 65 f8             	lea    -0x8(%ebp),%esp
    fb03:	5b                   	pop    %ebx
    fb04:	5e                   	pop    %esi
    fb05:	5d                   	pop    %ebp
    fb06:	c3                   	ret    

0000fb07 <net_if_post_init>:

void net_if_post_init(void)
{
    fb07:	55                   	push   %ebp
    fb08:	89 e5                	mov    %esp,%ebp
    fb0a:	53                   	push   %ebx
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    fb0b:	bb a0 aa 40 00       	mov    $0x40aaa0,%ebx
    fb10:	81 fb c0 aa 40 00    	cmp    $0x40aac0,%ebx
    fb16:	74 0c                	je     fb24 <net_if_post_init+0x1d>
		net_if_up(iface);
    fb18:	53                   	push   %ebx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    fb19:	83 c3 20             	add    $0x20,%ebx
		net_if_up(iface);
    fb1c:	e8 a2 fd ff ff       	call   f8c3 <net_if_up>
    fb21:	58                   	pop    %eax
    fb22:	eb ec                	jmp    fb10 <net_if_post_init+0x9>
	}
}
    fb24:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fb27:	c9                   	leave  
    fb28:	c3                   	ret    

0000fb29 <net_buf_frags_len>:
{
    fb29:	89 c2                	mov    %eax,%edx
	size_t bytes = 0;
    fb2b:	31 c0                	xor    %eax,%eax
	while (buf) {
    fb2d:	85 d2                	test   %edx,%edx
    fb2f:	74 0a                	je     fb3b <net_buf_frags_len+0x12>
		bytes += buf->len;
    fb31:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
    fb35:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
    fb37:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
    fb39:	eb f2                	jmp    fb2d <net_buf_frags_len+0x4>
	}

	return bytes;
}
    fb3b:	c3                   	ret    

0000fb3c <pkt_cursor_jump>:

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
    fb3c:	8b 48 18             	mov    0x18(%eax),%ecx
    fb3f:	8b 09                	mov    (%ecx),%ecx
    fb41:	89 48 18             	mov    %ecx,0x18(%eax)
	while (cursor->buf) {
    fb44:	8b 48 18             	mov    0x18(%eax),%ecx
    fb47:	85 c9                	test   %ecx,%ecx
    fb49:	75 08                	jne    fb53 <pkt_cursor_jump+0x17>
	}

	if (cursor->buf) {
		cursor->pos = cursor->buf->data;
	} else {
		cursor->pos = NULL;
    fb4b:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    fb52:	c3                   	ret    
{
    fb53:	55                   	push   %ebp
    fb54:	89 e5                	mov    %esp,%ebp
    fb56:	53                   	push   %ebx
		size_t len = write ? cursor->buf->size : cursor->buf->len;
    fb57:	84 d2                	test   %dl,%dl
    fb59:	74 06                	je     fb61 <pkt_cursor_jump+0x25>
    fb5b:	0f b7 59 0e          	movzwl 0xe(%ecx),%ebx
    fb5f:	eb 04                	jmp    fb65 <pkt_cursor_jump+0x29>
    fb61:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
		if (!len) {
    fb65:	85 db                	test   %ebx,%ebx
    fb67:	75 15                	jne    fb7e <pkt_cursor_jump+0x42>
			cursor->buf = cursor->buf->frags;
    fb69:	8b 09                	mov    (%ecx),%ecx
    fb6b:	89 48 18             	mov    %ecx,0x18(%eax)
	while (cursor->buf) {
    fb6e:	8b 48 18             	mov    0x18(%eax),%ecx
    fb71:	85 c9                	test   %ecx,%ecx
    fb73:	75 e2                	jne    fb57 <pkt_cursor_jump+0x1b>
		cursor->pos = NULL;
    fb75:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    fb7c:	eb 06                	jmp    fb84 <pkt_cursor_jump+0x48>
		cursor->pos = cursor->buf->data;
    fb7e:	8b 51 08             	mov    0x8(%ecx),%edx
    fb81:	89 50 1c             	mov    %edx,0x1c(%eax)
	}
}
    fb84:	5b                   	pop    %ebx
    fb85:	5d                   	pop    %ebp
    fb86:	c3                   	ret    

0000fb87 <pkt_cursor_advance>:
static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
    fb87:	8b 48 18             	mov    0x18(%eax),%ecx
    fb8a:	85 c9                	test   %ecx,%ecx
    fb8c:	74 2c                	je     fbba <pkt_cursor_advance+0x33>
{
    fb8e:	55                   	push   %ebp
		return;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
    fb8f:	84 d2                	test   %dl,%dl
{
    fb91:	89 e5                	mov    %esp,%ebp
    fb93:	56                   	push   %esi
    fb94:	53                   	push   %ebx
	len = write ? cursor->buf->size : cursor->buf->len;
    fb95:	74 06                	je     fb9d <pkt_cursor_advance+0x16>
    fb97:	0f b7 59 0e          	movzwl 0xe(%ecx),%ebx
    fb9b:	eb 04                	jmp    fba1 <pkt_cursor_advance+0x1a>
    fb9d:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
	if ((cursor->pos - cursor->buf->data) == len) {
    fba1:	8b 70 1c             	mov    0x1c(%eax),%esi
    fba4:	2b 71 08             	sub    0x8(%ecx),%esi
    fba7:	39 de                	cmp    %ebx,%esi
    fba9:	75 0b                	jne    fbb6 <pkt_cursor_advance+0x2f>
		pkt_cursor_jump(pkt, write);
	}
}
    fbab:	5b                   	pop    %ebx
    fbac:	5e                   	pop    %esi
		pkt_cursor_jump(pkt, write);
    fbad:	0f b6 d2             	movzbl %dl,%edx
}
    fbb0:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
    fbb1:	e9 86 ff ff ff       	jmp    fb3c <pkt_cursor_jump>
}
    fbb6:	5b                   	pop    %ebx
    fbb7:	5e                   	pop    %esi
    fbb8:	5d                   	pop    %ebp
    fbb9:	c3                   	ret    
    fbba:	c3                   	ret    

0000fbbb <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
    fbbb:	55                   	push   %ebp
    fbbc:	89 e5                	mov    %esp,%ebp
    fbbe:	57                   	push   %edi
    fbbf:	56                   	push   %esi
    fbc0:	53                   	push   %ebx
    fbc1:	83 ec 08             	sub    $0x8,%esp
    fbc4:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return pkt->overwrite;
    fbc7:	8a 58 3d             	mov    0x3d(%eax),%bl
    fbca:	83 e3 01             	and    $0x1,%ebx
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (net_pkt_is_being_overwritten(pkt)) {
    fbcd:	89 df                	mov    %ebx,%edi
    fbcf:	88 5d f3             	mov    %bl,-0xd(%ebp)
    fbd2:	83 f7 01             	xor    $0x1,%edi
    fbd5:	8b 58 18             	mov    0x18(%eax),%ebx
		write = false;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
    fbd8:	89 fa                	mov    %edi,%edx
    fbda:	20 ca                	and    %cl,%dl
    fbdc:	88 55 f2             	mov    %dl,-0xe(%ebp)
    fbdf:	74 06                	je     fbe7 <pkt_cursor_update+0x2c>
    fbe1:	0f b7 4b 0e          	movzwl 0xe(%ebx),%ecx
    fbe5:	eb 04                	jmp    fbeb <pkt_cursor_update+0x30>
    fbe7:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
	if (length + (cursor->pos - cursor->buf->data) == len &&
    fbeb:	8b 70 1c             	mov    0x1c(%eax),%esi
    fbee:	89 f7                	mov    %esi,%edi
    fbf0:	2b 7b 08             	sub    0x8(%ebx),%edi
    fbf3:	03 7d ec             	add    -0x14(%ebp),%edi
    fbf6:	39 cf                	cmp    %ecx,%edi
    fbf8:	75 1d                	jne    fc17 <pkt_cursor_update+0x5c>
    fbfa:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
    fbfe:	74 08                	je     fc08 <pkt_cursor_update+0x4d>
	    !(net_pkt_is_being_overwritten(pkt) && len < cursor->buf->size)) {
    fc00:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
    fc04:	39 cb                	cmp    %ecx,%ebx
    fc06:	77 0f                	ja     fc17 <pkt_cursor_update+0x5c>
		pkt_cursor_jump(pkt, write);
    fc08:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
	} else {
		cursor->pos += length;
	}
}
    fc0c:	59                   	pop    %ecx
    fc0d:	5b                   	pop    %ebx
    fc0e:	5b                   	pop    %ebx
    fc0f:	5e                   	pop    %esi
    fc10:	5f                   	pop    %edi
    fc11:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
    fc12:	e9 25 ff ff ff       	jmp    fb3c <pkt_cursor_jump>
		cursor->pos += length;
    fc17:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fc1a:	01 f2                	add    %esi,%edx
    fc1c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    fc1f:	58                   	pop    %eax
    fc20:	5a                   	pop    %edx
    fc21:	5b                   	pop    %ebx
    fc22:	5e                   	pop    %esi
    fc23:	5f                   	pop    %edi
    fc24:	5d                   	pop    %ebp
    fc25:	c3                   	ret    

0000fc26 <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
    fc26:	55                   	push   %ebp
    fc27:	89 e5                	mov    %esp,%ebp
    fc29:	57                   	push   %edi
    fc2a:	56                   	push   %esi
    fc2b:	89 d6                	mov    %edx,%esi
    fc2d:	53                   	push   %ebx
    fc2e:	89 c3                	mov    %eax,%ebx
    fc30:	83 ec 08             	sub    $0x8,%esp
    fc33:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    fc36:	8a 45 08             	mov    0x8(%ebp),%al
    fc39:	88 45 ee             	mov    %al,-0x12(%ebp)
    fc3c:	8a 45 0c             	mov    0xc(%ebp),%al
    fc3f:	88 45 ef             	mov    %al,-0x11(%ebp)
	/* We use such variable to avoid lengthy lines */
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (c_op->buf && length) {
    fc42:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
    fc46:	0f 84 c6 00 00 00    	je     fd12 <net_pkt_cursor_operate+0xec>
    fc4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fc50:	0f 84 c6 00 00 00    	je     fd1c <net_pkt_cursor_operate+0xf6>
    fc56:	8a 53 3d             	mov    0x3d(%ebx),%dl
		size_t d_len, len;

		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
    fc59:	89 d8                	mov    %ebx,%eax
    fc5b:	83 e2 01             	and    $0x1,%edx
				   false : write);
    fc5e:	83 f2 01             	xor    $0x1,%edx
    fc61:	22 55 ef             	and    -0x11(%ebp),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
    fc64:	0f b6 d2             	movzbl %dl,%edx
    fc67:	e8 1b ff ff ff       	call   fb87 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
    fc6c:	8b 43 18             	mov    0x18(%ebx),%eax
    fc6f:	85 c0                	test   %eax,%eax
    fc71:	75 0a                	jne    fc7d <net_pkt_cursor_operate+0x57>
		length -= len;
	}

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
    fc73:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
    fc78:	e9 a1 00 00 00       	jmp    fd1e <net_pkt_cursor_operate+0xf8>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
    fc7d:	8b 53 1c             	mov    0x1c(%ebx),%edx
    fc80:	89 d1                	mov    %edx,%ecx
    fc82:	2b 48 08             	sub    0x8(%eax),%ecx
    fc85:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    fc89:	74 0c                	je     fc97 <net_pkt_cursor_operate+0x71>
    fc8b:	f6 43 3d 01          	testb  $0x1,0x3d(%ebx)
    fc8f:	75 06                	jne    fc97 <net_pkt_cursor_operate+0x71>
			d_len = c_op->buf->size - (c_op->pos - c_op->buf->data);
    fc91:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
    fc95:	eb 04                	jmp    fc9b <net_pkt_cursor_operate+0x75>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
    fc97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    fc9b:	29 c8                	sub    %ecx,%eax
		if (!d_len) {
    fc9d:	85 c0                	test   %eax,%eax
    fc9f:	74 d2                	je     fc73 <net_pkt_cursor_operate+0x4d>
		if (length < d_len) {
    fca1:	8b 7d f0             	mov    -0x10(%ebp),%edi
    fca4:	39 c7                	cmp    %eax,%edi
    fca6:	76 02                	jbe    fcaa <net_pkt_cursor_operate+0x84>
    fca8:	89 c7                	mov    %eax,%edi
		if (copy) {
    fcaa:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
    fcae:	74 16                	je     fcc6 <net_pkt_cursor_operate+0xa0>
			memcpy(write ? c_op->pos : data,
    fcb0:	89 f0                	mov    %esi,%eax
    fcb2:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    fcb6:	74 04                	je     fcbc <net_pkt_cursor_operate+0x96>
    fcb8:	89 d0                	mov    %edx,%eax
    fcba:	89 f2                	mov    %esi,%edx
    fcbc:	57                   	push   %edi
    fcbd:	52                   	push   %edx
    fcbe:	50                   	push   %eax
    fcbf:	e8 6d ac ff ff       	call   a931 <memcpy>
    fcc4:	eb 0d                	jmp    fcd3 <net_pkt_cursor_operate+0xad>
		} else if (data) {
    fcc6:	85 f6                	test   %esi,%esi
    fcc8:	74 0c                	je     fcd6 <net_pkt_cursor_operate+0xb0>
			memset(c_op->pos, *(int *)data, len);
    fcca:	57                   	push   %edi
    fccb:	ff 36                	pushl  (%esi)
    fccd:	52                   	push   %edx
    fcce:	e8 cd ac ff ff       	call   a9a0 <memset>
    fcd3:	83 c4 0c             	add    $0xc,%esp
		if (write && !net_pkt_is_being_overwritten(pkt)) {
    fcd6:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
    fcda:	74 15                	je     fcf1 <net_pkt_cursor_operate+0xcb>
    fcdc:	f6 43 3d 01          	testb  $0x1,0x3d(%ebx)
    fce0:	75 0f                	jne    fcf1 <net_pkt_cursor_operate+0xcb>
			net_buf_add(c_op->buf, len);
    fce2:	8b 43 18             	mov    0x18(%ebx),%eax
    fce5:	57                   	push   %edi
    fce6:	83 c0 08             	add    $0x8,%eax
    fce9:	50                   	push   %eax
    fcea:	e8 0c bd ff ff       	call   b9fb <net_buf_simple_add>
    fcef:	58                   	pop    %eax
    fcf0:	5a                   	pop    %edx
		pkt_cursor_update(pkt, len, write);
    fcf1:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
    fcf5:	89 fa                	mov    %edi,%edx
    fcf7:	89 d8                	mov    %ebx,%eax
    fcf9:	e8 bd fe ff ff       	call   fbbb <pkt_cursor_update>
		if (copy && data) {
    fcfe:	85 f6                	test   %esi,%esi
    fd00:	74 08                	je     fd0a <net_pkt_cursor_operate+0xe4>
    fd02:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
    fd06:	74 02                	je     fd0a <net_pkt_cursor_operate+0xe4>
			data = (u8_t *) data + len;
    fd08:	01 fe                	add    %edi,%esi
		length -= len;
    fd0a:	29 7d f0             	sub    %edi,-0x10(%ebp)
    fd0d:	e9 30 ff ff ff       	jmp    fc42 <net_pkt_cursor_operate+0x1c>
	if (length) {
    fd12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fd16:	0f 85 57 ff ff ff    	jne    fc73 <net_pkt_cursor_operate+0x4d>
	}

	return 0;
    fd1c:	31 c0                	xor    %eax,%eax
}
    fd1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    fd21:	5b                   	pop    %ebx
    fd22:	5e                   	pop    %esi
    fd23:	5f                   	pop    %edi
    fd24:	5d                   	pop    %ebp
    fd25:	c3                   	ret    

0000fd26 <pkt_estimate_headers_length.part.20>:
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
    fd26:	66 83 f8 02          	cmp    $0x2,%ax
		hdr_len += NET_IPV6H_LEN;
    fd2a:	b9 28 00 00 00       	mov    $0x28,%ecx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
    fd2f:	74 0b                	je     fd3c <pkt_estimate_headers_length.part.20+0x16>
		hdr_len += NET_IPV4H_LEN;
    fd31:	31 c9                	xor    %ecx,%ecx
    fd33:	66 48                	dec    %ax
    fd35:	0f 95 c1             	setne  %cl
    fd38:	49                   	dec    %ecx
    fd39:	83 e1 14             	and    $0x14,%ecx
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    fd3c:	83 fa 11             	cmp    $0x11,%edx
    fd3f:	75 05                	jne    fd46 <pkt_estimate_headers_length.part.20+0x20>
		hdr_len += NET_UDPH_LEN;
    fd41:	83 c1 08             	add    $0x8,%ecx
    fd44:	eb 0d                	jmp    fd53 <pkt_estimate_headers_length.part.20+0x2d>
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
    fd46:	83 fa 01             	cmp    $0x1,%edx
    fd49:	74 05                	je     fd50 <pkt_estimate_headers_length.part.20+0x2a>
    fd4b:	83 fa 3a             	cmp    $0x3a,%edx
    fd4e:	75 03                	jne    fd53 <pkt_estimate_headers_length.part.20+0x2d>
		hdr_len += NET_ICMPH_LEN;
    fd50:	83 c1 04             	add    $0x4,%ecx
}
    fd53:	89 c8                	mov    %ecx,%eax
    fd55:	c3                   	ret    

0000fd56 <net_pkt_get_reserve_data>:
{
    fd56:	55                   	push   %ebp
    fd57:	89 e5                	mov    %esp,%ebp
    fd59:	56                   	push   %esi
    fd5a:	53                   	push   %ebx
    fd5b:	8b 75 0c             	mov    0xc(%ebp),%esi
    fd5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (k_is_in_isr()) {
    fd61:	e8 db 43 01 00       	call   24141 <k_is_in_isr>
    fd66:	84 c0                	test   %al,%al
    fd68:	74 09                	je     fd73 <net_pkt_get_reserve_data+0x1d>
		frag = net_buf_alloc(pool, K_NO_WAIT);
    fd6a:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
    fd71:	eb 03                	jmp    fd76 <net_pkt_get_reserve_data+0x20>
		frag = net_buf_alloc(pool, timeout);
    fd73:	89 75 0c             	mov    %esi,0xc(%ebp)
    fd76:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    fd79:	5b                   	pop    %ebx
    fd7a:	5e                   	pop    %esi
    fd7b:	5d                   	pop    %ebp
		frag = net_buf_alloc(pool, timeout);
    fd7c:	e9 b0 bb ff ff       	jmp    b931 <net_buf_alloc_fixed>

0000fd81 <net_pkt_get_reserve_rx_data>:
{
    fd81:	55                   	push   %ebp
    fd82:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&rx_bufs, timeout);
    fd84:	ff 75 08             	pushl  0x8(%ebp)
    fd87:	68 50 aa 40 00       	push   $0x40aa50
    fd8c:	e8 c5 ff ff ff       	call   fd56 <net_pkt_get_reserve_data>
    fd91:	5a                   	pop    %edx
    fd92:	59                   	pop    %ecx
}
    fd93:	c9                   	leave  
    fd94:	c3                   	ret    

0000fd95 <net_pkt_get_reserve_tx_data>:
{
    fd95:	55                   	push   %ebp
    fd96:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&tx_bufs, timeout);
    fd98:	ff 75 08             	pushl  0x8(%ebp)
    fd9b:	68 78 aa 40 00       	push   $0x40aa78
    fda0:	e8 b1 ff ff ff       	call   fd56 <net_pkt_get_reserve_data>
    fda5:	5a                   	pop    %edx
    fda6:	59                   	pop    %ecx
}
    fda7:	c9                   	leave  
    fda8:	c3                   	ret    

0000fda9 <net_pkt_get_frag>:
{
    fda9:	55                   	push   %ebp
    fdaa:	89 e5                	mov    %esp,%ebp
	if (pkt->slab == &rx_pkts) {
    fdac:	8b 55 08             	mov    0x8(%ebp),%edx
{
    fdaf:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (pkt->slab == &rx_pkts) {
    fdb2:	81 7a 10 48 a9 40 00 	cmpl   $0x40a948,0x10(%edx)
		return net_pkt_get_reserve_rx_data(timeout);
    fdb9:	89 45 08             	mov    %eax,0x8(%ebp)
	if (pkt->slab == &rx_pkts) {
    fdbc:	75 06                	jne    fdc4 <net_pkt_get_frag+0x1b>
}
    fdbe:	5d                   	pop    %ebp
		return net_pkt_get_reserve_rx_data(timeout);
    fdbf:	e9 bd ff ff ff       	jmp    fd81 <net_pkt_get_reserve_rx_data>
}
    fdc4:	5d                   	pop    %ebp
	return net_pkt_get_reserve_tx_data(timeout);
    fdc5:	e9 cb ff ff ff       	jmp    fd95 <net_pkt_get_reserve_tx_data>

0000fdca <net_pkt_ref>:
{
    fdca:	55                   	push   %ebp
    fdcb:	89 e5                	mov    %esp,%ebp
    fdcd:	53                   	push   %ebx
    fdce:	8b 55 08             	mov    0x8(%ebp),%edx
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
    fdd1:	8d 4a 28             	lea    0x28(%edx),%ecx
    fdd4:	85 d2                	test   %edx,%edx
    fdd6:	74 11                	je     fde9 <net_pkt_ref+0x1f>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    fdd8:	8b 01                	mov    (%ecx),%eax
		if (!ref) {
    fdda:	85 c0                	test   %eax,%eax
    fddc:	74 0b                	je     fde9 <net_pkt_ref+0x1f>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
    fdde:	8d 58 01             	lea    0x1(%eax),%ebx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    fde1:	f0 0f b1 19          	lock cmpxchg %ebx,(%ecx)
    fde5:	74 04                	je     fdeb <net_pkt_ref+0x21>
    fde7:	eb eb                	jmp    fdd4 <net_pkt_ref+0xa>
			return NULL;
    fde9:	31 d2                	xor    %edx,%edx
}
    fdeb:	5b                   	pop    %ebx
    fdec:	89 d0                	mov    %edx,%eax
    fdee:	5d                   	pop    %ebp
    fdef:	c3                   	ret    

0000fdf0 <net_pkt_frag_unref>:
{
    fdf0:	55                   	push   %ebp
    fdf1:	89 e5                	mov    %esp,%ebp
	if (!frag) {
    fdf3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    fdf7:	74 06                	je     fdff <net_pkt_frag_unref+0xf>
}
    fdf9:	5d                   	pop    %ebp
	net_buf_unref(frag);
    fdfa:	e9 4e bb ff ff       	jmp    b94d <net_buf_unref>
}
    fdff:	5d                   	pop    %ebp
    fe00:	c3                   	ret    

0000fe01 <net_pkt_unref>:
{
    fe01:	55                   	push   %ebp
    fe02:	89 e5                	mov    %esp,%ebp
    fe04:	53                   	push   %ebx
	if (!pkt) {
    fe05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    fe09:	74 3e                	je     fe49 <net_pkt_unref+0x48>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    fe0b:	8b 45 08             	mov    0x8(%ebp),%eax
    fe0e:	8b 50 28             	mov    0x28(%eax),%edx
		if (!ref) {
    fe11:	85 d2                	test   %edx,%edx
    fe13:	74 34                	je     fe49 <net_pkt_unref+0x48>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    fe15:	8b 4d 08             	mov    0x8(%ebp),%ecx
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
    fe18:	8d 5a ff             	lea    -0x1(%edx),%ebx
    fe1b:	89 d0                	mov    %edx,%eax
    fe1d:	f0 0f b1 59 28       	lock cmpxchg %ebx,0x28(%ecx)
    fe22:	75 e7                	jne    fe0b <net_pkt_unref+0xa>
	if (ref > 1) {
    fe24:	4a                   	dec    %edx
    fe25:	7f 22                	jg     fe49 <net_pkt_unref+0x48>
	if (pkt->frags) {
    fe27:	8b 45 08             	mov    0x8(%ebp),%eax
    fe2a:	8b 40 14             	mov    0x14(%eax),%eax
    fe2d:	85 c0                	test   %eax,%eax
    fe2f:	74 07                	je     fe38 <net_pkt_unref+0x37>
		net_pkt_frag_unref(pkt->frags);
    fe31:	50                   	push   %eax
    fe32:	e8 b9 ff ff ff       	call   fdf0 <net_pkt_frag_unref>
    fe37:	59                   	pop    %ecx
	k_mem_slab_free(pkt->slab, (void **)&pkt);
    fe38:	8d 45 08             	lea    0x8(%ebp),%eax
    fe3b:	50                   	push   %eax
    fe3c:	8b 45 08             	mov    0x8(%ebp),%eax
    fe3f:	ff 70 10             	pushl  0x10(%eax)
    fe42:	e8 ec 30 01 00       	call   22f33 <k_mem_slab_free>
    fe47:	58                   	pop    %eax
    fe48:	5a                   	pop    %edx
}
    fe49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fe4c:	c9                   	leave  
    fe4d:	c3                   	ret    

0000fe4e <net_pkt_frag_insert>:
{
    fe4e:	55                   	push   %ebp
    fe4f:	89 e5                	mov    %esp,%ebp
    fe51:	56                   	push   %esi
    fe52:	53                   	push   %ebx
    fe53:	8b 75 0c             	mov    0xc(%ebp),%esi
    fe56:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_buf_frag_last(frag)->frags = pkt->frags;
    fe59:	56                   	push   %esi
    fe5a:	e8 65 bb ff ff       	call   b9c4 <net_buf_frag_last>
    fe5f:	5a                   	pop    %edx
    fe60:	8b 53 14             	mov    0x14(%ebx),%edx
    fe63:	89 10                	mov    %edx,(%eax)
	pkt->frags = frag;
    fe65:	89 73 14             	mov    %esi,0x14(%ebx)
}
    fe68:	8d 65 f8             	lea    -0x8(%ebp),%esp
    fe6b:	5b                   	pop    %ebx
    fe6c:	5e                   	pop    %esi
    fe6d:	5d                   	pop    %ebp
    fe6e:	c3                   	ret    

0000fe6f <net_pkt_get_info>:
{
    fe6f:	55                   	push   %ebp
    fe70:	89 e5                	mov    %esp,%ebp
    fe72:	53                   	push   %ebx
    fe73:	8b 5d 08             	mov    0x8(%ebp),%ebx
    fe76:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    fe79:	8b 55 10             	mov    0x10(%ebp),%edx
    fe7c:	8b 45 14             	mov    0x14(%ebp),%eax
	if (rx) {
    fe7f:	85 db                	test   %ebx,%ebx
    fe81:	74 06                	je     fe89 <net_pkt_get_info+0x1a>
		*rx = &rx_pkts;
    fe83:	c7 03 48 a9 40 00    	movl   $0x40a948,(%ebx)
	if (tx) {
    fe89:	85 c9                	test   %ecx,%ecx
    fe8b:	74 06                	je     fe93 <net_pkt_get_info+0x24>
		*tx = &tx_pkts;
    fe8d:	c7 01 24 a9 40 00    	movl   $0x40a924,(%ecx)
	if (rx_data) {
    fe93:	85 d2                	test   %edx,%edx
    fe95:	74 06                	je     fe9d <net_pkt_get_info+0x2e>
		*rx_data = &rx_bufs;
    fe97:	c7 02 50 aa 40 00    	movl   $0x40aa50,(%edx)
	if (tx_data) {
    fe9d:	85 c0                	test   %eax,%eax
    fe9f:	74 06                	je     fea7 <net_pkt_get_info+0x38>
		*tx_data = &tx_bufs;
    fea1:	c7 00 78 aa 40 00    	movl   $0x40aa78,(%eax)
}
    fea7:	5b                   	pop    %ebx
    fea8:	5d                   	pop    %ebp
    fea9:	c3                   	ret    

0000feaa <net_pkt_available_buffer>:
{
    feaa:	55                   	push   %ebp
    feab:	31 c0                	xor    %eax,%eax
    fead:	89 e5                	mov    %esp,%ebp
    feaf:	53                   	push   %ebx
    feb0:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!pkt) {
    feb3:	85 d2                	test   %edx,%edx
    feb5:	74 1e                	je     fed5 <net_pkt_available_buffer+0x2b>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
    feb7:	8b 42 14             	mov    0x14(%edx),%eax
	size_t size = 0;
    feba:	31 db                	xor    %ebx,%ebx
	struct net_buf *buf = pkt->buffer;
    febc:	89 c2                	mov    %eax,%edx
	while (buf) {
    febe:	85 d2                	test   %edx,%edx
    fec0:	74 0a                	je     fecc <net_pkt_available_buffer+0x22>
		size += buf->size;
    fec2:	0f b7 4a 0e          	movzwl 0xe(%edx),%ecx
		buf = buf->frags;
    fec6:	8b 12                	mov    (%edx),%edx
		size += buf->size;
    fec8:	01 cb                	add    %ecx,%ebx
		buf = buf->frags;
    feca:	eb f2                	jmp    febe <net_pkt_available_buffer+0x14>
	return net_buf_frags_len(pkt->frags);
    fecc:	e8 58 fc ff ff       	call   fb29 <net_buf_frags_len>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
    fed1:	29 c3                	sub    %eax,%ebx
    fed3:	89 d8                	mov    %ebx,%eax
}
    fed5:	5b                   	pop    %ebx
    fed6:	5d                   	pop    %ebp
    fed7:	c3                   	ret    

0000fed8 <net_pkt_available_payload_buffer>:
{
    fed8:	55                   	push   %ebp
    fed9:	31 c0                	xor    %eax,%eax
    fedb:	89 e5                	mov    %esp,%ebp
    fedd:	57                   	push   %edi
    fede:	56                   	push   %esi
    fedf:	53                   	push   %ebx
    fee0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!pkt) {
    fee3:	85 db                	test   %ebx,%ebx
    fee5:	74 36                	je     ff1d <net_pkt_available_payload_buffer+0x45>
	return pkt->family;
    fee7:	8a 43 3f             	mov    0x3f(%ebx),%al
		return  0;
    feea:	be 00 00 00 00       	mov    $0x0,%esi
    feef:	d0 e8                	shr    %al
	if (family == AF_UNSPEC) {
    fef1:	24 07                	and    $0x7,%al
    fef3:	74 0d                	je     ff02 <net_pkt_available_payload_buffer+0x2a>
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
    fef5:	0f b6 c0             	movzbl %al,%eax
    fef8:	8b 55 0c             	mov    0xc(%ebp),%edx
    fefb:	e8 26 fe ff ff       	call   fd26 <pkt_estimate_headers_length.part.20>
    ff00:	89 c6                	mov    %eax,%esi
	return net_buf_frags_len(pkt->frags);
    ff02:	8b 43 14             	mov    0x14(%ebx),%eax
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
    ff05:	31 ff                	xor    %edi,%edi
    ff07:	e8 1d fc ff ff       	call   fb29 <net_buf_frags_len>
    ff0c:	39 f0                	cmp    %esi,%eax
    ff0e:	73 04                	jae    ff14 <net_pkt_available_payload_buffer+0x3c>
    ff10:	89 f7                	mov    %esi,%edi
    ff12:	29 c7                	sub    %eax,%edi
	len = net_pkt_available_buffer(pkt) - hdr_len;
    ff14:	53                   	push   %ebx
    ff15:	e8 90 ff ff ff       	call   feaa <net_pkt_available_buffer>
    ff1a:	5a                   	pop    %edx
    ff1b:	29 f8                	sub    %edi,%eax
}
    ff1d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ff20:	5b                   	pop    %ebx
    ff21:	5e                   	pop    %esi
    ff22:	5f                   	pop    %edi
    ff23:	5d                   	pop    %ebp
    ff24:	c3                   	ret    

0000ff25 <net_pkt_trim_buffer>:
{
    ff25:	55                   	push   %ebp
    ff26:	89 e5                	mov    %esp,%ebp
    ff28:	57                   	push   %edi
    ff29:	56                   	push   %esi
    ff2a:	8b 75 08             	mov    0x8(%ebp),%esi
    ff2d:	53                   	push   %ebx
	buf = pkt->buffer;
    ff2e:	8b 46 14             	mov    0x14(%esi),%eax
	prev = buf;
    ff31:	89 c3                	mov    %eax,%ebx
	while (buf) {
    ff33:	85 c0                	test   %eax,%eax
    ff35:	74 2e                	je     ff65 <net_pkt_trim_buffer+0x40>
		struct net_buf *next = buf->frags;
    ff37:	8b 38                	mov    (%eax),%edi
		if (!buf->len) {
    ff39:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
    ff3e:	75 1f                	jne    ff5f <net_pkt_trim_buffer+0x3a>
			if (buf == pkt->buffer) {
    ff40:	39 46 14             	cmp    %eax,0x14(%esi)
    ff43:	75 05                	jne    ff4a <net_pkt_trim_buffer+0x25>
				pkt->buffer = next;
    ff45:	89 7e 14             	mov    %edi,0x14(%esi)
    ff48:	eb 06                	jmp    ff50 <net_pkt_trim_buffer+0x2b>
			} else if (buf == prev->frags) {
    ff4a:	39 03                	cmp    %eax,(%ebx)
    ff4c:	75 02                	jne    ff50 <net_pkt_trim_buffer+0x2b>
				prev->frags = next;
    ff4e:	89 3b                	mov    %edi,(%ebx)
			buf->frags = NULL;
    ff50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			net_buf_unref(buf);
    ff56:	50                   	push   %eax
    ff57:	e8 f1 b9 ff ff       	call   b94d <net_buf_unref>
    ff5c:	58                   	pop    %eax
    ff5d:	89 d8                	mov    %ebx,%eax
    ff5f:	89 c3                	mov    %eax,%ebx
    ff61:	89 f8                	mov    %edi,%eax
    ff63:	eb ce                	jmp    ff33 <net_pkt_trim_buffer+0xe>
}
    ff65:	8d 65 f4             	lea    -0xc(%ebp),%esp
    ff68:	5b                   	pop    %ebx
    ff69:	5e                   	pop    %esi
    ff6a:	5f                   	pop    %edi
    ff6b:	5d                   	pop    %ebp
    ff6c:	c3                   	ret    

0000ff6d <net_pkt_cursor_init>:
{
    ff6d:	55                   	push   %ebp
    ff6e:	89 e5                	mov    %esp,%ebp
    ff70:	8b 55 08             	mov    0x8(%ebp),%edx
	pkt->cursor.buf = pkt->buffer;
    ff73:	8b 42 14             	mov    0x14(%edx),%eax
    ff76:	89 42 18             	mov    %eax,0x18(%edx)
	if (pkt->cursor.buf) {
    ff79:	85 c0                	test   %eax,%eax
    ff7b:	74 03                	je     ff80 <net_pkt_cursor_init+0x13>
		pkt->cursor.pos = pkt->cursor.buf->data;
    ff7d:	8b 40 08             	mov    0x8(%eax),%eax
    ff80:	89 42 1c             	mov    %eax,0x1c(%edx)
}
    ff83:	5d                   	pop    %ebp
    ff84:	c3                   	ret    

0000ff85 <pkt_alloc>:
{
    ff85:	55                   	push   %ebp
    ff86:	89 e5                	mov    %esp,%ebp
    ff88:	56                   	push   %esi
    ff89:	53                   	push   %ebx
    ff8a:	89 d6                	mov    %edx,%esi
    ff8c:	51                   	push   %ecx
    ff8d:	89 c3                	mov    %eax,%ebx
	if (k_is_in_isr()) {
    ff8f:	e8 ad 41 01 00       	call   24141 <k_is_in_isr>
    ff94:	84 c0                	test   %al,%al
    ff96:	74 02                	je     ff9a <pkt_alloc+0x15>
		timeout = K_NO_WAIT;
    ff98:	31 f6                	xor    %esi,%esi
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
    ff9a:	56                   	push   %esi
    ff9b:	8d 45 f4             	lea    -0xc(%ebp),%eax
    ff9e:	50                   	push   %eax
    ff9f:	53                   	push   %ebx
    ffa0:	e8 28 2f 01 00       	call   22ecd <k_mem_slab_alloc>
    ffa5:	83 c4 0c             	add    $0xc,%esp
		return NULL;
    ffa8:	31 d2                	xor    %edx,%edx
	if (ret) {
    ffaa:	85 c0                	test   %eax,%eax
    ffac:	75 2a                	jne    ffd8 <pkt_alloc+0x53>
	memset(pkt, 0, sizeof(struct net_pkt));
    ffae:	6a 48                	push   $0x48
    ffb0:	6a 00                	push   $0x0
    ffb2:	ff 75 f4             	pushl  -0xc(%ebp)
    ffb5:	e8 e6 a9 ff ff       	call   a9a0 <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
    ffba:	8b 45 f4             	mov    -0xc(%ebp),%eax
	memset(pkt, 0, sizeof(struct net_pkt));
    ffbd:	83 c4 0c             	add    $0xc,%esp
	pkt->atomic_ref = ATOMIC_INIT(1);
    ffc0:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
	pkt->slab = slab;
    ffc7:	89 58 10             	mov    %ebx,0x10(%eax)
	pkt->ipv6_next_hdr = next_hdr;
    ffca:	c6 40 47 ff          	movb   $0xff,0x47(%eax)
	net_pkt_cursor_init(pkt);
    ffce:	50                   	push   %eax
    ffcf:	e8 99 ff ff ff       	call   ff6d <net_pkt_cursor_init>
    ffd4:	58                   	pop    %eax
	return pkt;
    ffd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
    ffd8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    ffdb:	89 d0                	mov    %edx,%eax
    ffdd:	5b                   	pop    %ebx
    ffde:	5e                   	pop    %esi
    ffdf:	5d                   	pop    %ebp
    ffe0:	c3                   	ret    

0000ffe1 <pkt_alloc_on_iface>:
{
    ffe1:	55                   	push   %ebp
    ffe2:	89 e5                	mov    %esp,%ebp
    ffe4:	53                   	push   %ebx
    ffe5:	89 d3                	mov    %edx,%ebx
    ffe7:	89 ca                	mov    %ecx,%edx
	pkt = pkt_alloc(slab, timeout);
    ffe9:	e8 97 ff ff ff       	call   ff85 <pkt_alloc>
	if (pkt) {
    ffee:	85 c0                	test   %eax,%eax
    fff0:	74 17                	je     10009 <pkt_alloc_on_iface+0x28>
	pkt->iface = iface;
    fff2:	89 58 24             	mov    %ebx,0x24(%eax)
	if (iface) {
    fff5:	85 db                	test   %ebx,%ebx
    fff7:	74 10                	je     10009 <pkt_alloc_on_iface+0x28>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    fff9:	8b 13                	mov    (%ebx),%edx
    fffb:	8a 52 15             	mov    0x15(%edx),%dl
    fffe:	88 50 31             	mov    %dl,0x31(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   10001:	8b 13                	mov    (%ebx),%edx
   10003:	8a 52 15             	mov    0x15(%edx),%dl
   10006:	88 50 39             	mov    %dl,0x39(%eax)
}
   10009:	5b                   	pop    %ebx
   1000a:	5d                   	pop    %ebp
   1000b:	c3                   	ret    

0001000c <net_pkt_rx_alloc_on_iface>:
{
   1000c:	55                   	push   %ebp
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
   1000d:	b8 48 a9 40 00       	mov    $0x40a948,%eax
{
   10012:	89 e5                	mov    %esp,%ebp
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
   10014:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   10017:	8b 55 08             	mov    0x8(%ebp),%edx
}
   1001a:	5d                   	pop    %ebp
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
   1001b:	e9 c1 ff ff ff       	jmp    ffe1 <pkt_alloc_on_iface>

00010020 <net_pkt_append_buffer>:
{
   10020:	55                   	push   %ebp
   10021:	89 e5                	mov    %esp,%ebp
   10023:	53                   	push   %ebx
   10024:	8b 55 08             	mov    0x8(%ebp),%edx
   10027:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
   1002a:	8b 42 14             	mov    0x14(%edx),%eax
   1002d:	85 c0                	test   %eax,%eax
   1002f:	75 0c                	jne    1003d <net_pkt_append_buffer+0x1d>
		pkt->buffer = buffer;
   10031:	89 5a 14             	mov    %ebx,0x14(%edx)
}
   10034:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10037:	c9                   	leave  
		net_pkt_cursor_init(pkt);
   10038:	e9 30 ff ff ff       	jmp    ff6d <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   1003d:	50                   	push   %eax
   1003e:	e8 81 b9 ff ff       	call   b9c4 <net_buf_frag_last>
   10043:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
   10046:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   10049:	5a                   	pop    %edx
   1004a:	89 45 08             	mov    %eax,0x8(%ebp)
}
   1004d:	c9                   	leave  
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   1004e:	e9 83 b9 ff ff       	jmp    b9d6 <net_buf_frag_insert>

00010053 <net_pkt_alloc_buffer>:
{
   10053:	55                   	push   %ebp
   10054:	89 e5                	mov    %esp,%ebp
   10056:	57                   	push   %edi
   10057:	56                   	push   %esi
   10058:	53                   	push   %ebx
   10059:	83 ec 10             	sub    $0x10,%esp
   1005c:	8b 7d 14             	mov    0x14(%ebp),%edi
   1005f:	e8 8e 48 01 00       	call   248f2 <z_impl_k_uptime_get_32>
   10064:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
   10067:	8b 45 0c             	mov    0xc(%ebp),%eax
   1006a:	0b 45 10             	or     0x10(%ebp),%eax
   1006d:	75 0f                	jne    1007e <net_pkt_alloc_buffer+0x2b>
   1006f:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
   10072:	31 db                	xor    %ebx,%ebx
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
   10074:	f6 40 3f 0e          	testb  $0xe,0x3f(%eax)
   10078:	0f 84 a9 01 00 00    	je     10227 <net_pkt_alloc_buffer+0x1d4>
	if (k_is_in_isr()) {
   1007e:	e8 be 40 01 00       	call   24141 <k_is_in_isr>
   10083:	84 c0                	test   %al,%al
   10085:	74 02                	je     10089 <net_pkt_alloc_buffer+0x36>
		timeout = K_NO_WAIT;
   10087:	31 ff                	xor    %edi,%edi
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
   10089:	8b 45 08             	mov    0x8(%ebp),%eax
	size_t size = 0;
   1008c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
   10093:	8b 40 14             	mov    0x14(%eax),%eax
	struct net_buf *buf = pkt->buffer;
   10096:	89 c6                	mov    %eax,%esi
	while (buf) {
   10098:	85 f6                	test   %esi,%esi
   1009a:	74 0b                	je     100a7 <net_pkt_alloc_buffer+0x54>
		size += buf->size;
   1009c:	0f b7 56 0e          	movzwl 0xe(%esi),%edx
		buf = buf->frags;
   100a0:	8b 36                	mov    (%esi),%esi
		size += buf->size;
   100a2:	01 55 f0             	add    %edx,-0x10(%ebp)
   100a5:	eb f1                	jmp    10098 <net_pkt_alloc_buffer+0x45>
	return net_buf_frags_len(pkt->frags);
   100a7:	e8 7d fa ff ff       	call   fb29 <net_buf_frags_len>
	if (!alloc_len) {
   100ac:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   100af:	89 45 ec             	mov    %eax,-0x14(%ebp)
   100b2:	8b 45 08             	mov    0x8(%ebp),%eax
   100b5:	8a 40 3f             	mov    0x3f(%eax),%al
   100b8:	88 c2                	mov    %al,%dl
   100ba:	d0 ea                	shr    %dl
   100bc:	83 e2 07             	and    $0x7,%edx
   100bf:	0f b6 c2             	movzbl %dl,%eax
   100c2:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	size_t hdr_len = 0;
   100c6:	31 c0                	xor    %eax,%eax
	if (!alloc_len) {
   100c8:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
   100cb:	75 11                	jne    100de <net_pkt_alloc_buffer+0x8b>
	size_t hdr_len = 0;
   100cd:	89 f0                	mov    %esi,%eax
	if (family == AF_UNSPEC) {
   100cf:	84 d2                	test   %dl,%dl
   100d1:	74 0b                	je     100de <net_pkt_alloc_buffer+0x8b>
		hdr_len = pkt_estimate_headers_length(pkt,
   100d3:	0f b6 c2             	movzbl %dl,%eax
   100d6:	8b 55 10             	mov    0x10(%ebp),%edx
   100d9:	e8 48 fc ff ff       	call   fd26 <pkt_estimate_headers_length.part.20>
	if (net_pkt_iface(pkt)) {
   100de:	8b 4d 08             	mov    0x8(%ebp),%ecx
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
   100e1:	03 45 0c             	add    0xc(%ebp),%eax
	if (net_pkt_iface(pkt)) {
   100e4:	8b 51 24             	mov    0x24(%ecx),%edx
		max_len = 0;
   100e7:	31 c9                	xor    %ecx,%ecx
	if (net_pkt_iface(pkt)) {
   100e9:	85 d2                	test   %edx,%edx
   100eb:	74 06                	je     100f3 <net_pkt_alloc_buffer+0xa0>
	return iface->if_dev->mtu;
   100ed:	8b 0a                	mov    (%edx),%ecx
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
   100ef:	0f b7 49 18          	movzwl 0x18(%ecx),%ecx
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
   100f3:	66 83 7d e8 02       	cmpw   $0x2,-0x18(%ebp)
   100f8:	75 11                	jne    1010b <net_pkt_alloc_buffer+0xb8>
		max_len = MAX(max_len, NET_IPV6_MTU);
   100fa:	89 ca                	mov    %ecx,%edx
   100fc:	81 f9 00 05 00 00    	cmp    $0x500,%ecx
   10102:	73 2f                	jae    10133 <net_pkt_alloc_buffer+0xe0>
   10104:	ba 00 05 00 00       	mov    $0x500,%edx
   10109:	eb 28                	jmp    10133 <net_pkt_alloc_buffer+0xe0>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1010b:	66 83 7d e8 01       	cmpw   $0x1,-0x18(%ebp)
   10110:	75 11                	jne    10123 <net_pkt_alloc_buffer+0xd0>
		max_len = MAX(max_len, NET_IPV4_MTU);
   10112:	89 ca                	mov    %ecx,%edx
   10114:	81 f9 40 02 00 00    	cmp    $0x240,%ecx
   1011a:	73 17                	jae    10133 <net_pkt_alloc_buffer+0xe0>
   1011c:	ba 40 02 00 00       	mov    $0x240,%edx
   10121:	eb 10                	jmp    10133 <net_pkt_alloc_buffer+0xe0>
	return iface->if_dev->l2;
   10123:	8b 1a                	mov    (%edx),%ebx
			max_len = size;
   10125:	89 c2                	mov    %eax,%edx
		if (net_if_l2(net_pkt_iface(pkt)) ==
   10127:	81 7b 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%ebx)
   1012e:	75 03                	jne    10133 <net_pkt_alloc_buffer+0xe0>
			max_len += sizeof(struct net_eth_hdr);
   10130:	8d 51 0e             	lea    0xe(%ecx),%edx
	max_len -= existing;
   10133:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10136:	2b 5d f0             	sub    -0x10(%ebp),%ebx
	return MIN(size, max_len);
   10139:	01 d3                	add    %edx,%ebx
   1013b:	39 c3                	cmp    %eax,%ebx
   1013d:	76 02                	jbe    10141 <net_pkt_alloc_buffer+0xee>
   1013f:	89 c3                	mov    %eax,%ebx
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
   10141:	8b 45 08             	mov    0x8(%ebp),%eax
   10144:	c7 45 f0 78 aa 40 00 	movl   $0x40aa78,-0x10(%ebp)
   1014b:	81 78 10 24 a9 40 00 	cmpl   $0x40a924,0x10(%eax)
   10152:	74 07                	je     1015b <net_pkt_alloc_buffer+0x108>
   10154:	c7 45 f0 50 aa 40 00 	movl   $0x40aa50,-0x10(%ebp)
	if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   1015b:	8d 47 01             	lea    0x1(%edi),%eax
   1015e:	83 f8 01             	cmp    $0x1,%eax
   10161:	76 10                	jbe    10173 <net_pkt_alloc_buffer+0x120>
   10163:	e8 8a 47 01 00       	call   248f2 <z_impl_k_uptime_get_32>
		timeout -= MIN(timeout, diff);
   10168:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1016b:	39 f8                	cmp    %edi,%eax
   1016d:	76 02                	jbe    10171 <net_pkt_alloc_buffer+0x11e>
   1016f:	89 f8                	mov    %edi,%eax
   10171:	29 c7                	sub    %eax,%edi
   10173:	e8 7a 47 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	struct net_buf *current = NULL;
   10178:	31 c9                	xor    %ecx,%ecx
   1017a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (size) {
   1017d:	85 db                	test   %ebx,%ebx
   1017f:	74 64                	je     101e5 <net_pkt_alloc_buffer+0x192>
		new = net_buf_alloc_fixed(pool, timeout);
   10181:	57                   	push   %edi
   10182:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   10185:	ff 75 f0             	pushl  -0x10(%ebp)
   10188:	e8 a4 b7 ff ff       	call   b931 <net_buf_alloc_fixed>
   1018d:	5a                   	pop    %edx
		if (!new) {
   1018e:	85 c0                	test   %eax,%eax
		new = net_buf_alloc_fixed(pool, timeout);
   10190:	59                   	pop    %ecx
   10191:	89 c2                	mov    %eax,%edx
		if (!new) {
   10193:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   10196:	75 0d                	jne    101a5 <net_pkt_alloc_buffer+0x152>
	if (first) {
   10198:	85 f6                	test   %esi,%esi
   1019a:	74 4d                	je     101e9 <net_pkt_alloc_buffer+0x196>
		net_buf_unref(first);
   1019c:	56                   	push   %esi
   1019d:	e8 ab b7 ff ff       	call   b94d <net_buf_unref>
   101a2:	5f                   	pop    %edi
	if (!buf) {
   101a3:	eb 44                	jmp    101e9 <net_pkt_alloc_buffer+0x196>
		if (!first && !current) {
   101a5:	89 f0                	mov    %esi,%eax
   101a7:	09 c8                	or     %ecx,%eax
   101a9:	74 04                	je     101af <net_pkt_alloc_buffer+0x15c>
			current->frags = new;
   101ab:	89 11                	mov    %edx,(%ecx)
   101ad:	eb 02                	jmp    101b1 <net_pkt_alloc_buffer+0x15e>
		if (!first && !current) {
   101af:	89 d6                	mov    %edx,%esi
		if (current->size > size) {
   101b1:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
   101b5:	39 d8                	cmp    %ebx,%eax
   101b7:	76 04                	jbe    101bd <net_pkt_alloc_buffer+0x16a>
			current->size = size;
   101b9:	66 89 5a 0e          	mov    %bx,0xe(%edx)
		size -= current->size;
   101bd:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
   101c1:	29 c3                	sub    %eax,%ebx
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   101c3:	8d 47 01             	lea    0x1(%edi),%eax
   101c6:	83 f8 01             	cmp    $0x1,%eax
   101c9:	76 16                	jbe    101e1 <net_pkt_alloc_buffer+0x18e>
   101cb:	89 55 e8             	mov    %edx,-0x18(%ebp)
   101ce:	e8 1f 47 01 00       	call   248f2 <z_impl_k_uptime_get_32>
			timeout -= MIN(timeout, diff);
   101d3:	2b 45 ec             	sub    -0x14(%ebp),%eax
   101d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
   101d9:	39 f8                	cmp    %edi,%eax
   101db:	76 02                	jbe    101df <net_pkt_alloc_buffer+0x18c>
   101dd:	89 f8                	mov    %edi,%eax
   101df:	29 c7                	sub    %eax,%edi
		if (!first && !current) {
   101e1:	89 d1                	mov    %edx,%ecx
   101e3:	eb 98                	jmp    1017d <net_pkt_alloc_buffer+0x12a>
	if (!buf) {
   101e5:	85 f6                	test   %esi,%esi
   101e7:	75 31                	jne    1021a <net_pkt_alloc_buffer+0x1c7>
		return -ENOMEM;
   101e9:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
		NET_ERR("Data buffer allocation failed.");
   101ee:	f6 05 d4 a8 40 00 07 	testb  $0x7,0x40a8d4
   101f5:	74 30                	je     10227 <net_pkt_alloc_buffer+0x1d4>
   101f7:	ba 2c 52 02 00       	mov    $0x2522c,%edx
   101fc:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   10202:	c1 ea 03             	shr    $0x3,%edx
   10205:	c1 e2 06             	shl    $0x6,%edx
   10208:	83 ca 01             	or     $0x1,%edx
   1020b:	52                   	push   %edx
   1020c:	68 47 7b 02 00       	push   $0x27b47
   10211:	e8 74 32 ff ff       	call   348a <log_0>
   10216:	59                   	pop    %ecx
   10217:	5e                   	pop    %esi
   10218:	eb 0d                	jmp    10227 <net_pkt_alloc_buffer+0x1d4>
	net_pkt_append_buffer(pkt, buf);
   1021a:	56                   	push   %esi
	return 0;
   1021b:	31 db                	xor    %ebx,%ebx
	net_pkt_append_buffer(pkt, buf);
   1021d:	ff 75 08             	pushl  0x8(%ebp)
   10220:	e8 fb fd ff ff       	call   10020 <net_pkt_append_buffer>
   10225:	58                   	pop    %eax
   10226:	5a                   	pop    %edx
}
   10227:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1022a:	89 d8                	mov    %ebx,%eax
   1022c:	5b                   	pop    %ebx
   1022d:	5e                   	pop    %esi
   1022e:	5f                   	pop    %edi
   1022f:	5d                   	pop    %ebp
   10230:	c3                   	ret    

00010231 <pkt_alloc_with_buffer>:
{
   10231:	55                   	push   %ebp
   10232:	89 e5                	mov    %esp,%ebp
   10234:	57                   	push   %edi
   10235:	56                   	push   %esi
   10236:	89 c7                	mov    %eax,%edi
   10238:	53                   	push   %ebx
   10239:	89 ce                	mov    %ecx,%esi
   1023b:	83 ec 0c             	sub    $0xc,%esp
   1023e:	89 55 e8             	mov    %edx,-0x18(%ebp)
   10241:	8b 45 08             	mov    0x8(%ebp),%eax
   10244:	8b 5d 10             	mov    0x10(%ebp),%ebx
   10247:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1024a:	e8 a3 46 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
   1024f:	89 d9                	mov    %ebx,%ecx
   10251:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10254:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10257:	89 f8                	mov    %edi,%eax
   10259:	e8 83 fd ff ff       	call   ffe1 <pkt_alloc_on_iface>
   1025e:	89 c7                	mov    %eax,%edi
	if (!pkt) {
   10260:	85 c0                	test   %eax,%eax
   10262:	74 47                	je     102ab <pkt_alloc_with_buffer+0x7a>
	pkt->family = family;
   10264:	8a 45 ec             	mov    -0x14(%ebp),%al
   10267:	83 e0 07             	and    $0x7,%eax
   1026a:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1026d:	8a 47 3f             	mov    0x3f(%edi),%al
   10270:	83 e0 f1             	and    $0xfffffff1,%eax
   10273:	09 d0                	or     %edx,%eax
   10275:	88 47 3f             	mov    %al,0x3f(%edi)
	if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   10278:	8d 43 01             	lea    0x1(%ebx),%eax
   1027b:	83 f8 01             	cmp    $0x1,%eax
   1027e:	76 10                	jbe    10290 <pkt_alloc_with_buffer+0x5f>
   10280:	e8 6d 46 01 00       	call   248f2 <z_impl_k_uptime_get_32>
		timeout -= MIN(timeout, diff);
   10285:	2b 45 f0             	sub    -0x10(%ebp),%eax
   10288:	39 d8                	cmp    %ebx,%eax
   1028a:	76 02                	jbe    1028e <pkt_alloc_with_buffer+0x5d>
   1028c:	89 d8                	mov    %ebx,%eax
   1028e:	29 c3                	sub    %eax,%ebx
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
   10290:	53                   	push   %ebx
   10291:	ff 75 0c             	pushl  0xc(%ebp)
   10294:	56                   	push   %esi
   10295:	57                   	push   %edi
   10296:	e8 b8 fd ff ff       	call   10053 <net_pkt_alloc_buffer>
   1029b:	83 c4 10             	add    $0x10,%esp
	if (ret) {
   1029e:	85 c0                	test   %eax,%eax
   102a0:	74 09                	je     102ab <pkt_alloc_with_buffer+0x7a>
		net_pkt_unref(pkt);
   102a2:	57                   	push   %edi
		return NULL;
   102a3:	31 ff                	xor    %edi,%edi
		net_pkt_unref(pkt);
   102a5:	e8 57 fb ff ff       	call   fe01 <net_pkt_unref>
   102aa:	58                   	pop    %eax
}
   102ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
   102ae:	89 f8                	mov    %edi,%eax
   102b0:	5b                   	pop    %ebx
   102b1:	5e                   	pop    %esi
   102b2:	5f                   	pop    %edi
   102b3:	5d                   	pop    %ebp
   102b4:	c3                   	ret    

000102b5 <net_pkt_alloc_with_buffer>:
{
   102b5:	55                   	push   %ebp
   102b6:	89 e5                	mov    %esp,%ebp
   102b8:	53                   	push   %ebx
   102b9:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
   102bc:	8b 5d 18             	mov    0x18(%ebp),%ebx
   102bf:	89 5d 10             	mov    %ebx,0x10(%ebp)
   102c2:	8b 5d 14             	mov    0x14(%ebp),%ebx
   102c5:	0f b7 c0             	movzwl %ax,%eax
{
   102c8:	8b 55 08             	mov    0x8(%ebp),%edx
   102cb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
   102ce:	89 45 08             	mov    %eax,0x8(%ebp)
   102d1:	89 5d 0c             	mov    %ebx,0xc(%ebp)
   102d4:	b8 24 a9 40 00       	mov    $0x40a924,%eax
}
   102d9:	5b                   	pop    %ebx
   102da:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
   102db:	e9 51 ff ff ff       	jmp    10231 <pkt_alloc_with_buffer>

000102e0 <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
   102e0:	55                   	push   %ebp
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   102e1:	31 d2                	xor    %edx,%edx
{
   102e3:	89 e5                	mov    %esp,%ebp
   102e5:	8b 45 08             	mov    0x8(%ebp),%eax
   102e8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   102eb:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
   102f2:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
   102f9:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   102fa:	e9 27 f9 ff ff       	jmp    fc26 <net_pkt_cursor_operate>

000102ff <net_pkt_memset>:

int net_pkt_memset(struct net_pkt *pkt, int byte, size_t amount)
{
   102ff:	55                   	push   %ebp
   10300:	89 e5                	mov    %esp,%ebp
	NET_DBG("pkt %p byte %d amount %zu", pkt, byte, amount);

	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
   10302:	6a 01                	push   $0x1
   10304:	6a 00                	push   $0x0
   10306:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10309:	8d 55 0c             	lea    0xc(%ebp),%edx
   1030c:	8b 45 08             	mov    0x8(%ebp),%eax
   1030f:	e8 12 f9 ff ff       	call   fc26 <net_pkt_cursor_operate>
   10314:	5a                   	pop    %edx
   10315:	59                   	pop    %ecx
}
   10316:	c9                   	leave  
   10317:	c3                   	ret    

00010318 <net_pkt_read>:

int net_pkt_read(struct net_pkt *pkt, void *data, size_t length)
{
   10318:	55                   	push   %ebp
   10319:	89 e5                	mov    %esp,%ebp
   1031b:	8b 45 08             	mov    0x8(%ebp),%eax
   1031e:	8b 55 0c             	mov    0xc(%ebp),%edx
	NET_DBG("pkt %p data %p length %zu", pkt, data, length);

	return net_pkt_cursor_operate(pkt, data, length, true, false);
   10321:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10324:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
   1032b:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
   10332:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, data, length, true, false);
   10333:	e9 ee f8 ff ff       	jmp    fc26 <net_pkt_cursor_operate>

00010338 <net_pkt_read_be32>:

	return ret;
}

int net_pkt_read_be32(struct net_pkt *pkt, u32_t *data)
{
   10338:	55                   	push   %ebp
   10339:	89 e5                	mov    %esp,%ebp
   1033b:	50                   	push   %eax
	u8_t d32[4];
	int ret;

	ret = net_pkt_read(pkt, d32, sizeof(u32_t));
   1033c:	6a 04                	push   $0x4
   1033e:	8d 45 fc             	lea    -0x4(%ebp),%eax
   10341:	50                   	push   %eax
   10342:	ff 75 08             	pushl  0x8(%ebp)
   10345:	e8 ce ff ff ff       	call   10318 <net_pkt_read>
   1034a:	8b 55 fc             	mov    -0x4(%ebp),%edx

	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
   1034d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ret = net_pkt_read(pkt, d32, sizeof(u32_t));
   10350:	83 c4 0c             	add    $0xc,%esp
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
   10353:	0f ca                	bswap  %edx
   10355:	89 11                	mov    %edx,(%ecx)

	return ret;
}
   10357:	c9                   	leave  
   10358:	c3                   	ret    

00010359 <net_pkt_copy>:
}

int net_pkt_copy(struct net_pkt *pkt_dst,
		 struct net_pkt *pkt_src,
		 size_t length)
{
   10359:	55                   	push   %ebp
   1035a:	89 e5                	mov    %esp,%ebp
   1035c:	57                   	push   %edi
   1035d:	56                   	push   %esi
   1035e:	53                   	push   %ebx
   1035f:	83 ec 08             	sub    $0x8,%esp
   10362:	8b 75 08             	mov    0x8(%ebp),%esi
	struct net_pkt_cursor *c_dst = &pkt_dst->cursor;
	struct net_pkt_cursor *c_src = &pkt_src->cursor;

	while (c_dst->buf && c_src->buf && length) {
   10365:	83 7e 18 00          	cmpl   $0x0,0x18(%esi)
   10369:	0f 84 c9 00 00 00    	je     10438 <net_pkt_copy+0xdf>
   1036f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10372:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   10376:	0f 84 bc 00 00 00    	je     10438 <net_pkt_copy+0xdf>
   1037c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10380:	0f 84 ae 00 00 00    	je     10434 <net_pkt_copy+0xdb>
		size_t s_len, d_len, len;

		pkt_cursor_advance(pkt_dst, true);
   10386:	ba 01 00 00 00       	mov    $0x1,%edx
   1038b:	89 f0                	mov    %esi,%eax
   1038d:	e8 f5 f7 ff ff       	call   fb87 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
   10392:	31 d2                	xor    %edx,%edx
   10394:	8b 45 0c             	mov    0xc(%ebp),%eax
   10397:	e8 eb f7 ff ff       	call   fb87 <pkt_cursor_advance>

		if (!c_dst->buf || !c_src->buf) {
   1039c:	8b 7e 18             	mov    0x18(%esi),%edi
   1039f:	85 ff                	test   %edi,%edi
   103a1:	0f 84 99 00 00 00    	je     10440 <net_pkt_copy+0xe7>
   103a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   103aa:	8b 40 18             	mov    0x18(%eax),%eax
   103ad:	85 c0                	test   %eax,%eax
   103af:	0f 84 8b 00 00 00    	je     10440 <net_pkt_copy+0xe7>
			break;
		}

		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   103b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   103b8:	8b 56 1c             	mov    0x1c(%esi),%edx
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   103bb:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
   103bf:	8b 49 1c             	mov    0x1c(%ecx),%ecx
   103c2:	89 5d f0             	mov    %ebx,-0x10(%ebp)
   103c5:	89 cb                	mov    %ecx,%ebx
   103c7:	2b 58 08             	sub    0x8(%eax),%ebx
   103ca:	89 5d ec             	mov    %ebx,-0x14(%ebp)
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   103cd:	89 d3                	mov    %edx,%ebx
   103cf:	2b 5f 08             	sub    0x8(%edi),%ebx
   103d2:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
   103d6:	29 d8                	sub    %ebx,%eax
   103d8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   103db:	2b 5d ec             	sub    -0x14(%ebp),%ebx
   103de:	39 c3                	cmp    %eax,%ebx
   103e0:	76 02                	jbe    103e4 <net_pkt_copy+0x8b>
   103e2:	89 c3                	mov    %eax,%ebx
		if (length < s_len && length < d_len) {
   103e4:	39 5d 10             	cmp    %ebx,0x10(%ebp)
   103e7:	72 06                	jb     103ef <net_pkt_copy+0x96>
			} else {
				len = s_len;
			}
		}

		if (!len) {
   103e9:	85 db                	test   %ebx,%ebx
   103eb:	75 05                	jne    103f2 <net_pkt_copy+0x99>
   103ed:	eb 51                	jmp    10440 <net_pkt_copy+0xe7>
   103ef:	8b 5d 10             	mov    0x10(%ebp),%ebx
			break;
		}

		memcpy(c_dst->pos, c_src->pos, len);
   103f2:	53                   	push   %ebx
   103f3:	51                   	push   %ecx
   103f4:	52                   	push   %edx
   103f5:	e8 37 a5 ff ff       	call   a931 <memcpy>
   103fa:	83 c4 0c             	add    $0xc,%esp

		if (!net_pkt_is_being_overwritten(pkt_dst)) {
   103fd:	f6 46 3d 01          	testb  $0x1,0x3d(%esi)
   10401:	75 0f                	jne    10412 <net_pkt_copy+0xb9>
			net_buf_add(c_dst->buf, len);
   10403:	8b 46 18             	mov    0x18(%esi),%eax
   10406:	53                   	push   %ebx
   10407:	83 c0 08             	add    $0x8,%eax
   1040a:	50                   	push   %eax
   1040b:	e8 eb b5 ff ff       	call   b9fb <net_buf_simple_add>
   10410:	58                   	pop    %eax
   10411:	5a                   	pop    %edx
		}

		pkt_cursor_update(pkt_dst, len, true);
   10412:	b9 01 00 00 00       	mov    $0x1,%ecx
   10417:	89 da                	mov    %ebx,%edx
   10419:	89 f0                	mov    %esi,%eax
   1041b:	e8 9b f7 ff ff       	call   fbbb <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
   10420:	31 c9                	xor    %ecx,%ecx
   10422:	89 da                	mov    %ebx,%edx
   10424:	8b 45 0c             	mov    0xc(%ebp),%eax
   10427:	e8 8f f7 ff ff       	call   fbbb <pkt_cursor_update>

		length -= len;
   1042c:	29 5d 10             	sub    %ebx,0x10(%ebp)
   1042f:	e9 31 ff ff ff       	jmp    10365 <net_pkt_copy+0xc>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
   10434:	31 c0                	xor    %eax,%eax
   10436:	eb 0d                	jmp    10445 <net_pkt_copy+0xec>
   10438:	31 c0                	xor    %eax,%eax
	if (length) {
   1043a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1043e:	74 05                	je     10445 <net_pkt_copy+0xec>
		return -ENOBUFS;
   10440:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
}
   10445:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10448:	5b                   	pop    %ebx
   10449:	5e                   	pop    %esi
   1044a:	5f                   	pop    %edi
   1044b:	5d                   	pop    %ebp
   1044c:	c3                   	ret    

0001044d <net_pkt_remaining_data>:

	return clone_pkt;
}

size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
   1044d:	55                   	push   %ebp
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
   1044e:	31 c0                	xor    %eax,%eax
{
   10450:	89 e5                	mov    %esp,%ebp
   10452:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
   10455:	85 c9                	test   %ecx,%ecx
   10457:	74 25                	je     1047e <net_pkt_remaining_data+0x31>
   10459:	8b 51 18             	mov    0x18(%ecx),%edx
   1045c:	85 d2                	test   %edx,%edx
   1045e:	74 1e                	je     1047e <net_pkt_remaining_data+0x31>
   10460:	8b 49 1c             	mov    0x1c(%ecx),%ecx
   10463:	85 c9                	test   %ecx,%ecx
   10465:	74 17                	je     1047e <net_pkt_remaining_data+0x31>
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
   10467:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
   1046b:	2b 4a 08             	sub    0x8(%edx),%ecx
   1046e:	29 c8                	sub    %ecx,%eax

	buf = buf->frags;
	while (buf) {
		data_length += buf->len;
		buf = buf->frags;
   10470:	8b 12                	mov    (%edx),%edx
	while (buf) {
   10472:	85 d2                	test   %edx,%edx
   10474:	74 08                	je     1047e <net_pkt_remaining_data+0x31>
		data_length += buf->len;
   10476:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
   1047a:	01 c8                	add    %ecx,%eax
   1047c:	eb f2                	jmp    10470 <net_pkt_remaining_data+0x23>
	}

	return data_length;
}
   1047e:	5d                   	pop    %ebp
   1047f:	c3                   	ret    

00010480 <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
   10480:	55                   	push   %ebp
   10481:	89 e5                	mov    %esp,%ebp
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
   10483:	8b 55 08             	mov    0x8(%ebp),%edx
{
   10486:	8b 45 0c             	mov    0xc(%ebp),%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
   10489:	8b 52 14             	mov    0x14(%edx),%edx
   1048c:	85 d2                	test   %edx,%edx
   1048e:	74 16                	je     104a6 <net_pkt_update_length+0x26>
		if (buf->len < length) {
   10490:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
   10494:	39 c1                	cmp    %eax,%ecx
   10496:	73 04                	jae    1049c <net_pkt_update_length+0x1c>
			length -= buf->len;
   10498:	29 c8                	sub    %ecx,%eax
   1049a:	eb 06                	jmp    104a2 <net_pkt_update_length+0x22>
		} else {
			buf->len = length;
   1049c:	66 89 42 0c          	mov    %ax,0xc(%edx)
			length = 0;
   104a0:	31 c0                	xor    %eax,%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
   104a2:	8b 12                	mov    (%edx),%edx
   104a4:	eb e6                	jmp    1048c <net_pkt_update_length+0xc>
		}
	}

	return !length ? 0 : -EINVAL;
   104a6:	83 f8 01             	cmp    $0x1,%eax
}
   104a9:	5d                   	pop    %ebp
	return !length ? 0 : -EINVAL;
   104aa:	19 c0                	sbb    %eax,%eax
   104ac:	f7 d0                	not    %eax
   104ae:	83 e0 ea             	and    $0xffffffea,%eax
}
   104b1:	c3                   	ret    

000104b2 <net_pkt_get_current_offset>:

	return 0;
}

u16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
   104b2:	55                   	push   %ebp
	struct net_buf *buf = pkt->buffer;
	u16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
   104b3:	31 c0                	xor    %eax,%eax
{
   104b5:	89 e5                	mov    %esp,%ebp
   104b7:	53                   	push   %ebx
   104b8:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
   104bb:	8b 5a 18             	mov    0x18(%edx),%ebx
   104be:	85 db                	test   %ebx,%ebx
   104c0:	74 1d                	je     104df <net_pkt_get_current_offset+0x2d>
   104c2:	8b 4a 1c             	mov    0x1c(%edx),%ecx
   104c5:	85 c9                	test   %ecx,%ecx
   104c7:	74 16                	je     104df <net_pkt_get_current_offset+0x2d>
	struct net_buf *buf = pkt->buffer;
   104c9:	8b 42 14             	mov    0x14(%edx),%eax
	}

	offset = 0;
   104cc:	31 d2                	xor    %edx,%edx

	while (buf != pkt->cursor.buf) {
   104ce:	39 c3                	cmp    %eax,%ebx
   104d0:	74 07                	je     104d9 <net_pkt_get_current_offset+0x27>
		offset += buf->len;
   104d2:	03 50 0c             	add    0xc(%eax),%edx
		buf = buf->frags;
   104d5:	8b 00                	mov    (%eax),%eax
   104d7:	eb f5                	jmp    104ce <net_pkt_get_current_offset+0x1c>
	}

	offset += pkt->cursor.pos - buf->data;
   104d9:	2b 4b 08             	sub    0x8(%ebx),%ecx
   104dc:	8d 04 0a             	lea    (%edx,%ecx,1),%eax

	return offset;
}
   104df:	5b                   	pop    %ebx
   104e0:	5d                   	pop    %ebp
   104e1:	c3                   	ret    

000104e2 <net_pkt_is_contiguous>:

bool net_pkt_is_contiguous(struct net_pkt *pkt, size_t size)
{
   104e2:	55                   	push   %ebp
		if (len >= size) {
			return true;
		}
	}

	return false;
   104e3:	31 c0                	xor    %eax,%eax
{
   104e5:	89 e5                	mov    %esp,%ebp
   104e7:	53                   	push   %ebx
   104e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pkt->cursor.buf && pkt->cursor.pos) {
   104eb:	8b 4b 18             	mov    0x18(%ebx),%ecx
   104ee:	85 c9                	test   %ecx,%ecx
   104f0:	74 22                	je     10514 <net_pkt_is_contiguous+0x32>
   104f2:	8b 53 1c             	mov    0x1c(%ebx),%edx
   104f5:	85 d2                	test   %edx,%edx
   104f7:	74 1b                	je     10514 <net_pkt_is_contiguous+0x32>
			pkt->cursor.buf->len : pkt->cursor.buf->size;
   104f9:	f6 43 3d 01          	testb  $0x1,0x3d(%ebx)
   104fd:	74 06                	je     10505 <net_pkt_is_contiguous+0x23>
   104ff:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
   10503:	eb 04                	jmp    10509 <net_pkt_is_contiguous+0x27>
   10505:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
   10509:	2b 51 08             	sub    0x8(%ecx),%edx
   1050c:	29 d0                	sub    %edx,%eax
		if (len >= size) {
   1050e:	3b 45 0c             	cmp    0xc(%ebp),%eax
   10511:	0f 93 c0             	setae  %al
}
   10514:	5b                   	pop    %ebx
   10515:	5d                   	pop    %ebp
   10516:	c3                   	ret    

00010517 <net_pkt_write>:
{
   10517:	55                   	push   %ebp
   10518:	89 e5                	mov    %esp,%ebp
   1051a:	57                   	push   %edi
   1051b:	56                   	push   %esi
   1051c:	53                   	push   %ebx
   1051d:	8b 5d 08             	mov    0x8(%ebp),%ebx
   10520:	8b 7d 0c             	mov    0xc(%ebp),%edi
   10523:	8b 75 10             	mov    0x10(%ebp),%esi
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   10526:	3b 7b 1c             	cmp    0x1c(%ebx),%edi
   10529:	75 1c                	jne    10547 <net_pkt_write+0x30>
   1052b:	56                   	push   %esi
   1052c:	53                   	push   %ebx
   1052d:	e8 b0 ff ff ff       	call   104e2 <net_pkt_is_contiguous>
   10532:	5a                   	pop    %edx
   10533:	84 c0                	test   %al,%al
   10535:	59                   	pop    %ecx
   10536:	74 0f                	je     10547 <net_pkt_write+0x30>
		return net_pkt_skip(pkt, length);
   10538:	89 75 0c             	mov    %esi,0xc(%ebp)
}
   1053b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1053e:	5b                   	pop    %ebx
   1053f:	5e                   	pop    %esi
   10540:	5f                   	pop    %edi
   10541:	5d                   	pop    %ebp
		return net_pkt_skip(pkt, length);
   10542:	e9 99 fd ff ff       	jmp    102e0 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
   10547:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
   1054e:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
   10555:	8d 65 f4             	lea    -0xc(%ebp),%esp
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
   10558:	89 d8                	mov    %ebx,%eax
   1055a:	89 f1                	mov    %esi,%ecx
   1055c:	89 fa                	mov    %edi,%edx
}
   1055e:	5b                   	pop    %ebx
   1055f:	5e                   	pop    %esi
   10560:	5f                   	pop    %edi
   10561:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
   10562:	e9 bf f6 ff ff       	jmp    fc26 <net_pkt_cursor_operate>

00010567 <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
   10567:	55                   	push   %ebp
   10568:	89 e5                	mov    %esp,%ebp
   1056a:	57                   	push   %edi
   1056b:	56                   	push   %esi
   1056c:	53                   	push   %ebx
   1056d:	51                   	push   %ecx
   1056e:	8b 75 0c             	mov    0xc(%ebp),%esi
   10571:	8b 5d 08             	mov    0x8(%ebp),%ebx
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
   10574:	8b 4e 04             	mov    0x4(%esi),%ecx
   10577:	51                   	push   %ecx
   10578:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1057b:	53                   	push   %ebx
   1057c:	e8 61 ff ff ff       	call   104e2 <net_pkt_is_contiguous>
   10581:	5f                   	pop    %edi
   10582:	84 c0                	test   %al,%al
   10584:	5a                   	pop    %edx
   10585:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10588:	74 07                	je     10591 <net_pkt_get_data+0x2a>
			access->data = pkt->cursor.pos;
   1058a:	8b 43 1c             	mov    0x1c(%ebx),%eax
   1058d:	89 06                	mov    %eax,(%esi)
   1058f:	eb 63                	jmp    105f4 <net_pkt_get_data+0x8d>
		} else if (net_pkt_is_being_overwritten(pkt)) {
   10591:	f6 43 3d 01          	testb  $0x1,0x3d(%ebx)
   10595:	74 5d                	je     105f4 <net_pkt_get_data+0x8d>
   10597:	8b 06                	mov    (%esi),%eax
			struct net_pkt_cursor backup;

			if (!access->data) {
   10599:	85 c0                	test   %eax,%eax
   1059b:	75 32                	jne    105cf <net_pkt_get_data+0x68>
				NET_ERR("Uncontiguous data"
   1059d:	f6 05 d4 a8 40 00 07 	testb  $0x7,0x40a8d4
   105a4:	74 50                	je     105f6 <net_pkt_get_data+0x8f>
   105a6:	ba 2c 52 02 00       	mov    $0x2522c,%edx
   105ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
   105ae:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   105b4:	c1 ea 03             	shr    $0x3,%edx
   105b7:	c1 e2 06             	shl    $0x6,%edx
   105ba:	83 ca 01             	or     $0x1,%edx
   105bd:	52                   	push   %edx
   105be:	68 66 7b 02 00       	push   $0x27b66
   105c3:	e8 c2 2e ff ff       	call   348a <log_0>
   105c8:	58                   	pop    %eax
   105c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105cc:	5a                   	pop    %edx
   105cd:	eb 27                	jmp    105f6 <net_pkt_get_data+0x8f>
	backup->buf = pkt->cursor.buf;
   105cf:	8b 53 18             	mov    0x18(%ebx),%edx
	backup->pos = pkt->cursor.pos;
   105d2:	8b 7b 1c             	mov    0x1c(%ebx),%edi
				return NULL;
			}

			net_pkt_cursor_backup(pkt, &backup);

			if (net_pkt_read(pkt, access->data, access->size)) {
   105d5:	51                   	push   %ecx
	backup->buf = pkt->cursor.buf;
   105d6:	89 55 f0             	mov    %edx,-0x10(%ebp)
   105d9:	50                   	push   %eax
   105da:	53                   	push   %ebx
   105db:	e8 38 fd ff ff       	call   10318 <net_pkt_read>
   105e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
   105e3:	83 c4 0c             	add    $0xc,%esp
	pkt->cursor.buf = backup->buf;
   105e6:	89 53 18             	mov    %edx,0x18(%ebx)
   105e9:	85 c0                	test   %eax,%eax
	pkt->cursor.pos = backup->pos;
   105eb:	89 7b 1c             	mov    %edi,0x1c(%ebx)
   105ee:	74 04                	je     105f4 <net_pkt_get_data+0x8d>
				net_pkt_cursor_restore(pkt, &backup);
				return NULL;
   105f0:	31 c0                	xor    %eax,%eax
   105f2:	eb 02                	jmp    105f6 <net_pkt_get_data+0x8f>
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
   105f4:	8b 06                	mov    (%esi),%eax
	}

	return NULL;
}
   105f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   105f9:	5b                   	pop    %ebx
   105fa:	5e                   	pop    %esi
   105fb:	5f                   	pop    %edi
   105fc:	5d                   	pop    %ebp
   105fd:	c3                   	ret    

000105fe <net_pkt_set_data>:

int net_pkt_set_data(struct net_pkt *pkt,
		     struct net_pkt_data_access *access)
{
   105fe:	55                   	push   %ebp
   105ff:	89 e5                	mov    %esp,%ebp
   10601:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
   10604:	ff 70 04             	pushl  0x4(%eax)
   10607:	ff 30                	pushl  (%eax)
   10609:	ff 75 08             	pushl  0x8(%ebp)
   1060c:	e8 06 ff ff ff       	call   10517 <net_pkt_write>
   10611:	83 c4 0c             	add    $0xc,%esp
}
   10614:	c9                   	leave  
   10615:	c3                   	ret    

00010616 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
   10616:	c3                   	ret    

00010617 <k_work_submit_to_queue>:
{
   10617:	55                   	push   %ebp
   10618:	89 c1                	mov    %eax,%ecx
   1061a:	89 e5                	mov    %esp,%ebp
   1061c:	56                   	push   %esi
   1061d:	53                   	push   %ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1061e:	8b 42 08             	mov    0x8(%edx),%eax
   10621:	89 c6                	mov    %eax,%esi
   10623:	89 c3                	mov    %eax,%ebx
   10625:	83 ce 01             	or     $0x1,%esi
   10628:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
   1062d:	75 f2                	jne    10621 <k_work_submit_to_queue+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1062f:	80 e3 01             	and    $0x1,%bl
   10632:	75 09                	jne    1063d <k_work_submit_to_queue+0x26>
		k_queue_append(&work_q->queue, work);
   10634:	52                   	push   %edx
   10635:	51                   	push   %ecx
   10636:	e8 6b 30 01 00       	call   236a6 <k_queue_append>
   1063b:	58                   	pop    %eax
   1063c:	5a                   	pop    %edx
}
   1063d:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10640:	5b                   	pop    %ebx
   10641:	5e                   	pop    %esi
   10642:	5d                   	pop    %ebp
   10643:	c3                   	ret    

00010644 <net_tc_submit_to_tx_queue>:

static struct net_traffic_class tx_classes[NET_TC_TX_COUNT];
static struct net_traffic_class rx_classes[NET_TC_RX_COUNT];

void net_tc_submit_to_tx_queue(u8_t tc, struct net_pkt *pkt)
{
   10644:	55                   	push   %ebp
   10645:	89 e5                	mov    %esp,%ebp
	return &pkt->work;
   10647:	8b 45 0c             	mov    0xc(%ebp),%eax
   1064a:	8d 50 04             	lea    0x4(%eax),%edx
	k_work_submit_to_queue(&tx_classes[tc].work_q, net_pkt_work(pkt));
   1064d:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
   10651:	6b c0 5c             	imul   $0x5c,%eax,%eax
   10654:	05 20 0e 40 00       	add    $0x400e20,%eax
}
   10659:	5d                   	pop    %ebp
	k_work_submit_to_queue(&tx_classes[tc].work_q, net_pkt_work(pkt));
   1065a:	e9 b8 ff ff ff       	jmp    10617 <k_work_submit_to_queue>

0001065f <net_tc_submit_to_rx_queue>:

void net_tc_submit_to_rx_queue(u8_t tc, struct net_pkt *pkt)
{
   1065f:	55                   	push   %ebp
   10660:	89 e5                	mov    %esp,%ebp
   10662:	8b 45 0c             	mov    0xc(%ebp),%eax
   10665:	8d 50 04             	lea    0x4(%eax),%edx
	k_work_submit_to_queue(&rx_classes[tc].work_q, net_pkt_work(pkt));
   10668:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
   1066c:	6b c0 5c             	imul   $0x5c,%eax,%eax
   1066f:	05 c0 0d 40 00       	add    $0x400dc0,%eax
}
   10674:	5d                   	pop    %ebp
	k_work_submit_to_queue(&rx_classes[tc].work_q, net_pkt_work(pkt));
   10675:	e9 9d ff ff ff       	jmp    10617 <k_work_submit_to_queue>

0001067a <net_tx_priority2tc>:

int net_tx_priority2tc(enum net_priority prio)
{
   1067a:	55                   	push   %ebp
	if (prio > NET_PRIORITY_NC) {
		/* Use default value suggested in 802.1Q */
		prio = NET_PRIORITY_BE;
   1067b:	31 c0                	xor    %eax,%eax
{
   1067d:	89 e5                	mov    %esp,%ebp
   1067f:	8b 55 08             	mov    0x8(%ebp),%edx
	if (prio > NET_PRIORITY_NC) {
   10682:	80 fa 07             	cmp    $0x7,%dl
   10685:	77 03                	ja     1068a <net_tx_priority2tc+0x10>
   10687:	0f b6 c2             	movzbl %dl,%eax
	}

	return tx_prio2tc_map[prio];
   1068a:	0f b6 80 2c 60 02 00 	movzbl 0x2602c(%eax),%eax
}
   10691:	5d                   	pop    %ebp
   10692:	c3                   	ret    

00010693 <net_rx_priority2tc>:
   10693:	e9 e2 ff ff ff       	jmp    1067a <net_tx_priority2tc>

00010698 <net_tc_tx_init>:
/* Create workqueue for each traffic class we are using. All the network
 * traffic goes through these classes. There needs to be at least one traffic
 * class in the system.
 */
void net_tc_tx_init(void)
{
   10698:	55                   	push   %ebp

	for (i = 0; i < NET_TC_TX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = tx_tc2thread(i);
		tx_classes[i].tc = thread_priority;
   10699:	c7 05 78 0e 40 00 07 	movl   $0x7,0x400e78
   106a0:	00 00 00 
{
   106a3:	89 e5                	mov    %esp,%ebp
			"prio %d (%d)", i,
			&tx_classes[i].work_q.queue, TX_STACK(i),
			K_THREAD_STACK_SIZEOF(tx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&tx_classes[i].work_q,
   106a5:	6a f7                	push   $0xfffffff7
   106a7:	68 b0 04 00 00       	push   $0x4b0
		NET_STACK_GET_NAME(TX, tx_stack, 0)[i].stack = tx_stack[i];
   106ac:	c7 05 00 ab 40 00 60 	movl   $0x407460,0x40ab00
   106b3:	74 40 00 
		k_work_q_start(&tx_classes[i].work_q,
   106b6:	68 60 74 40 00       	push   $0x407460
		NET_STACK_GET_NAME(TX, tx_stack, 0)[i].prio = thread_priority;
   106bb:	c7 05 14 ab 40 00 07 	movl   $0x7,0x40ab14
   106c2:	00 00 00 
		k_work_q_start(&tx_classes[i].work_q,
   106c5:	68 20 0e 40 00       	push   $0x400e20
		NET_STACK_GET_NAME(TX, tx_stack, 0)[i].idx = i;
   106ca:	c7 05 18 ab 40 00 00 	movl   $0x0,0x40ab18
   106d1:	00 00 00 
		k_work_q_start(&tx_classes[i].work_q,
   106d4:	e8 6d 3d 01 00       	call   24446 <k_work_q_start>
   106d9:	83 c4 10             	add    $0x10,%esp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   106dc:	68 95 7b 02 00       	push   $0x27b95
   106e1:	68 38 0e 40 00       	push   $0x400e38
   106e6:	e8 b4 3a 01 00       	call   2419f <z_impl_k_thread_name_set>
   106eb:	58                   	pop    %eax
   106ec:	5a                   	pop    %edx
			       tx_stack[i],
			       K_THREAD_STACK_SIZEOF(tx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&tx_classes[i].work_q.thread, "tx_workq");
	}
}
   106ed:	c9                   	leave  
   106ee:	c3                   	ret    

000106ef <net_tc_rx_init>:

void net_tc_rx_init(void)
{
   106ef:	55                   	push   %ebp

	for (i = 0; i < NET_TC_RX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = rx_tc2thread(i);
		rx_classes[i].tc = thread_priority;
   106f0:	c7 05 18 0e 40 00 07 	movl   $0x7,0x400e18
   106f7:	00 00 00 
{
   106fa:	89 e5                	mov    %esp,%ebp
			"prio %d (%d)", i,
			&rx_classes[i].work_q.queue, RX_STACK(i),
			K_THREAD_STACK_SIZEOF(rx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&rx_classes[i].work_q,
   106fc:	6a f7                	push   $0xfffffff7
   106fe:	68 dc 05 00 00       	push   $0x5dc
		NET_STACK_GET_NAME(RX, rx_stack, 0)[i].stack = rx_stack[i];
   10703:	c7 05 e0 aa 40 00 84 	movl   $0x406e84,0x40aae0
   1070a:	6e 40 00 
		k_work_q_start(&rx_classes[i].work_q,
   1070d:	68 84 6e 40 00       	push   $0x406e84
		NET_STACK_GET_NAME(RX, rx_stack, 0)[i].prio = thread_priority;
   10712:	c7 05 f4 aa 40 00 07 	movl   $0x7,0x40aaf4
   10719:	00 00 00 
		k_work_q_start(&rx_classes[i].work_q,
   1071c:	68 c0 0d 40 00       	push   $0x400dc0
		NET_STACK_GET_NAME(RX, rx_stack, 0)[i].idx = i;
   10721:	c7 05 f8 aa 40 00 00 	movl   $0x0,0x40aaf8
   10728:	00 00 00 
		k_work_q_start(&rx_classes[i].work_q,
   1072b:	e8 16 3d 01 00       	call   24446 <k_work_q_start>
   10730:	83 c4 10             	add    $0x10,%esp
   10733:	68 9e 7b 02 00       	push   $0x27b9e
   10738:	68 d8 0d 40 00       	push   $0x400dd8
   1073d:	e8 5d 3a 01 00       	call   2419f <z_impl_k_thread_name_set>
   10742:	58                   	pop    %eax
   10743:	5a                   	pop    %edx
			       rx_stack[i],
			       K_THREAD_STACK_SIZEOF(rx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&rx_classes[i].work_q.thread, "rx_workq");
	}
}
   10744:	c9                   	leave  
   10745:	c3                   	ret    

00010746 <calc_chksum>:

	return 0;
}

static u16_t calc_chksum(u16_t sum, const u8_t *data, size_t len)
{
   10746:	55                   	push   %ebp
   10747:	89 e5                	mov    %esp,%ebp
   10749:	56                   	push   %esi
   1074a:	53                   	push   %ebx
	const u8_t *end;
	u16_t tmp;

	end = data + len - 1;
   1074b:	8d 5c 0a ff          	lea    -0x1(%edx,%ecx,1),%ebx

	while (data < end) {
   1074f:	39 da                	cmp    %ebx,%edx
   10751:	73 27                	jae    1077a <calc_chksum+0x34>
		tmp = (data[0] << 8) + data[1];
   10753:	0f b6 0a             	movzbl (%edx),%ecx
   10756:	89 ce                	mov    %ecx,%esi
   10758:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
   1075c:	c1 e6 08             	shl    $0x8,%esi
   1075f:	01 f1                	add    %esi,%ecx
   10761:	31 f6                	xor    %esi,%esi
   10763:	66 01 c8             	add    %cx,%ax
   10766:	73 05                	jae    1076d <calc_chksum+0x27>
   10768:	be 01 00 00 00       	mov    $0x1,%esi
		sum += tmp;
		if (sum < tmp) {
			sum++;
   1076d:	66 83 fe 01          	cmp    $0x1,%si
   10771:	66 83 d8 ff          	sbb    $0xffff,%ax
		}

		data += 2;
   10775:	83 c2 02             	add    $0x2,%edx
   10778:	eb d5                	jmp    1074f <calc_chksum+0x9>
	}

	if (data == end) {
   1077a:	75 1a                	jne    10796 <calc_chksum+0x50>
		tmp = data[0] << 8;
   1077c:	0f b6 12             	movzbl (%edx),%edx
   1077f:	c1 e2 08             	shl    $0x8,%edx
   10782:	31 c9                	xor    %ecx,%ecx
   10784:	66 01 d0             	add    %dx,%ax
   10787:	73 05                	jae    1078e <calc_chksum+0x48>
   10789:	b9 01 00 00 00       	mov    $0x1,%ecx
		sum += tmp;
		if (sum < tmp) {
			sum++;
   1078e:	66 83 f9 01          	cmp    $0x1,%cx
   10792:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
	}

	return sum;
}
   10796:	5b                   	pop    %ebx
   10797:	5e                   	pop    %esi
   10798:	5d                   	pop    %ebp
   10799:	c3                   	ret    

0001079a <net_byte_to_hex>:
{
   1079a:	55                   	push   %ebp
   1079b:	89 e5                	mov    %esp,%ebp
   1079d:	57                   	push   %edi
   1079e:	56                   	push   %esi
   1079f:	53                   	push   %ebx
   107a0:	51                   	push   %ecx
   107a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   107a4:	8b 75 08             	mov    0x8(%ebp),%esi
   107a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
   107aa:	8b 5d 10             	mov    0x10(%ebp),%ebx
		if (i == 0 && !pad && !val) {
   107ad:	8a 45 f0             	mov    -0x10(%ebp),%al
{
   107b0:	8b 7d 14             	mov    0x14(%ebp),%edi
		if (i == 0 && !pad && !val) {
   107b3:	c0 e8 04             	shr    $0x4,%al
   107b6:	8d 4e 01             	lea    0x1(%esi),%ecx
   107b9:	75 06                	jne    107c1 <net_byte_to_hex+0x27>
   107bb:	89 fa                	mov    %edi,%edx
   107bd:	fe ca                	dec    %dl
   107bf:	75 11                	jne    107d2 <net_byte_to_hex+0x38>
		if (val < 10) {
   107c1:	3c 09                	cmp    $0x9,%al
   107c3:	76 06                	jbe    107cb <net_byte_to_hex+0x31>
			*ptr++ = (char) (val - 10 + base);
   107c5:	8d 44 18 f6          	lea    -0xa(%eax,%ebx,1),%eax
   107c9:	eb 03                	jmp    107ce <net_byte_to_hex+0x34>
			*ptr++ = (char) (val + '0');
   107cb:	83 c0 30             	add    $0x30,%eax
   107ce:	88 06                	mov    %al,(%esi)
   107d0:	eb 02                	jmp    107d4 <net_byte_to_hex+0x3a>
		if (i == 0 && !pad && !val) {
   107d2:	89 f1                	mov    %esi,%ecx
   107d4:	8a 55 f0             	mov    -0x10(%ebp),%dl
   107d7:	8d 41 01             	lea    0x1(%ecx),%eax
   107da:	83 e2 0f             	and    $0xf,%edx
		if (val < 10) {
   107dd:	80 fa 09             	cmp    $0x9,%dl
			*ptr++ = (char) (val + '0');
   107e0:	8d 72 30             	lea    0x30(%edx),%esi
		if (val < 10) {
   107e3:	76 04                	jbe    107e9 <net_byte_to_hex+0x4f>
			*ptr++ = (char) (val - 10 + base);
   107e5:	8d 74 1a f6          	lea    -0xa(%edx,%ebx,1),%esi
   107e9:	89 f3                	mov    %esi,%ebx
	*ptr = '\0';
   107eb:	c6 41 01 00          	movb   $0x0,0x1(%ecx)
   107ef:	88 19                	mov    %bl,(%ecx)
}
   107f1:	5a                   	pop    %edx
   107f2:	5b                   	pop    %ebx
   107f3:	5e                   	pop    %esi
   107f4:	5f                   	pop    %edi
   107f5:	5d                   	pop    %ebp
   107f6:	c3                   	ret    

000107f7 <net_sprint_ll_addr_buf>:
{
   107f7:	55                   	push   %ebp
   107f8:	89 e5                	mov    %esp,%ebp
   107fa:	57                   	push   %edi
   107fb:	56                   	push   %esi
		len = 6U;
   107fc:	bf 06 00 00 00       	mov    $0x6,%edi
{
   10801:	53                   	push   %ebx
   10802:	50                   	push   %eax
   10803:	8b 45 0c             	mov    0xc(%ebp),%eax
   10806:	8b 75 10             	mov    0x10(%ebp),%esi
	switch (ll_len) {
   10809:	3c 08                	cmp    $0x8,%al
   1080b:	75 02                	jne    1080f <net_sprint_ll_addr_buf+0x18>
   1080d:	89 c7                	mov    %eax,%edi
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
   1080f:	8a 4d 14             	mov    0x14(%ebp),%cl
   10812:	89 f2                	mov    %esi,%edx
   10814:	31 db                	xor    %ebx,%ebx
   10816:	89 f8                	mov    %edi,%eax
   10818:	38 d8                	cmp    %bl,%al
   1081a:	76 2b                	jbe    10847 <net_sprint_ll_addr_buf+0x50>
   1081c:	84 c9                	test   %cl,%cl
   1081e:	74 27                	je     10847 <net_sprint_ll_addr_buf+0x50>
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
   10820:	6a 01                	push   $0x1
   10822:	8b 45 08             	mov    0x8(%ebp),%eax
   10825:	6a 41                	push   $0x41
   10827:	88 4d f3             	mov    %cl,-0xd(%ebp)
   1082a:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
   1082e:	50                   	push   %eax
   1082f:	43                   	inc    %ebx
   10830:	52                   	push   %edx
   10831:	e8 64 ff ff ff       	call   1079a <net_byte_to_hex>
   10836:	8a 4d f3             	mov    -0xd(%ebp),%cl
   10839:	83 c4 10             	add    $0x10,%esp
		*ptr++ = ':';
   1083c:	8d 50 01             	lea    0x1(%eax),%edx
   1083f:	c6 00 3a             	movb   $0x3a,(%eax)
		blen -= 3;
   10842:	83 e9 03             	sub    $0x3,%ecx
   10845:	eb cf                	jmp    10816 <net_sprint_ll_addr_buf+0x1f>
		return NULL;
   10847:	31 c0                	xor    %eax,%eax
	if (!(ptr - buf)) {
   10849:	39 f2                	cmp    %esi,%edx
   1084b:	74 06                	je     10853 <net_sprint_ll_addr_buf+0x5c>
	*(ptr - 1) = '\0';
   1084d:	c6 42 ff 00          	movb   $0x0,-0x1(%edx)
	return buf;
   10851:	89 f0                	mov    %esi,%eax
}
   10853:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10856:	5b                   	pop    %ebx
   10857:	5e                   	pop    %esi
   10858:	5f                   	pop    %edi
   10859:	5d                   	pop    %ebp
   1085a:	c3                   	ret    

0001085b <net_addr_ntop>:
{
   1085b:	55                   	push   %ebp
   1085c:	89 e5                	mov    %esp,%ebp
   1085e:	57                   	push   %edi
   1085f:	56                   	push   %esi
   10860:	53                   	push   %ebx
   10861:	83 ec 34             	sub    $0x34,%esp
	unsigned char zeros[8] = { 0 };
   10864:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   1086b:	8b 45 08             	mov    0x8(%ebp),%eax
	unsigned char zeros[8] = { 0 };
   1086e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
{
   10875:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (family == AF_INET6) {
   10878:	66 83 7d d0 02       	cmpw   $0x2,-0x30(%ebp)
   1087d:	75 5c                	jne    108db <net_addr_ntop+0x80>
		w = (u16_t *)addr6->s6_addr16;
   1087f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10882:	8d 4d ec             	lea    -0x14(%ebp),%ecx
   10885:	89 45 c8             	mov    %eax,-0x38(%ebp)
   10888:	31 d2                	xor    %edx,%edx
{
   1088a:	89 d0                	mov    %edx,%eax
				if (UNALIGNED_GET(&w[j]) != 0) {
   1088c:	8b 7d 0c             	mov    0xc(%ebp),%edi
   1088f:	66 83 3c 47 00       	cmpw   $0x0,(%edi,%eax,2)
   10894:	74 11                	je     108a7 <net_addr_ntop+0x4c>
   10896:	42                   	inc    %edx
   10897:	41                   	inc    %ecx
		for (i = 0U; i < 8; i++) {
   10898:	83 fa 08             	cmp    $0x8,%edx
   1089b:	75 ed                	jne    1088a <net_addr_ntop+0x2f>
   1089d:	31 c0                	xor    %eax,%eax
	s8_t pos = -1;
   1089f:	b2 ff                	mov    $0xff,%dl
	u8_t i, bl, bh, longest = 1U;
   108a1:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
   108a5:	eb 0f                	jmp    108b6 <net_addr_ntop+0x5b>
				zeros[i]++;
   108a7:	40                   	inc    %eax
   108a8:	fe 01                	incb   (%ecx)
			for (j = i; j < 8; j++) {
   108aa:	3c 07                	cmp    $0x7,%al
   108ac:	76 de                	jbe    1088c <net_addr_ntop+0x31>
   108ae:	eb e6                	jmp    10896 <net_addr_ntop+0x3b>
   108b0:	40                   	inc    %eax
		for (i = 0U; i < 8; i++) {
   108b1:	83 f8 08             	cmp    $0x8,%eax
   108b4:	74 10                	je     108c6 <net_addr_ntop+0x6b>
			if (zeros[i] > longest) {
   108b6:	8a 4c 05 ec          	mov    -0x14(%ebp,%eax,1),%cl
   108ba:	3a 4d eb             	cmp    -0x15(%ebp),%cl
   108bd:	76 f1                	jbe    108b0 <net_addr_ntop+0x55>
				pos = i;
   108bf:	88 c2                	mov    %al,%dl
   108c1:	88 4d eb             	mov    %cl,-0x15(%ebp)
   108c4:	eb ea                	jmp    108b0 <net_addr_ntop+0x55>
		if (longest == 1) {
   108c6:	80 7d eb 01          	cmpb   $0x1,-0x15(%ebp)
		len = 8;
   108ca:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
	char delim = ':';
   108d1:	c6 45 ea 3a          	movb   $0x3a,-0x16(%ebp)
		if (longest == 1) {
   108d5:	75 28                	jne    108ff <net_addr_ntop+0xa4>
			pos = -1;
   108d7:	b2 ff                	mov    $0xff,%dl
   108d9:	eb 24                	jmp    108ff <net_addr_ntop+0xa4>
	} else if (family == AF_INET) {
   108db:	66 83 7d d0 01       	cmpw   $0x1,-0x30(%ebp)
   108e0:	74 0c                	je     108ee <net_addr_ntop+0x93>
		return NULL;
   108e2:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
   108e9:	e9 a5 01 00 00       	jmp    10a93 <net_addr_ntop+0x238>
		len = 4;
   108ee:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
		delim = '.';
   108f5:	c6 45 ea 2e          	movb   $0x2e,-0x16(%ebp)
	s8_t pos = -1;
   108f9:	b2 ff                	mov    $0xff,%dl
	u8_t i, bl, bh, longest = 1U;
   108fb:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
		if (i == pos) {
   108ff:	0f be c2             	movsbl %dl,%eax
	for (i = 0U; i < len; i++) {
   10902:	8b 4d 10             	mov    0x10(%ebp),%ecx
	bool needcolon = false;
   10905:	31 f6                	xor    %esi,%esi
	for (i = 0U; i < len; i++) {
   10907:	31 ff                	xor    %edi,%edi
		if (i == pos) {
   10909:	89 45 c0             	mov    %eax,-0x40(%ebp)
	for (i = 0U; i < len; i++) {
   1090c:	89 f8                	mov    %edi,%eax
   1090e:	0f b6 c0             	movzbl %al,%eax
   10911:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   10914:	0f 8d 60 01 00 00    	jge    10a7a <net_addr_ntop+0x21f>
		if (len == 4) {
   1091a:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
   1091e:	0f 85 a0 00 00 00    	jne    109c4 <net_addr_ntop+0x169>
			value = (u32_t)addr->s4_addr[i];
   10924:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   10927:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
			if (value == 0) {
   1092b:	84 c0                	test   %al,%al
   1092d:	75 11                	jne    10940 <net_addr_ntop+0xe5>
				*ptr++ = delim;
   1092f:	8a 5d ea             	mov    -0x16(%ebp),%bl
				*ptr++ = '0';
   10932:	c6 01 30             	movb   $0x30,(%ecx)
				*ptr++ = delim;
   10935:	8d 41 02             	lea    0x2(%ecx),%eax
   10938:	88 59 01             	mov    %bl,0x1(%ecx)
				continue;
   1093b:	e9 32 01 00 00       	jmp    10a72 <net_addr_ntop+0x217>
			l = net_value_to_udec(ptr, value, 0);
   10940:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   10943:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
   10946:	c7 45 dc 09 00 00 00 	movl   $0x9,-0x24(%ebp)
   1094d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
   10954:	c7 45 d8 00 ca 9a 3b 	movl   $0x3b9aca00,-0x28(%ebp)
		value = value % divisor;
   1095b:	31 d2                	xor    %edx,%edx
   1095d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10960:	f7 75 d8             	divl   -0x28(%ebp)
		if ((precision > i) || (temp != 0)) {
   10963:	8b 5d dc             	mov    -0x24(%ebp),%ebx
   10966:	89 55 c4             	mov    %edx,-0x3c(%ebp)
   10969:	39 5d cc             	cmp    %ebx,-0x34(%ebp)
   1096c:	7f 08                	jg     10976 <net_addr_ntop+0x11b>
   1096e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10971:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
   10974:	72 14                	jb     1098a <net_addr_ntop+0x12f>
			*buf++ = (char) (temp + '0');
   10976:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   10979:	83 c0 30             	add    $0x30,%eax
   1097c:	88 03                	mov    %al,(%ebx)
   1097e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10981:	89 45 cc             	mov    %eax,-0x34(%ebp)
   10984:	89 d8                	mov    %ebx,%eax
   10986:	40                   	inc    %eax
   10987:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (i = 9; i >= 0; i--, divisor /= 10) {
   1098a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1098d:	31 d2                	xor    %edx,%edx
   1098f:	ff 4d dc             	decl   -0x24(%ebp)
   10992:	bb 0a 00 00 00       	mov    $0xa,%ebx
   10997:	f7 f3                	div    %ebx
   10999:	89 45 d8             	mov    %eax,-0x28(%ebp)
		value = value % divisor;
   1099c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1099f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	for (i = 9; i >= 0; i--, divisor /= 10) {
   109a2:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
   109a6:	75 b3                	jne    1095b <net_addr_ntop+0x100>
	*buf = 0;
   109a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	return buf - start;
   109ab:	89 c3                	mov    %eax,%ebx
   109ad:	29 cb                	sub    %ecx,%ebx
	*buf = 0;
   109af:	c6 00 00             	movb   $0x0,(%eax)
			ptr += l;
   109b2:	0f b6 db             	movzbl %bl,%ebx
   109b5:	01 d9                	add    %ebx,%ecx
			*ptr++ = delim;
   109b7:	8a 5d ea             	mov    -0x16(%ebp),%bl
   109ba:	8d 41 01             	lea    0x1(%ecx),%eax
   109bd:	88 19                	mov    %bl,(%ecx)
			continue;
   109bf:	e9 ae 00 00 00       	jmp    10a72 <net_addr_ntop+0x217>
		if (i == pos) {
   109c4:	39 45 c0             	cmp    %eax,-0x40(%ebp)
   109c7:	75 25                	jne    109ee <net_addr_ntop+0x193>
			if (needcolon || i == 0) {
   109c9:	89 f8                	mov    %edi,%eax
   109cb:	84 c0                	test   %al,%al
   109cd:	74 06                	je     109d5 <net_addr_ntop+0x17a>
   109cf:	89 f0                	mov    %esi,%eax
   109d1:	84 c0                	test   %al,%al
   109d3:	74 04                	je     109d9 <net_addr_ntop+0x17e>
				*ptr++ = ':';
   109d5:	c6 01 3a             	movb   $0x3a,(%ecx)
   109d8:	41                   	inc    %ecx
			i += longest - 1;
   109d9:	0f b6 75 eb          	movzbl -0x15(%ebp),%esi
			*ptr++ = ':';
   109dd:	8d 41 01             	lea    0x1(%ecx),%eax
   109e0:	c6 01 3a             	movb   $0x3a,(%ecx)
			i += longest - 1;
   109e3:	8d 7c 37 ff          	lea    -0x1(%edi,%esi,1),%edi
			needcolon = false;
   109e7:	31 f6                	xor    %esi,%esi
			continue;
   109e9:	e9 84 00 00 00       	jmp    10a72 <net_addr_ntop+0x217>
		if (needcolon) {
   109ee:	89 f0                	mov    %esi,%eax
   109f0:	84 c0                	test   %al,%al
   109f2:	74 04                	je     109f8 <net_addr_ntop+0x19d>
			*ptr++ = ':';
   109f4:	c6 01 3a             	movb   $0x3a,(%ecx)
   109f7:	41                   	inc    %ecx
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
   109f8:	89 f8                	mov    %edi,%eax
   109fa:	8b 75 c8             	mov    -0x38(%ebp),%esi
   109fd:	0f b6 c0             	movzbl %al,%eax
   10a00:	66 8b 14 46          	mov    (%esi,%eax,2),%dx
   10a04:	86 f2                	xchg   %dh,%dl
		if (bh) {
   10a06:	89 d6                	mov    %edx,%esi
   10a08:	66 c1 ee 08          	shr    $0x8,%si
		bl = value & 0xff;
   10a0c:	0f b6 da             	movzbl %dl,%ebx
		if (bh) {
   10a0f:	74 35                	je     10a46 <net_addr_ntop+0x1eb>
			if (bh > 0x0f) {
   10a11:	66 83 fe 0f          	cmp    $0xf,%si
		bh = value >> 8;
   10a15:	89 f2                	mov    %esi,%edx
			if (bh > 0x0f) {
   10a17:	76 13                	jbe    10a2c <net_addr_ntop+0x1d1>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
   10a19:	6a 00                	push   $0x0
   10a1b:	6a 61                	push   $0x61
   10a1d:	0f b6 d2             	movzbl %dl,%edx
   10a20:	52                   	push   %edx
   10a21:	51                   	push   %ecx
   10a22:	e8 73 fd ff ff       	call   1079a <net_byte_to_hex>
   10a27:	83 c4 10             	add    $0x10,%esp
   10a2a:	eb 12                	jmp    10a3e <net_addr_ntop+0x1e3>
				if (bh < 10) {
   10a2c:	8d 41 01             	lea    0x1(%ecx),%eax
   10a2f:	80 fa 09             	cmp    $0x9,%dl
   10a32:	77 05                	ja     10a39 <net_addr_ntop+0x1de>
					*ptr++ = (char)(bh + '0');
   10a34:	8d 56 30             	lea    0x30(%esi),%edx
   10a37:	eb 03                	jmp    10a3c <net_addr_ntop+0x1e1>
					*ptr++ = (char) (bh - 10 + 'a');
   10a39:	8d 56 57             	lea    0x57(%esi),%edx
   10a3c:	88 11                	mov    %dl,(%ecx)
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
   10a3e:	6a 01                	push   $0x1
   10a40:	6a 61                	push   $0x61
   10a42:	53                   	push   %ebx
   10a43:	50                   	push   %eax
   10a44:	eb 0b                	jmp    10a51 <net_addr_ntop+0x1f6>
		} else if (bl > 0x0f) {
   10a46:	80 fb 0f             	cmp    $0xf,%bl
   10a49:	76 10                	jbe    10a5b <net_addr_ntop+0x200>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   10a4b:	6a 00                	push   $0x0
   10a4d:	6a 61                	push   $0x61
   10a4f:	53                   	push   %ebx
   10a50:	51                   	push   %ecx
   10a51:	e8 44 fd ff ff       	call   1079a <net_byte_to_hex>
   10a56:	83 c4 10             	add    $0x10,%esp
   10a59:	eb 12                	jmp    10a6d <net_addr_ntop+0x212>
			if (bl < 10) {
   10a5b:	8d 41 01             	lea    0x1(%ecx),%eax
   10a5e:	80 fb 09             	cmp    $0x9,%bl
   10a61:	77 05                	ja     10a68 <net_addr_ntop+0x20d>
				*ptr++ = (char)(bl + '0');
   10a63:	83 c2 30             	add    $0x30,%edx
   10a66:	eb 03                	jmp    10a6b <net_addr_ntop+0x210>
				*ptr++ = (char) (bl - 10 + 'a');
   10a68:	83 c2 57             	add    $0x57,%edx
   10a6b:	88 11                	mov    %dl,(%ecx)
		needcolon = true;
   10a6d:	be 01 00 00 00       	mov    $0x1,%esi
	for (i = 0U; i < len; i++) {
   10a72:	47                   	inc    %edi
   10a73:	89 c1                	mov    %eax,%ecx
   10a75:	e9 92 fe ff ff       	jmp    1090c <net_addr_ntop+0xb1>
	if (!(ptr - dst)) {
   10a7a:	3b 4d 10             	cmp    0x10(%ebp),%ecx
   10a7d:	0f 84 5f fe ff ff    	je     108e2 <net_addr_ntop+0x87>
	if (family == AF_INET) {
   10a83:	66 83 7d d0 01       	cmpw   $0x1,-0x30(%ebp)
   10a88:	75 06                	jne    10a90 <net_addr_ntop+0x235>
		*(ptr - 1) = '\0';
   10a8a:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
   10a8e:	eb 03                	jmp    10a93 <net_addr_ntop+0x238>
		*ptr = '\0';
   10a90:	c6 01 00             	movb   $0x0,(%ecx)
}
   10a93:	8b 45 10             	mov    0x10(%ebp),%eax
   10a96:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10a99:	5b                   	pop    %ebx
   10a9a:	5e                   	pop    %esi
   10a9b:	5f                   	pop    %edi
   10a9c:	5d                   	pop    %ebp
   10a9d:	c3                   	ret    

00010a9e <net_sprint_addr>:
	char *s = buf[++i % NBUFS];
   10a9e:	a1 b4 42 40 00       	mov    0x4042b4,%eax
   10aa3:	b9 03 00 00 00       	mov    $0x3,%ecx
   10aa8:	40                   	inc    %eax
{
   10aa9:	55                   	push   %ebp
	char *s = buf[++i % NBUFS];
   10aaa:	99                   	cltd   
   10aab:	a3 b4 42 40 00       	mov    %eax,0x4042b4
{
   10ab0:	89 e5                	mov    %esp,%ebp
	char *s = buf[++i % NBUFS];
   10ab2:	f7 f9                	idiv   %ecx
   10ab4:	6b c2 28             	imul   $0x28,%edx,%eax
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
   10ab7:	6a 28                	push   $0x28
	char *s = buf[++i % NBUFS];
   10ab9:	05 80 0e 40 00       	add    $0x400e80,%eax
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
   10abe:	50                   	push   %eax
   10abf:	ff 75 0c             	pushl  0xc(%ebp)
   10ac2:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   10ac6:	50                   	push   %eax
   10ac7:	e8 8f fd ff ff       	call   1085b <net_addr_ntop>
   10acc:	83 c4 10             	add    $0x10,%esp
}
   10acf:	c9                   	leave  
   10ad0:	c3                   	ret    

00010ad1 <net_addr_pton>:
{
   10ad1:	55                   	push   %ebp
   10ad2:	89 e5                	mov    %esp,%ebp
   10ad4:	57                   	push   %edi
   10ad5:	56                   	push   %esi
   10ad6:	53                   	push   %ebx
   10ad7:	83 ec 08             	sub    $0x8,%esp
   10ada:	8b 45 08             	mov    0x8(%ebp),%eax
   10add:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (family == AF_INET) {
   10ae0:	66 83 f8 01          	cmp    $0x1,%ax
   10ae4:	75 66                	jne    10b4c <net_addr_pton+0x7b>
		len = strlen(src);
   10ae6:	53                   	push   %ebx
   10ae7:	e8 77 9d ff ff       	call   a863 <strlen>
   10aec:	5e                   	pop    %esi
   10aed:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
   10aef:	31 d2                	xor    %edx,%edx
   10af1:	39 fa                	cmp    %edi,%edx
   10af3:	74 1e                	je     10b13 <net_addr_pton+0x42>
			if (!(src[i] >= '0' && src[i] <= '9') &&
   10af5:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
   10af8:	8d 71 d0             	lea    -0x30(%ecx),%esi
   10afb:	89 f0                	mov    %esi,%eax
   10afd:	3c 09                	cmp    $0x9,%al
   10aff:	76 0f                	jbe    10b10 <net_addr_pton+0x3f>
   10b01:	80 f9 2e             	cmp    $0x2e,%cl
   10b04:	74 0a                	je     10b10 <net_addr_pton+0x3f>
				return -EINVAL;
   10b06:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   10b0b:	e9 b9 01 00 00       	jmp    10cc9 <net_addr_pton+0x1f8>
		for (i = 0; i < len; i++) {
   10b10:	42                   	inc    %edx
   10b11:	eb de                	jmp    10af1 <net_addr_pton+0x20>
		(void)memset(addr, 0, sizeof(struct in_addr));
   10b13:	6a 04                	push   $0x4
		for (i = 0; i < sizeof(struct in_addr); i++) {
   10b15:	31 f6                	xor    %esi,%esi
		(void)memset(addr, 0, sizeof(struct in_addr));
   10b17:	6a 00                	push   $0x0
   10b19:	ff 75 10             	pushl  0x10(%ebp)
   10b1c:	e8 7f 9e ff ff       	call   a9a0 <memset>
   10b21:	83 c4 0c             	add    $0xc,%esp
			addr->s4_addr[i] = strtol(src, &endptr, 10);
   10b24:	6a 0a                	push   $0xa
   10b26:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b29:	50                   	push   %eax
   10b2a:	53                   	push   %ebx
   10b2b:	e8 bb 99 ff ff       	call   a4eb <strtol>
   10b30:	8b 7d 10             	mov    0x10(%ebp),%edi
   10b33:	83 c4 0c             	add    $0xc,%esp
   10b36:	88 04 37             	mov    %al,(%edi,%esi,1)
			src = ++endptr;
   10b39:	8b 45 f0             	mov    -0x10(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
   10b3c:	46                   	inc    %esi
			src = ++endptr;
   10b3d:	8d 58 01             	lea    0x1(%eax),%ebx
		for (i = 0; i < sizeof(struct in_addr); i++) {
   10b40:	83 fe 04             	cmp    $0x4,%esi
   10b43:	75 df                	jne    10b24 <net_addr_pton+0x53>
	return 0;
   10b45:	31 c0                	xor    %eax,%eax
   10b47:	e9 7d 01 00 00       	jmp    10cc9 <net_addr_pton+0x1f8>
	} else if (family == AF_INET6) {
   10b4c:	66 83 f8 02          	cmp    $0x2,%ax
   10b50:	75 b4                	jne    10b06 <net_addr_pton+0x35>
		int expected_groups = strchr(src, '.') ? 6 : 8;
   10b52:	6a 2e                	push   $0x2e
   10b54:	53                   	push   %ebx
   10b55:	e8 cf 9c ff ff       	call   a829 <strchr>
   10b5a:	83 f8 01             	cmp    $0x1,%eax
   10b5d:	5a                   	pop    %edx
   10b5e:	19 f6                	sbb    %esi,%esi
   10b60:	59                   	pop    %ecx
   10b61:	83 e6 02             	and    $0x2,%esi
   10b64:	83 c6 06             	add    $0x6,%esi
		if (*src == ':') {
   10b67:	80 3b 3a             	cmpb   $0x3a,(%ebx)
   10b6a:	75 01                	jne    10b6d <net_addr_pton+0x9c>
			src++;
   10b6c:	43                   	inc    %ebx
		len = strlen(src);
   10b6d:	53                   	push   %ebx
   10b6e:	e8 f0 9c ff ff       	call   a863 <strlen>
   10b73:	5f                   	pop    %edi
   10b74:	89 c2                	mov    %eax,%edx
		for (i = 0; i < len; i++) {
   10b76:	31 ff                	xor    %edi,%edi
   10b78:	39 d7                	cmp    %edx,%edi
   10b7a:	7d 31                	jge    10bad <net_addr_pton+0xdc>
			if (!(src[i] >= '0' && src[i] <= '9') &&
   10b7c:	8a 0c 3b             	mov    (%ebx,%edi,1),%cl
   10b7f:	8d 41 d0             	lea    -0x30(%ecx),%eax
   10b82:	3c 09                	cmp    $0x9,%al
   10b84:	76 24                	jbe    10baa <net_addr_pton+0xd9>
			    !(src[i] >= 'A' && src[i] <= 'F') &&
   10b86:	8d 41 bf             	lea    -0x41(%ecx),%eax
			if (!(src[i] >= '0' && src[i] <= '9') &&
   10b89:	3c 05                	cmp    $0x5,%al
   10b8b:	76 1d                	jbe    10baa <net_addr_pton+0xd9>
			    !(src[i] >= 'a' && src[i] <= 'f') &&
   10b8d:	8d 41 9f             	lea    -0x61(%ecx),%eax
			    !(src[i] >= 'A' && src[i] <= 'F') &&
   10b90:	3c 05                	cmp    $0x5,%al
   10b92:	0f 97 45 ec          	seta   -0x14(%ebp)
			    !(src[i] >= 'a' && src[i] <= 'f') &&
   10b96:	80 f9 2e             	cmp    $0x2e,%cl
   10b99:	0f 95 c0             	setne  %al
			    src[i] != '.' && src[i] != ':')
   10b9c:	84 45 ec             	test   %al,-0x14(%ebp)
   10b9f:	74 09                	je     10baa <net_addr_pton+0xd9>
   10ba1:	80 f9 3a             	cmp    $0x3a,%cl
   10ba4:	0f 85 5c ff ff ff    	jne    10b06 <net_addr_pton+0x35>
		for (i = 0; i < len; i++) {
   10baa:	47                   	inc    %edi
   10bab:	eb cb                	jmp    10b78 <net_addr_pton+0xa7>
		for (i = 0; i < expected_groups; i++) {
   10bad:	31 d2                	xor    %edx,%edx
			if (!src || *src == '\0') {
   10baf:	85 db                	test   %ebx,%ebx
   10bb1:	0f 84 4f ff ff ff    	je     10b06 <net_addr_pton+0x35>
   10bb7:	8a 03                	mov    (%ebx),%al
   10bb9:	84 c0                	test   %al,%al
   10bbb:	0f 84 45 ff ff ff    	je     10b06 <net_addr_pton+0x35>
			if (*src != ':') {
   10bc1:	3c 3a                	cmp    $0x3a,%al
   10bc3:	74 54                	je     10c19 <net_addr_pton+0x148>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
   10bc5:	6a 10                	push   $0x10
   10bc7:	89 55 ec             	mov    %edx,-0x14(%ebp)
   10bca:	6a 00                	push   $0x0
   10bcc:	53                   	push   %ebx
   10bcd:	e8 19 99 ff ff       	call   a4eb <strtol>
   10bd2:	83 c4 0c             	add    $0xc,%esp
   10bd5:	89 c7                	mov    %eax,%edi
   10bd7:	66 c1 ef 08          	shr    $0x8,%di
   10bdb:	6a 10                	push   $0x10
   10bdd:	6a 00                	push   $0x0
   10bdf:	53                   	push   %ebx
   10be0:	e8 06 99 ff ff       	call   a4eb <strtol>
   10be5:	c1 e0 08             	shl    $0x8,%eax
   10be8:	83 c4 0c             	add    $0xc,%esp
   10beb:	09 c7                	or     %eax,%edi
   10bed:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10bf0:	8b 45 10             	mov    0x10(%ebp),%eax
   10bf3:	66 89 3c 50          	mov    %di,(%eax,%edx,2)
				src = strchr(src, ':');
   10bf7:	6a 3a                	push   $0x3a
   10bf9:	53                   	push   %ebx
   10bfa:	e8 2a 9c ff ff       	call   a829 <strchr>
   10bff:	59                   	pop    %ecx
				if (src) {
   10c00:	85 c0                	test   %eax,%eax
				src = strchr(src, ':');
   10c02:	5b                   	pop    %ebx
				if (src) {
   10c03:	8b 55 ec             	mov    -0x14(%ebp),%edx
				src = strchr(src, ':');
   10c06:	89 c3                	mov    %eax,%ebx
				if (src) {
   10c08:	74 03                	je     10c0d <net_addr_pton+0x13c>
					src++;
   10c0a:	43                   	inc    %ebx
   10c0b:	eb 5c                	jmp    10c69 <net_addr_pton+0x198>
					if (i < expected_groups - 1) {
   10c0d:	8d 46 ff             	lea    -0x1(%esi),%eax
   10c10:	39 d0                	cmp    %edx,%eax
   10c12:	7e 55                	jle    10c69 <net_addr_pton+0x198>
   10c14:	e9 ed fe ff ff       	jmp    10b06 <net_addr_pton+0x35>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
   10c19:	8b 45 10             	mov    0x10(%ebp),%eax
   10c1c:	66 c7 04 50 00 00    	movw   $0x0,(%eax,%edx,2)
			for (; i < expected_groups; i++) {
   10c22:	42                   	inc    %edx
   10c23:	39 d6                	cmp    %edx,%esi
   10c25:	7f f2                	jg     10c19 <net_addr_pton+0x148>
			tmp = strrchr(src, ':');
   10c27:	6a 3a                	push   $0x3a
   10c29:	53                   	push   %ebx
   10c2a:	e8 1c 9c ff ff       	call   a84b <strrchr>
   10c2f:	5f                   	pop    %edi
			if (src == tmp && (expected_groups == 6 || !src[1])) {
   10c30:	39 d8                	cmp    %ebx,%eax
			tmp = strrchr(src, ':');
   10c32:	5a                   	pop    %edx
			if (src == tmp && (expected_groups == 6 || !src[1])) {
   10c33:	75 0e                	jne    10c43 <net_addr_pton+0x172>
   10c35:	83 fe 06             	cmp    $0x6,%esi
   10c38:	74 06                	je     10c40 <net_addr_pton+0x16f>
   10c3a:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
   10c3e:	75 0b                	jne    10c4b <net_addr_pton+0x17a>
				src++;
   10c40:	43                   	inc    %ebx
				break;
   10c41:	eb 2f                	jmp    10c72 <net_addr_pton+0x1a1>
			if (expected_groups == 6) {
   10c43:	83 fe 06             	cmp    $0x6,%esi
   10c46:	75 05                	jne    10c4d <net_addr_pton+0x17c>
				tmp--;
   10c48:	48                   	dec    %eax
   10c49:	eb 02                	jmp    10c4d <net_addr_pton+0x17c>
   10c4b:	89 d8                	mov    %ebx,%eax
			i = expected_groups - 1;
   10c4d:	8d 56 ff             	lea    -0x1(%esi),%edx
				if (*tmp == ':') {
   10c50:	80 38 3a             	cmpb   $0x3a,(%eax)
   10c53:	75 01                	jne    10c56 <net_addr_pton+0x185>
					i--;
   10c55:	4a                   	dec    %edx
				if (i < 0) {
   10c56:	85 d2                	test   %edx,%edx
   10c58:	0f 88 a8 fe ff ff    	js     10b06 <net_addr_pton+0x35>
			} while (tmp-- != src);
   10c5e:	48                   	dec    %eax
   10c5f:	8d 48 01             	lea    0x1(%eax),%ecx
   10c62:	39 cb                	cmp    %ecx,%ebx
   10c64:	75 ea                	jne    10c50 <net_addr_pton+0x17f>
			src++;
   10c66:	8d 58 02             	lea    0x2(%eax),%ebx
		for (i = 0; i < expected_groups; i++) {
   10c69:	42                   	inc    %edx
   10c6a:	39 d6                	cmp    %edx,%esi
   10c6c:	0f 8f 3d ff ff ff    	jg     10baf <net_addr_pton+0xde>
		if (expected_groups == 6) {
   10c72:	83 fe 06             	cmp    $0x6,%esi
   10c75:	0f 85 ca fe ff ff    	jne    10b45 <net_addr_pton+0x74>
			for (i = 0; i < 4; i++) {
   10c7b:	31 f6                	xor    %esi,%esi
				if (!src || !*src) {
   10c7d:	85 db                	test   %ebx,%ebx
   10c7f:	0f 84 81 fe ff ff    	je     10b06 <net_addr_pton+0x35>
   10c85:	80 3b 00             	cmpb   $0x0,(%ebx)
   10c88:	0f 84 78 fe ff ff    	je     10b06 <net_addr_pton+0x35>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
   10c8e:	6a 0a                	push   $0xa
   10c90:	6a 00                	push   $0x0
   10c92:	53                   	push   %ebx
   10c93:	e8 53 98 ff ff       	call   a4eb <strtol>
   10c98:	83 c4 0c             	add    $0xc,%esp
   10c9b:	8b 4d 10             	mov    0x10(%ebp),%ecx
   10c9e:	88 44 31 0c          	mov    %al,0xc(%ecx,%esi,1)
				src = strchr(src, '.');
   10ca2:	6a 2e                	push   $0x2e
   10ca4:	53                   	push   %ebx
   10ca5:	e8 7f 9b ff ff       	call   a829 <strchr>
   10caa:	5a                   	pop    %edx
   10cab:	89 c3                	mov    %eax,%ebx
   10cad:	59                   	pop    %ecx
				if (src) {
   10cae:	85 c0                	test   %eax,%eax
   10cb0:	74 03                	je     10cb5 <net_addr_pton+0x1e4>
					src++;
   10cb2:	43                   	inc    %ebx
   10cb3:	eb 09                	jmp    10cbe <net_addr_pton+0x1ed>
					if (i < 3) {
   10cb5:	83 fe 03             	cmp    $0x3,%esi
   10cb8:	0f 85 48 fe ff ff    	jne    10b06 <net_addr_pton+0x35>
			for (i = 0; i < 4; i++) {
   10cbe:	46                   	inc    %esi
   10cbf:	83 fe 04             	cmp    $0x4,%esi
   10cc2:	75 b9                	jne    10c7d <net_addr_pton+0x1ac>
   10cc4:	e9 7c fe ff ff       	jmp    10b45 <net_addr_pton+0x74>
}
   10cc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10ccc:	5b                   	pop    %ebx
   10ccd:	5e                   	pop    %esi
   10cce:	5f                   	pop    %edi
   10ccf:	5d                   	pop    %ebp
   10cd0:	c3                   	ret    

00010cd1 <net_calc_chksum>:

	return sum;
}

u16_t net_calc_chksum(struct net_pkt *pkt, u8_t proto)
{
   10cd1:	55                   	push   %ebp
   10cd2:	89 e5                	mov    %esp,%ebp
   10cd4:	57                   	push   %edi
   10cd5:	56                   	push   %esi
   10cd6:	53                   	push   %ebx
   10cd7:	83 ec 10             	sub    $0x10,%esp
   10cda:	8b 5d 08             	mov    0x8(%ebp),%ebx
   10cdd:	8b 55 0c             	mov    0xc(%ebp),%edx
	return pkt->family;
   10ce0:	8a 4b 3f             	mov    0x3f(%ebx),%cl
   10ce3:	d0 e9                	shr    %cl
   10ce5:	83 e1 07             	and    $0x7,%ecx
	size_t len = 0U;
	u16_t sum = 0U;
	struct net_pkt_cursor backup;
	bool ow;

	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   10ce8:	80 f9 01             	cmp    $0x1,%cl
   10ceb:	75 2b                	jne    10d18 <net_calc_chksum+0x47>
	    net_pkt_family(pkt) == AF_INET) {
		if (proto != IPPROTO_ICMP) {
   10ced:	80 fa 01             	cmp    $0x1,%dl
   10cf0:	74 5a                	je     10d4c <net_calc_chksum+0x7b>
			len = 2 * sizeof(struct in_addr);
			sum = net_pkt_get_len(pkt) -
   10cf2:	8b 4b 14             	mov    0x14(%ebx),%ecx
	size_t bytes = 0;
   10cf5:	31 f6                	xor    %esi,%esi
	while (buf) {
   10cf7:	85 c9                	test   %ecx,%ecx
   10cf9:	74 0a                	je     10d05 <net_calc_chksum+0x34>
		bytes += buf->len;
   10cfb:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
		buf = buf->frags;
   10cff:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
   10d01:	01 c6                	add    %eax,%esi
		buf = buf->frags;
   10d03:	eb f2                	jmp    10cf7 <net_calc_chksum+0x26>
				net_pkt_ip_hdr_len(pkt) + proto;
   10d05:	0f b6 43 3c          	movzbl 0x3c(%ebx),%eax
   10d09:	0f b6 d2             	movzbl %dl,%edx
			sum = net_pkt_get_len(pkt) -
   10d0c:	29 c2                	sub    %eax,%edx
   10d0e:	8d 3c 32             	lea    (%edx,%esi,1),%edi
			len = 2 * sizeof(struct in_addr);
   10d11:	be 08 00 00 00       	mov    $0x8,%esi
   10d16:	eb 38                	jmp    10d50 <net_calc_chksum+0x7f>
		sum =  net_pkt_get_len(pkt) -
			net_pkt_ip_hdr_len(pkt) -
			net_pkt_ipv6_ext_len(pkt) + proto;
	} else {
		NET_DBG("Unknown protocol family %d", net_pkt_family(pkt));
		return 0;
   10d18:	31 c0                	xor    %eax,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
   10d1a:	80 f9 02             	cmp    $0x2,%cl
   10d1d:	0f 85 15 01 00 00    	jne    10e38 <net_calc_chksum+0x167>
		sum =  net_pkt_get_len(pkt) -
   10d23:	8b 4b 14             	mov    0x14(%ebx),%ecx
	size_t bytes = 0;
   10d26:	31 c0                	xor    %eax,%eax
	while (buf) {
   10d28:	85 c9                	test   %ecx,%ecx
   10d2a:	74 0a                	je     10d36 <net_calc_chksum+0x65>
		bytes += buf->len;
   10d2c:	0f b7 71 0c          	movzwl 0xc(%ecx),%esi
		buf = buf->frags;
   10d30:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
   10d32:	01 f0                	add    %esi,%eax
		buf = buf->frags;
   10d34:	eb f2                	jmp    10d28 <net_calc_chksum+0x57>
			net_pkt_ipv6_ext_len(pkt) + proto;
   10d36:	0f b6 fa             	movzbl %dl,%edi
			net_pkt_ip_hdr_len(pkt) -
   10d39:	0f b6 53 3c          	movzbl 0x3c(%ebx),%edx
		sum =  net_pkt_get_len(pkt) -
   10d3d:	29 d7                	sub    %edx,%edi
		len = 2 * sizeof(struct in6_addr);
   10d3f:	be 20 00 00 00       	mov    $0x20,%esi
		sum =  net_pkt_get_len(pkt) -
   10d44:	66 2b 7b 42          	sub    0x42(%ebx),%di
   10d48:	01 c7                	add    %eax,%edi
   10d4a:	eb 04                	jmp    10d50 <net_calc_chksum+0x7f>
	u16_t sum = 0U;
   10d4c:	31 ff                	xor    %edi,%edi
	size_t len = 0U;
   10d4e:	31 f6                	xor    %esi,%esi
	backup->buf = pkt->cursor.buf;
   10d50:	8b 43 18             	mov    0x18(%ebx),%eax
   10d53:	89 45 ec             	mov    %eax,-0x14(%ebp)
	backup->pos = pkt->cursor.pos;
   10d56:	8b 43 1c             	mov    0x1c(%ebx),%eax
   10d59:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}

	net_pkt_cursor_backup(pkt, &backup);
	net_pkt_cursor_init(pkt);
   10d5c:	53                   	push   %ebx
   10d5d:	e8 0b f2 ff ff       	call   ff6d <net_pkt_cursor_init>
	return pkt->overwrite;
   10d62:	8a 43 3d             	mov    0x3d(%ebx),%al
   10d65:	88 c2                	mov    %al,%dl
	pkt->overwrite = overwrite;
   10d67:	83 c8 01             	or     $0x1,%eax
   10d6a:	88 43 3d             	mov    %al,0x3d(%ebx)
	return pkt->overwrite;
   10d6d:	83 e2 01             	and    $0x1,%edx

	ow = net_pkt_is_being_overwritten(pkt);
	net_pkt_set_overwrite(pkt, true);

	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
   10d70:	0f b6 43 3c          	movzbl 0x3c(%ebx),%eax
   10d74:	29 f0                	sub    %esi,%eax
   10d76:	88 55 f3             	mov    %dl,-0xd(%ebp)
   10d79:	89 04 24             	mov    %eax,(%esp)
   10d7c:	53                   	push   %ebx
   10d7d:	e8 5e f5 ff ff       	call   102e0 <net_pkt_skip>
   10d82:	58                   	pop    %eax
   10d83:	5a                   	pop    %edx

	sum = calc_chksum(sum, pkt->cursor.pos, len);
   10d84:	89 f1                	mov    %esi,%ecx
   10d86:	8b 53 1c             	mov    0x1c(%ebx),%edx
   10d89:	0f b7 c7             	movzwl %di,%eax
   10d8c:	e8 b5 f9 ff ff       	call   10746 <calc_chksum>
   10d91:	89 c2                	mov    %eax,%edx

	net_pkt_skip(pkt, len + net_pkt_ipv6_ext_len(pkt));
   10d93:	0f b7 43 42          	movzwl 0x42(%ebx),%eax
   10d97:	01 c6                	add    %eax,%esi
	sum = calc_chksum(sum, pkt->cursor.pos, len);
   10d99:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	net_pkt_skip(pkt, len + net_pkt_ipv6_ext_len(pkt));
   10d9c:	56                   	push   %esi
   10d9d:	53                   	push   %ebx
   10d9e:	e8 3d f5 ff ff       	call   102e0 <net_pkt_skip>
   10da3:	59                   	pop    %ecx
	if (!cur->buf || !cur->pos) {
   10da4:	8b 4b 18             	mov    0x18(%ebx),%ecx
	net_pkt_skip(pkt, len + net_pkt_ipv6_ext_len(pkt));
   10da7:	5e                   	pop    %esi
	if (!cur->buf || !cur->pos) {
   10da8:	85 c9                	test   %ecx,%ecx
   10daa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10dad:	74 63                	je     10e12 <net_calc_chksum+0x141>
   10daf:	8b 43 1c             	mov    0x1c(%ebx),%eax
   10db2:	85 c0                	test   %eax,%eax
   10db4:	74 5c                	je     10e12 <net_calc_chksum+0x141>
	len = cur->buf->len - (cur->pos - cur->buf->data);
   10db6:	0f b7 71 0c          	movzwl 0xc(%ecx),%esi
   10dba:	2b 41 08             	sub    0x8(%ecx),%eax
   10dbd:	29 c6                	sub    %eax,%esi
	while (cur->buf) {
   10dbf:	8b 7b 18             	mov    0x18(%ebx),%edi
   10dc2:	85 ff                	test   %edi,%edi
   10dc4:	74 4c                	je     10e12 <net_calc_chksum+0x141>
		sum = calc_chksum(sum, cur->pos, len);
   10dc6:	0f b7 c2             	movzwl %dx,%eax
   10dc9:	89 f1                	mov    %esi,%ecx
   10dcb:	8b 53 1c             	mov    0x1c(%ebx),%edx
   10dce:	e8 73 f9 ff ff       	call   10746 <calc_chksum>
		cur->buf = cur->buf->frags;
   10dd3:	8b 0f                	mov    (%edi),%ecx
		sum = calc_chksum(sum, cur->pos, len);
   10dd5:	89 c2                	mov    %eax,%edx
		cur->buf = cur->buf->frags;
   10dd7:	89 4b 18             	mov    %ecx,0x18(%ebx)
		if (!cur->buf || !cur->buf->len) {
   10dda:	85 c9                	test   %ecx,%ecx
   10ddc:	74 34                	je     10e12 <net_calc_chksum+0x141>
   10dde:	8b 41 0c             	mov    0xc(%ecx),%eax
   10de1:	66 85 c0             	test   %ax,%ax
   10de4:	74 2c                	je     10e12 <net_calc_chksum+0x141>
		cur->pos = cur->buf->data;
   10de6:	8b 49 08             	mov    0x8(%ecx),%ecx
		if (len % 2) {
   10de9:	83 e6 01             	and    $0x1,%esi
		cur->pos = cur->buf->data;
   10dec:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
		if (len % 2) {
   10def:	0f b7 f0             	movzwl %ax,%esi
   10df2:	74 cb                	je     10dbf <net_calc_chksum+0xee>
			sum += *cur->pos;
   10df4:	0f b6 01             	movzbl (%ecx),%eax
   10df7:	31 ff                	xor    %edi,%edi
   10df9:	66 01 c2             	add    %ax,%dx
   10dfc:	73 05                	jae    10e03 <net_calc_chksum+0x132>
   10dfe:	bf 01 00 00 00       	mov    $0x1,%edi
				sum++;
   10e03:	66 83 ff 01          	cmp    $0x1,%di
   10e07:	66 83 da ff          	sbb    $0xffff,%dx
			cur->pos++;
   10e0b:	41                   	inc    %ecx
   10e0c:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
			len = cur->buf->len - 1;
   10e0f:	4e                   	dec    %esi
   10e10:	eb ad                	jmp    10dbf <net_calc_chksum+0xee>

	sum = pkt_calc_chksum(pkt, sum);

	sum = (sum == 0) ? 0xffff : htons(sum);
   10e12:	83 c8 ff             	or     $0xffffffff,%eax
   10e15:	66 85 d2             	test   %dx,%dx
   10e18:	74 04                	je     10e1e <net_calc_chksum+0x14d>
   10e1a:	89 d0                	mov    %edx,%eax
   10e1c:	86 e0                	xchg   %ah,%al
	pkt->overwrite = overwrite;
   10e1e:	8a 53 3d             	mov    0x3d(%ebx),%dl
	pkt->cursor.buf = backup->buf;
   10e21:	8b 7d ec             	mov    -0x14(%ebp),%edi
	pkt->overwrite = overwrite;
   10e24:	83 e2 fe             	and    $0xfffffffe,%edx
	pkt->cursor.buf = backup->buf;
   10e27:	89 7b 18             	mov    %edi,0x18(%ebx)
	pkt->overwrite = overwrite;
   10e2a:	0a 55 f3             	or     -0xd(%ebp),%dl
	pkt->cursor.pos = backup->pos;
   10e2d:	8b 7d e8             	mov    -0x18(%ebp),%edi
   10e30:	89 7b 1c             	mov    %edi,0x1c(%ebx)
	pkt->overwrite = overwrite;
   10e33:	88 53 3d             	mov    %dl,0x3d(%ebx)

	net_pkt_cursor_restore(pkt, &backup);

	net_pkt_set_overwrite(pkt, ow);

	return ~sum;
   10e36:	f7 d0                	not    %eax
}
   10e38:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10e3b:	5b                   	pop    %ebx
   10e3c:	5e                   	pop    %esi
   10e3d:	5f                   	pop    %edi
   10e3e:	5d                   	pop    %ebp
   10e3f:	c3                   	ret    

00010e40 <net_calc_chksum_ipv4>:

#if defined(CONFIG_NET_IPV4)
u16_t net_calc_chksum_ipv4(struct net_pkt *pkt)
{
   10e40:	55                   	push   %ebp
   10e41:	89 e5                	mov    %esp,%ebp
   10e43:	8b 45 08             	mov    0x8(%ebp),%eax
	u16_t sum;

	sum = calc_chksum(0, pkt->buffer->data, net_pkt_ip_hdr_len(pkt));
   10e46:	0f b6 48 3c          	movzbl 0x3c(%eax),%ecx
   10e4a:	8b 40 14             	mov    0x14(%eax),%eax
   10e4d:	8b 50 08             	mov    0x8(%eax),%edx
   10e50:	31 c0                	xor    %eax,%eax
   10e52:	e8 ef f8 ff ff       	call   10746 <calc_chksum>

	sum = (sum == 0) ? 0xffff : htons(sum);
   10e57:	83 ca ff             	or     $0xffffffff,%edx
   10e5a:	66 85 c0             	test   %ax,%ax
   10e5d:	74 04                	je     10e63 <net_calc_chksum_ipv4+0x23>
   10e5f:	86 e0                	xchg   %ah,%al
   10e61:	89 c2                	mov    %eax,%edx

	return ~sum;
   10e63:	89 d0                	mov    %edx,%eax
}
   10e65:	5d                   	pop    %ebp
	return ~sum;
   10e66:	f7 d0                	not    %eax
}
   10e68:	c3                   	ret    

00010e69 <icmpv4_create>:
#define PKT_WAIT_TIME K_SECONDS(1)

static sys_slist_t handlers;

static int icmpv4_create(struct net_pkt *pkt, u8_t icmp_type, u8_t icmp_code)
{
   10e69:	55                   	push   %ebp
   10e6a:	89 e5                	mov    %esp,%ebp
   10e6c:	56                   	push   %esi
   10e6d:	53                   	push   %ebx
   10e6e:	89 c3                	mov    %eax,%ebx
   10e70:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10e73:	8d 75 f0             	lea    -0x10(%ebp),%esi
{
   10e76:	89 55 e8             	mov    %edx,-0x18(%ebp)
   10e79:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10e7c:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   10e7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10e84:	50                   	push   %eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   10e85:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10e8c:	e8 d6 f6 ff ff       	call   10567 <net_pkt_get_data>
   10e91:	5a                   	pop    %edx
   10e92:	59                   	pop    %ecx
	if (!icmp_hdr) {
   10e93:	85 c0                	test   %eax,%eax
   10e95:	74 1c                	je     10eb3 <icmpv4_create+0x4a>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
   10e97:	8b 55 e8             	mov    -0x18(%ebp),%edx
	icmp_hdr->code   = icmp_code;
   10e9a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	icmp_hdr->type   = icmp_type;
   10e9d:	88 10                	mov    %dl,(%eax)
	icmp_hdr->code   = icmp_code;
   10e9f:	88 48 01             	mov    %cl,0x1(%eax)
	icmp_hdr->chksum = 0;
   10ea2:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)

	return net_pkt_set_data(pkt, &icmpv4_access);
   10ea8:	56                   	push   %esi
   10ea9:	53                   	push   %ebx
   10eaa:	e8 4f f7 ff ff       	call   105fe <net_pkt_set_data>
   10eaf:	5a                   	pop    %edx
   10eb0:	59                   	pop    %ecx
   10eb1:	eb 05                	jmp    10eb8 <icmpv4_create+0x4f>
		return -ENOBUFS;
   10eb3:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
}
   10eb8:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10ebb:	5b                   	pop    %ebx
   10ebc:	5e                   	pop    %esi
   10ebd:	5d                   	pop    %ebp
   10ebe:	c3                   	ret    

00010ebf <icmpv4_handle_echo_request>:
	return net_pkt_set_data(pkt, &icmpv4_access);
}

static enum net_verdict icmpv4_handle_echo_request(struct net_pkt *pkt,
						   struct net_ipv4_hdr *ip_hdr)
{
   10ebf:	55                   	push   %ebp
   10ec0:	89 e5                	mov    %esp,%ebp
   10ec2:	57                   	push   %edi
   10ec3:	56                   	push   %esi
	s16_t payload_len;

	/* If interface can not select src address based on dst addr
	 * and src address is unspecified, drop the echo request.
	 */
	if (net_ipv4_is_addr_unspecified(&ip_hdr->src)) {
   10ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
{
   10ec7:	53                   	push   %ebx
   10ec8:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (net_ipv4_is_addr_unspecified(&ip_hdr->src)) {
   10ecb:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   10ecf:	0f 84 af 00 00 00    	je     10f84 <icmpv4_handle_echo_request+0xc5>

	NET_DBG("Received Echo Request from %s to %s",
		log_strdup(net_sprint_ipv4_addr(&ip_hdr->src)),
		log_strdup(net_sprint_ipv4_addr(&ip_hdr->dst)));

	payload_len = net_pkt_get_len(pkt) -
   10ed5:	8b 47 14             	mov    0x14(%edi),%eax
	size_t bytes = 0;
   10ed8:	31 db                	xor    %ebx,%ebx
	while (buf) {
   10eda:	85 c0                	test   %eax,%eax
   10edc:	74 0a                	je     10ee8 <icmpv4_handle_echo_request+0x29>
		bytes += buf->len;
   10ede:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   10ee2:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   10ee4:	01 d3                	add    %edx,%ebx
		buf = buf->frags;
   10ee6:	eb f2                	jmp    10eda <icmpv4_handle_echo_request+0x1b>
		net_pkt_ip_hdr_len(pkt) - NET_ICMPH_LEN;
   10ee8:	0f b6 47 3c          	movzbl 0x3c(%edi),%eax
   10eec:	29 c3                	sub    %eax,%ebx
   10eee:	83 eb 04             	sub    $0x4,%ebx
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
   10ef1:	66 83 fb 03          	cmp    $0x3,%bx
   10ef5:	0f 8e 89 00 00 00    	jle    10f84 <icmpv4_handle_echo_request+0xc5>
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
   10efb:	68 e8 03 00 00       	push   $0x3e8
   10f00:	6a 01                	push   $0x1
   10f02:	6a 01                	push   $0x1
   10f04:	0f bf db             	movswl %bx,%ebx
   10f07:	53                   	push   %ebx
   10f08:	ff 77 24             	pushl  0x24(%edi)
   10f0b:	e8 a5 f3 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   10f10:	83 c4 14             	add    $0x14,%esp
   10f13:	89 c6                	mov    %eax,%esi
					  AF_INET, IPPROTO_ICMP,
					  PKT_WAIT_TIME);
	if (!reply) {
   10f15:	85 c0                	test   %eax,%eax
   10f17:	74 6b                	je     10f84 <icmpv4_handle_echo_request+0xc5>
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv4_create(reply, &ip_hdr->dst, &ip_hdr->src) ||
   10f19:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f1c:	83 c0 0c             	add    $0xc,%eax
   10f1f:	50                   	push   %eax
   10f20:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f23:	83 c0 10             	add    $0x10,%eax
   10f26:	50                   	push   %eax
   10f27:	56                   	push   %esi
   10f28:	e8 51 04 00 00       	call   1137e <net_ipv4_create>
   10f2d:	83 c4 0c             	add    $0xc,%esp
   10f30:	85 c0                	test   %eax,%eax
   10f32:	75 49                	jne    10f7d <icmpv4_handle_echo_request+0xbe>
	    icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   10f34:	31 c9                	xor    %ecx,%ecx
   10f36:	31 d2                	xor    %edx,%edx
   10f38:	89 f0                	mov    %esi,%eax
   10f3a:	e8 2a ff ff ff       	call   10e69 <icmpv4_create>
	if (net_ipv4_create(reply, &ip_hdr->dst, &ip_hdr->src) ||
   10f3f:	85 c0                	test   %eax,%eax
   10f41:	75 3a                	jne    10f7d <icmpv4_handle_echo_request+0xbe>
	    net_pkt_copy(reply, pkt, payload_len)) {
   10f43:	53                   	push   %ebx
   10f44:	57                   	push   %edi
   10f45:	56                   	push   %esi
   10f46:	e8 0e f4 ff ff       	call   10359 <net_pkt_copy>
   10f4b:	83 c4 0c             	add    $0xc,%esp
	    icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   10f4e:	85 c0                	test   %eax,%eax
   10f50:	75 2b                	jne    10f7d <icmpv4_handle_echo_request+0xbe>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	net_pkt_cursor_init(reply);
   10f52:	56                   	push   %esi
   10f53:	e8 15 f0 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
   10f58:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
   10f5f:	56                   	push   %esi
   10f60:	e8 a1 04 00 00       	call   11406 <net_ipv4_finalize>
   10f65:	59                   	pop    %ecx
   10f66:	5b                   	pop    %ebx

	NET_DBG("Sending Echo Reply from %s to %s",
		log_strdup(net_sprint_ipv4_addr(&ip_hdr->dst)),
		log_strdup(net_sprint_ipv4_addr(&ip_hdr->src)));

	if (net_send_data(reply) < 0) {
   10f67:	56                   	push   %esi
   10f68:	e8 e0 c8 ff ff       	call   d84d <net_send_data>
   10f6d:	5a                   	pop    %edx
   10f6e:	85 c0                	test   %eax,%eax
   10f70:	78 0b                	js     10f7d <icmpv4_handle_echo_request+0xbe>
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
   10f72:	57                   	push   %edi
   10f73:	e8 89 ee ff ff       	call   fe01 <net_pkt_unref>
   10f78:	5a                   	pop    %edx

	return NET_OK;
   10f79:	31 c0                	xor    %eax,%eax
   10f7b:	eb 0c                	jmp    10f89 <icmpv4_handle_echo_request+0xca>
drop:
	if (reply) {
		net_pkt_unref(reply);
   10f7d:	56                   	push   %esi
   10f7e:	e8 7e ee ff ff       	call   fe01 <net_pkt_unref>
   10f83:	58                   	pop    %eax
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
   10f84:	b8 02 00 00 00       	mov    $0x2,%eax
}
   10f89:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10f8c:	5b                   	pop    %ebx
   10f8d:	5e                   	pop    %esi
   10f8e:	5f                   	pop    %edi
   10f8f:	5d                   	pop    %ebp
   10f90:	c3                   	ret    

00010f91 <net_icmpv4_finalize>:
{
   10f91:	55                   	push   %ebp
   10f92:	89 e5                	mov    %esp,%ebp
   10f94:	57                   	push   %edi
   10f95:	56                   	push   %esi
   10f96:	53                   	push   %ebx
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10f97:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
   10f9a:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   10f9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   10fa4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   10fa7:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   10fae:	56                   	push   %esi
   10faf:	53                   	push   %ebx
   10fb0:	e8 b2 f5 ff ff       	call   10567 <net_pkt_get_data>
   10fb5:	5a                   	pop    %edx
   10fb6:	89 c7                	mov    %eax,%edi
   10fb8:	59                   	pop    %ecx
   10fb9:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!icmp_hdr) {
   10fbe:	85 ff                	test   %edi,%edi
   10fc0:	74 17                	je     10fd9 <net_icmpv4_finalize+0x48>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline u16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
   10fc2:	6a 01                	push   $0x1
   10fc4:	53                   	push   %ebx
   10fc5:	e8 07 fd ff ff       	call   10cd1 <net_calc_chksum>
   10fca:	5a                   	pop    %edx
   10fcb:	59                   	pop    %ecx
	icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
   10fcc:	66 89 47 02          	mov    %ax,0x2(%edi)
	return net_pkt_set_data(pkt, &icmpv4_access);
   10fd0:	56                   	push   %esi
   10fd1:	53                   	push   %ebx
   10fd2:	e8 27 f6 ff ff       	call   105fe <net_pkt_set_data>
   10fd7:	5b                   	pop    %ebx
   10fd8:	5e                   	pop    %esi
}
   10fd9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10fdc:	5b                   	pop    %ebx
   10fdd:	5e                   	pop    %esi
   10fde:	5f                   	pop    %edi
   10fdf:	5d                   	pop    %ebp
   10fe0:	c3                   	ret    

00010fe1 <net_icmpv4_send_echo_request>:

int net_icmpv4_send_echo_request(struct net_if *iface,
				 struct in_addr *dst,
				 u16_t identifier,
				 u16_t sequence)
{
   10fe1:	55                   	push   %ebp
   10fe2:	89 e5                	mov    %esp,%ebp
   10fe4:	57                   	push   %edi
   10fe5:	56                   	push   %esi
	struct net_icmpv4_echo_req *echo_req;
	const struct in_addr *src;
	struct net_pkt *pkt;

	if (!iface->config.ip.ipv4) {
		return -EINVAL;
   10fe6:	bf ea ff ff ff       	mov    $0xffffffea,%edi
{
   10feb:	53                   	push   %ebx
   10fec:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   10fef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   10ff6:	8b 45 08             	mov    0x8(%ebp),%eax
   10ff9:	8b 55 10             	mov    0x10(%ebp),%edx
   10ffc:	8b 4d 14             	mov    0x14(%ebp),%ecx
   10fff:	89 55 e8             	mov    %edx,-0x18(%ebp)
	if (!iface->config.ip.ipv4) {
   11002:	8b 70 08             	mov    0x8(%eax),%esi
{
   11005:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   11008:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	if (!iface->config.ip.ipv4) {
   1100f:	85 f6                	test   %esi,%esi
   11011:	0f 84 a8 00 00 00    	je     110bf <net_icmpv4_send_echo_request+0xde>
	}

	/* Take the first address of the network interface */
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;

	pkt = net_pkt_alloc_with_buffer(iface,
   11017:	68 e8 03 00 00       	push   $0x3e8
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;
   1101c:	83 c6 04             	add    $0x4,%esi
	pkt = net_pkt_alloc_with_buffer(iface,
   1101f:	6a 01                	push   $0x1
					sizeof(struct net_icmpv4_echo_req),
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		return -ENOMEM;
   11021:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	pkt = net_pkt_alloc_with_buffer(iface,
   11026:	6a 01                	push   $0x1
   11028:	6a 04                	push   $0x4
   1102a:	50                   	push   %eax
   1102b:	e8 85 f2 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   11030:	83 c4 14             	add    $0x14,%esp
   11033:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
   11035:	85 c0                	test   %eax,%eax
   11037:	0f 84 82 00 00 00    	je     110bf <net_icmpv4_send_echo_request+0xde>
	}

	if (net_ipv4_create(pkt, src, dst) ||
   1103d:	ff 75 0c             	pushl  0xc(%ebp)
   11040:	56                   	push   %esi
   11041:	50                   	push   %eax
   11042:	e8 37 03 00 00       	call   1137e <net_ipv4_create>
   11047:	83 c4 0c             	add    $0xc,%esp
   1104a:	85 c0                	test   %eax,%eax
   1104c:	74 07                	je     11055 <net_icmpv4_send_echo_request+0x74>
	int ret = -ENOBUFS;
   1104e:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
   11053:	eb 63                	jmp    110b8 <net_icmpv4_send_echo_request+0xd7>
	    icmpv4_create(pkt, NET_ICMPV4_ECHO_REQUEST, 0)) {
   11055:	31 c9                	xor    %ecx,%ecx
   11057:	ba 08 00 00 00       	mov    $0x8,%edx
   1105c:	89 d8                	mov    %ebx,%eax
   1105e:	e8 06 fe ff ff       	call   10e69 <icmpv4_create>
   11063:	89 c7                	mov    %eax,%edi
	if (net_ipv4_create(pkt, src, dst) ||
   11065:	85 c0                	test   %eax,%eax
   11067:	75 e5                	jne    1104e <net_icmpv4_send_echo_request+0x6d>
		goto drop;
	}

	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
   11069:	8d 75 ec             	lea    -0x14(%ebp),%esi
   1106c:	56                   	push   %esi
   1106d:	53                   	push   %ebx
   1106e:	e8 f4 f4 ff ff       	call   10567 <net_pkt_get_data>
   11073:	59                   	pop    %ecx
							pkt, &icmpv4_access);
	if (!echo_req) {
   11074:	85 c0                	test   %eax,%eax
	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
   11076:	5a                   	pop    %edx
	if (!echo_req) {
   11077:	74 d5                	je     1104e <net_icmpv4_send_echo_request+0x6d>
		goto drop;
	}

	echo_req->identifier = htons(identifier);
   11079:	8b 55 e8             	mov    -0x18(%ebp),%edx
	echo_req->sequence   = htons(sequence);
   1107c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	echo_req->identifier = htons(identifier);
   1107f:	86 f2                	xchg   %dh,%dl
	echo_req->sequence   = htons(sequence);
   11081:	86 e9                	xchg   %ch,%cl
	echo_req->identifier = htons(identifier);
   11083:	66 89 10             	mov    %dx,(%eax)
	echo_req->sequence   = htons(sequence);
   11086:	66 89 48 02          	mov    %cx,0x2(%eax)

	net_pkt_set_data(pkt, &icmpv4_access);
   1108a:	56                   	push   %esi
   1108b:	53                   	push   %ebx
   1108c:	e8 6d f5 ff ff       	call   105fe <net_pkt_set_data>
   11091:	5a                   	pop    %edx
   11092:	59                   	pop    %ecx

	net_pkt_cursor_init(pkt);
   11093:	53                   	push   %ebx
   11094:	e8 d4 ee ff ff       	call   ff6d <net_pkt_cursor_init>

	net_ipv4_finalize(pkt, IPPROTO_ICMP);
   11099:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
   110a0:	53                   	push   %ebx
   110a1:	e8 60 03 00 00       	call   11406 <net_ipv4_finalize>
   110a6:	5e                   	pop    %esi
   110a7:	58                   	pop    %eax
	NET_DBG("Sending ICMPv4 Echo Request type %d from %s to %s",
		NET_ICMPV4_ECHO_REQUEST,
		log_strdup(net_sprint_ipv4_addr(src)),
		log_strdup(net_sprint_ipv4_addr(dst)));

	if (net_send_data(pkt) >= 0) {
   110a8:	53                   	push   %ebx
   110a9:	e8 9f c7 ff ff       	call   d84d <net_send_data>
   110ae:	5a                   	pop    %edx
   110af:	85 c0                	test   %eax,%eax
   110b1:	79 0c                	jns    110bf <net_icmpv4_send_echo_request+0xde>
		return 0;
	}

	net_stats_update_icmp_drop(iface);

	ret = -EIO;
   110b3:	bf fb ff ff ff       	mov    $0xfffffffb,%edi

drop:
	net_pkt_unref(pkt);
   110b8:	53                   	push   %ebx
   110b9:	e8 43 ed ff ff       	call   fe01 <net_pkt_unref>
   110be:	58                   	pop    %eax

	return ret;
}
   110bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   110c2:	89 f8                	mov    %edi,%eax
   110c4:	5b                   	pop    %ebx
   110c5:	5e                   	pop    %esi
   110c6:	5f                   	pop    %edi
   110c7:	5d                   	pop    %ebp
   110c8:	c3                   	ret    

000110c9 <net_icmpv4_send_error>:

int net_icmpv4_send_error(struct net_pkt *orig, u8_t type, u8_t code)
{
   110c9:	55                   	push   %ebp
   110ca:	89 e5                	mov    %esp,%ebp
   110cc:	57                   	push   %edi
   110cd:	56                   	push   %esi
   110ce:	53                   	push   %ebx
   110cf:	83 ec 1c             	sub    $0x1c,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   110d2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
   110d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   110dc:	8b 75 08             	mov    0x8(%ebp),%esi
   110df:	89 45 e0             	mov    %eax,-0x20(%ebp)
   110e2:	8b 45 10             	mov    0x10(%ebp),%eax
	int err = -EIO;
	struct net_ipv4_hdr *ip_hdr;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
   110e5:	56                   	push   %esi
{
   110e6:	89 45 dc             	mov    %eax,-0x24(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   110e9:	c7 45 e8 14 00 00 00 	movl   $0x14,-0x18(%ebp)
	net_pkt_cursor_init(orig);
   110f0:	e8 78 ee ff ff       	call   ff6d <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
   110f5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   110f8:	89 04 24             	mov    %eax,(%esp)
   110fb:	56                   	push   %esi
   110fc:	e8 66 f4 ff ff       	call   10567 <net_pkt_get_data>
   11101:	59                   	pop    %ecx
   11102:	5b                   	pop    %ebx
	int err = -EIO;
   11103:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
	if (!ip_hdr) {
   11108:	85 c0                	test   %eax,%eax
   1110a:	0f 84 0b 01 00 00    	je     1121b <net_icmpv4_send_error+0x152>
   11110:	89 c2                	mov    %eax,%edx
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_ICMP) {
   11112:	80 78 09 01          	cmpb   $0x1,0x9(%eax)
   11116:	75 34                	jne    1114c <net_icmpv4_send_error+0x83>
   11118:	89 45 d8             	mov    %eax,-0x28(%ebp)
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   1111b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1111e:	50                   	push   %eax
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   1111f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   11126:	56                   	push   %esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   11127:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   1112e:	e8 34 f4 ff ff       	call   10567 <net_pkt_get_data>
   11133:	5f                   	pop    %edi
   11134:	5a                   	pop    %edx
							orig, &icmpv4_access);
		if (!icmp_hdr || icmp_hdr->code < 8) {
   11135:	85 c0                	test   %eax,%eax
   11137:	74 09                	je     11142 <net_icmpv4_send_error+0x79>
   11139:	80 78 01 07          	cmpb   $0x7,0x1(%eax)
   1113d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11140:	77 0a                	ja     1114c <net_icmpv4_send_error+0x83>
			/* We must not send ICMP errors back */
			err = -EINVAL;
   11142:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
   11147:	e9 cf 00 00 00       	jmp    1121b <net_icmpv4_send_error+0x152>
			goto drop_no_pkt;
		}
	}

	if (ip_hdr->proto == IPPROTO_UDP) {
   1114c:	8a 42 09             	mov    0x9(%edx),%al
		copy_len = sizeof(struct net_ipv4_hdr) +
   1114f:	bf 1c 00 00 00       	mov    $0x1c,%edi
	if (ip_hdr->proto == IPPROTO_UDP) {
   11154:	3c 11                	cmp    $0x11,%al
   11156:	74 0e                	je     11166 <net_icmpv4_send_error+0x9d>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->proto == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv4_hdr) +
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = 0;
   11158:	3c 06                	cmp    $0x6,%al
   1115a:	0f 95 c0             	setne  %al
   1115d:	0f b6 c0             	movzbl %al,%eax
   11160:	89 c7                	mov    %eax,%edi
   11162:	4f                   	dec    %edi
   11163:	83 e7 28             	and    $0x28,%edi
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
   11166:	68 e8 03 00 00       	push   $0x3e8
   1116b:	8d 47 04             	lea    0x4(%edi),%eax
   1116e:	6a 01                	push   $0x1
   11170:	89 55 d8             	mov    %edx,-0x28(%ebp)
   11173:	6a 01                	push   $0x1
   11175:	50                   	push   %eax
   11176:	ff 76 24             	pushl  0x24(%esi)
   11179:	e8 37 f1 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   1117e:	83 c4 14             	add    $0x14,%esp
   11181:	89 c3                	mov    %eax,%ebx
					copy_len + NET_ICMPV4_UNUSED_LEN,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		err =  -ENOMEM;
   11183:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
	if (!pkt) {
   11188:	85 c0                	test   %eax,%eax
   1118a:	0f 84 8b 00 00 00    	je     1121b <net_icmpv4_send_error+0x152>
		goto drop_no_pkt;
	}

	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   11190:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11193:	8d 42 0c             	lea    0xc(%edx),%eax
   11196:	83 c2 10             	add    $0x10,%edx
   11199:	50                   	push   %eax
   1119a:	52                   	push   %edx
   1119b:	53                   	push   %ebx
   1119c:	e8 dd 01 00 00       	call   1137e <net_ipv4_create>
   111a1:	83 c4 0c             	add    $0xc,%esp
   111a4:	85 c0                	test   %eax,%eax
   111a6:	74 0e                	je     111b6 <net_icmpv4_send_error+0xed>
		net_stats_update_icmp_sent(net_pkt_iface(orig));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
   111a8:	53                   	push   %ebx
   111a9:	e8 53 ec ff ff       	call   fe01 <net_pkt_unref>
   111ae:	5b                   	pop    %ebx
	int err = -EIO;
   111af:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
   111b4:	eb 65                	jmp    1121b <net_icmpv4_send_error+0x152>
	    icmpv4_create(pkt, type, code) ||
   111b6:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
   111ba:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
   111be:	89 d8                	mov    %ebx,%eax
   111c0:	e8 a4 fc ff ff       	call   10e69 <icmpv4_create>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   111c5:	85 c0                	test   %eax,%eax
   111c7:	75 df                	jne    111a8 <net_icmpv4_send_error+0xdf>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   111c9:	6a 04                	push   $0x4
   111cb:	6a 00                	push   $0x0
   111cd:	53                   	push   %ebx
   111ce:	e8 2c f1 ff ff       	call   102ff <net_pkt_memset>
   111d3:	83 c4 0c             	add    $0xc,%esp
	    icmpv4_create(pkt, type, code) ||
   111d6:	85 c0                	test   %eax,%eax
   111d8:	75 ce                	jne    111a8 <net_icmpv4_send_error+0xdf>
	    net_pkt_copy(pkt, orig, copy_len)) {
   111da:	57                   	push   %edi
   111db:	56                   	push   %esi
   111dc:	53                   	push   %ebx
   111dd:	e8 77 f1 ff ff       	call   10359 <net_pkt_copy>
   111e2:	83 c4 0c             	add    $0xc,%esp
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   111e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
   111e8:	85 c0                	test   %eax,%eax
   111ea:	75 bc                	jne    111a8 <net_icmpv4_send_error+0xdf>
	net_pkt_cursor_init(pkt);
   111ec:	53                   	push   %ebx
   111ed:	e8 7b ed ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
   111f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
   111f9:	53                   	push   %ebx
   111fa:	e8 07 02 00 00       	call   11406 <net_ipv4_finalize>
   111ff:	58                   	pop    %eax
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   11200:	8b 46 2c             	mov    0x2c(%esi),%eax
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
   11203:	5a                   	pop    %edx
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   11204:	89 43 34             	mov    %eax,0x34(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
   11207:	8a 46 30             	mov    0x30(%esi),%al
   1120a:	88 43 38             	mov    %al,0x38(%ebx)
	if (net_send_data(pkt) >= 0) {
   1120d:	53                   	push   %ebx
   1120e:	e8 3a c6 ff ff       	call   d84d <net_send_data>
   11213:	59                   	pop    %ecx
   11214:	85 c0                	test   %eax,%eax
   11216:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   11219:	78 8d                	js     111a8 <net_icmpv4_send_error+0xdf>
drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;

}
   1121b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1121e:	89 c8                	mov    %ecx,%eax
   11220:	5b                   	pop    %ebx
   11221:	5e                   	pop    %esi
   11222:	5f                   	pop    %edi
   11223:	5d                   	pop    %ebp
   11224:	c3                   	ret    

00011225 <net_icmpv4_register_handler>:

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
   11225:	55                   	push   %ebp
Z_GENLIST_PREPEND(slist, snode)
   11226:	8b 15 b8 42 40 00    	mov    0x4042b8,%edx
   1122c:	89 e5                	mov    %esp,%ebp
   1122e:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
   11231:	89 10                	mov    %edx,(%eax)
	list->head = node;
   11233:	a3 b8 42 40 00       	mov    %eax,0x4042b8
Z_GENLIST_PREPEND(slist, snode)
   11238:	83 3d bc 42 40 00 00 	cmpl   $0x0,0x4042bc
   1123f:	75 05                	jne    11246 <net_icmpv4_register_handler+0x21>
	list->tail = node;
   11241:	a3 bc 42 40 00       	mov    %eax,0x4042bc
	sys_slist_prepend(&handlers, &handler->node);
}
   11246:	5d                   	pop    %ebp
   11247:	c3                   	ret    

00011248 <net_icmpv4_unregister_handler>:

void net_icmpv4_unregister_handler(struct net_icmpv4_handler *handler)
{
   11248:	55                   	push   %ebp
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   11249:	a1 b8 42 40 00       	mov    0x4042b8,%eax
   1124e:	89 e5                	mov    %esp,%ebp
   11250:	31 c9                	xor    %ecx,%ecx
   11252:	8b 55 08             	mov    0x8(%ebp),%edx
   11255:	85 c0                	test   %eax,%eax
   11257:	74 3c                	je     11295 <net_icmpv4_unregister_handler+0x4d>
   11259:	39 c2                	cmp    %eax,%edx
   1125b:	75 32                	jne    1128f <net_icmpv4_unregister_handler+0x47>
Z_GENLIST_REMOVE(slist, snode)
   1125d:	8b 02                	mov    (%edx),%eax
   1125f:	85 c9                	test   %ecx,%ecx
   11261:	75 14                	jne    11277 <net_icmpv4_unregister_handler+0x2f>
	list->head = node;
   11263:	a3 b8 42 40 00       	mov    %eax,0x4042b8
Z_GENLIST_REMOVE(slist, snode)
   11268:	3b 15 bc 42 40 00    	cmp    0x4042bc,%edx
   1126e:	75 17                	jne    11287 <net_icmpv4_unregister_handler+0x3f>
	list->tail = node;
   11270:	a3 bc 42 40 00       	mov    %eax,0x4042bc
   11275:	eb 10                	jmp    11287 <net_icmpv4_unregister_handler+0x3f>
	parent->next = child;
   11277:	89 01                	mov    %eax,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
   11279:	3b 15 bc 42 40 00    	cmp    0x4042bc,%edx
   1127f:	75 06                	jne    11287 <net_icmpv4_unregister_handler+0x3f>
	list->tail = node;
   11281:	89 0d bc 42 40 00    	mov    %ecx,0x4042bc
	parent->next = child;
   11287:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   1128d:	eb 06                	jmp    11295 <net_icmpv4_unregister_handler+0x4d>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1128f:	89 c1                	mov    %eax,%ecx
   11291:	8b 00                	mov    (%eax),%eax
   11293:	eb c0                	jmp    11255 <net_icmpv4_unregister_handler+0xd>
	sys_slist_find_and_remove(&handlers, &handler->node);
}
   11295:	5d                   	pop    %ebp
   11296:	c3                   	ret    

00011297 <net_icmpv4_input>:

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
   11297:	55                   	push   %ebp
   11298:	89 e5                	mov    %esp,%ebp
   1129a:	57                   	push   %edi
   1129b:	56                   	push   %esi
   1129c:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   1129d:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   112a0:	83 ec 0c             	sub    $0xc,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   112a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   112aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
   112ad:	8b 7d 0c             	mov    0xc(%ebp),%edi
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   112b0:	50                   	push   %eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   112b1:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   112b8:	53                   	push   %ebx
   112b9:	e8 a9 f2 ff ff       	call   10567 <net_pkt_get_data>
   112be:	59                   	pop    %ecx
	if (!icmp_hdr) {
   112bf:	85 c0                	test   %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   112c1:	5e                   	pop    %esi
	if (!icmp_hdr) {
   112c2:	75 07                	jne    112cb <net_icmpv4_input+0x34>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
   112c4:	b8 02 00 00 00       	mov    $0x2,%eax
   112c9:	eb 6e                	jmp    11339 <net_icmpv4_input+0xa2>
   112cb:	6a 01                	push   $0x1
   112cd:	89 c6                	mov    %eax,%esi
   112cf:	53                   	push   %ebx
   112d0:	e8 fc f9 ff ff       	call   10cd1 <net_calc_chksum>
	}

	if (net_calc_chksum_icmpv4(pkt) != 0) {
   112d5:	66 85 c0             	test   %ax,%ax
   112d8:	59                   	pop    %ecx
   112d9:	5a                   	pop    %edx
   112da:	75 e8                	jne    112c4 <net_icmpv4_input+0x2d>
		NET_DBG("DROP: Invalid checksum");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &ip_hdr->dst) &&
   112dc:	8b 53 24             	mov    0x24(%ebx),%edx
   112df:	89 55 e8             	mov    %edx,-0x18(%ebp)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   112e2:	e8 c5 01 00 00       	call   114ac <net_ipv4_broadcast_address>
   112e7:	8b 00                	mov    (%eax),%eax
   112e9:	39 47 10             	cmp    %eax,0x10(%edi)
   112ec:	74 d6                	je     112c4 <net_icmpv4_input+0x2d>
   112ee:	8d 47 10             	lea    0x10(%edi),%eax
	return net_if_ipv4_is_addr_bcast(iface, addr);
   112f1:	8b 55 e8             	mov    -0x18(%ebp),%edx
   112f4:	50                   	push   %eax
   112f5:	52                   	push   %edx
   112f6:	e8 69 e0 ff ff       	call   f364 <net_if_ipv4_is_addr_bcast>
   112fb:	59                   	pop    %ecx
   112fc:	84 c0                	test   %al,%al
   112fe:	5a                   	pop    %edx
   112ff:	75 c3                	jne    112c4 <net_icmpv4_input+0x2d>
	return net_pkt_skip(pkt, access->size);
   11301:	ff 75 f0             	pushl  -0x10(%ebp)
   11304:	53                   	push   %ebx
   11305:	e8 d6 ef ff ff       	call   102e0 <net_pkt_skip>
   1130a:	58                   	pop    %eax
	NET_DBG("ICMPv4 packet received type %d code %d",
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   1130b:	a1 b8 42 40 00       	mov    0x4042b8,%eax
   11310:	5a                   	pop    %edx
   11311:	85 c0                	test   %eax,%eax
   11313:	74 af                	je     112c4 <net_icmpv4_input+0x2d>
		if (cb->type == icmp_hdr->type &&
   11315:	8a 0e                	mov    (%esi),%cl
   11317:	38 48 08             	cmp    %cl,0x8(%eax)
   1131a:	75 15                	jne    11331 <net_icmpv4_input+0x9a>
		    (cb->code == icmp_hdr->code || cb->code == 0)) {
   1131c:	8a 50 09             	mov    0x9(%eax),%dl
   1131f:	38 56 01             	cmp    %dl,0x1(%esi)
   11322:	74 04                	je     11328 <net_icmpv4_input+0x91>
   11324:	84 d2                	test   %dl,%dl
   11326:	75 09                	jne    11331 <net_icmpv4_input+0x9a>
			return cb->handler(pkt, ip_hdr);
   11328:	57                   	push   %edi
   11329:	53                   	push   %ebx
   1132a:	ff 50 04             	call   *0x4(%eax)
   1132d:	5a                   	pop    %edx
   1132e:	59                   	pop    %ecx
   1132f:	eb 08                	jmp    11339 <net_icmpv4_input+0xa2>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   11331:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   11333:	85 c0                	test   %eax,%eax
   11335:	75 e0                	jne    11317 <net_icmpv4_input+0x80>
   11337:	eb 8b                	jmp    112c4 <net_icmpv4_input+0x2d>

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
   11339:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1133c:	5b                   	pop    %ebx
   1133d:	5e                   	pop    %esi
   1133e:	5f                   	pop    %edi
   1133f:	5d                   	pop    %ebp
   11340:	c3                   	ret    

00011341 <net_icmpv4_init>:
	.code = 0,
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
   11341:	55                   	push   %ebp
   11342:	89 e5                	mov    %esp,%ebp
	net_icmpv4_register_handler(&echo_request_handler);
   11344:	68 90 a6 40 00       	push   $0x40a690
   11349:	e8 d7 fe ff ff       	call   11225 <net_icmpv4_register_handler>
   1134e:	58                   	pop    %eax
}
   1134f:	c9                   	leave  
   11350:	c3                   	ret    

00011351 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   11351:	8b 00                	mov    (%eax),%eax
   11353:	0f c8                	bswap  %eax
   11355:	25 00 00 00 e0       	and    $0xe0000000,%eax
   1135a:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
   1135f:	0f 94 c0             	sete   %al
}
   11362:	c3                   	ret    

00011363 <net_ipv4_is_addr_bcast>:
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   11363:	8b 0a                	mov    (%edx),%ecx
   11365:	39 0d 34 60 02 00    	cmp    %ecx,0x26034
   1136b:	74 0e                	je     1137b <net_ipv4_is_addr_bcast+0x18>
{
   1136d:	55                   	push   %ebp
   1136e:	89 e5                	mov    %esp,%ebp
	return net_if_ipv4_is_addr_bcast(iface, addr);
   11370:	52                   	push   %edx
   11371:	50                   	push   %eax
   11372:	e8 ed df ff ff       	call   f364 <net_if_ipv4_is_addr_bcast>
   11377:	5a                   	pop    %edx
   11378:	59                   	pop    %ecx
}
   11379:	c9                   	leave  
   1137a:	c3                   	ret    
		return true;
   1137b:	b0 01                	mov    $0x1,%al
}
   1137d:	c3                   	ret    

0001137e <net_ipv4_create>:
#define NET_BUF_TIMEOUT K_MSEC(50)

int net_ipv4_create(struct net_pkt *pkt,
		    const struct in_addr *src,
		    const struct in_addr *dst)
{
   1137e:	55                   	push   %ebp
   1137f:	89 e5                	mov    %esp,%ebp
   11381:	56                   	push   %esi
   11382:	53                   	push   %ebx
   11383:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   11386:	8d 75 f0             	lea    -0x10(%ebp),%esi
{
   11389:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   1138c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   11393:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   11394:	c7 45 f4 14 00 00 00 	movl   $0x14,-0xc(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   1139b:	53                   	push   %ebx
   1139c:	e8 c6 f1 ff ff       	call   10567 <net_pkt_get_data>
   113a1:	5a                   	pop    %edx
   113a2:	89 c2                	mov    %eax,%edx
   113a4:	59                   	pop    %ecx
   113a5:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!ipv4_hdr) {
   113aa:	85 d2                	test   %edx,%edx
   113ac:	74 51                	je     113ff <net_ipv4_create+0x81>
		return -ENOBUFS;
	}

	ipv4_hdr->vhl       = 0x45;
   113ae:	c7 02 45 00 00 00    	movl   $0x45,(%edx)
	ipv4_hdr->tos       = 0x00;
	ipv4_hdr->len       = 0;
	ipv4_hdr->id[0]     = 0;
   113b4:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	ipv4_hdr->id[1]     = 0;
	ipv4_hdr->offset[0] = 0;
	ipv4_hdr->offset[1] = 0;

	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
   113bb:	8a 43 41             	mov    0x41(%ebx),%al
   113be:	88 42 08             	mov    %al,0x8(%edx)
	if (ipv4_hdr->ttl == 0) {
   113c1:	84 c0                	test   %al,%al
   113c3:	75 13                	jne    113d8 <net_ipv4_create+0x5a>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
   113c5:	8b 4b 24             	mov    0x24(%ebx),%ecx
   113c8:	8b 49 08             	mov    0x8(%ecx),%ecx
	if (!iface->config.ip.ipv4) {
   113cb:	85 c9                	test   %ecx,%ecx
   113cd:	74 06                	je     113d5 <net_ipv4_create+0x57>
	return iface->config.ip.ipv4->ttl;
   113cf:	8a 81 10 01 00 00    	mov    0x110(%ecx),%al
   113d5:	88 42 08             	mov    %al,0x8(%edx)
	}

	ipv4_hdr->proto     = 0;
	ipv4_hdr->chksum    = 0;

	net_ipaddr_copy(&ipv4_hdr->dst, dst);
   113d8:	8b 45 10             	mov    0x10(%ebp),%eax
	ipv4_hdr->proto     = 0;
   113db:	c6 42 09 00          	movb   $0x0,0x9(%edx)
	ipv4_hdr->chksum    = 0;
   113df:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
	net_ipaddr_copy(&ipv4_hdr->dst, dst);
   113e5:	8b 00                	mov    (%eax),%eax
   113e7:	89 42 10             	mov    %eax,0x10(%edx)
	net_ipaddr_copy(&ipv4_hdr->src, src);
   113ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   113ed:	8b 00                	mov    (%eax),%eax
   113ef:	89 42 0c             	mov    %eax,0xc(%edx)
	pkt->ip_hdr_len = len;
   113f2:	c6 43 3c 14          	movb   $0x14,0x3c(%ebx)

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
   113f6:	56                   	push   %esi
   113f7:	53                   	push   %ebx
   113f8:	e8 01 f2 ff ff       	call   105fe <net_pkt_set_data>
   113fd:	5a                   	pop    %edx
   113fe:	59                   	pop    %ecx
}
   113ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11402:	5b                   	pop    %ebx
   11403:	5e                   	pop    %esi
   11404:	5d                   	pop    %ebp
   11405:	c3                   	ret    

00011406 <net_ipv4_finalize>:

int net_ipv4_finalize(struct net_pkt *pkt, u8_t next_header_proto)
{
   11406:	55                   	push   %ebp
   11407:	89 e5                	mov    %esp,%ebp
   11409:	57                   	push   %edi
   1140a:	56                   	push   %esi
   1140b:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   1140c:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
   1140f:	83 ec 0c             	sub    $0xc,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   11412:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   11419:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1141c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1141f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   11422:	c7 45 f0 14 00 00 00 	movl   $0x14,-0x10(%ebp)
	pkt->overwrite = overwrite;
   11429:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   1142d:	56                   	push   %esi
   1142e:	53                   	push   %ebx
   1142f:	e8 33 f1 ff ff       	call   10567 <net_pkt_get_data>
   11434:	5f                   	pop    %edi
   11435:	89 c7                	mov    %eax,%edi
   11437:	5a                   	pop    %edx
	if (!ipv4_hdr) {
		return -ENOBUFS;
   11438:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!ipv4_hdr) {
   1143d:	85 ff                	test   %edi,%edi
   1143f:	74 5d                	je     1149e <net_ipv4_finalize+0x98>
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   11441:	8b 43 14             	mov    0x14(%ebx),%eax
	size_t bytes = 0;
   11444:	31 c9                	xor    %ecx,%ecx
	while (buf) {
   11446:	85 c0                	test   %eax,%eax
   11448:	74 0a                	je     11454 <net_ipv4_finalize+0x4e>
		bytes += buf->len;
   1144a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   1144e:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   11450:	01 d1                	add    %edx,%ecx
		buf = buf->frags;
   11452:	eb f2                	jmp    11446 <net_ipv4_finalize+0x40>
	ipv4_hdr->proto = next_header_proto;
   11454:	8a 45 e8             	mov    -0x18(%ebp),%al
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   11457:	86 e9                	xchg   %ch,%cl
	ipv4_hdr->proto = next_header_proto;
   11459:	88 47 09             	mov    %al,0x9(%edi)
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   1145c:	66 89 4f 02          	mov    %cx,0x2(%edi)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   11460:	ff 73 24             	pushl  0x24(%ebx)
   11463:	e8 b3 e3 ff ff       	call   f81b <net_if_need_calc_tx_checksum>
   11468:	59                   	pop    %ecx
   11469:	84 c0                	test   %al,%al
   1146b:	74 0b                	je     11478 <net_ipv4_finalize+0x72>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
   1146d:	53                   	push   %ebx
   1146e:	e8 cd f9 ff ff       	call   10e40 <net_calc_chksum_ipv4>
   11473:	5a                   	pop    %edx
   11474:	66 89 47 0a          	mov    %ax,0xa(%edi)
	}

	net_pkt_set_data(pkt, &ipv4_access);
   11478:	56                   	push   %esi
   11479:	53                   	push   %ebx
   1147a:	e8 7f f1 ff ff       	call   105fe <net_pkt_set_data>
   1147f:	59                   	pop    %ecx
   11480:	5e                   	pop    %esi

	if (IS_ENABLED(CONFIG_NET_UDP) &&
   11481:	80 7d e8 11          	cmpb   $0x11,-0x18(%ebp)
   11485:	75 08                	jne    1148f <net_ipv4_finalize+0x89>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
   11487:	53                   	push   %ebx
   11488:	e8 fc 53 00 00       	call   16889 <net_udp_finalize>
   1148d:	eb 0e                	jmp    1149d <net_ipv4_finalize+0x97>
		return net_tcp_finalize(pkt);
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
   1148f:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMP) {
   11491:	80 7d e8 01          	cmpb   $0x1,-0x18(%ebp)
   11495:	75 07                	jne    1149e <net_ipv4_finalize+0x98>
		return net_icmpv4_finalize(pkt);
   11497:	53                   	push   %ebx
   11498:	e8 f4 fa ff ff       	call   10f91 <net_icmpv4_finalize>
   1149d:	5a                   	pop    %edx
}
   1149e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   114a1:	5b                   	pop    %ebx
   114a2:	5e                   	pop    %esi
   114a3:	5f                   	pop    %edi
   114a4:	5d                   	pop    %ebp
   114a5:	c3                   	ret    

000114a6 <net_ipv4_unspecified_address>:
const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
}
   114a6:	b8 38 60 02 00       	mov    $0x26038,%eax
   114ab:	c3                   	ret    

000114ac <net_ipv4_broadcast_address>:
const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
   114ac:	b8 34 60 02 00       	mov    $0x26034,%eax
   114b1:	c3                   	ret    

000114b2 <net_ipv4_input>:

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
   114b2:	55                   	push   %ebp
   114b3:	89 e5                	mov    %esp,%ebp
   114b5:	57                   	push   %edi
   114b6:	56                   	push   %esi
	size_t bytes = 0;
   114b7:	31 ff                	xor    %edi,%edi
   114b9:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   114ba:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   114bd:	83 ec 24             	sub    $0x24,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   114c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
{
   114c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   114c6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   114cd:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   114d4:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
	int real_len = net_pkt_get_len(pkt);
   114db:	8b 43 14             	mov    0x14(%ebx),%eax
	while (buf) {
   114de:	85 c0                	test   %eax,%eax
   114e0:	74 0a                	je     114ec <net_ipv4_input+0x3a>
		bytes += buf->len;
   114e2:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   114e6:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   114e8:	01 d7                	add    %edx,%edi
		buf = buf->frags;
   114ea:	eb f2                	jmp    114de <net_ipv4_input+0x2c>
	u8_t hdr_len;
	int pkt_len;

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   114ec:	8d 45 dc             	lea    -0x24(%ebp),%eax
   114ef:	50                   	push   %eax
   114f0:	53                   	push   %ebx
   114f1:	e8 71 f0 ff ff       	call   10567 <net_pkt_get_data>
   114f6:	59                   	pop    %ecx
	if (!hdr) {
   114f7:	85 c0                	test   %eax,%eax
	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   114f9:	5e                   	pop    %esi
   114fa:	89 c6                	mov    %eax,%esi
	if (!hdr) {
   114fc:	0f 84 09 01 00 00    	je     1160b <net_ipv4_input+0x159>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4;
   11502:	8a 00                	mov    (%eax),%al
   11504:	83 e0 0f             	and    $0xf,%eax
   11507:	c1 e0 02             	shl    $0x2,%eax
   1150a:	88 45 d3             	mov    %al,-0x2d(%ebp)
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
   1150d:	3c 13                	cmp    $0x13,%al
   1150f:	0f 86 f6 00 00 00    	jbe    1160b <net_ipv4_input+0x159>
	pkt->ip_hdr_len = len;
   11515:	88 43 3c             	mov    %al,0x3c(%ebx)
		goto drop;
	}

	net_pkt_set_ip_hdr_len(pkt, hdr_len);

	pkt_len = ntohs(hdr->len);
   11518:	66 8b 46 02          	mov    0x2(%esi),%ax
   1151c:	86 e0                	xchg   %ah,%al
   1151e:	0f b7 c0             	movzwl %ax,%eax
	if (real_len < pkt_len) {
   11521:	39 f8                	cmp    %edi,%eax
   11523:	0f 8f e2 00 00 00    	jg     1160b <net_ipv4_input+0x159>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
   11529:	7d 09                	jge    11534 <net_ipv4_input+0x82>
		net_pkt_update_length(pkt, pkt_len);
   1152b:	50                   	push   %eax
   1152c:	53                   	push   %ebx
   1152d:	e8 4e ef ff ff       	call   10480 <net_pkt_update_length>
   11532:	58                   	pop    %eax
   11533:	5a                   	pop    %edx
	}

	if (net_ipv4_is_addr_mcast(&hdr->src)) {
   11534:	8d 56 0c             	lea    0xc(%esi),%edx
   11537:	89 d0                	mov    %edx,%eax
   11539:	e8 13 fe ff ff       	call   11351 <net_ipv4_is_addr_mcast>
   1153e:	84 c0                	test   %al,%al
   11540:	0f 85 c5 00 00 00    	jne    1160b <net_ipv4_input+0x159>
		NET_DBG("DROP: src addr is mcast");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->src)) {
   11546:	8b 43 24             	mov    0x24(%ebx),%eax
   11549:	e8 15 fe ff ff       	call   11363 <net_ipv4_is_addr_bcast>
   1154e:	84 c0                	test   %al,%al
   11550:	0f 85 b5 00 00 00    	jne    1160b <net_ipv4_input+0x159>
		NET_DBG("DROP: src addr is bcast");
		goto drop;
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   11556:	ff 73 24             	pushl  0x24(%ebx)
   11559:	e8 dd e2 ff ff       	call   f83b <net_if_need_calc_rx_checksum>
   1155e:	5f                   	pop    %edi
   1155f:	84 c0                	test   %al,%al
   11561:	75 21                	jne    11584 <net_ipv4_input+0xd2>
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   11563:	6a 00                	push   $0x0
	    net_calc_chksum_ipv4(pkt) != 0) {
		NET_DBG("DROP: invalid chksum");
		goto drop;
	}

	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
   11565:	8d 7e 10             	lea    0x10(%esi),%edi
   11568:	57                   	push   %edi
   11569:	e8 6e df ff ff       	call   f4dc <net_if_ipv4_addr_lookup>
   1156e:	5a                   	pop    %edx
   1156f:	85 c0                	test   %eax,%eax
   11571:	59                   	pop    %ecx
   11572:	0f 95 c2             	setne  %dl
	if (!ret) {
   11575:	75 1b                	jne    11592 <net_ipv4_input+0xe0>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
   11577:	89 fa                	mov    %edi,%edx
   11579:	31 c0                	xor    %eax,%eax
   1157b:	e8 e3 fd ff ff       	call   11363 <net_ipv4_is_addr_bcast>
   11580:	88 c2                	mov    %al,%dl
   11582:	eb 0e                	jmp    11592 <net_ipv4_input+0xe0>
	    net_calc_chksum_ipv4(pkt) != 0) {
   11584:	53                   	push   %ebx
   11585:	e8 b6 f8 ff ff       	call   10e40 <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   1158a:	66 85 c0             	test   %ax,%ax
	    net_calc_chksum_ipv4(pkt) != 0) {
   1158d:	59                   	pop    %ecx
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   1158e:	74 d3                	je     11563 <net_ipv4_input+0xb1>
   11590:	eb 79                	jmp    1160b <net_ipv4_input+0x159>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
   11592:	84 d2                	test   %dl,%dl
   11594:	75 0b                	jne    115a1 <net_ipv4_input+0xef>
	    !net_ipv4_is_addr_mcast(&hdr->dst)) ||
   11596:	89 f8                	mov    %edi,%eax
   11598:	e8 b4 fd ff ff       	call   11351 <net_ipv4_is_addr_mcast>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
   1159d:	84 c0                	test   %al,%al
   1159f:	74 6a                	je     1160b <net_ipv4_input+0x159>
	    ((hdr->proto == IPPROTO_UDP &&
   115a1:	8a 46 09             	mov    0x9(%esi),%al
	    !net_ipv4_is_addr_mcast(&hdr->dst)) ||
   115a4:	3c 11                	cmp    $0x11,%al
   115a6:	75 1e                	jne    115c6 <net_ipv4_input+0x114>
	    ((hdr->proto == IPPROTO_UDP &&
   115a8:	8b 46 10             	mov    0x10(%esi),%eax
   115ab:	39 05 34 60 02 00    	cmp    %eax,0x26034
   115b1:	74 58                	je     1160b <net_ipv4_input+0x159>
	return net_pkt_skip(pkt, access->size);
   115b3:	ff 75 e0             	pushl  -0x20(%ebp)
   115b6:	53                   	push   %ebx
   115b7:	e8 24 ed ff ff       	call   102e0 <net_pkt_skip>
   115bc:	58                   	pop    %eax
   115bd:	5a                   	pop    %edx
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ipv4_access);

	if (hdr_len > sizeof(struct net_ipv4_hdr)) {
   115be:	80 7d d3 14          	cmpb   $0x14,-0x2d(%ebp)
   115c2:	74 2a                	je     115ee <net_ipv4_input+0x13c>
   115c4:	eb 14                	jmp    115da <net_ipv4_input+0x128>
	      !IS_ENABLED(CONFIG_NET_DHCPV4)) ||
   115c6:	3c 06                	cmp    $0x6,%al
   115c8:	75 e9                	jne    115b3 <net_ipv4_input+0x101>
	      net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->dst)))) {
   115ca:	8b 43 24             	mov    0x24(%ebx),%eax
   115cd:	89 fa                	mov    %edi,%edx
   115cf:	e8 8f fd ff ff       	call   11363 <net_ipv4_is_addr_bcast>
	     (hdr->proto == IPPROTO_TCP &&
   115d4:	84 c0                	test   %al,%al
   115d6:	74 db                	je     115b3 <net_ipv4_input+0x101>
   115d8:	eb 31                	jmp    1160b <net_ipv4_input+0x159>
		/* There are probably options, let's skip them */
		if (net_pkt_skip(pkt, hdr_len - sizeof(struct net_ipv4_hdr))) {
   115da:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
   115de:	83 e8 14             	sub    $0x14,%eax
   115e1:	50                   	push   %eax
   115e2:	53                   	push   %ebx
   115e3:	e8 f8 ec ff ff       	call   102e0 <net_pkt_skip>
   115e8:	59                   	pop    %ecx
   115e9:	85 c0                	test   %eax,%eax
   115eb:	5f                   	pop    %edi
   115ec:	75 1d                	jne    1160b <net_ipv4_input+0x159>
	pkt->ipv4_ttl = ttl;
   115ee:	8a 46 08             	mov    0x8(%esi),%al
   115f1:	88 43 41             	mov    %al,0x41(%ebx)
	pkt->family = family;
   115f4:	8a 43 3f             	mov    0x3f(%ebx),%al
   115f7:	83 e0 f1             	and    $0xfffffff1,%eax
   115fa:	83 c8 02             	or     $0x2,%eax
   115fd:	88 43 3f             	mov    %al,0x3f(%ebx)

	NET_DBG("IPv4 packet received from %s to %s",
		log_strdup(net_sprint_ipv4_addr(&hdr->src)),
		log_strdup(net_sprint_ipv4_addr(&hdr->dst)));

	switch (hdr->proto) {
   11600:	8a 46 09             	mov    0x9(%esi),%al
   11603:	3c 01                	cmp    $0x1,%al
   11605:	74 0b                	je     11612 <net_ipv4_input+0x160>
   11607:	3c 11                	cmp    $0x11,%al
   11609:	74 17                	je     11622 <net_ipv4_input+0x170>
	if (verdict != NET_DROP) {
		return verdict;
	}
drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
   1160b:	b8 02 00 00 00       	mov    $0x2,%eax
   11610:	eb 43                	jmp    11655 <net_ipv4_input+0x1a3>
		verdict = net_icmpv4_input(pkt, hdr);
   11612:	56                   	push   %esi
   11613:	53                   	push   %ebx
   11614:	e8 7e fc ff ff       	call   11297 <net_icmpv4_input>
   11619:	5f                   	pop    %edi
	if (verdict == NET_DROP) {
   1161a:	83 f8 02             	cmp    $0x2,%eax
		verdict = net_icmpv4_input(pkt, hdr);
   1161d:	5a                   	pop    %edx
	if (verdict == NET_DROP) {
   1161e:	75 17                	jne    11637 <net_ipv4_input+0x185>
   11620:	eb e9                	jmp    1160b <net_ipv4_input+0x159>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
   11622:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11625:	50                   	push   %eax
   11626:	53                   	push   %ebx
   11627:	e8 dc 52 00 00       	call   16908 <net_udp_input>
   1162c:	5a                   	pop    %edx
   1162d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   11630:	59                   	pop    %ecx
		if (proto_hdr.udp) {
   11631:	85 c0                	test   %eax,%eax
   11633:	74 d6                	je     1160b <net_ipv4_input+0x159>
			verdict = NET_OK;
   11635:	31 c0                	xor    %eax,%eax
	} else if (hdr->proto == IPPROTO_ICMP) {
   11637:	0f b6 56 09          	movzbl 0x9(%esi),%edx
   1163b:	80 fa 01             	cmp    $0x1,%dl
   1163e:	74 15                	je     11655 <net_ipv4_input+0x1a3>
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
   11640:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	ip.ipv4 = hdr;
   11643:	89 75 d8             	mov    %esi,-0x28(%ebp)
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
   11646:	50                   	push   %eax
   11647:	8d 45 d8             	lea    -0x28(%ebp),%eax
   1164a:	52                   	push   %edx
   1164b:	50                   	push   %eax
   1164c:	53                   	push   %ebx
   1164d:	e8 a5 4f 00 00       	call   165f7 <net_conn_input>
   11652:	83 c4 10             	add    $0x10,%esp
}
   11655:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11658:	5b                   	pop    %ebx
   11659:	5e                   	pop    %esi
   1165a:	5f                   	pop    %edi
   1165b:	5d                   	pop    %ebp
   1165c:	c3                   	ret    

0001165d <net_icmpv6_register_handler>:

	return "?";
}

void net_icmpv6_register_handler(struct net_icmpv6_handler *handler)
{
   1165d:	55                   	push   %ebp
Z_GENLIST_PREPEND(slist, snode)
   1165e:	8b 15 c0 42 40 00    	mov    0x4042c0,%edx
   11664:	89 e5                	mov    %esp,%ebp
   11666:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
   11669:	89 10                	mov    %edx,(%eax)
	list->head = node;
   1166b:	a3 c0 42 40 00       	mov    %eax,0x4042c0
Z_GENLIST_PREPEND(slist, snode)
   11670:	83 3d c4 42 40 00 00 	cmpl   $0x0,0x4042c4
   11677:	75 05                	jne    1167e <net_icmpv6_register_handler+0x21>
	list->tail = node;
   11679:	a3 c4 42 40 00       	mov    %eax,0x4042c4
	sys_slist_prepend(&handlers, &handler->node);
}
   1167e:	5d                   	pop    %ebp
   1167f:	c3                   	ret    

00011680 <net_icmpv6_unregister_handler>:

void net_icmpv6_unregister_handler(struct net_icmpv6_handler *handler)
{
   11680:	55                   	push   %ebp
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   11681:	a1 c0 42 40 00       	mov    0x4042c0,%eax
   11686:	89 e5                	mov    %esp,%ebp
   11688:	31 c9                	xor    %ecx,%ecx
   1168a:	8b 55 08             	mov    0x8(%ebp),%edx
   1168d:	85 c0                	test   %eax,%eax
   1168f:	74 3c                	je     116cd <net_icmpv6_unregister_handler+0x4d>
   11691:	39 c2                	cmp    %eax,%edx
   11693:	75 32                	jne    116c7 <net_icmpv6_unregister_handler+0x47>
Z_GENLIST_REMOVE(slist, snode)
   11695:	8b 02                	mov    (%edx),%eax
   11697:	85 c9                	test   %ecx,%ecx
   11699:	75 14                	jne    116af <net_icmpv6_unregister_handler+0x2f>
	list->head = node;
   1169b:	a3 c0 42 40 00       	mov    %eax,0x4042c0
Z_GENLIST_REMOVE(slist, snode)
   116a0:	3b 15 c4 42 40 00    	cmp    0x4042c4,%edx
   116a6:	75 17                	jne    116bf <net_icmpv6_unregister_handler+0x3f>
	list->tail = node;
   116a8:	a3 c4 42 40 00       	mov    %eax,0x4042c4
   116ad:	eb 10                	jmp    116bf <net_icmpv6_unregister_handler+0x3f>
	parent->next = child;
   116af:	89 01                	mov    %eax,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
   116b1:	3b 15 c4 42 40 00    	cmp    0x4042c4,%edx
   116b7:	75 06                	jne    116bf <net_icmpv6_unregister_handler+0x3f>
	list->tail = node;
   116b9:	89 0d c4 42 40 00    	mov    %ecx,0x4042c4
	parent->next = child;
   116bf:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   116c5:	eb 06                	jmp    116cd <net_icmpv6_unregister_handler+0x4d>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   116c7:	89 c1                	mov    %eax,%ecx
   116c9:	8b 00                	mov    (%eax),%eax
   116cb:	eb c0                	jmp    1168d <net_icmpv6_unregister_handler+0xd>
	sys_slist_find_and_remove(&handlers, &handler->node);
}
   116cd:	5d                   	pop    %ebp
   116ce:	c3                   	ret    

000116cf <net_icmpv6_finalize>:

int net_icmpv6_finalize(struct net_pkt *pkt)
{
   116cf:	55                   	push   %ebp
   116d0:	89 e5                	mov    %esp,%ebp
   116d2:	57                   	push   %edi
   116d3:	56                   	push   %esi
   116d4:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   116d5:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
   116d8:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   116db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   116e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   116e5:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   116ec:	56                   	push   %esi
   116ed:	53                   	push   %ebx
   116ee:	e8 74 ee ff ff       	call   10567 <net_pkt_get_data>
   116f3:	5a                   	pop    %edx
   116f4:	89 c7                	mov    %eax,%edi
   116f6:	59                   	pop    %ecx
   116f7:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!icmp_hdr) {
   116fc:	85 ff                	test   %edi,%edi
   116fe:	74 17                	je     11717 <net_icmpv6_finalize+0x48>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
   11700:	6a 3a                	push   $0x3a
   11702:	53                   	push   %ebx
   11703:	e8 c9 f5 ff ff       	call   10cd1 <net_calc_chksum>
   11708:	5a                   	pop    %edx
   11709:	59                   	pop    %ecx
		return -ENOBUFS;
	}

	icmp_hdr->chksum = net_calc_chksum_icmpv6(pkt);
   1170a:	66 89 47 02          	mov    %ax,0x2(%edi)

	return net_pkt_set_data(pkt, &icmp_access);
   1170e:	56                   	push   %esi
   1170f:	53                   	push   %ebx
   11710:	e8 e9 ee ff ff       	call   105fe <net_pkt_set_data>
   11715:	5b                   	pop    %ebx
   11716:	5e                   	pop    %esi
}
   11717:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1171a:	5b                   	pop    %ebx
   1171b:	5e                   	pop    %esi
   1171c:	5f                   	pop    %edi
   1171d:	5d                   	pop    %ebp
   1171e:	c3                   	ret    

0001171f <net_icmpv6_create>:

int net_icmpv6_create(struct net_pkt *pkt, u8_t icmp_type, u8_t icmp_code)
{
   1171f:	55                   	push   %ebp
   11720:	89 e5                	mov    %esp,%ebp
   11722:	57                   	push   %edi
   11723:	56                   	push   %esi
   11724:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11725:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
   11728:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   1172b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   11732:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   11735:	8b 7d 10             	mov    0x10(%ebp),%edi
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11738:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   11739:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11740:	ff 75 08             	pushl  0x8(%ebp)
   11743:	e8 1f ee ff ff       	call   10567 <net_pkt_get_data>
   11748:	5a                   	pop    %edx
   11749:	89 c2                	mov    %eax,%edx
   1174b:	59                   	pop    %ecx
   1174c:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!icmp_hdr) {
   11751:	85 d2                	test   %edx,%edx
   11753:	74 18                	je     1176d <net_icmpv6_create+0x4e>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
	icmp_hdr->code   = icmp_code;
   11755:	89 f8                	mov    %edi,%eax
	icmp_hdr->type   = icmp_type;
   11757:	88 1a                	mov    %bl,(%edx)
	icmp_hdr->code   = icmp_code;
   11759:	88 42 01             	mov    %al,0x1(%edx)
	icmp_hdr->chksum = 0;
   1175c:	66 c7 42 02 00 00    	movw   $0x0,0x2(%edx)

	return net_pkt_set_data(pkt, &icmp_access);
   11762:	56                   	push   %esi
   11763:	ff 75 08             	pushl  0x8(%ebp)
   11766:	e8 93 ee ff ff       	call   105fe <net_pkt_set_data>
   1176b:	5a                   	pop    %edx
   1176c:	59                   	pop    %ecx
}
   1176d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11770:	5b                   	pop    %ebx
   11771:	5e                   	pop    %esi
   11772:	5f                   	pop    %edi
   11773:	5d                   	pop    %ebp
   11774:	c3                   	ret    

00011775 <icmpv6_handle_echo_request>:

static
enum net_verdict icmpv6_handle_echo_request(struct net_pkt *pkt,
					    struct net_ipv6_hdr *ip_hdr,
					    struct net_icmp_hdr *icmp_hdr)
{
   11775:	55                   	push   %ebp
   11776:	89 e5                	mov    %esp,%ebp
   11778:	57                   	push   %edi
   11779:	56                   	push   %esi
   1177a:	53                   	push   %ebx
   1177b:	51                   	push   %ecx
   1177c:	8b 75 0c             	mov    0xc(%ebp),%esi
   1177f:	8b 7d 08             	mov    0x8(%ebp),%edi

	NET_DBG("Received Echo Request from %s to %s",
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->dst)));

	payload_len = ntohs(ip_hdr->len) -
   11782:	66 8b 46 04          	mov    0x4(%esi),%ax
   11786:	86 e0                	xchg   %ah,%al
   11788:	66 2b 47 42          	sub    0x42(%edi),%ax
   1178c:	83 e8 04             	sub    $0x4,%eax
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
	if (payload_len < NET_ICMPV6_UNUSED_LEN) {
   1178f:	66 83 f8 03          	cmp    $0x3,%ax
   11793:	0f 8e ae 00 00 00    	jle    11847 <icmpv6_handle_echo_request+0xd2>
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
   11799:	68 e8 03 00 00       	push   $0x3e8
   1179e:	6a 3a                	push   $0x3a
   117a0:	6a 02                	push   $0x2
   117a2:	98                   	cwtl   
   117a3:	50                   	push   %eax
   117a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
   117a7:	ff 77 24             	pushl  0x24(%edi)
   117aa:	e8 06 eb ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   117af:	83 c4 14             	add    $0x14,%esp
   117b2:	89 c3                	mov    %eax,%ebx
					  AF_INET6, IPPROTO_ICMPV6,
					  PKT_WAIT_TIME);
	if (!reply) {
   117b4:	85 c0                	test   %eax,%eax
   117b6:	0f 84 8b 00 00 00    	je     11847 <icmpv6_handle_echo_request+0xd2>
	return addr->s6_addr[0] == 0xFF;
   117bc:	8d 46 18             	lea    0x18(%esi),%eax
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
   117bf:	80 7e 18 ff          	cmpb   $0xff,0x18(%esi)
   117c3:	75 0b                	jne    117d0 <icmpv6_handle_echo_request+0x5b>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
   117c5:	50                   	push   %eax
   117c6:	ff 77 24             	pushl  0x24(%edi)
   117c9:	e8 bd d9 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   117ce:	59                   	pop    %ecx
   117cf:	5a                   	pop    %edx
	 * Same for source as it points to original pkt ll src address.
	 */
	net_pkt_lladdr_dst(reply)->addr = NULL;
	net_pkt_lladdr_src(reply)->addr = NULL;

	if (net_ipv6_create(reply, src, &ip_hdr->src)) {
   117d0:	83 c6 08             	add    $0x8,%esi
	net_pkt_lladdr_dst(reply)->addr = NULL;
   117d3:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
	net_pkt_lladdr_src(reply)->addr = NULL;
   117da:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	if (net_ipv6_create(reply, src, &ip_hdr->src)) {
   117e1:	56                   	push   %esi
   117e2:	50                   	push   %eax
   117e3:	53                   	push   %ebx
   117e4:	e8 52 05 00 00       	call   11d3b <net_ipv6_create>
   117e9:	83 c4 0c             	add    $0xc,%esp
   117ec:	85 c0                	test   %eax,%eax
   117ee:	75 50                	jne    11840 <icmpv6_handle_echo_request+0xcb>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
   117f0:	6a 00                	push   $0x0
   117f2:	68 81 00 00 00       	push   $0x81
   117f7:	53                   	push   %ebx
   117f8:	e8 22 ff ff ff       	call   1171f <net_icmpv6_create>
   117fd:	83 c4 0c             	add    $0xc,%esp
   11800:	85 c0                	test   %eax,%eax
   11802:	75 3c                	jne    11840 <icmpv6_handle_echo_request+0xcb>
	    net_pkt_copy(reply, pkt, payload_len)) {
   11804:	ff 75 f0             	pushl  -0x10(%ebp)
   11807:	57                   	push   %edi
   11808:	53                   	push   %ebx
   11809:	e8 4b eb ff ff       	call   10359 <net_pkt_copy>
   1180e:	83 c4 0c             	add    $0xc,%esp
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
   11811:	85 c0                	test   %eax,%eax
   11813:	75 2b                	jne    11840 <icmpv6_handle_echo_request+0xcb>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	net_pkt_cursor_init(reply);
   11815:	53                   	push   %ebx
   11816:	e8 52 e7 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(reply, IPPROTO_ICMPV6);
   1181b:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   11822:	53                   	push   %ebx
   11823:	e8 c3 05 00 00       	call   11deb <net_ipv6_finalize>
   11828:	59                   	pop    %ecx
   11829:	5e                   	pop    %esi

	NET_DBG("Sending Echo Reply from %s to %s",
		log_strdup(net_sprint_ipv6_addr(src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)));

	if (net_send_data(reply) < 0) {
   1182a:	53                   	push   %ebx
   1182b:	e8 1d c0 ff ff       	call   d84d <net_send_data>
   11830:	5a                   	pop    %edx
   11831:	85 c0                	test   %eax,%eax
   11833:	78 0b                	js     11840 <icmpv6_handle_echo_request+0xcb>
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
   11835:	57                   	push   %edi
   11836:	e8 c6 e5 ff ff       	call   fe01 <net_pkt_unref>
   1183b:	5a                   	pop    %edx

	return NET_OK;
   1183c:	31 c0                	xor    %eax,%eax
   1183e:	eb 0c                	jmp    1184c <icmpv6_handle_echo_request+0xd7>

drop:
	if (reply) {
		net_pkt_unref(reply);
   11840:	53                   	push   %ebx
   11841:	e8 bb e5 ff ff       	call   fe01 <net_pkt_unref>
   11846:	58                   	pop    %eax
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
   11847:	b8 02 00 00 00       	mov    $0x2,%eax
}
   1184c:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1184f:	5b                   	pop    %ebx
   11850:	5e                   	pop    %esi
   11851:	5f                   	pop    %edi
   11852:	5d                   	pop    %ebp
   11853:	c3                   	ret    

00011854 <net_icmpv6_send_error>:

int net_icmpv6_send_error(struct net_pkt *orig, u8_t type, u8_t code,
			  u32_t param)
{
   11854:	55                   	push   %ebp
   11855:	89 e5                	mov    %esp,%ebp
   11857:	57                   	push   %edi
   11858:	56                   	push   %esi
   11859:	53                   	push   %ebx
   1185a:	83 ec 18             	sub    $0x18,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   1185d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
   11864:	8b 45 0c             	mov    0xc(%ebp),%eax
   11867:	8b 75 08             	mov    0x8(%ebp),%esi
   1186a:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1186d:	8b 45 10             	mov    0x10(%ebp),%eax
	struct net_ipv6_hdr *ip_hdr;
	const struct in6_addr *src;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
   11870:	56                   	push   %esi
{
   11871:	89 45 dc             	mov    %eax,-0x24(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11874:	c7 45 e8 28 00 00 00 	movl   $0x28,-0x18(%ebp)
	net_pkt_cursor_init(orig);
   1187b:	e8 ed e6 ff ff       	call   ff6d <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
   11880:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11883:	89 04 24             	mov    %eax,(%esp)
   11886:	56                   	push   %esi
   11887:	e8 db ec ff ff       	call   10567 <net_pkt_get_data>
   1188c:	5b                   	pop    %ebx
   1188d:	5f                   	pop    %edi
	int err = -EIO;
   1188e:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
	if (!ip_hdr) {
   11893:	85 c0                	test   %eax,%eax
   11895:	0f 84 6c 01 00 00    	je     11a07 <net_icmpv6_send_error+0x1b3>
   1189b:	89 c7                	mov    %eax,%edi
		goto drop_no_pkt;
	}

	if (ip_hdr->nexthdr == IPPROTO_ICMPV6) {
   1189d:	80 78 06 3a          	cmpb   $0x3a,0x6(%eax)
   118a1:	75 40                	jne    118e3 <net_icmpv6_send_error+0x8f>
	return net_pkt_skip(pkt, access->size);
   118a3:	ff 75 e8             	pushl  -0x18(%ebp)
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
   118a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   118ad:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
   118b4:	56                   	push   %esi
   118b5:	e8 26 ea ff ff       	call   102e0 <net_pkt_skip>
   118ba:	5b                   	pop    %ebx
   118bb:	58                   	pop    %eax
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		net_pkt_acknowledge_data(orig, &ipv6_access);

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   118bc:	8d 45 ec             	lea    -0x14(%ebp),%eax
   118bf:	50                   	push   %eax
   118c0:	56                   	push   %esi
   118c1:	e8 a1 ec ff ff       	call   10567 <net_pkt_get_data>
   118c6:	5a                   	pop    %edx
							orig, &icmpv6_access);
		if (!icmp_hdr || icmp_hdr->code < 128) {
   118c7:	85 c0                	test   %eax,%eax
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   118c9:	59                   	pop    %ecx
		if (!icmp_hdr || icmp_hdr->code < 128) {
   118ca:	74 06                	je     118d2 <net_icmpv6_send_error+0x7e>
   118cc:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   118d0:	78 0a                	js     118dc <net_icmpv6_send_error+0x88>
			/* We must not send ICMP errors back */
			err = -EINVAL;
   118d2:	ba ea ff ff ff       	mov    $0xffffffea,%edx
   118d7:	e9 2b 01 00 00       	jmp    11a07 <net_icmpv6_send_error+0x1b3>
			goto drop_no_pkt;
		}

		net_pkt_cursor_init(orig);
   118dc:	56                   	push   %esi
   118dd:	e8 8b e6 ff ff       	call   ff6d <net_pkt_cursor_init>
   118e2:	59                   	pop    %ecx
	}

	if (ip_hdr->nexthdr == IPPROTO_UDP) {
   118e3:	8a 57 06             	mov    0x6(%edi),%dl
		copy_len = sizeof(struct net_ipv6_hdr) +
   118e6:	b8 30 00 00 00       	mov    $0x30,%eax
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
   118eb:	80 fa 11             	cmp    $0x11,%dl
   118ee:	74 1d                	je     1190d <net_icmpv6_send_error+0xb9>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv6_hdr) +
   118f0:	b8 3c 00 00 00       	mov    $0x3c,%eax
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
   118f5:	80 fa 06             	cmp    $0x6,%dl
   118f8:	74 13                	je     1190d <net_icmpv6_send_error+0xb9>
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = net_pkt_get_len(orig);
   118fa:	8b 56 14             	mov    0x14(%esi),%edx
	size_t bytes = 0;
   118fd:	31 c0                	xor    %eax,%eax
	while (buf) {
   118ff:	85 d2                	test   %edx,%edx
   11901:	74 0a                	je     1190d <net_icmpv6_send_error+0xb9>
		bytes += buf->len;
   11903:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
   11907:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
   11909:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
   1190b:	eb f2                	jmp    118ff <net_icmpv6_send_error+0xab>
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
   1190d:	68 e8 03 00 00       	push   $0x3e8
   11912:	83 c0 04             	add    $0x4,%eax
   11915:	6a 3a                	push   $0x3a
   11917:	6a 02                	push   $0x2
   11919:	50                   	push   %eax
   1191a:	ff 76 24             	pushl  0x24(%esi)
   1191d:	e8 93 e9 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   11922:	83 c4 14             	add    $0x14,%esp
   11925:	89 c3                	mov    %eax,%ebx
					copy_len + NET_ICMPV6_UNUSED_LEN,
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
		err = -ENOMEM;
   11927:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (!pkt) {
   1192c:	85 c0                	test   %eax,%eax
   1192e:	0f 84 d3 00 00 00    	je     11a07 <net_icmpv6_send_error+0x1b3>
   11934:	8d 47 18             	lea    0x18(%edi),%eax
		goto drop_no_pkt;
	}

	if (net_ipv6_is_addr_mcast(&ip_hdr->dst)) {
   11937:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
   1193b:	75 0b                	jne    11948 <net_icmpv6_send_error+0xf4>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
   1193d:	50                   	push   %eax
   1193e:	ff 73 24             	pushl  0x24(%ebx)
   11941:	e8 45 d8 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   11946:	59                   	pop    %ecx
   11947:	5a                   	pop    %edx
						  &ip_hdr->dst);
	} else {
		src = &ip_hdr->dst;
	}

	if (net_ipv6_create(pkt, src, &ip_hdr->src) ||
   11948:	83 c7 08             	add    $0x8,%edi
   1194b:	57                   	push   %edi
   1194c:	50                   	push   %eax
   1194d:	53                   	push   %ebx
   1194e:	e8 e8 03 00 00       	call   11d3b <net_ipv6_create>
   11953:	83 c4 0c             	add    $0xc,%esp
   11956:	85 c0                	test   %eax,%eax
   11958:	74 0a                	je     11964 <net_icmpv6_send_error+0x110>
	int err = -EIO;
   1195a:	bf fb ff ff ff       	mov    $0xfffffffb,%edi
   1195f:	e9 9a 00 00 00       	jmp    119fe <net_icmpv6_send_error+0x1aa>
	    net_icmpv6_create(pkt, type, code)) {
   11964:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
   11968:	50                   	push   %eax
   11969:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
   1196d:	50                   	push   %eax
   1196e:	53                   	push   %ebx
   1196f:	e8 ab fd ff ff       	call   1171f <net_icmpv6_create>
   11974:	83 c4 0c             	add    $0xc,%esp
	if (net_ipv6_create(pkt, src, &ip_hdr->src) ||
   11977:	85 c0                	test   %eax,%eax
   11979:	75 df                	jne    1195a <net_icmpv6_send_error+0x106>
		goto drop;
	}

	/* Depending on error option, we store the param into the ICMP message.
	 */
	if (type == NET_ICMPV6_PARAM_PROBLEM) {
   1197b:	80 7d e0 04          	cmpb   $0x4,-0x20(%ebp)
   1197f:	75 16                	jne    11997 <net_icmpv6_send_error+0x143>
	u32_t data_be32 = htonl(data);
   11981:	8b 45 14             	mov    0x14(%ebp),%eax
	return net_pkt_write(pkt, &data_be32, sizeof(u32_t));
   11984:	6a 04                	push   $0x4
   11986:	0f c8                	bswap  %eax
	u32_t data_be32 = htonl(data);
   11988:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return net_pkt_write(pkt, &data_be32, sizeof(u32_t));
   1198b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1198e:	50                   	push   %eax
   1198f:	53                   	push   %ebx
   11990:	e8 82 eb ff ff       	call   10517 <net_pkt_write>
   11995:	eb 0a                	jmp    119a1 <net_icmpv6_send_error+0x14d>
		err = net_pkt_write_be32(pkt, param);
	} else {
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
   11997:	6a 04                	push   $0x4
   11999:	6a 00                	push   $0x0
   1199b:	53                   	push   %ebx
   1199c:	e8 5e e9 ff ff       	call   102ff <net_pkt_memset>
   119a1:	83 c4 0c             	add    $0xc,%esp
   119a4:	89 c7                	mov    %eax,%edi
	}

	/* Allocator might not have been able to allocate all requested space,
	 * so let's copy as much as we can.
	 */
	copy_len = net_pkt_available_buffer(pkt);
   119a6:	53                   	push   %ebx
   119a7:	e8 fe e4 ff ff       	call   feaa <net_pkt_available_buffer>
   119ac:	5a                   	pop    %edx

	if (err || net_pkt_copy(pkt, orig, copy_len)) {
   119ad:	85 ff                	test   %edi,%edi
   119af:	75 4d                	jne    119fe <net_icmpv6_send_error+0x1aa>
   119b1:	50                   	push   %eax
   119b2:	56                   	push   %esi
   119b3:	53                   	push   %ebx
   119b4:	e8 a0 e9 ff ff       	call   10359 <net_pkt_copy>
   119b9:	83 c4 0c             	add    $0xc,%esp
   119bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
   119bf:	85 c0                	test   %eax,%eax
   119c1:	75 3b                	jne    119fe <net_icmpv6_send_error+0x1aa>
		goto drop;
	}

	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_dst(orig)->addr;
   119c3:	8b 46 34             	mov    0x34(%esi),%eax
   119c6:	89 43 2c             	mov    %eax,0x2c(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
   119c9:	8a 46 38             	mov    0x38(%esi),%al
   119cc:	88 43 30             	mov    %al,0x30(%ebx)
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   119cf:	8b 46 2c             	mov    0x2c(%esi),%eax
   119d2:	89 43 34             	mov    %eax,0x34(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
   119d5:	8a 46 30             	mov    0x30(%esi),%al
   119d8:	88 43 38             	mov    %al,0x38(%ebx)

	net_pkt_cursor_init(pkt);
   119db:	53                   	push   %ebx
   119dc:	e8 8c e5 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   119e1:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   119e8:	53                   	push   %ebx
   119e9:	e8 fd 03 00 00       	call   11deb <net_ipv6_finalize>
   119ee:	5a                   	pop    %edx
   119ef:	59                   	pop    %ecx
	NET_DBG("Sending ICMPv6 Error Message type %d code %d param %d"
		" from %s to %s", type, code, param,
		log_strdup(net_sprint_ipv6_addr(src)),
		log_strdup(net_sprint_ipv6_addr(&ip_hdr->src)));

	if (net_send_data(pkt) >= 0) {
   119f0:	53                   	push   %ebx
   119f1:	e8 57 be ff ff       	call   d84d <net_send_data>
   119f6:	5e                   	pop    %esi
   119f7:	85 c0                	test   %eax,%eax
   119f9:	8b 55 e0             	mov    -0x20(%ebp),%edx
   119fc:	79 09                	jns    11a07 <net_icmpv6_send_error+0x1b3>
		net_stats_update_icmp_sent(net_pkt_iface(pkt));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
   119fe:	53                   	push   %ebx
   119ff:	e8 fd e3 ff ff       	call   fe01 <net_pkt_unref>
   11a04:	58                   	pop    %eax
   11a05:	89 fa                	mov    %edi,%edx

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;
}
   11a07:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11a0a:	89 d0                	mov    %edx,%eax
   11a0c:	5b                   	pop    %ebx
   11a0d:	5e                   	pop    %esi
   11a0e:	5f                   	pop    %edi
   11a0f:	5d                   	pop    %ebp
   11a10:	c3                   	ret    

00011a11 <net_icmpv6_send_echo_request>:

int net_icmpv6_send_echo_request(struct net_if *iface,
				 struct in6_addr *dst,
				 u16_t identifier,
				 u16_t sequence)
{
   11a11:	55                   	push   %ebp
   11a12:	89 e5                	mov    %esp,%ebp
   11a14:	57                   	push   %edi
   11a15:	56                   	push   %esi
   11a16:	53                   	push   %ebx
   11a17:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
   11a1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	int ret = -ENOBUFS;
	struct net_icmpv6_echo_req *echo_req;
	const struct in6_addr *src;
	struct net_pkt *pkt;

	src = net_if_ipv6_select_src_addr(iface, dst);
   11a21:	ff 75 0c             	pushl  0xc(%ebp)
{
   11a24:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11a27:	8b 45 14             	mov    0x14(%ebp),%eax
	src = net_if_ipv6_select_src_addr(iface, dst);
   11a2a:	53                   	push   %ebx
{
   11a2b:	8b 7d 10             	mov    0x10(%ebp),%edi
   11a2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
   11a31:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	src = net_if_ipv6_select_src_addr(iface, dst);
   11a38:	e8 4e d7 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   11a3d:	59                   	pop    %ecx
   11a3e:	5e                   	pop    %esi
   11a3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	pkt = net_pkt_alloc_with_buffer(iface,
   11a42:	68 e8 03 00 00       	push   $0x3e8
					sizeof(struct net_icmpv6_echo_req),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
		return -ENOMEM;
   11a47:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
	pkt = net_pkt_alloc_with_buffer(iface,
   11a4c:	6a 3a                	push   $0x3a
   11a4e:	6a 02                	push   $0x2
   11a50:	6a 04                	push   $0x4
   11a52:	53                   	push   %ebx
   11a53:	e8 5d e8 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   11a58:	83 c4 14             	add    $0x14,%esp
	if (!pkt) {
   11a5b:	85 c0                	test   %eax,%eax
   11a5d:	0f 84 8b 00 00 00    	je     11aee <net_icmpv6_send_echo_request+0xdd>
	}

	if (net_ipv6_create(pkt, src, dst) ||
   11a63:	ff 75 0c             	pushl  0xc(%ebp)
   11a66:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   11a69:	89 c3                	mov    %eax,%ebx
   11a6b:	52                   	push   %edx
   11a6c:	50                   	push   %eax
   11a6d:	e8 c9 02 00 00       	call   11d3b <net_ipv6_create>
   11a72:	83 c4 0c             	add    $0xc,%esp
   11a75:	85 c0                	test   %eax,%eax
   11a77:	74 07                	je     11a80 <net_icmpv6_send_echo_request+0x6f>
	int ret = -ENOBUFS;
   11a79:	be c9 ff ff ff       	mov    $0xffffffc9,%esi
   11a7e:	eb 67                	jmp    11ae7 <net_icmpv6_send_echo_request+0xd6>
	    net_icmpv6_create(pkt, NET_ICMPV6_ECHO_REQUEST, 0)) {
   11a80:	6a 00                	push   $0x0
   11a82:	68 80 00 00 00       	push   $0x80
   11a87:	53                   	push   %ebx
   11a88:	e8 92 fc ff ff       	call   1171f <net_icmpv6_create>
   11a8d:	83 c4 0c             	add    $0xc,%esp
   11a90:	89 c6                	mov    %eax,%esi
	if (net_ipv6_create(pkt, src, dst) ||
   11a92:	85 c0                	test   %eax,%eax
   11a94:	75 e3                	jne    11a79 <net_icmpv6_send_echo_request+0x68>
		goto drop;
	}

	echo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(
   11a96:	8d 55 ec             	lea    -0x14(%ebp),%edx
   11a99:	52                   	push   %edx
   11a9a:	53                   	push   %ebx
   11a9b:	e8 c7 ea ff ff       	call   10567 <net_pkt_get_data>
   11aa0:	59                   	pop    %ecx
							pkt, &icmpv6_access);
	if (!echo_req) {
   11aa1:	85 c0                	test   %eax,%eax
	echo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(
   11aa3:	5a                   	pop    %edx
	if (!echo_req) {
   11aa4:	74 d3                	je     11a79 <net_icmpv6_send_echo_request+0x68>
		goto drop;
	}

	echo_req->identifier = htons(identifier);
   11aa6:	66 c1 c7 08          	rol    $0x8,%di
	echo_req->sequence   = htons(sequence);

	net_pkt_set_data(pkt, &icmpv6_access);
   11aaa:	8d 55 ec             	lea    -0x14(%ebp),%edx
	echo_req->sequence   = htons(sequence);
   11aad:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	echo_req->identifier = htons(identifier);
   11ab0:	66 89 38             	mov    %di,(%eax)
	echo_req->sequence   = htons(sequence);
   11ab3:	86 e9                	xchg   %ch,%cl
   11ab5:	66 89 48 02          	mov    %cx,0x2(%eax)
	net_pkt_set_data(pkt, &icmpv6_access);
   11ab9:	52                   	push   %edx
   11aba:	53                   	push   %ebx
   11abb:	e8 3e eb ff ff       	call   105fe <net_pkt_set_data>
   11ac0:	5a                   	pop    %edx
   11ac1:	59                   	pop    %ecx

	net_pkt_cursor_init(pkt);
   11ac2:	53                   	push   %ebx
   11ac3:	e8 a5 e4 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   11ac8:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   11acf:	53                   	push   %ebx
   11ad0:	e8 16 03 00 00       	call   11deb <net_ipv6_finalize>
   11ad5:	5f                   	pop    %edi
   11ad6:	58                   	pop    %eax
	NET_DBG("Sending ICMPv6 Echo Request type %d from %s to %s",
		NET_ICMPV6_ECHO_REQUEST,
		log_strdup(net_sprint_ipv6_addr(src)),
		log_strdup(net_sprint_ipv6_addr(dst)));

	if (net_send_data(pkt) >= 0) {
   11ad7:	53                   	push   %ebx
   11ad8:	e8 70 bd ff ff       	call   d84d <net_send_data>
   11add:	5a                   	pop    %edx
   11ade:	85 c0                	test   %eax,%eax
   11ae0:	79 0c                	jns    11aee <net_icmpv6_send_echo_request+0xdd>
		return 0;
	}

	net_stats_update_icmp_drop(iface);

	ret = -EIO;
   11ae2:	be fb ff ff ff       	mov    $0xfffffffb,%esi

drop:
	net_pkt_unref(pkt);
   11ae7:	53                   	push   %ebx
   11ae8:	e8 14 e3 ff ff       	call   fe01 <net_pkt_unref>
   11aed:	58                   	pop    %eax

	return ret;
}
   11aee:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11af1:	89 f0                	mov    %esi,%eax
   11af3:	5b                   	pop    %ebx
   11af4:	5e                   	pop    %esi
   11af5:	5f                   	pop    %edi
   11af6:	5d                   	pop    %ebp
   11af7:	c3                   	ret    

00011af8 <net_icmpv6_input>:

enum net_verdict net_icmpv6_input(struct net_pkt *pkt,
				  struct net_ipv6_hdr *ip_hdr)
{
   11af8:	55                   	push   %ebp
   11af9:	89 e5                	mov    %esp,%ebp
   11afb:	56                   	push   %esi
   11afc:	53                   	push   %ebx
   11afd:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv6_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11b00:	8d 45 f0             	lea    -0x10(%ebp),%eax
{
   11b03:	8b 75 08             	mov    0x8(%ebp),%esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   11b06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11b0d:	50                   	push   %eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   11b0e:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11b15:	56                   	push   %esi
   11b16:	e8 4c ea ff ff       	call   10567 <net_pkt_get_data>
   11b1b:	5b                   	pop    %ebx
	if (!icmp_hdr) {
   11b1c:	85 c0                	test   %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   11b1e:	5a                   	pop    %edx
	if (!icmp_hdr) {
   11b1f:	75 07                	jne    11b28 <net_icmpv6_input+0x30>
		NET_DBG("DROP: NULL ICMPv6 header");
		return NET_DROP;
   11b21:	b8 02 00 00 00       	mov    $0x2,%eax
   11b26:	eb 4d                	jmp    11b75 <net_icmpv6_input+0x7d>
   11b28:	6a 3a                	push   $0x3a
   11b2a:	89 c3                	mov    %eax,%ebx
   11b2c:	56                   	push   %esi
   11b2d:	e8 9f f1 ff ff       	call   10cd1 <net_calc_chksum>
	}

	if (net_calc_chksum_icmpv6(pkt) != 0) {
   11b32:	66 85 c0             	test   %ax,%ax
   11b35:	59                   	pop    %ecx
   11b36:	5a                   	pop    %edx
   11b37:	75 e8                	jne    11b21 <net_icmpv6_input+0x29>
	return net_pkt_skip(pkt, access->size);
   11b39:	ff 75 f4             	pushl  -0xc(%ebp)
   11b3c:	56                   	push   %esi
   11b3d:	e8 9e e7 ff ff       	call   102e0 <net_pkt_skip>
   11b42:	58                   	pop    %eax
		net_icmpv6_type2str(icmp_hdr->type),
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   11b43:	a1 c0 42 40 00       	mov    0x4042c0,%eax
   11b48:	5a                   	pop    %edx
   11b49:	85 c0                	test   %eax,%eax
   11b4b:	74 d4                	je     11b21 <net_icmpv6_input+0x29>
		if (cb->type == icmp_hdr->type &&
   11b4d:	8a 0b                	mov    (%ebx),%cl
   11b4f:	38 48 08             	cmp    %cl,0x8(%eax)
   11b52:	75 19                	jne    11b6d <net_icmpv6_input+0x75>
		    (cb->code == icmp_hdr->code || cb->code == 0)) {
   11b54:	8a 50 09             	mov    0x9(%eax),%dl
   11b57:	38 53 01             	cmp    %dl,0x1(%ebx)
   11b5a:	74 04                	je     11b60 <net_icmpv6_input+0x68>
   11b5c:	84 d2                	test   %dl,%dl
   11b5e:	75 0d                	jne    11b6d <net_icmpv6_input+0x75>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
   11b60:	53                   	push   %ebx
   11b61:	ff 75 0c             	pushl  0xc(%ebp)
   11b64:	56                   	push   %esi
   11b65:	ff 50 04             	call   *0x4(%eax)
   11b68:	83 c4 0c             	add    $0xc,%esp
   11b6b:	eb 08                	jmp    11b75 <net_icmpv6_input+0x7d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   11b6d:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   11b6f:	85 c0                	test   %eax,%eax
   11b71:	75 dc                	jne    11b4f <net_icmpv6_input+0x57>
   11b73:	eb ac                	jmp    11b21 <net_icmpv6_input+0x29>
	}
drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
   11b75:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11b78:	5b                   	pop    %ebx
   11b79:	5e                   	pop    %esi
   11b7a:	5d                   	pop    %ebp
   11b7b:	c3                   	ret    

00011b7c <net_icmpv6_init>:
	.code = 0,
	.handler = icmpv6_handle_echo_request,
};

void net_icmpv6_init(void)
{
   11b7c:	55                   	push   %ebp
   11b7d:	89 e5                	mov    %esp,%ebp
	net_icmpv6_register_handler(&echo_request_handler);
   11b7f:	68 9c a6 40 00       	push   $0x40a69c
   11b84:	e8 d4 fa ff ff       	call   1165d <net_icmpv6_register_handler>
   11b89:	58                   	pop    %eax
}
   11b8a:	c9                   	leave  
   11b8b:	c3                   	ret    

00011b8c <net_nbr_unref>:
void net_nbr_unref_debug(struct net_nbr *nbr, const char *caller, int line)
#define net_nbr_unref(nbr) net_nbr_unref_debug(nbr, __func__, __LINE__)
#else
void net_nbr_unref(struct net_nbr *nbr)
#endif
{
   11b8c:	55                   	push   %ebp
   11b8d:	89 e5                	mov    %esp,%ebp
   11b8f:	8b 55 08             	mov    0x8(%ebp),%edx
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref - 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref - 1);
#endif
	if (--nbr->ref) {
   11b92:	fe 0a                	decb   (%edx)
   11b94:	75 0a                	jne    11ba0 <net_nbr_unref+0x14>
		return;
	}

	if (nbr->remove) {
   11b96:	8b 42 10             	mov    0x10(%edx),%eax
   11b99:	85 c0                	test   %eax,%eax
   11b9b:	74 03                	je     11ba0 <net_nbr_unref+0x14>
		nbr->remove(nbr);
	}
}
   11b9d:	5d                   	pop    %ebp
		nbr->remove(nbr);
   11b9e:	ff e0                	jmp    *%eax
}
   11ba0:	5d                   	pop    %ebp
   11ba1:	c3                   	ret    

00011ba2 <net_nbr_get>:
			((sizeof(struct net_nbr) +
			  start->size + start->extra_data_size) * idx));
}

struct net_nbr *net_nbr_get(struct net_nbr_table *table)
{
   11ba2:	55                   	push   %ebp
	int i;

	for (i = 0; i < table->nbr_count; i++) {
   11ba3:	31 c9                	xor    %ecx,%ecx
{
   11ba5:	89 e5                	mov    %esp,%ebp
   11ba7:	57                   	push   %edi
   11ba8:	56                   	push   %esi
   11ba9:	53                   	push   %ebx
   11baa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	for (i = 0; i < table->nbr_count; i++) {
   11bad:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
   11bb1:	39 ce                	cmp    %ecx,%esi
   11bb3:	7e 26                	jle    11bdb <net_nbr_get+0x39>
		struct net_nbr *nbr = get_nbr(table->nbr, i);
   11bb5:	8b 13                	mov    (%ebx),%edx
			  start->size + start->extra_data_size) * idx));
   11bb7:	0f b7 7a 02          	movzwl 0x2(%edx),%edi
   11bbb:	0f b7 42 04          	movzwl 0x4(%edx),%eax
   11bbf:	8d 44 07 14          	lea    0x14(%edi,%eax,1),%eax
   11bc3:	0f af c1             	imul   %ecx,%eax
	return (struct net_nbr *)((u8_t *)start +
   11bc6:	01 d0                	add    %edx,%eax

		if (!nbr->ref) {
   11bc8:	80 38 00             	cmpb   $0x0,(%eax)
   11bcb:	75 0b                	jne    11bd8 <net_nbr_get+0x36>
			nbr->data = nbr->__nbr;
   11bcd:	8d 50 14             	lea    0x14(%eax),%edx
	nbr->ref++;
   11bd0:	c6 00 01             	movb   $0x1,(%eax)
			nbr->data = nbr->__nbr;
   11bd3:	89 50 0c             	mov    %edx,0xc(%eax)

			return net_nbr_ref(nbr);
   11bd6:	eb 05                	jmp    11bdd <net_nbr_get+0x3b>
	for (i = 0; i < table->nbr_count; i++) {
   11bd8:	41                   	inc    %ecx
   11bd9:	eb d6                	jmp    11bb1 <net_nbr_get+0xf>
		}
	}

	return NULL;
   11bdb:	31 c0                	xor    %eax,%eax
}
   11bdd:	5b                   	pop    %ebx
   11bde:	5e                   	pop    %esi
   11bdf:	5f                   	pop    %edi
   11be0:	5d                   	pop    %ebp
   11be1:	c3                   	ret    

00011be2 <net_nbr_link>:

int net_nbr_link(struct net_nbr *nbr, struct net_if *iface,
		 struct net_linkaddr *lladdr)
{
   11be2:	55                   	push   %ebp
   11be3:	89 e5                	mov    %esp,%ebp
   11be5:	57                   	push   %edi
   11be6:	56                   	push   %esi
   11be7:	53                   	push   %ebx
   11be8:	50                   	push   %eax
	int i, avail = -1;

	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
		return -EALREADY;
   11be9:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
   11bee:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
   11bf1:	8b 75 10             	mov    0x10(%ebp),%esi
	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
   11bf4:	80 79 01 ff          	cmpb   $0xff,0x1(%ecx)
   11bf8:	0f 85 b4 00 00 00    	jne    11cb2 <net_nbr_link+0xd0>
   11bfe:	ba 00 0f 40 00       	mov    $0x400f00,%edx
	int i, avail = -1;
   11c03:	83 cb ff             	or     $0xffffffff,%ebx
	}

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   11c06:	31 ff                	xor    %edi,%edi
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
   11c08:	8a 42 08             	mov    0x8(%edx),%al
   11c0b:	83 fb ff             	cmp    $0xffffffff,%ebx
   11c0e:	75 06                	jne    11c16 <net_nbr_link+0x34>
   11c10:	84 c0                	test   %al,%al
   11c12:	74 3e                	je     11c52 <net_nbr_link+0x70>
   11c14:	eb 04                	jmp    11c1a <net_nbr_link+0x38>
			avail = i;
		}

		if (net_neighbor_lladdr[i].ref &&
   11c16:	84 c0                	test   %al,%al
   11c18:	74 3a                	je     11c54 <net_nbr_link+0x72>
		    !memcmp(lladdr->addr,
   11c1a:	0f b6 46 04          	movzbl 0x4(%esi),%eax
   11c1e:	50                   	push   %eax
   11c1f:	8d 42 02             	lea    0x2(%edx),%eax
   11c22:	50                   	push   %eax
   11c23:	89 55 f0             	mov    %edx,-0x10(%ebp)
   11c26:	ff 36                	pushl  (%esi)
   11c28:	e8 99 8c ff ff       	call   a8c6 <memcmp>
   11c2d:	83 c4 0c             	add    $0xc,%esp
		if (net_neighbor_lladdr[i].ref &&
   11c30:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11c33:	85 c0                	test   %eax,%eax
   11c35:	75 1d                	jne    11c54 <net_nbr_link+0x72>
			/* We found same lladdr in nbr cache so just
			 * increase the ref count.
			 */
			net_neighbor_lladdr[i].ref++;

			nbr->idx = i;
   11c37:	8b 75 08             	mov    0x8(%ebp),%esi
			net_neighbor_lladdr[i].ref++;
   11c3a:	8d 14 ff             	lea    (%edi,%edi,8),%edx
			nbr->idx = i;
   11c3d:	89 f9                	mov    %edi,%ecx
			net_neighbor_lladdr[i].ref++;
   11c3f:	fe 82 08 0f 40 00    	incb   0x400f08(%edx)
			nbr->idx = i;
   11c45:	88 4e 01             	mov    %cl,0x1(%esi)
			nbr->iface = iface;
   11c48:	89 f1                	mov    %esi,%ecx
   11c4a:	8b 75 0c             	mov    0xc(%ebp),%esi
   11c4d:	89 71 08             	mov    %esi,0x8(%ecx)

			return 0;
   11c50:	eb 60                	jmp    11cb2 <net_nbr_link+0xd0>
   11c52:	89 fb                	mov    %edi,%ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   11c54:	47                   	inc    %edi
   11c55:	83 c2 09             	add    $0x9,%edx
   11c58:	83 ff 08             	cmp    $0x8,%edi
   11c5b:	75 ab                	jne    11c08 <net_nbr_link+0x26>
		}
	}

	if (avail < 0) {
		return -ENOENT;
   11c5d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (avail < 0) {
   11c62:	83 fb ff             	cmp    $0xffffffff,%ebx
   11c65:	74 4b                	je     11cb2 <net_nbr_link+0xd0>
	}

	/* There was no existing entry in the lladdr cache,
	 * so allocate one for this lladdr.
	 */
	net_neighbor_lladdr[avail].ref++;
   11c67:	8d 14 db             	lea    (%ebx,%ebx,8),%edx
	nbr->idx = avail;
   11c6a:	8b 45 08             	mov    0x8(%ebp),%eax
	net_neighbor_lladdr[avail].ref++;
   11c6d:	8d 8a 00 0f 40 00    	lea    0x400f00(%edx),%ecx
   11c73:	fe 41 08             	incb   0x8(%ecx)
	nbr->idx = avail;
   11c76:	88 58 01             	mov    %bl,0x1(%eax)

	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
			 lladdr->len);
   11c79:	0f b6 46 04          	movzbl 0x4(%esi),%eax
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
   11c7d:	8b 3e                	mov    (%esi),%edi
{
	if (!lladdr_store || !new_addr) {
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
   11c7f:	3c 06                	cmp    $0x6,%al
   11c81:	77 18                	ja     11c9b <net_nbr_link+0xb9>
   11c83:	85 ff                	test   %edi,%edi
   11c85:	74 14                	je     11c9b <net_nbr_link+0xb9>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
   11c87:	88 41 01             	mov    %al,0x1(%ecx)
	memcpy(lladdr_store->addr, new_addr, new_len);
   11c8a:	50                   	push   %eax
   11c8b:	57                   	push   %edi
   11c8c:	81 c2 02 0f 40 00    	add    $0x400f02,%edx
   11c92:	52                   	push   %edx
   11c93:	e8 99 8c ff ff       	call   a931 <memcpy>
   11c98:	83 c4 0c             	add    $0xc,%esp
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
   11c9b:	8d 1c db             	lea    (%ebx,%ebx,8),%ebx
   11c9e:	8a 46 04             	mov    0x4(%esi),%al

	nbr->iface = iface;
   11ca1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
   11ca4:	88 83 01 0f 40 00    	mov    %al,0x400f01(%ebx)
	nbr->iface = iface;
   11caa:	8b 45 08             	mov    0x8(%ebp),%eax
   11cad:	89 48 08             	mov    %ecx,0x8(%eax)

	return 0;
   11cb0:	31 c0                	xor    %eax,%eax
}
   11cb2:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11cb5:	5b                   	pop    %ebx
   11cb6:	5e                   	pop    %esi
   11cb7:	5f                   	pop    %edi
   11cb8:	5d                   	pop    %ebp
   11cb9:	c3                   	ret    

00011cba <net_nbr_unlink>:

int net_nbr_unlink(struct net_nbr *nbr, struct net_linkaddr *lladdr)
{
   11cba:	55                   	push   %ebp
   11cbb:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
   11cc0:	89 e5                	mov    %esp,%ebp
   11cc2:	53                   	push   %ebx
   11cc3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ARG_UNUSED(lladdr);

	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
   11cc6:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
   11cca:	80 fa ff             	cmp    $0xff,%dl
   11ccd:	74 2b                	je     11cfa <net_nbr_unlink+0x40>
	}

	NET_ASSERT(nbr->idx < CONFIG_NET_IPV6_MAX_NEIGHBORS);
	NET_ASSERT(net_neighbor_lladdr[nbr->idx].ref > 0);

	net_neighbor_lladdr[nbr->idx].ref--;
   11ccf:	8d 14 d2             	lea    (%edx,%edx,8),%edx

	if (!net_neighbor_lladdr[nbr->idx].ref) {
   11cd2:	fe 8a 08 0f 40 00    	decb   0x400f08(%edx)
   11cd8:	75 13                	jne    11ced <net_nbr_unlink+0x33>
		(void)memset(net_neighbor_lladdr[nbr->idx].lladdr.addr, 0,
   11cda:	6a 06                	push   $0x6
   11cdc:	81 c2 02 0f 40 00    	add    $0x400f02,%edx
   11ce2:	6a 00                	push   $0x0
   11ce4:	52                   	push   %edx
   11ce5:	e8 b6 8c ff ff       	call   a9a0 <memset>
   11cea:	83 c4 0c             	add    $0xc,%esp
			     sizeof(net_neighbor_lladdr[nbr->idx].lladdr.addr));
	}

	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
   11ced:	c6 43 01 ff          	movb   $0xff,0x1(%ebx)
	nbr->iface = NULL;
   11cf1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	return 0;
   11cf8:	31 c0                	xor    %eax,%eax
}
   11cfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11cfd:	c9                   	leave  
   11cfe:	c3                   	ret    

00011cff <net_nbr_get_lladdr>:

	return NULL;
}

struct net_linkaddr_storage *net_nbr_get_lladdr(u8_t idx)
{
   11cff:	55                   	push   %ebp
   11d00:	89 e5                	mov    %esp,%ebp
	NET_ASSERT_INFO(idx < CONFIG_NET_IPV6_MAX_NEIGHBORS,
			"idx %d >= max %d", idx,
			CONFIG_NET_IPV6_MAX_NEIGHBORS);

	return &net_neighbor_lladdr[idx].lladdr;
   11d02:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
}
   11d06:	5d                   	pop    %ebp
	return &net_neighbor_lladdr[idx].lladdr;
   11d07:	8d 04 c0             	lea    (%eax,%eax,8),%eax
   11d0a:	05 00 0f 40 00       	add    $0x400f00,%eax
}
   11d0f:	c3                   	ret    

00011d10 <net_ipv6_is_addr_loopback>:
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   11d10:	31 d2                	xor    %edx,%edx
   11d12:	83 38 00             	cmpl   $0x0,(%eax)
   11d15:	75 18                	jne    11d2f <net_ipv6_is_addr_loopback+0x1f>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
   11d17:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   11d1b:	75 12                	jne    11d2f <net_ipv6_is_addr_loopback+0x1f>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
   11d1d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   11d21:	75 0c                	jne    11d2f <net_ipv6_is_addr_loopback+0x1f>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   11d23:	31 d2                	xor    %edx,%edx
   11d25:	81 78 0c 00 00 00 01 	cmpl   $0x1000000,0xc(%eax)
   11d2c:	0f 94 c2             	sete   %dl
   11d2f:	88 d0                	mov    %dl,%al
   11d31:	83 e0 01             	and    $0x1,%eax
}
   11d34:	c3                   	ret    

00011d35 <net_ipv6_unspecified_address>:
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

const struct in6_addr *net_ipv6_unspecified_address(void)
{
	return &in6addr_any;
}
   11d35:	b8 3c 60 02 00       	mov    $0x2603c,%eax
   11d3a:	c3                   	ret    

00011d3b <net_ipv6_create>:

int net_ipv6_create(struct net_pkt *pkt,
		    const struct in6_addr *src,
		    const struct in6_addr *dst)
{
   11d3b:	55                   	push   %ebp
   11d3c:	89 e5                	mov    %esp,%ebp
   11d3e:	57                   	push   %edi
   11d3f:	56                   	push   %esi
   11d40:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11d41:	8d 45 cc             	lea    -0x34(%ebp),%eax
{
   11d44:	83 ec 28             	sub    $0x28,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11d47:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
{
   11d4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11d51:	8b 75 10             	mov    0x10(%ebp),%esi
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11d54:	50                   	push   %eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11d55:	c7 45 d0 28 00 00 00 	movl   $0x28,-0x30(%ebp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11d5c:	53                   	push   %ebx
   11d5d:	e8 05 e8 ff ff       	call   10567 <net_pkt_get_data>
   11d62:	5f                   	pop    %edi
   11d63:	5a                   	pop    %edx
   11d64:	89 c2                	mov    %eax,%edx
	if (!ipv6_hdr) {
   11d66:	85 d2                	test   %edx,%edx
   11d68:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
   11d6d:	74 74                	je     11de3 <net_ipv6_create+0xa8>
		return -ENOBUFS;
	}

	ipv6_hdr->vtc     = 0x60;
   11d6f:	c7 02 60 00 00 00    	movl   $0x60,(%edx)
	ipv6_hdr->tcflow  = 0;
	ipv6_hdr->flow    = 0;
	ipv6_hdr->len     = 0;
	ipv6_hdr->nexthdr = 0;
   11d75:	c6 42 06 00          	movb   $0x0,0x6(%edx)

	/* User can tweak the default hop limit if needed */
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
   11d79:	8a 43 41             	mov    0x41(%ebx),%al
	ipv6_hdr->len     = 0;
   11d7c:	66 c7 42 04 00 00    	movw   $0x0,0x4(%edx)
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
   11d82:	88 42 07             	mov    %al,0x7(%edx)
	if (ipv6_hdr->hop_limit == 0) {
   11d85:	84 c0                	test   %al,%al
   11d87:	75 13                	jne    11d9c <net_ipv6_create+0x61>
		ipv6_hdr->hop_limit =
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
   11d89:	8b 4b 24             	mov    0x24(%ebx),%ecx
   11d8c:	8b 49 04             	mov    0x4(%ecx),%ecx
	if (!iface->config.ip.ipv6) {
   11d8f:	85 c9                	test   %ecx,%ecx
   11d91:	74 06                	je     11d99 <net_ipv6_create+0x5e>
	return iface->config.ip.ipv6->hop_limit;
   11d93:	8a 81 84 01 00 00    	mov    0x184(%ecx),%al
		ipv6_hdr->hop_limit =
   11d99:	88 42 07             	mov    %al,0x7(%edx)
	}

	net_ipaddr_copy(&ipv6_hdr->dst, dst);
   11d9c:	8d 7d d4             	lea    -0x2c(%ebp),%edi
   11d9f:	b9 04 00 00 00       	mov    $0x4,%ecx
   11da4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   11da6:	8d 7a 18             	lea    0x18(%edx),%edi
   11da9:	8d 75 d4             	lea    -0x2c(%ebp),%esi
   11dac:	b9 04 00 00 00       	mov    $0x4,%ecx
	net_ipaddr_copy(&ipv6_hdr->src, src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_ext_len(pkt, 0);

	return net_pkt_set_data(pkt, &ipv6_access);
   11db1:	8d 45 cc             	lea    -0x34(%ebp),%eax
	net_ipaddr_copy(&ipv6_hdr->dst, dst);
   11db4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	net_ipaddr_copy(&ipv6_hdr->src, src);
   11db6:	8b 75 0c             	mov    0xc(%ebp),%esi
   11db9:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   11dbc:	b9 04 00 00 00       	mov    $0x4,%ecx
   11dc1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   11dc3:	8d 7a 08             	lea    0x8(%edx),%edi
   11dc6:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   11dc9:	b9 04 00 00 00       	mov    $0x4,%ecx
   11dce:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	pkt->ip_hdr_len = len;
   11dd0:	c6 43 3c 28          	movb   $0x28,0x3c(%ebx)
	pkt->ipv6_ext_len = len;
   11dd4:	66 c7 43 42 00 00    	movw   $0x0,0x42(%ebx)
	return net_pkt_set_data(pkt, &ipv6_access);
   11dda:	50                   	push   %eax
   11ddb:	53                   	push   %ebx
   11ddc:	e8 1d e8 ff ff       	call   105fe <net_pkt_set_data>
   11de1:	5a                   	pop    %edx
   11de2:	59                   	pop    %ecx
}
   11de3:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11de6:	5b                   	pop    %ebx
   11de7:	5e                   	pop    %esi
   11de8:	5f                   	pop    %edi
   11de9:	5d                   	pop    %ebp
   11dea:	c3                   	ret    

00011deb <net_ipv6_finalize>:

int net_ipv6_finalize(struct net_pkt *pkt, u8_t next_header_proto)
{
   11deb:	55                   	push   %ebp
   11dec:	89 e5                	mov    %esp,%ebp
   11dee:	57                   	push   %edi
   11def:	56                   	push   %esi
   11df0:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
	struct net_ipv6_hdr *ipv6_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11df1:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
   11df4:	83 ec 0c             	sub    $0xc,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11df7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   11dfe:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11e01:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e04:	89 45 e8             	mov    %eax,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11e07:	c7 45 f0 28 00 00 00 	movl   $0x28,-0x10(%ebp)
	pkt->overwrite = overwrite;
   11e0e:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11e12:	56                   	push   %esi
   11e13:	53                   	push   %ebx
   11e14:	e8 4e e7 ff ff       	call   10567 <net_pkt_get_data>
   11e19:	5a                   	pop    %edx
	if (!ipv6_hdr) {
   11e1a:	85 c0                	test   %eax,%eax
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11e1c:	59                   	pop    %ecx
	if (!ipv6_hdr) {
   11e1d:	75 07                	jne    11e26 <net_ipv6_finalize+0x3b>
		return -ENOBUFS;
   11e1f:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
   11e24:	eb 73                	jmp    11e99 <net_ipv6_finalize+0xae>
	}

	ipv6_hdr->len = htons(net_pkt_get_len(pkt) -
   11e26:	8b 4b 14             	mov    0x14(%ebx),%ecx
	size_t bytes = 0;
   11e29:	31 d2                	xor    %edx,%edx
	while (buf) {
   11e2b:	85 c9                	test   %ecx,%ecx
   11e2d:	74 0a                	je     11e39 <net_ipv6_finalize+0x4e>
		bytes += buf->len;
   11e2f:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		buf = buf->frags;
   11e33:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
   11e35:	01 fa                	add    %edi,%edx
		buf = buf->frags;
   11e37:	eb f2                	jmp    11e2b <net_ipv6_finalize+0x40>
   11e39:	8d 4a d8             	lea    -0x28(%edx),%ecx
   11e3c:	83 ea 28             	sub    $0x28,%edx
   11e3f:	66 c1 e9 08          	shr    $0x8,%cx
   11e43:	c1 e2 08             	shl    $0x8,%edx
   11e46:	09 ca                	or     %ecx,%edx
   11e48:	66 89 50 04          	mov    %dx,0x4(%eax)
			      sizeof(struct net_ipv6_hdr));

	if (net_pkt_ipv6_next_hdr(pkt) != 255) {
   11e4c:	8a 53 47             	mov    0x47(%ebx),%dl
   11e4f:	80 fa ff             	cmp    $0xff,%dl
   11e52:	75 03                	jne    11e57 <net_ipv6_finalize+0x6c>
   11e54:	8a 55 e8             	mov    -0x18(%ebp),%dl
   11e57:	88 50 06             	mov    %dl,0x6(%eax)
		ipv6_hdr->nexthdr = net_pkt_ipv6_next_hdr(pkt);
	} else {
		ipv6_hdr->nexthdr = next_header_proto;
	}

	net_pkt_set_data(pkt, &ipv6_access);
   11e5a:	56                   	push   %esi
   11e5b:	53                   	push   %ebx
   11e5c:	e8 9d e7 ff ff       	call   105fe <net_pkt_set_data>
   11e61:	5f                   	pop    %edi
   11e62:	58                   	pop    %eax

	if (net_pkt_ipv6_next_hdr(pkt) != 255 &&
   11e63:	80 7b 47 ff          	cmpb   $0xff,0x47(%ebx)
   11e67:	75 0e                	jne    11e77 <net_ipv6_finalize+0x8c>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
		return -ENOBUFS;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
   11e69:	80 7d e8 11          	cmpb   $0x11,-0x18(%ebp)
   11e6d:	75 1b                	jne    11e8a <net_ipv6_finalize+0x9f>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
   11e6f:	53                   	push   %ebx
   11e70:	e8 14 4a 00 00       	call   16889 <net_udp_finalize>
   11e75:	eb 21                	jmp    11e98 <net_ipv6_finalize+0xad>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
   11e77:	0f b7 43 42          	movzwl 0x42(%ebx),%eax
   11e7b:	50                   	push   %eax
   11e7c:	53                   	push   %ebx
   11e7d:	e8 5e e4 ff ff       	call   102e0 <net_pkt_skip>
   11e82:	59                   	pop    %ecx
	if (net_pkt_ipv6_next_hdr(pkt) != 255 &&
   11e83:	85 c0                	test   %eax,%eax
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
   11e85:	5e                   	pop    %esi
	if (net_pkt_ipv6_next_hdr(pkt) != 255 &&
   11e86:	74 e1                	je     11e69 <net_ipv6_finalize+0x7e>
   11e88:	eb 95                	jmp    11e1f <net_ipv6_finalize+0x34>
		return net_tcp_finalize(pkt);
	} else if (next_header_proto == IPPROTO_ICMPV6) {
		return net_icmpv6_finalize(pkt);
	}

	return 0;
   11e8a:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMPV6) {
   11e8c:	80 7d e8 3a          	cmpb   $0x3a,-0x18(%ebp)
   11e90:	75 07                	jne    11e99 <net_ipv6_finalize+0xae>
		return net_icmpv6_finalize(pkt);
   11e92:	53                   	push   %ebx
   11e93:	e8 37 f8 ff ff       	call   116cf <net_icmpv6_finalize>
   11e98:	5a                   	pop    %edx
}
   11e99:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11e9c:	5b                   	pop    %ebx
   11e9d:	5e                   	pop    %esi
   11e9e:	5f                   	pop    %edi
   11e9f:	5d                   	pop    %ebp
   11ea0:	c3                   	ret    

00011ea1 <net_ipv6_input>:
}

#endif /* CONFIG_NET_ROUTE */

enum net_verdict net_ipv6_input(struct net_pkt *pkt, bool is_loopback)
{
   11ea1:	55                   	push   %ebp
   11ea2:	89 e5                	mov    %esp,%ebp
   11ea4:	57                   	push   %edi
   11ea5:	56                   	push   %esi
	size_t bytes = 0;
   11ea6:	31 f6                	xor    %esi,%esi
   11ea8:	53                   	push   %ebx
   11ea9:	83 ec 30             	sub    $0x30,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11eac:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
{
   11eb3:	8b 45 0c             	mov    0xc(%ebp),%eax
   11eb6:	8b 5d 08             	mov    0x8(%ebp),%ebx
   11eb9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   11ebc:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11ebf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   11ec2:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   11ec9:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
	enum net_verdict verdict = NET_DROP;
	int real_len = net_pkt_get_len(pkt);
   11ed0:	8b 43 14             	mov    0x14(%ebx),%eax
	while (buf) {
   11ed3:	85 c0                	test   %eax,%eax
   11ed5:	74 0a                	je     11ee1 <net_ipv6_input+0x40>
		bytes += buf->len;
   11ed7:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   11edb:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   11edd:	01 d6                	add    %edx,%esi
		buf = buf->frags;
   11edf:	eb f2                	jmp    11ed3 <net_ipv6_input+0x32>
	union net_ip_header ip;
	int pkt_len;

	net_stats_update_ipv6_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   11ee1:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11ee4:	50                   	push   %eax
   11ee5:	53                   	push   %ebx
   11ee6:	e8 7c e6 ff ff       	call   10567 <net_pkt_get_data>
   11eeb:	5a                   	pop    %edx
   11eec:	89 c7                	mov    %eax,%edi
   11eee:	59                   	pop    %ecx
	if (!hdr) {
   11eef:	85 c0                	test   %eax,%eax
   11ef1:	0f 84 65 03 00 00    	je     1225c <net_ipv6_input+0x3bb>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	pkt_len = ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);
   11ef7:	66 8b 40 04          	mov    0x4(%eax),%ax
   11efb:	86 e0                	xchg   %ah,%al
   11efd:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
   11f01:	0f b7 c0             	movzwl %ax,%eax
   11f04:	83 c0 28             	add    $0x28,%eax
	if (real_len < pkt_len) {
   11f07:	39 f0                	cmp    %esi,%eax
   11f09:	0f 8f 4d 03 00 00    	jg     1225c <net_ipv6_input+0x3bb>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
   11f0f:	7d 09                	jge    11f1a <net_ipv6_input+0x79>
		net_pkt_update_length(pkt, pkt_len);
   11f11:	50                   	push   %eax
   11f12:	53                   	push   %ebx
   11f13:	e8 68 e5 ff ff       	call   10480 <net_pkt_update_length>
   11f18:	5e                   	pop    %esi
   11f19:	58                   	pop    %eax

	NET_DBG("IPv6 packet len %d received from %s to %s", pkt_len,
		log_strdup(net_sprint_ipv6_addr(&hdr->src)),
		log_strdup(net_sprint_ipv6_addr(&hdr->dst)));

	if (net_ipv6_is_addr_mcast(&hdr->src) ||
   11f1a:	80 7f 08 ff          	cmpb   $0xff,0x8(%edi)
   11f1e:	0f 84 38 03 00 00    	je     1225c <net_ipv6_input+0x3bb>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
   11f24:	8a 4f 18             	mov    0x18(%edi),%cl
	    net_ipv6_is_addr_mcast_scope(&hdr->dst, 0)) {
   11f27:	8d 77 18             	lea    0x18(%edi),%esi
   11f2a:	80 f9 ff             	cmp    $0xff,%cl
   11f2d:	75 0a                	jne    11f39 <net_ipv6_input+0x98>
   11f2f:	80 7f 19 00          	cmpb   $0x0,0x19(%edi)
   11f33:	0f 84 23 03 00 00    	je     1225c <net_ipv6_input+0x3bb>
		NET_DBG("DROP: multicast packet");
		goto drop;
	}

	if (!is_loopback) {
   11f39:	80 7d cc 00          	cmpb   $0x0,-0x34(%ebp)
   11f3d:	0f 85 81 00 00 00    	jne    11fc4 <net_ipv6_input+0x123>
		if (net_ipv6_is_addr_loopback(&hdr->dst) ||
   11f43:	89 f0                	mov    %esi,%eax
   11f45:	e8 c6 fd ff ff       	call   11d10 <net_ipv6_is_addr_loopback>
   11f4a:	84 c0                	test   %al,%al
   11f4c:	0f 85 0a 03 00 00    	jne    1225c <net_ipv6_input+0x3bb>
		    net_ipv6_is_addr_loopback(&hdr->src)) {
   11f52:	8d 47 08             	lea    0x8(%edi),%eax
   11f55:	e8 b6 fd ff ff       	call   11d10 <net_ipv6_is_addr_loopback>
		if (net_ipv6_is_addr_loopback(&hdr->dst) ||
   11f5a:	84 c0                	test   %al,%al
   11f5c:	0f 85 fa 02 00 00    	jne    1225c <net_ipv6_input+0x3bb>
   11f62:	80 f9 ff             	cmp    $0xff,%cl
   11f65:	75 0a                	jne    11f71 <net_ipv6_input+0xd0>
   11f67:	80 7f 19 01          	cmpb   $0x1,0x19(%edi)
   11f6b:	0f 84 eb 02 00 00    	je     1225c <net_ipv6_input+0x3bb>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
   11f71:	66 a1 3e 60 02 00    	mov    0x2603e,%ax
   11f77:	66 39 47 1a          	cmp    %ax,0x1a(%edi)
   11f7b:	75 47                	jne    11fc4 <net_ipv6_input+0x123>
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
   11f7d:	a1 40 60 02 00       	mov    0x26040,%eax
   11f82:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
   11f86:	75 3c                	jne    11fc4 <net_ipv6_input+0x123>
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
   11f88:	66 a1 42 60 02 00    	mov    0x26042,%ax
   11f8e:	66 39 47 1e          	cmp    %ax,0x1e(%edi)
   11f92:	75 30                	jne    11fc4 <net_ipv6_input+0x123>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
   11f94:	a1 40 60 02 00       	mov    0x26040,%eax
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
   11f99:	39 47 1c             	cmp    %eax,0x1c(%edi)
   11f9c:	75 26                	jne    11fc4 <net_ipv6_input+0x123>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
   11f9e:	3b 47 20             	cmp    0x20(%edi),%eax
   11fa1:	75 21                	jne    11fc4 <net_ipv6_input+0x123>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
   11fa3:	a1 48 60 02 00       	mov    0x26048,%eax
   11fa8:	39 47 24             	cmp    %eax,0x24(%edi)
   11fab:	75 17                	jne    11fc4 <net_ipv6_input+0x123>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
   11fad:	fe c1                	inc    %cl
   11faf:	75 13                	jne    11fc4 <net_ipv6_input+0x123>
   11fb1:	8a 47 19             	mov    0x19(%edi),%al
   11fb4:	3c 05                	cmp    $0x5,%al
   11fb6:	0f 84 a0 02 00 00    	je     1225c <net_ipv6_input+0x3bb>
   11fbc:	3c 08                	cmp    $0x8,%al
   11fbe:	0f 84 98 02 00 00    	je     1225c <net_ipv6_input+0x3bb>
	pkt->ipv6_next_hdr = next_hdr;
   11fc4:	8a 47 06             	mov    0x6(%edi),%al
	pkt->ip_hdr_len = len;
   11fc7:	c6 43 3c 28          	movb   $0x28,0x3c(%ebx)
	pkt->ipv6_next_hdr = next_hdr;
   11fcb:	88 43 47             	mov    %al,0x47(%ebx)
	return pkt->frags->data;
   11fce:	8b 43 14             	mov    0x14(%ebx),%eax
	pkt->ipv6_ext_len = len;
   11fd1:	66 c7 43 42 00 00    	movw   $0x0,0x42(%ebx)

	/* Check extension headers */
	net_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);
	net_pkt_set_ipv6_ext_len(pkt, 0);
	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);
   11fd7:	8b 40 08             	mov    0x8(%eax),%eax
	pkt->ipv6_hop_limit = hop_limit;
   11fda:	8a 40 07             	mov    0x7(%eax),%al
   11fdd:	88 43 41             	mov    %al,0x41(%ebx)
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
   11fe0:	6a 00                	push   $0x0
   11fe2:	56                   	push   %esi
   11fe3:	e8 58 c0 ff ff       	call   e040 <net_if_ipv6_addr_lookup>
   11fe8:	5a                   	pop    %edx

	if (!net_ipv6_is_my_addr(&hdr->dst) &&
   11fe9:	85 c0                	test   %eax,%eax
   11feb:	59                   	pop    %ecx
   11fec:	75 6b                	jne    12059 <net_ipv6_input+0x1b8>
	return net_if_ipv6_maddr_lookup(maddr, NULL) != NULL;
   11fee:	6a 00                	push   $0x0
   11ff0:	56                   	push   %esi
   11ff1:	e8 d9 c9 ff ff       	call   e9cf <net_if_ipv6_maddr_lookup>
   11ff6:	5a                   	pop    %edx
   11ff7:	85 c0                	test   %eax,%eax
   11ff9:	59                   	pop    %ecx
   11ffa:	75 5d                	jne    12059 <net_ipv6_input+0x1b8>
	    !net_ipv6_is_my_maddr(&hdr->dst) &&
   11ffc:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
   12000:	74 57                	je     12059 <net_ipv6_input+0x1b8>
		found = net_route_get_info(net_pkt_iface(pkt),
   12002:	8d 45 d8             	lea    -0x28(%ebp),%eax
   12005:	50                   	push   %eax
   12006:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   12009:	50                   	push   %eax
   1200a:	56                   	push   %esi
   1200b:	ff 73 24             	pushl  0x24(%ebx)
   1200e:	e8 e3 28 00 00       	call   148f6 <net_route_get_info>
   12013:	83 c4 10             	add    $0x10,%esp
	if (found) {
   12016:	84 c0                	test   %al,%al
   12018:	0f 84 3e 02 00 00    	je     1225c <net_ipv6_input+0x3bb>
		if (route) {
   1201e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12021:	85 c0                	test   %eax,%eax
   12023:	74 1a                	je     1203f <net_ipv6_input+0x19e>
			net_pkt_set_iface(pkt, route->iface);
   12025:	8b 40 0c             	mov    0xc(%eax),%eax
	pkt->iface = iface;
   12028:	89 43 24             	mov    %eax,0x24(%ebx)
	if (iface) {
   1202b:	85 c0                	test   %eax,%eax
   1202d:	74 10                	je     1203f <net_ipv6_input+0x19e>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   1202f:	8b 10                	mov    (%eax),%edx
   12031:	8a 52 15             	mov    0x15(%edx),%dl
   12034:	88 53 31             	mov    %dl,0x31(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   12037:	8b 00                	mov    (%eax),%eax
   12039:	8a 40 15             	mov    0x15(%eax),%al
   1203c:	88 43 39             	mov    %al,0x39(%ebx)
		ret = net_route_packet(pkt, nexthop);
   1203f:	ff 75 d8             	pushl  -0x28(%ebp)
   12042:	53                   	push   %ebx
   12043:	e8 1a 29 00 00       	call   14962 <net_route_packet>
   12048:	59                   	pop    %ecx
		if (ret < 0) {
   12049:	85 c0                	test   %eax,%eax
		ret = net_route_packet(pkt, nexthop);
   1204b:	5b                   	pop    %ebx
		if (ret < 0) {
   1204c:	0f 88 0a 02 00 00    	js     1225c <net_ipv6_input+0x3bb>
	    !net_ipv6_is_addr_mcast(&hdr->dst)) {
		if (ipv6_route_packet(pkt, hdr) == NET_OK) {
			return NET_OK;
   12052:	31 c0                	xor    %eax,%eax
   12054:	e9 20 02 00 00       	jmp    12279 <net_ipv6_input+0x3d8>
	return net_pkt_skip(pkt, access->size);
   12059:	ff 75 e0             	pushl  -0x20(%ebp)
   1205c:	53                   	push   %ebx
   1205d:	e8 7e e2 ff ff       	call   102e0 <net_pkt_skip>
   12062:	58                   	pop    %eax
	u16_t ext_len = 0U;
   12063:	66 c7 45 c8 00 00    	movw   $0x0,-0x38(%ebp)
   12069:	5a                   	pop    %edx
	u8_t ext_bitmap = 0U;
   1206a:	c6 45 cc 00          	movb   $0x0,-0x34(%ebp)
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ipv6_access);

	nexthdr = hdr->nexthdr;
   1206e:	8a 57 06             	mov    0x6(%edi),%dl
		     u8_t flags);


static inline bool net_ipv6_is_nexthdr_upper_layer(u8_t nexthdr)
{
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
   12071:	80 fa 3a             	cmp    $0x3a,%dl
   12074:	0f 94 c1             	sete   %cl
   12077:	80 fa 11             	cmp    $0x11,%dl
   1207a:	0f 94 c0             	sete   %al
	while (!net_ipv6_is_nexthdr_upper_layer(nexthdr)) {
   1207d:	08 c1                	or     %al,%cl
   1207f:	0f 85 80 01 00 00    	jne    12205 <net_ipv6_input+0x364>
   12085:	80 fa 06             	cmp    $0x6,%dl
   12088:	0f 84 77 01 00 00    	je     12205 <net_ipv6_input+0x364>
	return net_pkt_read(pkt, data, 1);
   1208e:	6a 01                	push   $0x1
   12090:	8d 45 d2             	lea    -0x2e(%ebp),%eax
   12093:	50                   	push   %eax
   12094:	88 55 c7             	mov    %dl,-0x39(%ebp)
   12097:	53                   	push   %ebx
   12098:	e8 7b e2 ff ff       	call   10318 <net_pkt_read>
   1209d:	83 c4 0c             	add    $0xc,%esp
		int exthdr_len;

		NET_DBG("IPv6 next header %d", nexthdr);

		if (net_pkt_read_u8(pkt, &next_nexthdr)) {
   120a0:	85 c0                	test   %eax,%eax
   120a2:	0f 85 b4 01 00 00    	jne    1225c <net_ipv6_input+0x3bb>
			goto drop;
		}

		switch (nexthdr) {
   120a8:	8a 55 c7             	mov    -0x39(%ebp),%dl
   120ab:	80 fa 3b             	cmp    $0x3b,%dl
   120ae:	0f 84 a8 01 00 00    	je     1225c <net_ipv6_input+0x3bb>
   120b4:	80 fa 3c             	cmp    $0x3c,%dl
   120b7:	74 50                	je     12109 <net_ipv6_input+0x268>
   120b9:	84 d2                	test   %dl,%dl
   120bb:	0f 85 81 01 00 00    	jne    12242 <net_ipv6_input+0x3a1>
		case NET_IPV6_NEXTHDR_HBHO:
			if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_HBHO) {
   120c1:	f6 45 cc 01          	testb  $0x1,-0x34(%ebp)
   120c5:	74 32                	je     120f9 <net_ipv6_input+0x258>
				NET_ERR("DROP: multiple hop-by-hop");
   120c7:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   120ce:	0f 84 88 01 00 00    	je     1225c <net_ipv6_input+0x3bb>
   120d4:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   120d9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   120de:	c1 e8 03             	shr    $0x3,%eax
   120e1:	c1 e0 06             	shl    $0x6,%eax
   120e4:	83 c8 01             	or     $0x1,%eax
   120e7:	50                   	push   %eax
   120e8:	68 f7 7b 02 00       	push   $0x27bf7
   120ed:	e8 98 13 ff ff       	call   348a <log_0>
   120f2:	5b                   	pop    %ebx
   120f3:	5e                   	pop    %esi
   120f4:	e9 63 01 00 00       	jmp    1225c <net_ipv6_input+0x3bb>
				goto drop;
			}

			/* HBH option needs to be the first one */
			if (nexthdr != hdr->nexthdr) {
   120f9:	80 7f 06 00          	cmpb   $0x0,0x6(%edi)
   120fd:	0f 85 3f 01 00 00    	jne    12242 <net_ipv6_input+0x3a1>
				goto bad_hdr;
			}

			ext_bitmap |= NET_IPV6_EXT_HDR_BITMAP_HBHO;
   12103:	80 4d cc 01          	orb    $0x1,-0x34(%ebp)

			break;
   12107:	eb 1a                	jmp    12123 <net_ipv6_input+0x282>

		case NET_IPV6_NEXTHDR_DESTO:
			if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO2) {
   12109:	f6 45 cc 40          	testb  $0x40,-0x34(%ebp)
   1210d:	0f 85 2f 01 00 00    	jne    12242 <net_ipv6_input+0x3a1>
				/* DESTO option cannot appear more than twice */
				goto bad_hdr;
			}

			if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO1) {
   12113:	f6 45 cc 02          	testb  $0x2,-0x34(%ebp)
   12117:	74 06                	je     1211f <net_ipv6_input+0x27e>
				ext_bitmap |= NET_IPV6_EXT_HDR_BITMAP_DESTO2;
   12119:	80 4d cc 40          	orb    $0x40,-0x34(%ebp)
   1211d:	eb 04                	jmp    12123 <net_ipv6_input+0x282>
			} else {
				ext_bitmap |= NET_IPV6_EXT_HDR_BITMAP_DESTO1;
   1211f:	80 4d cc 02          	orb    $0x2,-0x34(%ebp)

		default:
			goto bad_hdr;
		}

		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
   12123:	66 8b 45 ca          	mov    -0x36(%ebp),%ax
   12127:	6a 01                	push   $0x1
	u16_t exthdr_len = 0U;
   12129:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%ebp)
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
   1212f:	8d 70 28             	lea    0x28(%eax),%esi
   12132:	8d 45 d8             	lea    -0x28(%ebp),%eax
   12135:	50                   	push   %eax
   12136:	53                   	push   %ebx
   12137:	e8 dc e1 ff ff       	call   10318 <net_pkt_read>
   1213c:	83 c4 0c             	add    $0xc,%esp
	if (net_pkt_read_u8(pkt, (u8_t *)&exthdr_len)) {
   1213f:	85 c0                	test   %eax,%eax
   12141:	0f 85 15 01 00 00    	jne    1225c <net_ipv6_input+0x3bb>
	exthdr_len = exthdr_len * 8 + 8;
   12147:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1214a:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
	if (exthdr_len > pkt_len) {
   12151:	66 39 c6             	cmp    %ax,%si
	exthdr_len = exthdr_len * 8 + 8;
   12154:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	if (exthdr_len > pkt_len) {
   12158:	0f 82 fe 00 00 00    	jb     1225c <net_ipv6_input+0x3bb>
	length += 2;
   1215e:	be 02 00 00 00       	mov    $0x2,%esi
	while (length < exthdr_len) {
   12163:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12166:	66 39 c6             	cmp    %ax,%si
   12169:	0f 83 8a 00 00 00    	jae    121f9 <net_ipv6_input+0x358>
   1216f:	6a 01                	push   $0x1
   12171:	8d 45 d3             	lea    -0x2d(%ebp),%eax
   12174:	50                   	push   %eax
   12175:	53                   	push   %ebx
   12176:	e8 9d e1 ff ff       	call   10318 <net_pkt_read>
   1217b:	83 c4 0c             	add    $0xc,%esp
		if (net_pkt_read_u8(pkt, &opt_type)) {
   1217e:	85 c0                	test   %eax,%eax
   12180:	0f 85 d6 00 00 00    	jne    1225c <net_ipv6_input+0x3bb>
		if (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {
   12186:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
   1218a:	75 0d                	jne    12199 <net_ipv6_input+0x2f8>
		switch (opt_type) {
   1218c:	8a 45 d3             	mov    -0x2d(%ebp),%al
   1218f:	84 c0                	test   %al,%al
   12191:	74 1e                	je     121b1 <net_ipv6_input+0x310>
   12193:	3c 01                	cmp    $0x1,%al
   12195:	74 55                	je     121ec <net_ipv6_input+0x34b>
   12197:	eb 1b                	jmp    121b4 <net_ipv6_input+0x313>
   12199:	6a 01                	push   $0x1
   1219b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1219e:	50                   	push   %eax
   1219f:	53                   	push   %ebx
   121a0:	e8 73 e1 ff ff       	call   10318 <net_pkt_read>
   121a5:	83 c4 0c             	add    $0xc,%esp
			if (net_pkt_read_u8(pkt, &opt_len)) {
   121a8:	85 c0                	test   %eax,%eax
   121aa:	74 e0                	je     1218c <net_ipv6_input+0x2eb>
   121ac:	e9 ab 00 00 00       	jmp    1225c <net_ipv6_input+0x3bb>
			length++;
   121b1:	46                   	inc    %esi
			break;
   121b2:	eb af                	jmp    12163 <net_ipv6_input+0x2c2>
	switch (opt_type & 0xc0) {
   121b4:	83 e0 c0             	and    $0xffffffc0,%eax
   121b7:	3c 80                	cmp    $0x80,%al
   121b9:	74 18                	je     121d3 <net_ipv6_input+0x332>
   121bb:	3c c0                	cmp    $0xc0,%al
   121bd:	74 0a                	je     121c9 <net_ipv6_input+0x328>
   121bf:	84 c0                	test   %al,%al
   121c1:	0f 85 95 00 00 00    	jne    1225c <net_ipv6_input+0x3bb>
   121c7:	eb 12                	jmp    121db <net_ipv6_input+0x33a>
		if (net_ipv6_is_addr_mcast(&hdr->dst)) {
   121c9:	80 7f 18 ff          	cmpb   $0xff,0x18(%edi)
   121cd:	0f 84 89 00 00 00    	je     1225c <net_ipv6_input+0x3bb>
		net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
   121d3:	0f b7 f6             	movzwl %si,%esi
   121d6:	56                   	push   %esi
   121d7:	6a 02                	push   $0x2
   121d9:	eb 76                	jmp    12251 <net_ipv6_input+0x3b0>
			if (net_pkt_skip(pkt, opt_len)) {
   121db:	0f b6 45 d4          	movzbl -0x2c(%ebp),%eax
   121df:	50                   	push   %eax
   121e0:	53                   	push   %ebx
   121e1:	e8 fa e0 ff ff       	call   102e0 <net_pkt_skip>
   121e6:	5a                   	pop    %edx
   121e7:	85 c0                	test   %eax,%eax
   121e9:	59                   	pop    %ecx
   121ea:	75 70                	jne    1225c <net_ipv6_input+0x3bb>
			length += opt_len + 2;
   121ec:	0f b6 45 d4          	movzbl -0x2c(%ebp),%eax
   121f0:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
			break;
   121f4:	e9 6a ff ff ff       	jmp    12163 <net_ipv6_input+0x2c2>
		if (exthdr_len < 0) {
			goto drop;
		}

		ext_len += exthdr_len;
   121f9:	66 01 45 c8          	add    %ax,-0x38(%ebp)
		nexthdr = next_nexthdr;
   121fd:	8a 55 d2             	mov    -0x2e(%ebp),%dl
   12200:	e9 6c fe ff ff       	jmp    12071 <net_ipv6_input+0x1d0>
	pkt->ipv6_ext_len = len;
   12205:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12208:	66 89 43 42          	mov    %ax,0x42(%ebx)
	pkt->family = family;
   1220c:	8a 43 3f             	mov    0x3f(%ebx),%al
   1220f:	83 e0 f1             	and    $0xfffffff1,%eax
   12212:	83 c8 04             	or     $0x4,%eax
	}

	net_pkt_set_ipv6_ext_len(pkt, ext_len);
	net_pkt_set_family(pkt, PF_INET6);

	switch (nexthdr) {
   12215:	80 fa 11             	cmp    $0x11,%dl
   12218:	88 43 3f             	mov    %al,0x3f(%ebx)
   1221b:	74 10                	je     1222d <net_ipv6_input+0x38c>
   1221d:	80 fa 3a             	cmp    $0x3a,%dl
   12220:	75 3a                	jne    1225c <net_ipv6_input+0x3bb>
	case IPPROTO_ICMPV6:
		verdict = net_icmpv6_input(pkt, hdr);
   12222:	57                   	push   %edi
   12223:	53                   	push   %ebx
   12224:	e8 cf f8 ff ff       	call   11af8 <net_icmpv6_input>
   12229:	5b                   	pop    %ebx
   1222a:	5e                   	pop    %esi
			verdict = NET_OK;
		}
		break;
	}

	if (verdict == NET_DROP) {
   1222b:	eb 4c                	jmp    12279 <net_ipv6_input+0x3d8>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
   1222d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   12230:	50                   	push   %eax
   12231:	53                   	push   %ebx
   12232:	e8 d1 46 00 00       	call   16908 <net_udp_input>
   12237:	5a                   	pop    %edx
   12238:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1223b:	59                   	pop    %ecx
		if (proto_hdr.udp) {
   1223c:	85 c0                	test   %eax,%eax
   1223e:	75 23                	jne    12263 <net_ipv6_input+0x3c2>
   12240:	eb 1a                	jmp    1225c <net_ipv6_input+0x3bb>

bad_hdr:
	/* Send error message about parameter problem (RFC 2460) */
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
			      NET_ICMPV6_PARAM_PROB_NEXTHEADER,
			      net_pkt_get_current_offset(pkt) - 1);
   12242:	53                   	push   %ebx
   12243:	e8 6a e2 ff ff       	call   104b2 <net_pkt_get_current_offset>
   12248:	0f b7 c0             	movzwl %ax,%eax
   1224b:	48                   	dec    %eax
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
   1224c:	89 04 24             	mov    %eax,(%esp)
   1224f:	6a 01                	push   $0x1
   12251:	6a 04                	push   $0x4
   12253:	53                   	push   %ebx
   12254:	e8 fb f5 ff ff       	call   11854 <net_icmpv6_send_error>
   12259:	83 c4 10             	add    $0x10,%esp

	NET_DBG("DROP: Unknown/wrong nexthdr type");
	net_stats_update_ip_errors_protoerr(net_pkt_iface(pkt));

	return NET_DROP;
   1225c:	b8 02 00 00 00       	mov    $0x2,%eax
   12261:	eb 16                	jmp    12279 <net_ipv6_input+0x3d8>
	verdict = net_conn_input(pkt, &ip, nexthdr, &proto_hdr);
   12263:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	ip.ipv6 = hdr;
   12266:	89 7d d8             	mov    %edi,-0x28(%ebp)
	verdict = net_conn_input(pkt, &ip, nexthdr, &proto_hdr);
   12269:	50                   	push   %eax
   1226a:	8d 45 d8             	lea    -0x28(%ebp),%eax
   1226d:	6a 11                	push   $0x11
   1226f:	50                   	push   %eax
   12270:	53                   	push   %ebx
   12271:	e8 81 43 00 00       	call   165f7 <net_conn_input>
   12276:	83 c4 10             	add    $0x10,%esp
}
   12279:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1227c:	5b                   	pop    %ebx
   1227d:	5e                   	pop    %esi
   1227e:	5f                   	pop    %edi
   1227f:	5d                   	pop    %ebp
   12280:	c3                   	ret    

00012281 <net_ipv6_init>:

void net_ipv6_init(void)
{
   12281:	55                   	push   %ebp
   12282:	89 e5                	mov    %esp,%ebp
	net_ipv6_nbr_init();
   12284:	e8 6a 1b 00 00       	call   13df3 <net_ipv6_nbr_init>

#if defined(CONFIG_NET_IPV6_MLD)
	net_ipv6_mld_init();
#endif
}
   12289:	5d                   	pop    %ebp
	net_ipv6_mld_init();
   1228a:	e9 4e 20 00 00       	jmp    142dd <net_ipv6_mld_init>

0001228f <net_ipv6_is_addr_unspecified>:
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   1228f:	31 d2                	xor    %edx,%edx
   12291:	83 38 00             	cmpl   $0x0,(%eax)
   12294:	75 15                	jne    122ab <net_ipv6_is_addr_unspecified+0x1c>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
   12296:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   1229a:	75 0f                	jne    122ab <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
   1229c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   122a0:	75 09                	jne    122ab <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   122a2:	31 d2                	xor    %edx,%edx
   122a4:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   122a8:	0f 94 c2             	sete   %dl
   122ab:	88 d0                	mov    %dl,%al
   122ad:	83 e0 01             	and    $0x1,%eax
}
   122b0:	c3                   	ret    

000122b1 <ipv6_nbr_set_state>:
}

static void ipv6_nbr_set_state(struct net_nbr *nbr,
			       enum net_ipv6_nbr_state new_state)
{
	if (new_state == net_ipv6_nbr_data(nbr)->state ||
   122b1:	8b 40 0c             	mov    0xc(%eax),%eax
   122b4:	8b 48 28             	mov    0x28(%eax),%ecx
   122b7:	39 d1                	cmp    %edx,%ecx
   122b9:	74 08                	je     122c3 <ipv6_nbr_set_state+0x12>
   122bb:	83 f9 05             	cmp    $0x5,%ecx
   122be:	74 03                	je     122c3 <ipv6_nbr_set_state+0x12>

	NET_DBG("nbr %p %s -> %s", nbr,
		net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state),
		net_ipv6_nbr_state2str(new_state));

	net_ipv6_nbr_data(nbr)->state = new_state;
   122c0:	89 50 28             	mov    %edx,0x28(%eax)
}
   122c3:	c3                   	ret    

000122c4 <iface_cb>:
	net_nbr_cb_t cb;
	void *user_data;
};

static void iface_cb(struct net_if *iface, void *user_data)
{
   122c4:	55                   	push   %ebp
   122c5:	89 e5                	mov    %esp,%ebp
   122c7:	56                   	push   %esi
   122c8:	53                   	push   %ebx
   122c9:	31 db                	xor    %ebx,%ebx
   122cb:	8b 75 0c             	mov    0xc(%ebp),%esi
	int i;

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref || nbr->iface != iface) {
   122ce:	80 bb 00 a0 40 00 00 	cmpb   $0x0,0x40a000(%ebx)
   122d5:	74 19                	je     122f0 <iface_cb+0x2c>
   122d7:	8b 45 08             	mov    0x8(%ebp),%eax
   122da:	39 83 08 a0 40 00    	cmp    %eax,0x40a008(%ebx)
   122e0:	75 0e                	jne    122f0 <iface_cb+0x2c>
			continue;
		}

		data->cb(nbr, data->user_data);
   122e2:	ff 76 04             	pushl  0x4(%esi)
   122e5:	8d 83 00 a0 40 00    	lea    0x40a000(%ebx),%eax
   122eb:	50                   	push   %eax
   122ec:	ff 16                	call   *(%esi)
   122ee:	58                   	pop    %eax
   122ef:	5a                   	pop    %edx
   122f0:	83 c3 44             	add    $0x44,%ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   122f3:	81 fb 20 02 00 00    	cmp    $0x220,%ebx
   122f9:	75 d3                	jne    122ce <iface_cb+0xa>
	}
}
   122fb:	8d 65 f8             	lea    -0x8(%ebp),%esp
   122fe:	5b                   	pop    %ebx
   122ff:	5e                   	pop    %esi
   12300:	5d                   	pop    %ebp
   12301:	c3                   	ret    

00012302 <net_neighbor_data_remove>:
void net_neighbor_data_remove(struct net_nbr *nbr)
{
	NET_DBG("Neighbor %p removed", nbr);

	return;
}
   12302:	c3                   	ret    

00012303 <nbr_clear_ns_pending>:
	if (data->pending) {
   12303:	8b 10                	mov    (%eax),%edx
	data->send_ns = 0;
   12305:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   1230c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	if (data->pending) {
   12313:	85 d2                	test   %edx,%edx
   12315:	74 18                	je     1232f <nbr_clear_ns_pending+0x2c>
{
   12317:	55                   	push   %ebp
   12318:	89 e5                	mov    %esp,%ebp
   1231a:	53                   	push   %ebx
   1231b:	89 c3                	mov    %eax,%ebx
		net_pkt_unref(data->pending);
   1231d:	52                   	push   %edx
   1231e:	e8 de da ff ff       	call   fe01 <net_pkt_unref>
   12323:	58                   	pop    %eax
		data->pending = NULL;
   12324:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
   1232a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1232d:	c9                   	leave  
   1232e:	c3                   	ret    
   1232f:	c3                   	ret    

00012330 <nbr_free>:
{
   12330:	55                   	push   %ebp
   12331:	89 e5                	mov    %esp,%ebp
   12333:	53                   	push   %ebx
   12334:	89 c3                	mov    %eax,%ebx
	nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
   12336:	8b 40 0c             	mov    0xc(%eax),%eax
   12339:	e8 c5 ff ff ff       	call   12303 <nbr_clear_ns_pending>
	net_ipv6_nbr_data(nbr)->reachable = 0;
   1233e:	8b 43 0c             	mov    0xc(%ebx),%eax
   12341:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   12348:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
   1234f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	net_nbr_unref(nbr);
   12356:	53                   	push   %ebx
   12357:	e8 30 f8 ff ff       	call   11b8c <net_nbr_unref>
	net_nbr_unlink(nbr, NULL);
   1235c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   12363:	53                   	push   %ebx
   12364:	e8 51 f9 ff ff       	call   11cba <net_nbr_unlink>
   12369:	58                   	pop    %eax
}
   1236a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_nbr_unlink(nbr, NULL);
   1236d:	5a                   	pop    %edx
}
   1236e:	c9                   	leave  
   1236f:	c3                   	ret    

00012370 <net_linkaddr_set>:
	if (!lladdr_store || !new_addr) {
   12370:	85 c0                	test   %eax,%eax
   12372:	74 2c                	je     123a0 <net_linkaddr_set+0x30>
   12374:	85 d2                	test   %edx,%edx
   12376:	74 28                	je     123a0 <net_linkaddr_set+0x30>
{
   12378:	55                   	push   %ebp
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
   12379:	80 f9 06             	cmp    $0x6,%cl
{
   1237c:	89 e5                	mov    %esp,%ebp
   1237e:	53                   	push   %ebx
   1237f:	89 c3                	mov    %eax,%ebx
		return -EMSGSIZE;
   12381:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
   12386:	77 1e                	ja     123a6 <net_linkaddr_set+0x36>
	lladdr_store->len = new_len;
   12388:	88 4b 01             	mov    %cl,0x1(%ebx)
	memcpy(lladdr_store->addr, new_addr, new_len);
   1238b:	83 c3 02             	add    $0x2,%ebx
   1238e:	0f b6 c9             	movzbl %cl,%ecx
   12391:	51                   	push   %ecx
   12392:	52                   	push   %edx
   12393:	53                   	push   %ebx
   12394:	e8 98 85 ff ff       	call   a931 <memcpy>
   12399:	83 c4 0c             	add    $0xc,%esp

	return 0;
   1239c:	31 c0                	xor    %eax,%eax
   1239e:	eb 06                	jmp    123a6 <net_linkaddr_set+0x36>
		return -EINVAL;
   123a0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   123a5:	c3                   	ret    
   123a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   123a9:	c9                   	leave  
   123aa:	c3                   	ret    

000123ab <k_delayed_work_remaining_get>:
{
   123ab:	55                   	push   %ebp
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
   123ac:	83 c0 0c             	add    $0xc,%eax
{
   123af:	89 e5                	mov    %esp,%ebp
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
   123b1:	50                   	push   %eax
   123b2:	e8 82 23 01 00       	call   24739 <z_timeout_remaining>
   123b7:	ba e8 03 00 00       	mov    $0x3e8,%edx
   123bc:	f7 ea                	imul   %edx
   123be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   123c5:	6a 64                	push   $0x64
   123c7:	52                   	push   %edx
   123c8:	50                   	push   %eax
   123c9:	e8 1f ee fe ff       	call   11ed <__udivdi3>
   123ce:	83 c4 10             	add    $0x10,%esp
}
   123d1:	c9                   	leave  
   123d2:	c3                   	ret    

000123d3 <k_delayed_work_submit>:
{
   123d3:	55                   	push   %ebp
   123d4:	89 e5                	mov    %esp,%ebp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   123d6:	52                   	push   %edx
   123d7:	50                   	push   %eax
   123d8:	68 60 41 40 00       	push   $0x404160
   123dd:	e8 f3 20 01 00       	call   244d5 <k_delayed_work_submit_to_queue>
   123e2:	83 c4 0c             	add    $0xc,%esp
}
   123e5:	c9                   	leave  
   123e6:	c3                   	ret    

000123e7 <ipv6_ns_reply_timeout>:
{
   123e7:	55                   	push   %ebp
   123e8:	89 e5                	mov    %esp,%ebp
   123ea:	56                   	push   %esi
   123eb:	53                   	push   %ebx
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
   123ec:	31 db                	xor    %ebx,%ebx
{
   123ee:	83 ec 10             	sub    $0x10,%esp
   123f1:	be 00 a0 40 00       	mov    $0x40a000,%esi
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   123f6:	e8 16 25 01 00       	call   24911 <z_impl_k_uptime_get>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
   123fb:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
   12400:	29 c1                	sub    %eax,%ecx
   12402:	19 d3                	sbb    %edx,%ebx
   12404:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   12407:	89 5d f4             	mov    %ebx,-0xc(%ebp)
		if (!nbr || !nbr->ref) {
   1240a:	80 3e 00             	cmpb   $0x0,(%esi)
   1240d:	74 79                	je     12488 <ipv6_ns_reply_timeout+0xa1>
		data = net_ipv6_nbr_data(nbr);
   1240f:	8b 5e 0c             	mov    0xc(%esi),%ebx
		if (!data) {
   12412:	85 db                	test   %ebx,%ebx
   12414:	74 72                	je     12488 <ipv6_ns_reply_timeout+0xa1>
		if (!data->send_ns) {
   12416:	8b 53 24             	mov    0x24(%ebx),%edx
   12419:	8b 43 20             	mov    0x20(%ebx),%eax
   1241c:	89 d1                	mov    %edx,%ecx
   1241e:	09 c1                	or     %eax,%ecx
   12420:	74 66                	je     12488 <ipv6_ns_reply_timeout+0xa1>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
   12422:	03 45 f0             	add    -0x10(%ebp),%eax
   12425:	13 55 f4             	adc    -0xc(%ebp),%edx
   12428:	89 d1                	mov    %edx,%ecx
   1242a:	89 c2                	mov    %eax,%edx
		if (remaining > 0) {
   1242c:	31 c0                	xor    %eax,%eax
   1242e:	39 d0                	cmp    %edx,%eax
   12430:	19 c8                	sbb    %ecx,%eax
   12432:	7d 23                	jge    12457 <ipv6_ns_reply_timeout+0x70>
			if (!k_delayed_work_remaining_get(
   12434:	b8 60 0f 40 00       	mov    $0x400f60,%eax
   12439:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1243c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   1243f:	e8 67 ff ff ff       	call   123ab <k_delayed_work_remaining_get>
   12444:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12447:	85 c0                	test   %eax,%eax
   12449:	75 3d                	jne    12488 <ipv6_ns_reply_timeout+0xa1>
				k_delayed_work_submit(&ipv6_ns_reply_timer,
   1244b:	b8 60 0f 40 00       	mov    $0x400f60,%eax
   12450:	e8 7e ff ff ff       	call   123d3 <k_delayed_work_submit>
   12455:	eb 31                	jmp    12488 <ipv6_ns_reply_timeout+0xa1>
		if (!data->pending) {
   12457:	8b 03                	mov    (%ebx),%eax
		data->send_ns = 0;
   12459:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
   12460:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
		if (!data->pending) {
   12467:	85 c0                	test   %eax,%eax
   12469:	74 1d                	je     12488 <ipv6_ns_reply_timeout+0xa1>
		net_pkt_unref(data->pending);
   1246b:	50                   	push   %eax
   1246c:	e8 90 d9 ff ff       	call   fe01 <net_pkt_unref>
   12471:	58                   	pop    %eax
		net_pkt_unref(data->pending);
   12472:	ff 33                	pushl  (%ebx)
   12474:	e8 88 d9 ff ff       	call   fe01 <net_pkt_unref>
		data->pending = NULL;
   12479:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		net_nbr_unref(nbr);
   1247f:	89 34 24             	mov    %esi,(%esp)
   12482:	e8 05 f7 ff ff       	call   11b8c <net_nbr_unref>
   12487:	5a                   	pop    %edx
   12488:	83 c6 44             	add    $0x44,%esi
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   1248b:	81 fe 20 a2 40 00    	cmp    $0x40a220,%esi
   12491:	0f 85 73 ff ff ff    	jne    1240a <ipv6_ns_reply_timeout+0x23>
}
   12497:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1249a:	5b                   	pop    %ebx
   1249b:	5e                   	pop    %esi
   1249c:	5d                   	pop    %ebp
   1249d:	c3                   	ret    

0001249e <set_llao>:
}

static inline bool set_llao(struct net_pkt *pkt,
			    struct net_linkaddr *lladdr,
			    u8_t llao_len, u8_t type)
{
   1249e:	55                   	push   %ebp
   1249f:	89 e5                	mov    %esp,%ebp
   124a1:	57                   	push   %edi
   124a2:	56                   	push   %esi
   124a3:	89 c6                	mov    %eax,%esi
   124a5:	53                   	push   %ebx
   124a6:	89 d7                	mov    %edx,%edi
   124a8:	53                   	push   %ebx
   124a9:	89 cb                	mov    %ecx,%ebx
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
   124ab:	8b 45 08             	mov    0x8(%ebp),%eax
		.type = type,
		.len  = llao_len >> 3,
	};

	if (net_pkt_write(pkt, &opt_hdr,
   124ae:	6a 02                	push   $0x2
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
   124b0:	88 45 f2             	mov    %al,-0xe(%ebp)
   124b3:	88 c8                	mov    %cl,%al
   124b5:	c0 e8 03             	shr    $0x3,%al
   124b8:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (net_pkt_write(pkt, &opt_hdr,
   124bb:	8d 45 f2             	lea    -0xe(%ebp),%eax
   124be:	50                   	push   %eax
   124bf:	56                   	push   %esi
   124c0:	e8 52 e0 ff ff       	call   10517 <net_pkt_write>
   124c5:	83 c4 0c             	add    $0xc,%esp
   124c8:	85 c0                	test   %eax,%eax
   124ca:	74 04                	je     124d0 <set_llao+0x32>
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
		return false;
   124cc:	31 c0                	xor    %eax,%eax
   124ce:	eb 31                	jmp    12501 <set_llao+0x63>
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
   124d0:	0f b6 47 04          	movzbl 0x4(%edi),%eax
   124d4:	50                   	push   %eax
   124d5:	ff 37                	pushl  (%edi)
   124d7:	56                   	push   %esi
   124d8:	e8 3a e0 ff ff       	call   10517 <net_pkt_write>
   124dd:	83 c4 0c             	add    $0xc,%esp
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
   124e0:	85 c0                	test   %eax,%eax
   124e2:	75 e8                	jne    124cc <set_llao+0x2e>
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
   124e4:	0f b6 47 04          	movzbl 0x4(%edi),%eax
   124e8:	0f b6 db             	movzbl %bl,%ebx
   124eb:	29 c3                	sub    %eax,%ebx
   124ed:	83 eb 02             	sub    $0x2,%ebx
   124f0:	53                   	push   %ebx
   124f1:	6a 00                	push   $0x0
   124f3:	56                   	push   %esi
   124f4:	e8 06 de ff ff       	call   102ff <net_pkt_memset>
   124f9:	83 c4 0c             	add    $0xc,%esp
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
   124fc:	85 c0                	test   %eax,%eax
   124fe:	0f 94 c0             	sete   %al
	}

	return true;
}
   12501:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12504:	5b                   	pop    %ebx
   12505:	5e                   	pop    %esi
   12506:	5f                   	pop    %edi
   12507:	5d                   	pop    %ebp
   12508:	c3                   	ret    

00012509 <nbr_lookup.isra.12>:
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
   12509:	55                   	push   %ebp
   1250a:	89 e5                	mov    %esp,%ebp
   1250c:	57                   	push   %edi
   1250d:	56                   	push   %esi
   1250e:	89 c7                	mov    %eax,%edi
   12510:	53                   	push   %ebx
   12511:	31 db                	xor    %ebx,%ebx
   12513:	51                   	push   %ecx
		if (!nbr->ref) {
   12514:	80 bb 00 a0 40 00 00 	cmpb   $0x0,0x40a000(%ebx)
   1251b:	75 0f                	jne    1252c <nbr_lookup.isra.12+0x23>
   1251d:	83 c3 44             	add    $0x44,%ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   12520:	81 fb 20 02 00 00    	cmp    $0x220,%ebx
   12526:	75 ec                	jne    12514 <nbr_lookup.isra.12+0xb>
	return NULL;
   12528:	31 f6                	xor    %esi,%esi
   1252a:	eb 31                	jmp    1255d <nbr_lookup.isra.12+0x54>
		if (iface && nbr->iface != iface) {
   1252c:	85 ff                	test   %edi,%edi
   1252e:	74 08                	je     12538 <nbr_lookup.isra.12+0x2f>
   12530:	3b bb 08 a0 40 00    	cmp    0x40a008(%ebx),%edi
   12536:	75 e5                	jne    1251d <nbr_lookup.isra.12+0x14>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
   12538:	6a 10                	push   $0x10
		if (net_ipv6_addr_cmp(&net_ipv6_nbr_data(nbr)->addr, addr)) {
   1253a:	8b 83 0c a0 40 00    	mov    0x40a00c(%ebx),%eax
   12540:	52                   	push   %edx
   12541:	83 c0 04             	add    $0x4,%eax
   12544:	89 55 f0             	mov    %edx,-0x10(%ebp)
   12547:	50                   	push   %eax
   12548:	e8 79 83 ff ff       	call   a8c6 <memcmp>
   1254d:	8d b3 00 a0 40 00    	lea    0x40a000(%ebx),%esi
   12553:	83 c4 0c             	add    $0xc,%esp
   12556:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12559:	85 c0                	test   %eax,%eax
   1255b:	75 c0                	jne    1251d <nbr_lookup.isra.12+0x14>
}
   1255d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12560:	89 f0                	mov    %esi,%eax
   12562:	5b                   	pop    %ebx
   12563:	5e                   	pop    %esi
   12564:	5f                   	pop    %edi
   12565:	5d                   	pop    %ebp
   12566:	c3                   	ret    

00012567 <dad_failed>:
{
   12567:	55                   	push   %ebp
   12568:	89 e5                	mov    %esp,%ebp
   1256a:	53                   	push   %ebx
	if (net_ipv6_is_ll_addr(addr)) {
   1256b:	66 81 3a fe 80       	cmpw   $0x80fe,(%edx)
   12570:	75 2e                	jne    125a0 <dad_failed+0x39>
		NET_ERR("DAD failed, no ll IPv6 address!");
   12572:	31 db                	xor    %ebx,%ebx
   12574:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   1257b:	74 2e                	je     125ab <dad_failed+0x44>
   1257d:	ba bc 51 02 00       	mov    $0x251bc,%edx
   12582:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   12588:	c1 ea 03             	shr    $0x3,%edx
   1258b:	c1 e2 06             	shl    $0x6,%edx
   1258e:	83 ca 01             	or     $0x1,%edx
   12591:	52                   	push   %edx
   12592:	68 1a 7c 02 00       	push   $0x27c1a
   12597:	e8 ee 0e ff ff       	call   348a <log_0>
   1259c:	59                   	pop    %ecx
   1259d:	58                   	pop    %eax
   1259e:	eb 0b                	jmp    125ab <dad_failed+0x44>
	net_if_ipv6_dad_failed(iface, addr);
   125a0:	52                   	push   %edx
	return true;
   125a1:	b3 01                	mov    $0x1,%bl
	net_if_ipv6_dad_failed(iface, addr);
   125a3:	50                   	push   %eax
   125a4:	e8 31 c2 ff ff       	call   e7da <net_if_ipv6_dad_failed>
   125a9:	58                   	pop    %eax
   125aa:	5a                   	pop    %edx
}
   125ab:	88 d8                	mov    %bl,%al
   125ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   125b0:	c9                   	leave  
   125b1:	c3                   	ret    

000125b2 <nbr_new.constprop.18>:
static struct net_nbr *nbr_new(struct net_if *iface,
   125b2:	55                   	push   %ebp
   125b3:	89 e5                	mov    %esp,%ebp
   125b5:	57                   	push   %edi
   125b6:	56                   	push   %esi
   125b7:	89 c7                	mov    %eax,%edi
   125b9:	53                   	push   %ebx
   125ba:	89 d6                	mov    %edx,%esi
   125bc:	83 ec 14             	sub    $0x14,%esp
   125bf:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
   125c2:	68 cc a6 40 00       	push   $0x40a6cc
   125c7:	e8 d6 f5 ff ff       	call   11ba2 <net_nbr_get>
   125cc:	5a                   	pop    %edx
   125cd:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
   125cf:	85 c0                	test   %eax,%eax
   125d1:	74 5b                	je     1262e <nbr_new.constprop.18+0x7c>
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
   125d3:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
	nbr->iface = iface;
   125d7:	89 78 08             	mov    %edi,0x8(%eax)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
   125da:	b9 04 00 00 00       	mov    $0x4,%ecx
   125df:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   125e2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   125e4:	8b 40 0c             	mov    0xc(%eax),%eax
   125e7:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   125ea:	b9 04 00 00 00       	mov    $0x4,%ecx
	ipv6_nbr_set_state(nbr, state);
   125ef:	8b 55 e0             	mov    -0x20(%ebp),%edx
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
   125f2:	8d 78 04             	lea    0x4(%eax),%edi
	ipv6_nbr_set_state(nbr, state);
   125f5:	89 d8                	mov    %ebx,%eax
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
   125f7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ipv6_nbr_set_state(nbr, state);
   125f9:	e8 b3 fc ff ff       	call   122b1 <ipv6_nbr_set_state>
	net_ipv6_nbr_data(nbr)->is_router = is_router;
   125fe:	8b 43 0c             	mov    0xc(%ebx),%eax
   12601:	c6 40 2f 01          	movb   $0x1,0x2f(%eax)
	net_ipv6_nbr_data(nbr)->pending = NULL;
   12605:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
   1260b:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   12612:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	net_ipv6_nbr_data(nbr)->reachable = 0;
   12619:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   12620:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
   12627:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
}
   1262e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12631:	89 d8                	mov    %ebx,%eax
   12633:	5b                   	pop    %ebx
   12634:	5e                   	pop    %esi
   12635:	5f                   	pop    %edi
   12636:	5d                   	pop    %ebp
   12637:	c3                   	ret    

00012638 <net_neighbor_table_clear>:
   12638:	c3                   	ret    

00012639 <dbg_update_neighbor_lladdr.isra.13>:
static void dbg_update_neighbor_lladdr(struct net_linkaddr *new_lladdr,
   12639:	55                   	push   %ebp
		 net_sprint_ll_addr(old_lladdr->addr, old_lladdr->len));
   1263a:	83 c0 02             	add    $0x2,%eax
static void dbg_update_neighbor_lladdr(struct net_linkaddr *new_lladdr,
   1263d:	89 e5                	mov    %esp,%ebp
   1263f:	83 ec 18             	sub    $0x18,%esp

static inline char *net_sprint_ll_addr(const u8_t *ll, u8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
   12642:	6a 18                	push   $0x18
   12644:	68 c8 42 40 00       	push   $0x4042c8
	snprintk(out, sizeof(out), "%s",
   12649:	0f b6 50 ff          	movzbl -0x1(%eax),%edx
   1264d:	52                   	push   %edx
   1264e:	50                   	push   %eax
   1264f:	e8 a3 e1 ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   12654:	83 c4 10             	add    $0x10,%esp
   12657:	50                   	push   %eax
   12658:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1265b:	68 6a a5 02 00       	push   $0x2a56a
   12660:	6a 18                	push   $0x18
   12662:	50                   	push   %eax
   12663:	e8 75 05 ff ff       	call   2bdd <snprintk>
   12668:	83 c4 10             	add    $0x10,%esp
}
   1266b:	c9                   	leave  
   1266c:	c3                   	ret    

0001266d <net_ipv6_nbr_state2str>:
{
   1266d:	55                   	push   %ebp
   1266e:	b8 3a 7c 02 00       	mov    $0x27c3a,%eax
   12673:	89 e5                	mov    %esp,%ebp
   12675:	8b 55 08             	mov    0x8(%ebp),%edx
   12678:	83 fa 05             	cmp    $0x5,%edx
   1267b:	77 07                	ja     12684 <net_ipv6_nbr_state2str+0x17>
   1267d:	8b 04 95 60 60 02 00 	mov    0x26060(,%edx,4),%eax
}
   12684:	5d                   	pop    %ebp
   12685:	c3                   	ret    

00012686 <net_ipv6_nbr_foreach>:
{
   12686:	55                   	push   %ebp
   12687:	89 e5                	mov    %esp,%ebp
   12689:	83 ec 08             	sub    $0x8,%esp
	struct iface_cb_data cb_data = {
   1268c:	8b 45 08             	mov    0x8(%ebp),%eax
   1268f:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12692:	8b 45 0c             	mov    0xc(%ebp),%eax
   12695:	89 45 fc             	mov    %eax,-0x4(%ebp)
	net_if_foreach(iface_cb, &cb_data);
   12698:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1269b:	50                   	push   %eax
   1269c:	68 c4 22 01 00       	push   $0x122c4
   126a1:	e8 f9 d1 ff ff       	call   f89f <net_if_foreach>
   126a6:	5a                   	pop    %edx
   126a7:	59                   	pop    %ecx
}
   126a8:	c9                   	leave  
   126a9:	c3                   	ret    

000126aa <net_ipv6_nbr_rm>:
{
   126aa:	55                   	push   %ebp
   126ab:	89 e5                	mov    %esp,%ebp
   126ad:	57                   	push   %edi
   126ae:	56                   	push   %esi
   126af:	53                   	push   %ebx
   126b0:	8b 75 0c             	mov    0xc(%ebp),%esi
   126b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
   126b6:	89 f2                	mov    %esi,%edx
   126b8:	89 d8                	mov    %ebx,%eax
   126ba:	e8 4a fe ff ff       	call   12509 <nbr_lookup.isra.12>
   126bf:	89 c7                	mov    %eax,%edi
	if (!nbr) {
   126c1:	31 c0                	xor    %eax,%eax
   126c3:	85 ff                	test   %edi,%edi
   126c5:	74 24                	je     126eb <net_ipv6_nbr_rm+0x41>
	net_route_del_by_nexthop(iface, addr);
   126c7:	56                   	push   %esi
   126c8:	53                   	push   %ebx
   126c9:	e8 23 21 00 00       	call   147f1 <net_route_del_by_nexthop>
   126ce:	58                   	pop    %eax
	nbr_free(nbr);
   126cf:	89 f8                	mov    %edi,%eax
	net_route_del_by_nexthop(iface, addr);
   126d1:	5a                   	pop    %edx
	nbr_free(nbr);
   126d2:	e8 59 fc ff ff       	call   12330 <nbr_free>
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
   126d7:	6a 00                	push   $0x0
   126d9:	6a 00                	push   $0x0
   126db:	53                   	push   %ebx
   126dc:	68 10 00 60 f0       	push   $0xf0600010
   126e1:	e8 dd 1d 00 00       	call   144c3 <net_mgmt_event_notify_with_info>
   126e6:	83 c4 10             	add    $0x10,%esp
	return true;
   126e9:	b0 01                	mov    $0x1,%al
}
   126eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   126ee:	5b                   	pop    %ebx
   126ef:	5e                   	pop    %esi
   126f0:	5f                   	pop    %edi
   126f1:	5d                   	pop    %ebp
   126f2:	c3                   	ret    

000126f3 <net_ipv6_nbr_lookup>:
{
   126f3:	55                   	push   %ebp
   126f4:	89 e5                	mov    %esp,%ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
   126f6:	8b 55 0c             	mov    0xc(%ebp),%edx
   126f9:	8b 45 08             	mov    0x8(%ebp),%eax
}
   126fc:	5d                   	pop    %ebp
	return nbr_lookup(&net_neighbor.table, iface, addr);
   126fd:	e9 07 fe ff ff       	jmp    12509 <nbr_lookup.isra.12>

00012702 <net_ipv6_send_na>:
}

int net_ipv6_send_na(struct net_if *iface, const struct in6_addr *src,
		     const struct in6_addr *dst, const struct in6_addr *tgt,
		     u8_t flags)
{
   12702:	55                   	push   %ebp
   12703:	89 e5                	mov    %esp,%ebp
   12705:	57                   	push   %edi
   12706:	56                   	push   %esi
   12707:	53                   	push   %ebx
   12708:	83 ec 24             	sub    $0x24,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
   1270b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
{
   12712:	8b 45 18             	mov    0x18(%ebp),%eax
   12715:	8b 75 14             	mov    0x14(%ebp),%esi
   12718:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (net_if_get_link_addr(iface)->len == 6) {
   1271b:	8b 45 08             	mov    0x8(%ebp),%eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
   1271e:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
	if (net_if_get_link_addr(iface)->len == 6) {
   12725:	8b 00                	mov    (%eax),%eax
   12727:	8a 50 14             	mov    0x14(%eax),%dl
   1272a:	b0 08                	mov    $0x8,%al
   1272c:	80 fa 06             	cmp    $0x6,%dl
   1272f:	74 09                	je     1273a <net_ipv6_send_na+0x38>
		return 16;
   12731:	80 fa 08             	cmp    $0x8,%dl
   12734:	0f 94 c0             	sete   %al
   12737:	c1 e0 04             	shl    $0x4,%eax
	struct net_pkt *pkt;
	u8_t llao_len;

	llao_len = get_llao_len(iface);

	pkt = net_pkt_alloc_with_buffer(iface,
   1273a:	6a 64                	push   $0x64
					sizeof(struct net_icmpv6_na_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
		return -ENOMEM;
   1273c:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	pkt = net_pkt_alloc_with_buffer(iface,
   12741:	6a 3a                	push   $0x3a
   12743:	0f b6 c0             	movzbl %al,%eax
   12746:	6a 02                	push   $0x2
   12748:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1274b:	83 c0 14             	add    $0x14,%eax
   1274e:	50                   	push   %eax
   1274f:	ff 75 08             	pushl  0x8(%ebp)
   12752:	e8 5e db ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   12757:	83 c4 14             	add    $0x14,%esp
   1275a:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
   1275c:	85 c0                	test   %eax,%eax
   1275e:	0f 84 cf 00 00 00    	je     12833 <net_ipv6_send_na+0x131>
	pkt->ipv6_hop_limit = hop_limit;
   12764:	c6 40 41 ff          	movb   $0xff,0x41(%eax)
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
   12768:	ff 75 10             	pushl  0x10(%ebp)
   1276b:	ff 75 0c             	pushl  0xc(%ebp)
   1276e:	50                   	push   %eax
   1276f:	e8 c7 f5 ff ff       	call   11d3b <net_ipv6_create>
   12774:	83 c4 0c             	add    $0xc,%esp
   12777:	85 c0                	test   %eax,%eax
   12779:	74 0a                	je     12785 <net_ipv6_send_na+0x83>
	int ret = -ENOBUFS;
   1277b:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
   12780:	e9 a7 00 00 00       	jmp    1282c <net_ipv6_send_na+0x12a>
	    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {
   12785:	6a 00                	push   $0x0
   12787:	68 88 00 00 00       	push   $0x88
   1278c:	53                   	push   %ebx
   1278d:	e8 8d ef ff ff       	call   1171f <net_icmpv6_create>
   12792:	83 c4 0c             	add    $0xc,%esp
	if (net_ipv6_create(pkt, src, dst) ||
   12795:	85 c0                	test   %eax,%eax
   12797:	75 e2                	jne    1277b <net_ipv6_send_na+0x79>
		goto drop;
	}

	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
   12799:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1279c:	50                   	push   %eax
   1279d:	53                   	push   %ebx
   1279e:	e8 c4 dd ff ff       	call   10567 <net_pkt_get_data>
   127a3:	5f                   	pop    %edi
	if (!na_hdr) {
   127a4:	85 c0                	test   %eax,%eax
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
   127a6:	5a                   	pop    %edx
	if (!na_hdr) {
   127a7:	74 d2                	je     1277b <net_ipv6_send_na+0x79>
		goto drop;
	}

	/* Let's make sure reserved part is full of 0 */
	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
   127a9:	6a 14                	push   $0x14
   127ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
   127ae:	6a 00                	push   $0x0

	na_hdr->flags = flags;
	net_ipaddr_copy(&na_hdr->tgt, tgt);
   127b0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
   127b3:	50                   	push   %eax
   127b4:	e8 e7 81 ff ff       	call   a9a0 <memset>
	na_hdr->flags = flags;
   127b9:	8b 55 d0             	mov    -0x30(%ebp),%edx
   127bc:	8a 45 d4             	mov    -0x2c(%ebp),%al
	net_ipaddr_copy(&na_hdr->tgt, tgt);
   127bf:	b9 04 00 00 00       	mov    $0x4,%ecx
	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
   127c4:	83 c4 0c             	add    $0xc,%esp
	na_hdr->flags = flags;
   127c7:	88 02                	mov    %al,(%edx)

	if (net_pkt_set_data(pkt, &na_access)) {
   127c9:	8d 45 dc             	lea    -0x24(%ebp),%eax
	net_ipaddr_copy(&na_hdr->tgt, tgt);
   127cc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   127ce:	8d 7a 04             	lea    0x4(%edx),%edi
   127d1:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   127d4:	b9 04 00 00 00       	mov    $0x4,%ecx
   127d9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &na_access)) {
   127db:	50                   	push   %eax
   127dc:	53                   	push   %ebx
   127dd:	e8 1c de ff ff       	call   105fe <net_pkt_set_data>
   127e2:	59                   	pop    %ecx
   127e3:	89 c7                	mov    %eax,%edi
   127e5:	5e                   	pop    %esi
   127e6:	85 c0                	test   %eax,%eax
   127e8:	75 91                	jne    1277b <net_ipv6_send_na+0x79>
	return &iface->if_dev->link_addr;
   127ea:	8b 45 08             	mov    0x8(%ebp),%eax
		goto drop;
	}

	if (!set_llao(pkt, net_if_get_link_addr(iface),
   127ed:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   127f0:	8b 10                	mov    (%eax),%edx
   127f2:	89 d8                	mov    %ebx,%eax
   127f4:	83 c2 10             	add    $0x10,%edx
   127f7:	6a 02                	push   $0x2
   127f9:	e8 a0 fc ff ff       	call   1249e <set_llao>
   127fe:	5a                   	pop    %edx
   127ff:	84 c0                	test   %al,%al
   12801:	0f 84 74 ff ff ff    	je     1277b <net_ipv6_send_na+0x79>
		      llao_len, NET_ICMPV6_ND_OPT_TLLAO)) {
		goto drop;
	}

	net_pkt_cursor_init(pkt);
   12807:	53                   	push   %ebx
   12808:	e8 60 d7 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   1280d:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   12814:	53                   	push   %ebx
   12815:	e8 d1 f5 ff ff       	call   11deb <net_ipv6_finalize>
   1281a:	5a                   	pop    %edx
   1281b:	59                   	pop    %ecx

	dbg_addr_sent_tgt("Neighbor Advertisement", src, dst, &na_hdr->tgt);

	if (net_send_data(pkt) < 0) {
   1281c:	53                   	push   %ebx
   1281d:	e8 2b b0 ff ff       	call   d84d <net_send_data>
   12822:	5e                   	pop    %esi
   12823:	85 c0                	test   %eax,%eax
   12825:	79 0c                	jns    12833 <net_ipv6_send_na+0x131>
		net_stats_update_ipv6_nd_drop(iface);
		ret = -EINVAL;
   12827:	bf ea ff ff ff       	mov    $0xffffffea,%edi
	net_stats_update_ipv6_nd_sent(iface);

	return 0;

drop:
	net_pkt_unref(pkt);
   1282c:	53                   	push   %ebx
   1282d:	e8 cf d5 ff ff       	call   fe01 <net_pkt_unref>
   12832:	58                   	pop    %eax

	return ret;
}
   12833:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12836:	89 f8                	mov    %edi,%eax
   12838:	5b                   	pop    %ebx
   12839:	5e                   	pop    %esi
   1283a:	5f                   	pop    %edi
   1283b:	5d                   	pop    %ebp
   1283c:	c3                   	ret    

0001283d <net_ipv6_nbr_set_reachable_timer>:
	}
}

void net_ipv6_nbr_set_reachable_timer(struct net_if *iface,
				      struct net_nbr *nbr)
{
   1283d:	55                   	push   %ebp
   1283e:	89 e5                	mov    %esp,%ebp
   12840:	57                   	push   %edi
   12841:	56                   	push   %esi
	u32_t time;

	time = net_if_ipv6_get_reachable_time(iface);
   12842:	8b 45 08             	mov    0x8(%ebp),%eax
{
   12845:	53                   	push   %ebx
   12846:	8b 75 0c             	mov    0xc(%ebp),%esi
   12849:	31 db                	xor    %ebx,%ebx
	time = net_if_ipv6_get_reachable_time(iface);
   1284b:	8b 40 04             	mov    0x4(%eax),%eax
	if (!iface->config.ip.ipv6) {
   1284e:	85 c0                	test   %eax,%eax
   12850:	74 06                	je     12858 <net_ipv6_nbr_set_reachable_timer+0x1b>
	return iface->config.ip.ipv6->reachable_time;
   12852:	8b 98 7c 01 00 00    	mov    0x17c(%eax),%ebx
	NET_ASSERT_INFO(time, "Zero reachable timeout!");

	NET_DBG("Starting reachable timer nbr %p data %p time %d ms",
		nbr, net_ipv6_nbr_data(nbr), time);

	net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
   12858:	8b 7e 0c             	mov    0xc(%esi),%edi
   1285b:	e8 b1 20 01 00       	call   24911 <z_impl_k_uptime_get>
   12860:	89 47 14             	mov    %eax,0x14(%edi)
	net_ipv6_nbr_data(nbr)->reachable_timeout = time;
   12863:	8b 46 0c             	mov    0xc(%esi),%eax
	net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
   12866:	89 57 18             	mov    %edx,0x18(%edi)
	net_ipv6_nbr_data(nbr)->reachable_timeout = time;
   12869:	89 58 1c             	mov    %ebx,0x1c(%eax)

	if (!k_delayed_work_remaining_get(&ipv6_nd_reachable_timer)) {
   1286c:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   12871:	e8 35 fb ff ff       	call   123ab <k_delayed_work_remaining_get>
   12876:	85 c0                	test   %eax,%eax
   12878:	75 10                	jne    1288a <net_ipv6_nbr_set_reachable_timer+0x4d>
		k_delayed_work_submit(&ipv6_nd_reachable_timer, time);
   1287a:	89 da                	mov    %ebx,%edx
	}
}
   1287c:	5b                   	pop    %ebx
   1287d:	5e                   	pop    %esi
		k_delayed_work_submit(&ipv6_nd_reachable_timer, time);
   1287e:	b8 80 0f 40 00       	mov    $0x400f80,%eax
}
   12883:	5f                   	pop    %edi
   12884:	5d                   	pop    %ebp
		k_delayed_work_submit(&ipv6_nd_reachable_timer, time);
   12885:	e9 49 fb ff ff       	jmp    123d3 <k_delayed_work_submit>
}
   1288a:	5b                   	pop    %ebx
   1288b:	5e                   	pop    %esi
   1288c:	5f                   	pop    %edi
   1288d:	5d                   	pop    %ebp
   1288e:	c3                   	ret    

0001288f <handle_na_input>:
}

static enum net_verdict handle_na_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
   1288f:	55                   	push   %ebp
   12890:	89 e5                	mov    %esp,%ebp
   12892:	57                   	push   %edi
   12893:	56                   	push   %esi
	size_t bytes = 0;
   12894:	31 f6                	xor    %esi,%esi
   12896:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
					      struct net_icmpv6_na_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   12897:	8d 45 d2             	lea    -0x2e(%ebp),%eax
{
   1289a:	83 ec 30             	sub    $0x30,%esp
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   1289d:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
   128a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
   128a3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
   128aa:	c7 45 d8 14 00 00 00 	movl   $0x14,-0x28(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   128b1:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
	u16_t length = net_pkt_get_len(pkt);
   128b8:	8b 43 14             	mov    0x14(%ebx),%eax
	while (buf) {
   128bb:	85 c0                	test   %eax,%eax
   128bd:	74 0a                	je     128c9 <handle_na_input+0x3a>
		bytes += buf->len;
   128bf:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
   128c3:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   128c5:	01 ce                	add    %ecx,%esi
		buf = buf->frags;
   128c7:	eb f2                	jmp    128bb <handle_na_input+0x2c>
	u16_t tllao_offset = 0U;
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_na_hdr *na_hdr;
	struct net_if_addr *ifaddr;

	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
   128c9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	u16_t length = net_pkt_get_len(pkt);
   128cc:	89 f7                	mov    %esi,%edi
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
   128ce:	50                   	push   %eax
   128cf:	53                   	push   %ebx
   128d0:	e8 92 dc ff ff       	call   10567 <net_pkt_get_data>
   128d5:	5a                   	pop    %edx
   128d6:	89 45 cc             	mov    %eax,-0x34(%ebp)
   128d9:	59                   	pop    %ecx
	if (!na_hdr) {
   128da:	85 c0                	test   %eax,%eax
   128dc:	75 2b                	jne    12909 <handle_na_input+0x7a>
		NET_ERR("DROP: NULL NA header");
   128de:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   128e5:	0f 84 73 02 00 00    	je     12b5e <handle_na_input+0x2cf>
   128eb:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   128f0:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   128f5:	c1 e8 03             	shr    $0x3,%eax
   128f8:	c1 e0 06             	shl    $0x6,%eax
   128fb:	83 c8 01             	or     $0x1,%eax
   128fe:	50                   	push   %eax
   128ff:	68 4a 7c 02 00       	push   $0x27c4a
   12904:	e9 cd 00 00 00       	jmp    129d6 <handle_na_input+0x147>
	dbg_addr_recv_tgt("Neighbor Advertisement",
			  &ip_hdr->src, &ip_hdr->dst, &na_hdr->tgt);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
   12909:	66 83 fe 41          	cmp    $0x41,%si
   1290d:	76 20                	jbe    1292f <handle_na_input+0xa0>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_na_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
   1290f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12912:	80 78 07 ff          	cmpb   $0xff,0x7(%eax)
   12916:	75 17                	jne    1292f <handle_na_input+0xa0>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
   12918:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1291b:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
   1291f:	74 0e                	je     1292f <handle_na_input+0xa0>
	     net_ipv6_is_addr_mcast(&na_hdr->tgt) ||
   12921:	f6 00 40             	testb  $0x40,(%eax)
   12924:	74 16                	je     1293c <handle_na_input+0xad>
	     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&
   12926:	8b 45 0c             	mov    0xc(%ebp),%eax
   12929:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
   1292d:	75 0d                	jne    1293c <handle_na_input+0xad>
	      net_ipv6_is_addr_mcast(&ip_hdr->dst))) &&
   1292f:	8b 45 10             	mov    0x10(%ebp),%eax
   12932:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   12936:	0f 85 22 02 00 00    	jne    12b5e <handle_na_input+0x2cf>
	return net_pkt_skip(pkt, access->size);
   1293c:	ff 75 d8             	pushl  -0x28(%ebp)
	}

	net_pkt_acknowledge_data(pkt, &na_access);

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_na_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
   1293f:	83 ef 2c             	sub    $0x2c,%edi
   12942:	53                   	push   %ebx
   12943:	e8 98 d9 ff ff       	call   102e0 <net_pkt_skip>
   12948:	58                   	pop    %eax

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
				net_pkt_get_data(pkt, &nd_access);
   12949:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1294c:	5a                   	pop    %edx
	pkt->ipv6_ext_opt_len = len;
   1294d:	c6 43 46 14          	movb   $0x14,0x46(%ebx)
   12951:	50                   	push   %eax
   12952:	53                   	push   %ebx
   12953:	e8 0f dc ff ff       	call   10567 <net_pkt_get_data>
   12958:	59                   	pop    %ecx
	u16_t tllao_offset = 0U;
   12959:	66 c7 45 ca 00 00    	movw   $0x0,-0x36(%ebp)
				net_pkt_get_data(pkt, &nd_access);
   1295f:	5e                   	pop    %esi

	while (nd_opt_hdr && nd_opt_hdr->len &&
   12960:	eb 17                	jmp    12979 <handle_na_input+0xea>
	return net_pkt_skip(pkt, access->size);
   12962:	ff 75 e0             	pushl  -0x20(%ebp)
   12965:	53                   	push   %ebx
   12966:	e8 75 d9 ff ff       	call   102e0 <net_pkt_skip>
   1296b:	5e                   	pop    %esi
   1296c:	58                   	pop    %eax
			goto drop;
		}

		net_pkt_acknowledge_data(pkt, &nd_access);
		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
   1296d:	8d 45 dc             	lea    -0x24(%ebp),%eax
   12970:	50                   	push   %eax
   12971:	53                   	push   %ebx
   12972:	e8 f0 db ff ff       	call   10567 <net_pkt_get_data>
   12977:	5a                   	pop    %edx
   12978:	59                   	pop    %ecx
	while (nd_opt_hdr && nd_opt_hdr->len &&
   12979:	85 c0                	test   %eax,%eax
   1297b:	74 65                	je     129e2 <handle_na_input+0x153>
   1297d:	8a 50 01             	mov    0x1(%eax),%dl
   12980:	84 d2                	test   %dl,%dl
   12982:	74 5e                	je     129e2 <handle_na_input+0x153>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
   12984:	0f b6 73 46          	movzbl 0x46(%ebx),%esi
	while (nd_opt_hdr && nd_opt_hdr->len &&
   12988:	66 39 f7             	cmp    %si,%di
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
   1298b:	89 f1                	mov    %esi,%ecx
	while (nd_opt_hdr && nd_opt_hdr->len &&
   1298d:	76 53                	jbe    129e2 <handle_na_input+0x153>
		switch (nd_opt_hdr->type) {
   1298f:	80 38 02             	cmpb   $0x2,(%eax)
   12992:	75 12                	jne    129a6 <handle_na_input+0x117>
			tllao_offset = net_pkt_ip_hdr_len(pkt) +
   12994:	66 8b 43 42          	mov    0x42(%ebx),%ax
   12998:	8d 44 06 06          	lea    0x6(%esi,%eax,1),%eax
   1299c:	0f b6 73 3c          	movzbl 0x3c(%ebx),%esi
   129a0:	01 f0                	add    %esi,%eax
   129a2:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
					     net_pkt_ipv6_ext_opt_len(pkt) +
   129a6:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
	pkt->ipv6_ext_opt_len = len;
   129a9:	88 53 46             	mov    %dl,0x46(%ebx)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
   129ac:	38 d1                	cmp    %dl,%cl
   129ae:	72 b2                	jb     12962 <handle_na_input+0xd3>
			NET_ERR("DROP: Corrupted NA message");
   129b0:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   129b7:	0f 84 a1 01 00 00    	je     12b5e <handle_na_input+0x2cf>
   129bd:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   129c2:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   129c7:	c1 e8 03             	shr    $0x3,%eax
   129ca:	c1 e0 06             	shl    $0x6,%eax
   129cd:	83 c8 01             	or     $0x1,%eax
   129d0:	50                   	push   %eax
   129d1:	68 5f 7c 02 00       	push   $0x27c5f
   129d6:	e8 af 0a ff ff       	call   348a <log_0>
   129db:	5b                   	pop    %ebx
   129dc:	5e                   	pop    %esi
   129dd:	e9 7c 01 00 00       	jmp    12b5e <handle_na_input+0x2cf>
	}

	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
   129e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
   129e5:	8d 50 04             	lea    0x4(%eax),%edx
   129e8:	52                   	push   %edx
   129e9:	89 55 c4             	mov    %edx,-0x3c(%ebp)
   129ec:	ff 73 24             	pushl  0x24(%ebx)
   129ef:	e8 11 b7 ff ff       	call   e105 <net_if_ipv6_addr_lookup_by_iface>
   129f4:	5a                   	pop    %edx
						  &na_hdr->tgt);
	if (ifaddr) {
   129f5:	85 c0                	test   %eax,%eax
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
   129f7:	59                   	pop    %ecx
	if (ifaddr) {
   129f8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   129fb:	74 17                	je     12a14 <handle_na_input+0x185>
		NET_DBG("Interface %p already has address %s",
			net_pkt_iface(pkt),
			log_strdup(net_sprint_ipv6_addr(&na_hdr->tgt)));

#if defined(CONFIG_NET_IPV6_DAD)
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
   129fd:	80 78 45 00          	cmpb   $0x0,0x45(%eax)
   12a01:	0f 85 57 01 00 00    	jne    12b5e <handle_na_input+0x2cf>
			dad_failed(net_pkt_iface(pkt), &na_hdr->tgt);
   12a07:	8b 43 24             	mov    0x24(%ebx),%eax
   12a0a:	e8 58 fb ff ff       	call   12567 <dad_failed>
   12a0f:	e9 4a 01 00 00       	jmp    12b5e <handle_na_input+0x2cf>
	struct net_linkaddr_storage lladdr = { 0 };
   12a14:	8d 7d ec             	lea    -0x14(%ebp),%edi
   12a17:	b9 02 00 00 00       	mov    $0x2,%ecx
   12a1c:	f3 ab                	rep stos %eax,%es:(%edi)
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt), &na_hdr->tgt);
   12a1e:	8b 43 24             	mov    0x24(%ebx),%eax
   12a21:	e8 e3 fa ff ff       	call   12509 <nbr_lookup.isra.12>
   12a26:	89 c6                	mov    %eax,%esi
	if (!nbr) {
   12a28:	85 c0                	test   %eax,%eax
   12a2a:	0f 84 2e 01 00 00    	je     12b5e <handle_na_input+0x2cf>
	if (tllao_offset) {
   12a30:	66 83 7d ca 00       	cmpw   $0x0,-0x36(%ebp)
   12a35:	75 08                	jne    12a3f <handle_na_input+0x1b0>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
   12a37:	80 7e 01 ff          	cmpb   $0xff,0x1(%esi)
   12a3b:	74 45                	je     12a82 <handle_na_input+0x1f3>
   12a3d:	eb 7a                	jmp    12ab9 <handle_na_input+0x22a>
		lladdr.len = net_if_get_link_addr(net_pkt_iface(pkt))->len;
   12a3f:	8b 43 24             	mov    0x24(%ebx),%eax
   12a42:	8b 00                	mov    (%eax),%eax
   12a44:	8a 40 14             	mov    0x14(%eax),%al
		net_pkt_cursor_init(pkt);
   12a47:	53                   	push   %ebx
		lladdr.len = net_if_get_link_addr(net_pkt_iface(pkt))->len;
   12a48:	88 45 ed             	mov    %al,-0x13(%ebp)
		net_pkt_cursor_init(pkt);
   12a4b:	e8 1d d5 ff ff       	call   ff6d <net_pkt_cursor_init>
		if (net_pkt_skip(pkt, tllao_offset) ||
   12a50:	0f b7 45 ca          	movzwl -0x36(%ebp),%eax
   12a54:	89 04 24             	mov    %eax,(%esp)
   12a57:	53                   	push   %ebx
   12a58:	e8 83 d8 ff ff       	call   102e0 <net_pkt_skip>
   12a5d:	59                   	pop    %ecx
   12a5e:	5f                   	pop    %edi
   12a5f:	85 c0                	test   %eax,%eax
   12a61:	0f 85 f7 00 00 00    	jne    12b5e <handle_na_input+0x2cf>
		    net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
   12a67:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
   12a6b:	50                   	push   %eax
   12a6c:	8d 45 ee             	lea    -0x12(%ebp),%eax
   12a6f:	50                   	push   %eax
   12a70:	53                   	push   %ebx
   12a71:	e8 a2 d8 ff ff       	call   10318 <net_pkt_read>
   12a76:	83 c4 0c             	add    $0xc,%esp
		if (net_pkt_skip(pkt, tllao_offset) ||
   12a79:	85 c0                	test   %eax,%eax
   12a7b:	74 ba                	je     12a37 <handle_na_input+0x1a8>
   12a7d:	e9 dc 00 00 00       	jmp    12b5e <handle_na_input+0x2cf>
		if (!tllao_offset) {
   12a82:	66 83 7d ca 00       	cmpw   $0x0,-0x36(%ebp)
   12a87:	0f 84 d1 00 00 00    	je     12b5e <handle_na_input+0x2cf>
		nbr_lladdr.len = lladdr.len;
   12a8d:	8a 45 ed             	mov    -0x13(%ebp),%al
   12a90:	88 45 e8             	mov    %al,-0x18(%ebp)
		nbr_lladdr.addr = lladdr.addr;
   12a93:	8d 45 ee             	lea    -0x12(%ebp),%eax
   12a96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
   12a99:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   12a9c:	50                   	push   %eax
   12a9d:	ff 73 24             	pushl  0x24(%ebx)
   12aa0:	56                   	push   %esi
   12aa1:	e8 3c f1 ff ff       	call   11be2 <net_nbr_link>
   12aa6:	83 c4 0c             	add    $0xc,%esp
   12aa9:	85 c0                	test   %eax,%eax
   12aab:	74 0c                	je     12ab9 <handle_na_input+0x22a>
			nbr_free(nbr);
   12aad:	89 f0                	mov    %esi,%eax
   12aaf:	e8 7c f8 ff ff       	call   12330 <nbr_free>
			return false;
   12ab4:	e9 a5 00 00 00       	jmp    12b5e <handle_na_input+0x2cf>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
   12ab9:	0f b6 46 01          	movzbl 0x1(%esi),%eax
   12abd:	50                   	push   %eax
   12abe:	e8 3c f2 ff ff       	call   11cff <net_nbr_get_lladdr>
   12ac3:	5a                   	pop    %edx
   12ac4:	89 c7                	mov    %eax,%edi
	if (!cached_lladdr) {
   12ac6:	85 c0                	test   %eax,%eax
   12ac8:	0f 84 90 00 00 00    	je     12b5e <handle_na_input+0x2cf>
	bool lladdr_changed = false;
   12ace:	c6 45 c4 00          	movb   $0x0,-0x3c(%ebp)
	if (tllao_offset) {
   12ad2:	66 83 7d ca 00       	cmpw   $0x0,-0x36(%ebp)
   12ad7:	74 1b                	je     12af4 <handle_na_input+0x265>
		lladdr_changed = memcmp(lladdr.addr,
   12ad9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   12add:	50                   	push   %eax
					cached_lladdr->addr,
   12ade:	8d 47 02             	lea    0x2(%edi),%eax
		lladdr_changed = memcmp(lladdr.addr,
   12ae1:	50                   	push   %eax
   12ae2:	8d 45 ee             	lea    -0x12(%ebp),%eax
   12ae5:	50                   	push   %eax
   12ae6:	e8 db 7d ff ff       	call   a8c6 <memcmp>
   12aeb:	83 c4 0c             	add    $0xc,%esp
   12aee:	85 c0                	test   %eax,%eax
   12af0:	0f 95 45 c4          	setne  -0x3c(%ebp)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
   12af4:	8b 46 0c             	mov    0xc(%esi),%eax
   12af7:	8b 40 28             	mov    0x28(%eax),%eax
   12afa:	85 c0                	test   %eax,%eax
   12afc:	75 43                	jne    12b41 <handle_na_input+0x2b2>
		if (!tllao_offset) {
   12afe:	66 83 7d ca 00       	cmpw   $0x0,-0x36(%ebp)
   12b03:	74 59                	je     12b5e <handle_na_input+0x2cf>
		if (lladdr_changed) {
   12b05:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12b09:	74 15                	je     12b20 <handle_na_input+0x291>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
   12b0b:	89 f8                	mov    %edi,%eax
   12b0d:	e8 27 fb ff ff       	call   12639 <dbg_update_neighbor_lladdr.isra.13>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
   12b12:	8d 55 ee             	lea    -0x12(%ebp),%edx
   12b15:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
   12b19:	89 f8                	mov    %edi,%eax
   12b1b:	e8 50 f8 ff ff       	call   12370 <net_linkaddr_set>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
   12b20:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12b23:	f6 00 40             	testb  $0x40,(%eax)
   12b26:	0f 84 9f 00 00 00    	je     12bcb <handle_na_input+0x33c>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
   12b2c:	89 f0                	mov    %esi,%eax
   12b2e:	ba 01 00 00 00       	mov    $0x1,%edx
   12b33:	e8 79 f7 ff ff       	call   122b1 <ipv6_nbr_set_state>
			net_ipv6_nbr_data(nbr)->ns_count = 0U;
   12b38:	8b 46 0c             	mov    0xc(%esi),%eax
   12b3b:	c6 40 2e 00          	movb   $0x0,0x2e(%eax)
	return (struct net_ipv6_nbr_data *)nbr->data;
   12b3f:	eb 62                	jmp    12ba3 <handle_na_input+0x314>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
   12b41:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   12b44:	f6 01 20             	testb  $0x20,(%ecx)
   12b47:	75 28                	jne    12b71 <handle_na_input+0x2e2>
   12b49:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12b4d:	74 19                	je     12b68 <handle_na_input+0x2d9>
		if (net_ipv6_nbr_data(nbr)->state ==
   12b4f:	48                   	dec    %eax
   12b50:	75 0c                	jne    12b5e <handle_na_input+0x2cf>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
   12b52:	ba 02 00 00 00       	mov    $0x2,%edx
   12b57:	89 f0                	mov    %esi,%eax
   12b59:	e8 53 f7 ff ff       	call   122b1 <ipv6_nbr_set_state>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
   12b5e:	b8 02 00 00 00       	mov    $0x2,%eax
   12b63:	e9 b1 00 00 00       	jmp    12c19 <handle_na_input+0x38a>
	if (na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE ||
   12b68:	66 83 7d ca 00       	cmpw   $0x0,-0x36(%ebp)
   12b6d:	75 1d                	jne    12b8c <handle_na_input+0x2fd>
   12b6f:	eb 66                	jmp    12bd7 <handle_na_input+0x348>
		if (lladdr_changed) {
   12b71:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12b75:	74 15                	je     12b8c <handle_na_input+0x2fd>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
   12b77:	89 f8                	mov    %edi,%eax
   12b79:	e8 bb fa ff ff       	call   12639 <dbg_update_neighbor_lladdr.isra.13>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
   12b7e:	8d 55 ee             	lea    -0x12(%ebp),%edx
   12b81:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
   12b85:	89 f8                	mov    %edi,%eax
   12b87:	e8 e4 f7 ff ff       	call   12370 <net_linkaddr_set>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
   12b8c:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12b8f:	f6 00 40             	testb  $0x40,(%eax)
   12b92:	74 31                	je     12bc5 <handle_na_input+0x336>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
   12b94:	89 f0                	mov    %esi,%eax
   12b96:	ba 01 00 00 00       	mov    $0x1,%edx
   12b9b:	e8 11 f7 ff ff       	call   122b1 <ipv6_nbr_set_state>
			net_ipv6_nbr_data(nbr)->reachable = 0;
   12ba0:	8b 46 0c             	mov    0xc(%esi),%eax
   12ba3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   12baa:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
			net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
   12bb1:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
   12bb8:	56                   	push   %esi
   12bb9:	ff 73 24             	pushl  0x24(%ebx)
   12bbc:	e8 7c fc ff ff       	call   1283d <net_ipv6_nbr_set_reachable_timer>
   12bc1:	5f                   	pop    %edi
   12bc2:	58                   	pop    %eax
   12bc3:	eb 12                	jmp    12bd7 <handle_na_input+0x348>
			if (lladdr_changed) {
   12bc5:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12bc9:	74 0c                	je     12bd7 <handle_na_input+0x348>
				ipv6_nbr_set_state(nbr,
   12bcb:	ba 02 00 00 00       	mov    $0x2,%edx
   12bd0:	89 f0                	mov    %esi,%eax
   12bd2:	e8 da f6 ff ff       	call   122b1 <ipv6_nbr_set_state>
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
   12bd7:	8b 45 cc             	mov    -0x34(%ebp),%eax
	net_ipv6_nbr_data(nbr)->is_router =
   12bda:	8b 56 0c             	mov    0xc(%esi),%edx
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
   12bdd:	8a 00                	mov    (%eax),%al
   12bdf:	c0 e8 07             	shr    $0x7,%al
	net_ipv6_nbr_data(nbr)->is_router =
   12be2:	88 42 2f             	mov    %al,0x2f(%edx)
	pending = net_ipv6_nbr_data(nbr)->pending;
   12be5:	8b 46 0c             	mov    0xc(%esi),%eax
   12be8:	8b 38                	mov    (%eax),%edi
	if (pending) {
   12bea:	85 ff                	test   %edi,%edi
   12bec:	74 22                	je     12c10 <handle_na_input+0x381>
		if (net_send_data(pending) < 0) {
   12bee:	57                   	push   %edi
   12bef:	e8 59 ac ff ff       	call   d84d <net_send_data>
   12bf4:	59                   	pop    %ecx
   12bf5:	85 c0                	test   %eax,%eax
   12bf7:	8b 46 0c             	mov    0xc(%esi),%eax
   12bfa:	79 07                	jns    12c03 <handle_na_input+0x374>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
   12bfc:	e8 02 f7 ff ff       	call   12303 <nbr_clear_ns_pending>
   12c01:	eb 06                	jmp    12c09 <handle_na_input+0x37a>
			net_ipv6_nbr_data(nbr)->pending = NULL;
   12c03:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		net_pkt_unref(pending);
   12c09:	57                   	push   %edi
   12c0a:	e8 f2 d1 ff ff       	call   fe01 <net_pkt_unref>
   12c0f:	5a                   	pop    %edx
	net_pkt_unref(pkt);
   12c10:	53                   	push   %ebx
   12c11:	e8 eb d1 ff ff       	call   fe01 <net_pkt_unref>
   12c16:	58                   	pop    %eax
	return NET_OK;
   12c17:	31 c0                	xor    %eax,%eax
}
   12c19:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12c1c:	5b                   	pop    %ebx
   12c1d:	5e                   	pop    %esi
   12c1e:	5f                   	pop    %edi
   12c1f:	5d                   	pop    %ebp
   12c20:	c3                   	ret    

00012c21 <net_ipv6_send_ns>:
		     struct net_pkt *pending,
		     const struct in6_addr *src,
		     const struct in6_addr *dst,
		     const struct in6_addr *tgt,
		     bool is_my_address)
{
   12c21:	55                   	push   %ebp
   12c22:	89 e5                	mov    %esp,%ebp
   12c24:	57                   	push   %edi
   12c25:	56                   	push   %esi
   12c26:	53                   	push   %ebx
   12c27:	83 ec 34             	sub    $0x34,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
   12c2a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
{
   12c31:	8b 7d 14             	mov    0x14(%ebp),%edi
   12c34:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c37:	8b 5d 10             	mov    0x10(%ebp),%ebx
   12c3a:	8b 75 18             	mov    0x18(%ebp),%esi
   12c3d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
   12c40:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
	struct net_icmpv6_ns_hdr *ns_hdr;
	struct in6_addr node_dst;
	struct net_nbr *nbr;
	u8_t llao_len;

	if (!dst) {
   12c47:	85 ff                	test   %edi,%edi
   12c49:	75 2a                	jne    12c75 <net_ipv6_send_ns+0x54>
	dst->s6_addr[13]  = src->s6_addr[13];
   12c4b:	8a 46 0d             	mov    0xd(%esi),%al
	dst->s6_addr[0]   = 0xFF;
   12c4e:	c7 45 d4 ff 02 00 00 	movl   $0x2ff,-0x2c(%ebp)
	dst->s6_addr[13]  = src->s6_addr[13];
   12c55:	88 45 e1             	mov    %al,-0x1f(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
   12c58:	66 8b 46 0e          	mov    0xe(%esi),%ax
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
   12c5c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
   12c63:	c7 45 dc 00 00 00 01 	movl   $0x1000000,-0x24(%ebp)
	dst->s6_addr[12]  = 0xFF;
   12c6a:	c6 45 e0 ff          	movb   $0xff,-0x20(%ebp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
   12c6e:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
		net_ipv6_addr_create_solicited_node(tgt, &node_dst);
		dst = &node_dst;
   12c72:	8d 7d d4             	lea    -0x2c(%ebp),%edi
	if (net_if_get_link_addr(iface)->len == 6) {
   12c75:	8b 45 08             	mov    0x8(%ebp),%eax
		return 8;
   12c78:	c6 45 c8 08          	movb   $0x8,-0x38(%ebp)
	if (net_if_get_link_addr(iface)->len == 6) {
   12c7c:	8b 00                	mov    (%eax),%eax
   12c7e:	8a 40 14             	mov    0x14(%eax),%al
   12c81:	3c 06                	cmp    $0x6,%al
   12c83:	74 0b                	je     12c90 <net_ipv6_send_ns+0x6f>
		return 16;
   12c85:	3c 08                	cmp    $0x8,%al
   12c87:	0f 94 c0             	sete   %al
   12c8a:	c1 e0 04             	shl    $0x4,%eax
   12c8d:	88 45 c8             	mov    %al,-0x38(%ebp)
	}

	llao_len = get_llao_len(iface);

	if (is_my_address) {
   12c90:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12c94:	74 0d                	je     12ca3 <net_ipv6_send_ns+0x82>
		src = net_ipv6_unspecified_address();
   12c96:	e8 9a f0 ff ff       	call   11d35 <net_ipv6_unspecified_address>
		llao_len = 0;
   12c9b:	c6 45 c8 00          	movb   $0x0,-0x38(%ebp)
		src = net_ipv6_unspecified_address();
   12c9f:	89 c3                	mov    %eax,%ebx
		llao_len = 0;
   12ca1:	eb 20                	jmp    12cc3 <net_ipv6_send_ns+0xa2>
	} else {
		if (!src) {
   12ca3:	85 db                	test   %ebx,%ebx
   12ca5:	75 0d                	jne    12cb4 <net_ipv6_send_ns+0x93>
			src = net_if_ipv6_select_src_addr(iface, dst);
   12ca7:	57                   	push   %edi
   12ca8:	ff 75 08             	pushl  0x8(%ebp)
   12cab:	e8 db c4 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   12cb0:	5a                   	pop    %edx
   12cb1:	89 c3                	mov    %eax,%ebx
   12cb3:	59                   	pop    %ecx
		}

		if (net_ipv6_is_addr_unspecified(src)) {
   12cb4:	89 d8                	mov    %ebx,%eax
   12cb6:	e8 d4 f5 ff ff       	call   1228f <net_ipv6_is_addr_unspecified>
   12cbb:	84 c0                	test   %al,%al
   12cbd:	0f 85 9e 01 00 00    	jne    12e61 <net_ipv6_send_ns+0x240>

			goto drop;
		}
	}

	pkt = net_pkt_alloc_with_buffer(iface,
   12cc3:	6a 64                	push   $0x64
   12cc5:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
   12cc9:	6a 3a                	push   $0x3a
   12ccb:	89 45 c0             	mov    %eax,-0x40(%ebp)
   12cce:	6a 02                	push   $0x2
   12cd0:	83 c0 14             	add    $0x14,%eax
   12cd3:	50                   	push   %eax
   12cd4:	ff 75 08             	pushl  0x8(%ebp)
   12cd7:	e8 d9 d5 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   12cdc:	83 c4 14             	add    $0x14,%esp
   12cdf:	89 45 c8             	mov    %eax,-0x38(%ebp)
					sizeof(struct net_icmpv6_ns_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
   12ce2:	85 c0                	test   %eax,%eax
   12ce4:	0f 84 7e 01 00 00    	je     12e68 <net_ipv6_send_ns+0x247>
	pkt->ipv6_hop_limit = hop_limit;
   12cea:	c6 40 41 ff          	movb   $0xff,0x41(%eax)
		goto drop;
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
   12cee:	57                   	push   %edi
   12cef:	53                   	push   %ebx
   12cf0:	50                   	push   %eax
   12cf1:	e8 45 f0 ff ff       	call   11d3b <net_ipv6_create>
   12cf6:	83 c4 0c             	add    $0xc,%esp
   12cf9:	85 c0                	test   %eax,%eax
   12cfb:	0f 85 53 01 00 00    	jne    12e54 <net_ipv6_send_ns+0x233>
	    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {
   12d01:	6a 00                	push   $0x0
   12d03:	68 87 00 00 00       	push   $0x87
   12d08:	ff 75 c8             	pushl  -0x38(%ebp)
   12d0b:	e8 0f ea ff ff       	call   1171f <net_icmpv6_create>
   12d10:	83 c4 0c             	add    $0xc,%esp
	if (net_ipv6_create(pkt, src, dst) ||
   12d13:	85 c0                	test   %eax,%eax
   12d15:	0f 85 39 01 00 00    	jne    12e54 <net_ipv6_send_ns+0x233>
		goto drop;
	}

	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
   12d1b:	8d 55 cc             	lea    -0x34(%ebp),%edx
   12d1e:	52                   	push   %edx
   12d1f:	ff 75 c8             	pushl  -0x38(%ebp)
   12d22:	e8 40 d8 ff ff       	call   10567 <net_pkt_get_data>
   12d27:	5b                   	pop    %ebx
	if (!ns_hdr) {
   12d28:	85 c0                	test   %eax,%eax
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
   12d2a:	5f                   	pop    %edi
   12d2b:	89 c3                	mov    %eax,%ebx
	if (!ns_hdr) {
   12d2d:	0f 84 21 01 00 00    	je     12e54 <net_ipv6_send_ns+0x233>
		goto drop;
	}

	ns_hdr->reserved = 0;
	net_ipaddr_copy(&ns_hdr->tgt, tgt);
   12d33:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   12d36:	b9 04 00 00 00       	mov    $0x4,%ecx
   12d3b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   12d3d:	8d 78 04             	lea    0x4(%eax),%edi
   12d40:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   12d43:	b9 04 00 00 00       	mov    $0x4,%ecx
	ns_hdr->reserved = 0;
   12d48:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	net_ipaddr_copy(&ns_hdr->tgt, tgt);
   12d4e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

	if (net_pkt_set_data(pkt, &ns_access)) {
   12d50:	8d 55 cc             	lea    -0x34(%ebp),%edx
   12d53:	8d 73 04             	lea    0x4(%ebx),%esi
   12d56:	52                   	push   %edx
   12d57:	ff 75 c8             	pushl  -0x38(%ebp)
   12d5a:	e8 9f d8 ff ff       	call   105fe <net_pkt_set_data>
   12d5f:	5a                   	pop    %edx
   12d60:	89 c7                	mov    %eax,%edi
   12d62:	59                   	pop    %ecx
   12d63:	85 c0                	test   %eax,%eax
   12d65:	0f 85 e9 00 00 00    	jne    12e54 <net_ipv6_send_ns+0x233>
		goto drop;
	}

	if (!is_my_address) {
   12d6b:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
   12d6f:	74 2b                	je     12d9c <net_ipv6_send_ns+0x17b>
			      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {
			goto drop;
		}
	}

	net_pkt_cursor_init(pkt);
   12d71:	ff 75 c8             	pushl  -0x38(%ebp)
   12d74:	e8 f4 d1 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   12d79:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   12d80:	ff 75 c8             	pushl  -0x38(%ebp)
   12d83:	e8 63 f0 ff ff       	call   11deb <net_ipv6_finalize>

	nbr = nbr_lookup(&net_neighbor.table, iface, &ns_hdr->tgt);
   12d88:	89 f2                	mov    %esi,%edx
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   12d8a:	5b                   	pop    %ebx
   12d8b:	58                   	pop    %eax
	nbr = nbr_lookup(&net_neighbor.table, iface, &ns_hdr->tgt);
   12d8c:	8b 45 08             	mov    0x8(%ebp),%eax
   12d8f:	e8 75 f7 ff ff       	call   12509 <nbr_lookup.isra.12>
   12d94:	89 c3                	mov    %eax,%ebx
	if (!nbr) {
   12d96:	85 c0                	test   %eax,%eax
   12d98:	75 3a                	jne    12dd4 <net_ipv6_send_ns+0x1b3>
   12d9a:	eb 22                	jmp    12dbe <net_ipv6_send_ns+0x19d>
	return &iface->if_dev->link_addr;
   12d9c:	8b 45 08             	mov    0x8(%ebp),%eax
		if (!set_llao(pkt, net_if_get_link_addr(iface),
   12d9f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
   12da2:	8b 00                	mov    (%eax),%eax
   12da4:	6a 01                	push   $0x1
   12da6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
   12da9:	8d 50 10             	lea    0x10(%eax),%edx
   12dac:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12daf:	e8 ea f6 ff ff       	call   1249e <set_llao>
   12db4:	59                   	pop    %ecx
   12db5:	84 c0                	test   %al,%al
   12db7:	75 b8                	jne    12d71 <net_ipv6_send_ns+0x150>
   12db9:	e9 96 00 00 00       	jmp    12e54 <net_ipv6_send_ns+0x233>
		nbr_print();

		nbr = nbr_new(iface, &ns_hdr->tgt, false,
   12dbe:	31 c9                	xor    %ecx,%ecx
   12dc0:	89 f2                	mov    %esi,%edx
   12dc2:	8b 45 08             	mov    0x8(%ebp),%eax
   12dc5:	e8 e8 f7 ff ff       	call   125b2 <nbr_new.constprop.18>
   12dca:	89 c3                	mov    %eax,%ebx
			      NET_IPV6_NBR_STATE_INCOMPLETE);
		if (!nbr) {
   12dcc:	85 c0                	test   %eax,%eax
   12dce:	0f 84 80 00 00 00    	je     12e54 <net_ipv6_send_ns+0x233>
				log_strdup(net_sprint_ipv6_addr(&ns_hdr->tgt)));
			goto drop;
		}
	}

	if (pending) {
   12dd4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12dd8:	74 3e                	je     12e18 <net_ipv6_send_ns+0x1f7>
		if (!net_ipv6_nbr_data(nbr)->pending) {
   12dda:	8b 73 0c             	mov    0xc(%ebx),%esi
   12ddd:	83 3e 00             	cmpl   $0x0,(%esi)
   12de0:	75 53                	jne    12e35 <net_ipv6_send_ns+0x214>
			net_ipv6_nbr_data(nbr)->pending = net_pkt_ref(pending);
   12de2:	ff 75 0c             	pushl  0xc(%ebp)
   12de5:	e8 e0 cf ff ff       	call   fdca <net_pkt_ref>
   12dea:	5a                   	pop    %edx
   12deb:	89 06                	mov    %eax,(%esi)
			goto drop;
		}

		NET_DBG("Setting timeout %d for NS", NS_REPLY_TIMEOUT);

		net_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();
   12ded:	8b 73 0c             	mov    0xc(%ebx),%esi
   12df0:	e8 1c 1b 01 00       	call   24911 <z_impl_k_uptime_get>
   12df5:	89 46 20             	mov    %eax,0x20(%esi)
   12df8:	89 56 24             	mov    %edx,0x24(%esi)

		/* Let's start the timer if necessary */
		if (!k_delayed_work_remaining_get(&ipv6_ns_reply_timer)) {
   12dfb:	b8 60 0f 40 00       	mov    $0x400f60,%eax
   12e00:	e8 a6 f5 ff ff       	call   123ab <k_delayed_work_remaining_get>
   12e05:	85 c0                	test   %eax,%eax
   12e07:	75 0f                	jne    12e18 <net_ipv6_send_ns+0x1f7>
			k_delayed_work_submit(&ipv6_ns_reply_timer,
   12e09:	ba e8 03 00 00       	mov    $0x3e8,%edx
   12e0e:	b8 60 0f 40 00       	mov    $0x400f60,%eax
   12e13:	e8 bb f5 ff ff       	call   123d3 <k_delayed_work_submit>
		}
	}

	dbg_addr_sent_tgt("Neighbor Solicitation", src, dst, &ns_hdr->tgt);

	if (net_send_data(pkt) < 0) {
   12e18:	ff 75 c8             	pushl  -0x38(%ebp)
   12e1b:	e8 2d aa ff ff       	call   d84d <net_send_data>
   12e20:	59                   	pop    %ecx
   12e21:	85 c0                	test   %eax,%eax
   12e23:	79 5e                	jns    12e83 <net_ipv6_send_ns+0x262>
		NET_DBG("Cannot send NS %p (pending %p)", pkt, pending);

		if (pending) {
   12e25:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12e29:	74 51                	je     12e7c <net_ipv6_send_ns+0x25b>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
   12e2b:	8b 43 0c             	mov    0xc(%ebx),%eax
   12e2e:	e8 d0 f4 ff ff       	call   12303 <nbr_clear_ns_pending>
			pending = NULL;
   12e33:	eb 47                	jmp    12e7c <net_ipv6_send_ns+0x25b>
	int ret = -ENOBUFS;
   12e35:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi

	return 0;

drop:
	if (pending) {
		net_pkt_unref(pending);
   12e3a:	ff 75 0c             	pushl  0xc(%ebp)
   12e3d:	e8 bf cf ff ff       	call   fe01 <net_pkt_unref>
   12e42:	5a                   	pop    %edx
	}

	if (pkt) {
   12e43:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12e47:	74 3a                	je     12e83 <net_ipv6_send_ns+0x262>
		net_pkt_unref(pkt);
   12e49:	ff 75 c8             	pushl  -0x38(%ebp)
   12e4c:	e8 b0 cf ff ff       	call   fe01 <net_pkt_unref>
   12e51:	58                   	pop    %eax
   12e52:	eb 2f                	jmp    12e83 <net_ipv6_send_ns+0x262>
	if (pending) {
   12e54:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
   12e59:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12e5d:	75 db                	jne    12e3a <net_ipv6_send_ns+0x219>
   12e5f:	eb e8                	jmp    12e49 <net_ipv6_send_ns+0x228>
			ret = -EINVAL;
   12e61:	bf ea ff ff ff       	mov    $0xffffffea,%edi
   12e66:	eb 05                	jmp    12e6d <net_ipv6_send_ns+0x24c>
		ret = -ENOMEM;
   12e68:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (pending) {
   12e6d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
   12e74:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12e78:	75 c0                	jne    12e3a <net_ipv6_send_ns+0x219>
   12e7a:	eb 07                	jmp    12e83 <net_ipv6_send_ns+0x262>
   12e7c:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
   12e81:	eb c6                	jmp    12e49 <net_ipv6_send_ns+0x228>
	}

	net_stats_update_ipv6_nd_drop(iface);

	return ret;
}
   12e83:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12e86:	89 f8                	mov    %edi,%eax
   12e88:	5b                   	pop    %ebx
   12e89:	5e                   	pop    %esi
   12e8a:	5f                   	pop    %edi
   12e8b:	5d                   	pop    %ebp
   12e8c:	c3                   	ret    

00012e8d <net_ipv6_nbr_add>:
{
   12e8d:	55                   	push   %ebp
   12e8e:	89 e5                	mov    %esp,%ebp
   12e90:	57                   	push   %edi
   12e91:	56                   	push   %esi
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
   12e92:	8b 55 0c             	mov    0xc(%ebp),%edx
   12e95:	8b 45 08             	mov    0x8(%ebp),%eax
{
   12e98:	53                   	push   %ebx
   12e99:	8b 75 10             	mov    0x10(%ebp),%esi
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
   12e9c:	e8 68 f6 ff ff       	call   12509 <nbr_lookup.isra.12>
	if (!nbr) {
   12ea1:	89 c3                	mov    %eax,%ebx
   12ea3:	85 c0                	test   %eax,%eax
   12ea5:	75 7b                	jne    12f22 <net_ipv6_nbr_add+0x95>
		nbr = nbr_new(iface, addr, is_router, state);
   12ea7:	8b 4d 18             	mov    0x18(%ebp),%ecx
   12eaa:	8b 55 0c             	mov    0xc(%ebp),%edx
   12ead:	8b 45 08             	mov    0x8(%ebp),%eax
   12eb0:	e8 fd f6 ff ff       	call   125b2 <nbr_new.constprop.18>
   12eb5:	89 c3                	mov    %eax,%ebx
		if (!nbr) {
   12eb7:	85 c0                	test   %eax,%eax
   12eb9:	75 67                	jne    12f22 <net_ipv6_nbr_add+0x95>
			NET_ERR("Could not add router neighbor %s [%s]",
   12ebb:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   12ec2:	0f 84 f8 00 00 00    	je     12fc0 <net_ipv6_nbr_add+0x133>
   12ec8:	6a 18                	push   $0x18
   12eca:	bf bc 51 02 00       	mov    $0x251bc,%edi
   12ecf:	68 c8 42 40 00       	push   $0x4042c8
   12ed4:	81 ef 3c 51 02 00    	sub    $0x2513c,%edi
   12eda:	0f b6 46 04          	movzbl 0x4(%esi),%eax
   12ede:	c1 ef 03             	shr    $0x3,%edi
   12ee1:	50                   	push   %eax
   12ee2:	ff 36                	pushl  (%esi)
   12ee4:	c1 e7 06             	shl    $0x6,%edi
   12ee7:	e8 0b d9 ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   12eec:	83 c4 10             	add    $0x10,%esp
   12eef:	83 cf 01             	or     $0x1,%edi
   12ef2:	50                   	push   %eax
   12ef3:	e8 63 09 ff ff       	call   385b <log_strdup>
   12ef8:	5a                   	pop    %edx
   12ef9:	89 c6                	mov    %eax,%esi
   12efb:	ff 75 0c             	pushl  0xc(%ebp)
   12efe:	6a 02                	push   $0x2
   12f00:	e8 99 db ff ff       	call   10a9e <net_sprint_addr>
   12f05:	59                   	pop    %ecx
   12f06:	5a                   	pop    %edx
   12f07:	50                   	push   %eax
   12f08:	e8 4e 09 ff ff       	call   385b <log_strdup>
   12f0d:	66 89 3c 24          	mov    %di,(%esp)
   12f11:	56                   	push   %esi
   12f12:	50                   	push   %eax
   12f13:	68 7a 7c 02 00       	push   $0x27c7a
   12f18:	e8 cc 05 ff ff       	call   34e9 <log_2>
   12f1d:	e9 9b 00 00 00       	jmp    12fbd <net_ipv6_nbr_add+0x130>
	if (net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
   12f22:	56                   	push   %esi
   12f23:	ff 75 08             	pushl  0x8(%ebp)
   12f26:	53                   	push   %ebx
   12f27:	e8 b6 ec ff ff       	call   11be2 <net_nbr_link>
   12f2c:	83 c4 0c             	add    $0xc,%esp
   12f2f:	83 f8 bb             	cmp    $0xffffffbb,%eax
   12f32:	75 59                	jne    12f8d <net_ipv6_nbr_add+0x100>
	    net_ipv6_nbr_data(nbr)->state != NET_IPV6_NBR_STATE_STATIC) {
   12f34:	8b 43 0c             	mov    0xc(%ebx),%eax
	if (net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
   12f37:	83 78 28 05          	cmpl   $0x5,0x28(%eax)
   12f3b:	74 6f                	je     12fac <net_ipv6_nbr_add+0x11f>
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
   12f3d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   12f41:	50                   	push   %eax
   12f42:	e8 b8 ed ff ff       	call   11cff <net_nbr_get_lladdr>
   12f47:	89 c7                	mov    %eax,%edi
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
   12f49:	0f b6 46 04          	movzbl 0x4(%esi),%eax
   12f4d:	89 04 24             	mov    %eax,(%esp)
   12f50:	8d 47 02             	lea    0x2(%edi),%eax
   12f53:	ff 36                	pushl  (%esi)
   12f55:	50                   	push   %eax
   12f56:	e8 6b 79 ff ff       	call   a8c6 <memcmp>
   12f5b:	83 c4 0c             	add    $0xc,%esp
   12f5e:	85 c0                	test   %eax,%eax
   12f60:	74 16                	je     12f78 <net_ipv6_nbr_add+0xeb>
			dbg_update_neighbor_lladdr(lladdr, cached_lladdr, addr);
   12f62:	89 f8                	mov    %edi,%eax
   12f64:	e8 d0 f6 ff ff       	call   12639 <dbg_update_neighbor_lladdr.isra.13>
			net_linkaddr_set(cached_lladdr, lladdr->addr,
   12f69:	8b 16                	mov    (%esi),%edx
   12f6b:	0f b6 4e 04          	movzbl 0x4(%esi),%ecx
   12f6f:	89 f8                	mov    %edi,%eax
   12f71:	e8 fa f3 ff ff       	call   12370 <net_linkaddr_set>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
   12f76:	eb 09                	jmp    12f81 <net_ipv6_nbr_add+0xf4>
		} else if (net_ipv6_nbr_data(nbr)->state ==
   12f78:	8b 43 0c             	mov    0xc(%ebx),%eax
   12f7b:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
   12f7f:	75 2b                	jne    12fac <net_ipv6_nbr_add+0x11f>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
   12f81:	ba 02 00 00 00       	mov    $0x2,%edx
   12f86:	89 d8                	mov    %ebx,%eax
   12f88:	e8 24 f3 ff ff       	call   122b1 <ipv6_nbr_set_state>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
   12f8d:	8b 43 0c             	mov    0xc(%ebx),%eax
   12f90:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
   12f94:	75 16                	jne    12fac <net_ipv6_nbr_add+0x11f>
		ret = net_ipv6_send_ns(iface, NULL, NULL, NULL, addr, false);
   12f96:	6a 00                	push   $0x0
   12f98:	ff 75 0c             	pushl  0xc(%ebp)
   12f9b:	6a 00                	push   $0x0
   12f9d:	6a 00                	push   $0x0
   12f9f:	6a 00                	push   $0x0
   12fa1:	ff 75 08             	pushl  0x8(%ebp)
   12fa4:	e8 78 fc ff ff       	call   12c21 <net_ipv6_send_ns>
   12fa9:	83 c4 18             	add    $0x18,%esp
   12fac:	6a 00                	push   $0x0
   12fae:	6a 00                	push   $0x0
   12fb0:	ff 75 08             	pushl  0x8(%ebp)
   12fb3:	68 0f 00 60 f0       	push   $0xf060000f
   12fb8:	e8 06 15 00 00       	call   144c3 <net_mgmt_event_notify_with_info>
   12fbd:	83 c4 10             	add    $0x10,%esp
}
   12fc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12fc3:	89 d8                	mov    %ebx,%eax
   12fc5:	5b                   	pop    %ebx
   12fc6:	5e                   	pop    %esi
   12fc7:	5f                   	pop    %edi
   12fc8:	5d                   	pop    %ebp
   12fc9:	c3                   	ret    

00012fca <handle_ra_input>:
#endif

static enum net_verdict handle_ra_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
   12fca:	55                   	push   %ebp
   12fcb:	89 e5                	mov    %esp,%ebp
   12fcd:	57                   	push   %edi
   12fce:	56                   	push   %esi
   12fcf:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
					      struct net_icmpv6_ra_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   12fd0:	8d 45 a6             	lea    -0x5a(%ebp),%eax
{
   12fd3:	83 ec 6c             	sub    $0x6c,%esp
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   12fd6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
{
   12fd9:	8b 75 08             	mov    0x8(%ebp),%esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
   12fdc:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
   12fe3:	c7 45 b0 0c 00 00 00 	movl   $0xc,-0x50(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   12fea:	c7 45 b8 02 00 00 00 	movl   $0x2,-0x48(%ebp)
	u16_t length = net_pkt_get_len(pkt);
   12ff1:	8b 46 14             	mov    0x14(%esi),%eax
	size_t bytes = 0;
   12ff4:	31 db                	xor    %ebx,%ebx
   12ff6:	89 45 9c             	mov    %eax,-0x64(%ebp)
	while (buf) {
   12ff9:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
   12ffd:	74 13                	je     13012 <handle_ra_input+0x48>
		bytes += buf->len;
   12fff:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13002:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   13006:	01 c3                	add    %eax,%ebx
		buf = buf->frags;
   13008:	8b 45 9c             	mov    -0x64(%ebp),%eax
   1300b:	8b 00                	mov    (%eax),%eax
   1300d:	89 45 9c             	mov    %eax,-0x64(%ebp)
   13010:	eb e7                	jmp    12ff9 <handle_ra_input+0x2f>
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_ra_hdr *ra_hdr;
	struct net_if_router *router;
	u32_t mtu;

	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
   13012:	8d 45 ac             	lea    -0x54(%ebp),%eax
   13015:	50                   	push   %eax
   13016:	56                   	push   %esi
   13017:	e8 4b d5 ff ff       	call   10567 <net_pkt_get_data>
   1301c:	5f                   	pop    %edi
   1301d:	89 45 98             	mov    %eax,-0x68(%ebp)
   13020:	5a                   	pop    %edx
	if (!ra_hdr) {
   13021:	85 c0                	test   %eax,%eax
   13023:	75 32                	jne    13057 <handle_ra_input+0x8d>
		NET_ERR("DROP: NULL RA header");
   13025:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   1302c:	0f 84 9d 01 00 00    	je     131cf <handle_ra_input+0x205>
   13032:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   13037:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1303c:	c1 e8 03             	shr    $0x3,%eax
   1303f:	c1 e0 06             	shl    $0x6,%eax
   13042:	83 c8 01             	or     $0x1,%eax
   13045:	50                   	push   %eax
   13046:	68 a0 7c 02 00       	push   $0x27ca0
   1304b:	e8 3a 04 ff ff       	call   348a <log_0>
   13050:	59                   	pop    %ecx
   13051:	5b                   	pop    %ebx
   13052:	e9 78 01 00 00       	jmp    131cf <handle_ra_input+0x205>

	dbg_addr_recv("Router Advertisement", &ip_hdr->src, &ip_hdr->dst);

	net_stats_update_ipv6_nd_recv(net_pkt_iface(pkt));

	if (((length < (sizeof(struct net_ipv6_hdr) +
   13057:	66 83 fb 39          	cmp    $0x39,%bx
   1305b:	76 11                	jbe    1306e <handle_ra_input+0xa4>
			sizeof(struct net_icmp_hdr) +
			sizeof(struct net_icmpv6_ra_hdr) +
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
   1305d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13060:	80 78 07 ff          	cmpb   $0xff,0x7(%eax)
   13064:	75 08                	jne    1306e <handle_ra_input+0xa4>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
   13066:	66 81 78 08 fe 80    	cmpw   $0x80fe,0x8(%eax)
   1306c:	74 0d                	je     1307b <handle_ra_input+0xb1>
	     !net_ipv6_is_ll_addr(&ip_hdr->src)) && icmp_hdr->code != 0) {
   1306e:	8b 45 10             	mov    0x10(%ebp),%eax
   13071:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   13075:	0f 85 54 01 00 00    	jne    131cf <handle_ra_input+0x205>
	return net_pkt_skip(pkt, access->size);
   1307b:	ff 75 b0             	pushl  -0x50(%ebp)
   1307e:	56                   	push   %esi
   1307f:	e8 5c d2 ff ff       	call   102e0 <net_pkt_skip>
   13084:	58                   	pop    %eax
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ra_access);

	ra_hdr->router_lifetime = ntohs(ra_hdr->router_lifetime);
   13085:	8b 45 98             	mov    -0x68(%ebp),%eax
   13088:	5a                   	pop    %edx
	ra_hdr->reachable_time = ntohl(ra_hdr->reachable_time);
   13089:	8b 7d 98             	mov    -0x68(%ebp),%edi
	ra_hdr->router_lifetime = ntohs(ra_hdr->router_lifetime);
   1308c:	66 c1 40 02 08       	rolw   $0x8,0x2(%eax)
	ra_hdr->reachable_time = ntohl(ra_hdr->reachable_time);
   13091:	8b 57 08             	mov    0x8(%edi),%edx
   13094:	8b 40 04             	mov    0x4(%eax),%eax
   13097:	0f c8                	bswap  %eax
   13099:	0f ca                	bswap  %edx
	ra_hdr->retrans_timer = ntohl(ra_hdr->retrans_timer);

	if (ra_hdr->cur_hop_limit) {
   1309b:	8a 0f                	mov    (%edi),%cl
	ra_hdr->reachable_time = ntohl(ra_hdr->reachable_time);
   1309d:	89 47 04             	mov    %eax,0x4(%edi)
	ra_hdr->retrans_timer = ntohl(ra_hdr->retrans_timer);
   130a0:	89 57 08             	mov    %edx,0x8(%edi)
	if (ra_hdr->cur_hop_limit) {
   130a3:	84 c9                	test   %cl,%cl
   130a5:	74 10                	je     130b7 <handle_ra_input+0xed>
	if (!iface->config.ip.ipv6) {
   130a7:	8b 56 24             	mov    0x24(%esi),%edx
   130aa:	8b 52 04             	mov    0x4(%edx),%edx
   130ad:	85 d2                	test   %edx,%edx
   130af:	74 06                	je     130b7 <handle_ra_input+0xed>
	iface->config.ip.ipv6->hop_limit = hop_limit;
   130b1:	88 8a 84 01 00 00    	mov    %cl,0x184(%edx)
				       ra_hdr->cur_hop_limit);
		NET_DBG("New hop limit %d",
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt)));
	}

	if (ra_hdr->reachable_time &&
   130b7:	8d 50 ff             	lea    -0x1(%eax),%edx
   130ba:	81 fa 7f ee 36 00    	cmp    $0x36ee7f,%edx
   130c0:	77 25                	ja     130e7 <handle_ra_input+0x11d>
	    ra_hdr->reachable_time <= MAX_REACHABLE_TIME &&
	    (net_if_ipv6_get_reachable_time(net_pkt_iface(pkt)) !=
   130c2:	8b 56 24             	mov    0x24(%esi),%edx
   130c5:	8b 5a 04             	mov    0x4(%edx),%ebx
	if (!iface->config.ip.ipv6) {
   130c8:	85 db                	test   %ebx,%ebx
   130ca:	74 0e                	je     130da <handle_ra_input+0x110>
	    ra_hdr->reachable_time <= MAX_REACHABLE_TIME &&
   130cc:	3b 83 7c 01 00 00    	cmp    0x17c(%ebx),%eax
   130d2:	74 13                	je     130e7 <handle_ra_input+0x11d>
	iface->config.ip.ipv6->base_reachable_time = reachable_time;
   130d4:	89 83 78 01 00 00    	mov    %eax,0x178(%ebx)
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
   130da:	53                   	push   %ebx
   130db:	e8 8f c1 ff ff       	call   f26f <net_if_ipv6_calc_reachable_time>
   130e0:	5f                   	pop    %edi
   130e1:	89 83 7c 01 00 00    	mov    %eax,0x17c(%ebx)
						    ra_hdr->reachable_time);
		net_if_ipv6_set_reachable_time(
			net_pkt_iface(pkt)->config.ip.ipv6);
	}

	if (ra_hdr->retrans_timer) {
   130e7:	8b 45 98             	mov    -0x68(%ebp),%eax
   130ea:	8b 50 08             	mov    0x8(%eax),%edx
   130ed:	85 d2                	test   %edx,%edx
   130ef:	74 10                	je     13101 <handle_ra_input+0x137>
		net_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),
   130f1:	8b 46 24             	mov    0x24(%esi),%eax
   130f4:	8b 40 04             	mov    0x4(%eax),%eax
	if (!iface->config.ip.ipv6) {
   130f7:	85 c0                	test   %eax,%eax
   130f9:	74 06                	je     13101 <handle_ra_input+0x137>
	iface->config.ip.ipv6->retrans_timer = retrans_timer;
   130fb:	89 90 80 01 00 00    	mov    %edx,0x180(%eax)

	net_pkt_set_ipv6_ext_opt_len(pkt, sizeof(struct net_icmpv6_ra_hdr));
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));

	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
				net_pkt_get_data(pkt, &nd_access);
   13101:	8d 45 b4             	lea    -0x4c(%ebp),%eax
	pkt->ipv6_ext_opt_len = len;
   13104:	c6 46 46 0c          	movb   $0xc,0x46(%esi)
   13108:	50                   	push   %eax
   13109:	56                   	push   %esi
   1310a:	e8 58 d4 ff ff       	call   10567 <net_pkt_get_data>
   1310f:	59                   	pop    %ecx
   13110:	5b                   	pop    %ebx
   13111:	89 c3                	mov    %eax,%ebx
   13113:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   13118:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1311d:	c1 e8 03             	shr    $0x3,%eax
			NET_ERR("Prefix %s/%d could not be added to iface %p",
   13120:	66 25 ff 03          	and    $0x3ff,%ax
   13124:	66 89 45 92          	mov    %ax,-0x6e(%ebp)
   13128:	c1 e0 06             	shl    $0x6,%eax
   1312b:	66 89 45 90          	mov    %ax,-0x70(%ebp)
	while (nd_opt_hdr) {
   1312f:	eb 42                	jmp    13173 <handle_ra_input+0x1a9>
	padding = len * 8 - 2 - lladdr.len;
   13131:	b0 fe                	mov    $0xfe,%al
   13133:	2b 45 c8             	sub    -0x38(%ebp),%eax
   13136:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (padding) {
   13139:	84 c0                	test   %al,%al
   1313b:	0f 85 98 00 00 00    	jne    131d9 <handle_ra_input+0x20f>
	return net_ipv6_nbr_add(net_pkt_iface(pkt), &NET_IPV6_HDR(pkt)->src,
   13141:	6a 02                	push   $0x2
   13143:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   13146:	6a 01                	push   $0x1
   13148:	50                   	push   %eax
	return pkt->frags->data;
   13149:	8b 46 14             	mov    0x14(%esi),%eax
   1314c:	8b 40 08             	mov    0x8(%eax),%eax
   1314f:	83 c0 08             	add    $0x8,%eax
   13152:	50                   	push   %eax
   13153:	ff 76 24             	pushl  0x24(%esi)
   13156:	e8 32 fd ff ff       	call   12e8d <net_ipv6_nbr_add>
   1315b:	83 c4 14             	add    $0x14,%esp
   1315e:	89 45 9c             	mov    %eax,-0x64(%ebp)
		net_pkt_acknowledge_data(pkt, &nd_access);

		switch (nd_opt_hdr->type) {
		case NET_ICMPV6_ND_OPT_SLLAO:
			nbr = handle_ra_neighbor(pkt, nd_opt_hdr->len);
			if (!nbr) {
   13161:	85 c0                	test   %eax,%eax
   13163:	74 6a                	je     131cf <handle_ra_input+0x205>

			break;
		}

		nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
					net_pkt_get_data(pkt, &nd_access);
   13165:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   13168:	50                   	push   %eax
   13169:	56                   	push   %esi
   1316a:	e8 f8 d3 ff ff       	call   10567 <net_pkt_get_data>
   1316f:	5b                   	pop    %ebx
   13170:	89 c3                	mov    %eax,%ebx
   13172:	5f                   	pop    %edi
	while (nd_opt_hdr) {
   13173:	85 db                	test   %ebx,%ebx
   13175:	0f 84 d1 03 00 00    	je     1354c <handle_ra_input+0x582>
	return net_pkt_skip(pkt, access->size);
   1317b:	ff 75 b8             	pushl  -0x48(%ebp)
   1317e:	56                   	push   %esi
   1317f:	e8 5c d1 ff ff       	call   102e0 <net_pkt_skip>
   13184:	58                   	pop    %eax
		switch (nd_opt_hdr->type) {
   13185:	8a 03                	mov    (%ebx),%al
   13187:	5a                   	pop    %edx
   13188:	3c 03                	cmp    $0x3,%al
   1318a:	0f 84 ca 00 00 00    	je     1325a <handle_ra_input+0x290>
   13190:	3c 05                	cmp    $0x5,%al
   13192:	74 5b                	je     131ef <handle_ra_input+0x225>
   13194:	fe c8                	dec    %al
   13196:	0f 85 8f 03 00 00    	jne    1352b <handle_ra_input+0x561>
	lladdr.addr = llstorage.addr;
   1319c:	8d 45 d8             	lea    -0x28(%ebp),%eax
	if (net_pkt_lladdr_src(pkt)->len < lladdr.len) {
   1319f:	8a 56 30             	mov    0x30(%esi),%dl
			nbr = handle_ra_neighbor(pkt, nd_opt_hdr->len);
   131a2:	8a 5b 01             	mov    0x1(%ebx),%bl
	if (net_pkt_lladdr_src(pkt)->len < lladdr.len) {
   131a5:	80 fa 05             	cmp    $0x5,%dl
	llstorage.len = NET_LINK_ADDR_MAX_LENGTH;
   131a8:	c6 45 d7 06          	movb   $0x6,-0x29(%ebp)
	lladdr.addr = llstorage.addr;
   131ac:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	lladdr.len = NET_LINK_ADDR_MAX_LENGTH;
   131af:	c6 45 c8 06          	movb   $0x6,-0x38(%ebp)
	if (net_pkt_lladdr_src(pkt)->len < lladdr.len) {
   131b3:	77 03                	ja     131b8 <handle_ra_input+0x1ee>
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
   131b5:	88 55 c8             	mov    %dl,-0x38(%ebp)
	if (net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
   131b8:	0f b6 55 c8          	movzbl -0x38(%ebp),%edx
   131bc:	52                   	push   %edx
   131bd:	50                   	push   %eax
   131be:	56                   	push   %esi
   131bf:	e8 54 d1 ff ff       	call   10318 <net_pkt_read>
   131c4:	83 c4 0c             	add    $0xc,%esp
   131c7:	85 c0                	test   %eax,%eax
   131c9:	0f 84 62 ff ff ff    	je     13131 <handle_ra_input+0x167>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
   131cf:	b8 02 00 00 00       	mov    $0x2,%eax
   131d4:	e9 1e 04 00 00       	jmp    135f7 <handle_ra_input+0x62d>
		if (net_pkt_skip(pkt, padding)) {
   131d9:	0f b6 c0             	movzbl %al,%eax
   131dc:	50                   	push   %eax
   131dd:	56                   	push   %esi
   131de:	e8 fd d0 ff ff       	call   102e0 <net_pkt_skip>
   131e3:	5b                   	pop    %ebx
   131e4:	85 c0                	test   %eax,%eax
   131e6:	5f                   	pop    %edi
   131e7:	0f 84 54 ff ff ff    	je     13141 <handle_ra_input+0x177>
   131ed:	eb e0                	jmp    131cf <handle_ra_input+0x205>
			if (net_pkt_skip(pkt, 2) ||
   131ef:	6a 02                	push   $0x2
   131f1:	56                   	push   %esi
   131f2:	e8 e9 d0 ff ff       	call   102e0 <net_pkt_skip>
   131f7:	5a                   	pop    %edx
   131f8:	85 c0                	test   %eax,%eax
   131fa:	59                   	pop    %ecx
   131fb:	75 d2                	jne    131cf <handle_ra_input+0x205>
			    net_pkt_read_be32(pkt, &mtu)) {
   131fd:	8d 45 a8             	lea    -0x58(%ebp),%eax
   13200:	50                   	push   %eax
   13201:	56                   	push   %esi
   13202:	e8 31 d1 ff ff       	call   10338 <net_pkt_read_be32>
   13207:	5b                   	pop    %ebx
			if (net_pkt_skip(pkt, 2) ||
   13208:	85 c0                	test   %eax,%eax
			    net_pkt_read_be32(pkt, &mtu)) {
   1320a:	5f                   	pop    %edi
			if (net_pkt_skip(pkt, 2) ||
   1320b:	75 c2                	jne    131cf <handle_ra_input+0x205>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
   1320d:	8b 45 a8             	mov    -0x58(%ebp),%eax
   13210:	8d 90 00 fb ff ff    	lea    -0x500(%eax),%edx
   13216:	81 fa ff fa 00 00    	cmp    $0xfaff,%edx
   1321c:	76 2e                	jbe    1324c <handle_ra_input+0x282>
				NET_ERR("DROP: Unsupported MTU %u, min is %u, "
   1321e:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   13225:	74 a8                	je     131cf <handle_ra_input+0x205>
   13227:	66 8b 55 92          	mov    -0x6e(%ebp),%dx
   1322b:	c1 e2 06             	shl    $0x6,%edx
   1322e:	83 ca 01             	or     $0x1,%edx
   13231:	52                   	push   %edx
   13232:	68 ff ff 00 00       	push   $0xffff
   13237:	68 00 05 00 00       	push   $0x500
   1323c:	50                   	push   %eax
   1323d:	68 b5 7c 02 00       	push   $0x27cb5
   13242:	e8 e9 02 ff ff       	call   3530 <log_3>
   13247:	83 c4 14             	add    $0x14,%esp
   1324a:	eb 83                	jmp    131cf <handle_ra_input+0x205>
	iface->if_dev->mtu = mtu;
   1324c:	8b 56 24             	mov    0x24(%esi),%edx
   1324f:	8b 12                	mov    (%edx),%edx
			net_if_set_mtu(net_pkt_iface(pkt), mtu);
   13251:	66 89 42 18          	mov    %ax,0x18(%edx)
   13255:	e9 0b ff ff ff       	jmp    13165 <handle_ra_input+0x19b>
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
   1325a:	8d 45 d6             	lea    -0x2a(%ebp),%eax
   1325d:	c7 45 c0 1e 00 00 00 	movl   $0x1e,-0x40(%ebp)
   13264:	89 45 bc             	mov    %eax,-0x44(%ebp)
				net_pkt_get_data(pkt, &rapfx_access);
   13267:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1326a:	50                   	push   %eax
   1326b:	56                   	push   %esi
   1326c:	e8 f6 d2 ff ff       	call   10567 <net_pkt_get_data>
   13271:	5a                   	pop    %edx
   13272:	89 45 a0             	mov    %eax,-0x60(%ebp)
   13275:	59                   	pop    %ecx
	if (!pfx_info) {
   13276:	85 c0                	test   %eax,%eax
   13278:	0f 84 51 ff ff ff    	je     131cf <handle_ra_input+0x205>
   1327e:	ff 75 c0             	pushl  -0x40(%ebp)
   13281:	56                   	push   %esi
   13282:	e8 59 d0 ff ff       	call   102e0 <net_pkt_skip>
   13287:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1328a:	5b                   	pop    %ebx
   1328b:	5f                   	pop    %edi
	pfx_info->preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
   1328c:	8b 7d a0             	mov    -0x60(%ebp),%edi
   1328f:	8b 50 02             	mov    0x2(%eax),%edx
   13292:	0f ca                	bswap  %edx
	pfx_info->valid_lifetime = ntohl(pfx_info->valid_lifetime);
   13294:	89 50 02             	mov    %edx,0x2(%eax)
	pfx_info->preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
   13297:	8b 40 06             	mov    0x6(%eax),%eax
   1329a:	0f c8                	bswap  %eax
   1329c:	89 47 06             	mov    %eax,0x6(%edi)
	if (pfx_info->valid_lifetime >= pfx_info->preferred_lifetime &&
   1329f:	39 c2                	cmp    %eax,%edx
   132a1:	0f 82 be fe ff ff    	jb     13165 <handle_ra_input+0x19b>
   132a7:	66 81 7f 0e fe 80    	cmpw   $0x80fe,0xe(%edi)
   132ad:	0f 84 b2 fe ff ff    	je     13165 <handle_ra_input+0x19b>
		if (pfx_info->flags & NET_ICMPV6_RA_FLAG_ONLINK) {
   132b3:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
   132b7:	0f 89 cb 00 00 00    	jns    13388 <handle_ra_input+0x3be>
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
   132bd:	0f b6 07             	movzbl (%edi),%eax
   132c0:	8d 5f 0e             	lea    0xe(%edi),%ebx
   132c3:	50                   	push   %eax
   132c4:	53                   	push   %ebx
   132c5:	ff 76 24             	pushl  0x24(%esi)
   132c8:	e8 9a b9 ff ff       	call   ec67 <net_if_ipv6_prefix_lookup>
   132cd:	83 c4 0c             	add    $0xc,%esp
	if (!prefix) {
   132d0:	85 c0                	test   %eax,%eax
   132d2:	75 75                	jne    13349 <handle_ra_input+0x37f>
		if (!prefix_info->valid_lifetime) {
   132d4:	8b 45 a0             	mov    -0x60(%ebp),%eax
   132d7:	8b 40 02             	mov    0x2(%eax),%eax
   132da:	85 c0                	test   %eax,%eax
   132dc:	0f 84 a6 00 00 00    	je     13388 <handle_ra_input+0x3be>
		prefix = net_if_ipv6_prefix_add(net_pkt_iface(pkt),
   132e2:	50                   	push   %eax
   132e3:	8b 45 a0             	mov    -0x60(%ebp),%eax
   132e6:	0f b6 00             	movzbl (%eax),%eax
   132e9:	50                   	push   %eax
   132ea:	53                   	push   %ebx
   132eb:	ff 76 24             	pushl  0x24(%esi)
   132ee:	e8 bf b7 ff ff       	call   eab2 <net_if_ipv6_prefix_add>
   132f3:	83 c4 10             	add    $0x10,%esp
		if (prefix) {
   132f6:	85 c0                	test   %eax,%eax
   132f8:	75 4f                	jne    13349 <handle_ra_input+0x37f>
			NET_ERR("Prefix %s/%d could not be added to iface %p",
   132fa:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   13301:	0f 84 81 00 00 00    	je     13388 <handle_ra_input+0x3be>
   13307:	8b 45 90             	mov    -0x70(%ebp),%eax
   1330a:	8b 56 24             	mov    0x24(%esi),%edx
   1330d:	83 c8 01             	or     $0x1,%eax
   13310:	89 55 88             	mov    %edx,-0x78(%ebp)
   13313:	66 89 45 94          	mov    %ax,-0x6c(%ebp)
   13317:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1331a:	0f b6 38             	movzbl (%eax),%edi
   1331d:	53                   	push   %ebx
   1331e:	6a 02                	push   $0x2
   13320:	e8 79 d7 ff ff       	call   10a9e <net_sprint_addr>
   13325:	5a                   	pop    %edx
   13326:	59                   	pop    %ecx
   13327:	50                   	push   %eax
   13328:	e8 2e 05 ff ff       	call   385b <log_strdup>
   1332d:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
   13330:	8b 55 88             	mov    -0x78(%ebp),%edx
   13333:	66 89 0c 24          	mov    %cx,(%esp)
   13337:	52                   	push   %edx
   13338:	57                   	push   %edi
   13339:	50                   	push   %eax
   1333a:	68 e4 7c 02 00       	push   $0x27ce4
   1333f:	e8 ec 01 ff ff       	call   3530 <log_3>
   13344:	83 c4 14             	add    $0x14,%esp
   13347:	eb 3f                	jmp    13388 <handle_ra_input+0x3be>
	switch (prefix_info->valid_lifetime) {
   13349:	8b 7d a0             	mov    -0x60(%ebp),%edi
   1334c:	8b 4f 02             	mov    0x2(%edi),%ecx
   1334f:	85 c9                	test   %ecx,%ecx
   13351:	74 10                	je     13363 <handle_ra_input+0x399>
   13353:	83 f9 ff             	cmp    $0xffffffff,%ecx
   13356:	8a 50 25             	mov    0x25(%eax),%dl
   13359:	75 1e                	jne    13379 <handle_ra_input+0x3af>
	prefix->is_infinite = is_infinite;
   1335b:	83 ca 01             	or     $0x1,%edx
   1335e:	88 50 25             	mov    %dl,0x25(%eax)
   13361:	eb 25                	jmp    13388 <handle_ra_input+0x3be>
		net_if_ipv6_prefix_rm(net_pkt_iface(pkt),
   13363:	0f b6 50 24          	movzbl 0x24(%eax),%edx
   13367:	83 c0 10             	add    $0x10,%eax
   1336a:	52                   	push   %edx
   1336b:	50                   	push   %eax
   1336c:	ff 76 24             	pushl  0x24(%esi)
   1336f:	e8 ef ba ff ff       	call   ee63 <net_if_ipv6_prefix_rm>
   13374:	83 c4 0c             	add    $0xc,%esp
		break;
   13377:	eb 0f                	jmp    13388 <handle_ra_input+0x3be>
   13379:	83 e2 fe             	and    $0xfffffffe,%edx
   1337c:	88 50 25             	mov    %dl,0x25(%eax)
		net_if_ipv6_prefix_set_timer(prefix,
   1337f:	51                   	push   %ecx
   13380:	50                   	push   %eax
   13381:	e8 dd b9 ff ff       	call   ed63 <net_if_ipv6_prefix_set_timer>
   13386:	5b                   	pop    %ebx
   13387:	5f                   	pop    %edi
		if ((pfx_info->flags & NET_ICMPV6_RA_FLAG_AUTONOMOUS) &&
   13388:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1338b:	f6 40 01 40          	testb  $0x40,0x1(%eax)
   1338f:	0f 84 d0 fd ff ff    	je     13165 <handle_ra_input+0x19b>
   13395:	83 78 02 00          	cmpl   $0x0,0x2(%eax)
   13399:	0f 84 c6 fd ff ff    	je     13165 <handle_ra_input+0x19b>
		    pfx_info->valid_lifetime &&
   1339f:	80 38 40             	cmpb   $0x40,(%eax)
   133a2:	0f 85 bd fd ff ff    	jne    13165 <handle_ra_input+0x19b>
	struct in6_addr addr = { };
   133a8:	31 c0                	xor    %eax,%eax
   133aa:	8d 7d c6             	lea    -0x3a(%ebp),%edi
   133ad:	b9 0e 00 00 00       	mov    $0xe,%ecx
   133b2:	f3 aa                	rep stos %al,%es:(%edi)
	net_ipv6_addr_create_iid(&addr,
   133b4:	8b 46 24             	mov    0x24(%esi),%eax
   133b7:	8b 18                	mov    (%eax),%ebx
	addr->s6_addr[0] = 0xfe;
   133b9:	66 c7 45 c4 fe 80    	movw   $0x80fe,-0x3c(%ebp)
	switch (lladdr->len) {
   133bf:	8a 43 14             	mov    0x14(%ebx),%al
   133c2:	3c 06                	cmp    $0x6,%al
   133c4:	74 24                	je     133ea <handle_ra_input+0x420>
   133c6:	3c 08                	cmp    $0x8,%al
   133c8:	74 54                	je     1341e <handle_ra_input+0x454>
   133ca:	3c 02                	cmp    $0x2,%al
   133cc:	75 65                	jne    13433 <handle_ra_input+0x469>
		if (lladdr->type == NET_LINK_IEEE802154) {
   133ce:	80 7b 15 01          	cmpb   $0x1,0x15(%ebx)
   133d2:	75 5f                	jne    13433 <handle_ra_input+0x469>
			addr->s6_addr[14] = lladdr->addr[0];
   133d4:	8b 43 10             	mov    0x10(%ebx),%eax
			addr->s6_addr[11] = 0xff;
   133d7:	66 c7 45 cf ff fe    	movw   $0xfeff,-0x31(%ebp)
			addr->s6_addr[14] = lladdr->addr[0];
   133dd:	8a 10                	mov    (%eax),%dl
   133df:	88 55 d2             	mov    %dl,-0x2e(%ebp)
			addr->s6_addr[15] = lladdr->addr[1];
   133e2:	8a 40 01             	mov    0x1(%eax),%al
   133e5:	88 45 d3             	mov    %al,-0x2d(%ebp)
   133e8:	eb 49                	jmp    13433 <handle_ra_input+0x469>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
   133ea:	6a 03                	push   $0x3
   133ec:	8d 45 cc             	lea    -0x34(%ebp),%eax
   133ef:	ff 73 10             	pushl  0x10(%ebx)
   133f2:	50                   	push   %eax
   133f3:	e8 39 75 ff ff       	call   a931 <memcpy>
   133f8:	83 c4 0c             	add    $0xc,%esp
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
   133fb:	8b 43 10             	mov    0x10(%ebx),%eax
   133fe:	83 c0 03             	add    $0x3,%eax
		addr->s6_addr[11] = 0xff;
   13401:	66 c7 45 cf ff fe    	movw   $0xfeff,-0x31(%ebp)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
   13407:	6a 03                	push   $0x3
   13409:	50                   	push   %eax
   1340a:	8d 45 d1             	lea    -0x2f(%ebp),%eax
   1340d:	50                   	push   %eax
   1340e:	e8 1e 75 ff ff       	call   a931 <memcpy>
   13413:	83 c4 0c             	add    $0xc,%esp
		if (lladdr->type == NET_LINK_ETHERNET) {
   13416:	80 7b 15 03          	cmpb   $0x3,0x15(%ebx)
   1341a:	75 17                	jne    13433 <handle_ra_input+0x469>
   1341c:	eb 11                	jmp    1342f <handle_ra_input+0x465>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
   1341e:	6a 08                	push   $0x8
   13420:	8d 45 cc             	lea    -0x34(%ebp),%eax
   13423:	ff 73 10             	pushl  0x10(%ebx)
   13426:	50                   	push   %eax
   13427:	e8 05 75 ff ff       	call   a931 <memcpy>
   1342c:	83 c4 0c             	add    $0xc,%esp
		addr->s6_addr[8] ^= 0x02;
   1342f:	80 75 cc 02          	xorb   $0x2,-0x34(%ebp)
	memcpy(&addr, &prefix_info->prefix, sizeof(struct in6_addr) / 2);
   13433:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13436:	6a 08                	push   $0x8
   13438:	83 c0 0e             	add    $0xe,%eax
   1343b:	8d 5d c4             	lea    -0x3c(%ebp),%ebx
   1343e:	50                   	push   %eax
   1343f:	53                   	push   %ebx
   13440:	e8 ec 74 ff ff       	call   a931 <memcpy>
   13445:	83 c4 0c             	add    $0xc,%esp
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
   13448:	6a 00                	push   $0x0
   1344a:	53                   	push   %ebx
   1344b:	e8 f0 ab ff ff       	call   e040 <net_if_ipv6_addr_lookup>
   13450:	89 45 94             	mov    %eax,-0x6c(%ebp)
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
   13453:	85 c0                	test   %eax,%eax
   13455:	8b 45 a0             	mov    -0x60(%ebp),%eax
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
   13458:	5a                   	pop    %edx
   13459:	59                   	pop    %ecx
   1345a:	8b 78 02             	mov    0x2(%eax),%edi
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
   1345d:	0f 84 a7 00 00 00    	je     1350a <handle_ra_input+0x540>
   13463:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13466:	80 78 44 01          	cmpb   $0x1,0x44(%eax)
   1346a:	0f 85 9a 00 00 00    	jne    1350a <handle_ra_input+0x540>
		if (prefix_info->valid_lifetime ==
   13470:	83 ff ff             	cmp    $0xffffffff,%edi
   13473:	75 09                	jne    1347e <handle_ra_input+0x4b4>
	ifaddr->is_infinite = is_infinite;
   13475:	80 48 47 01          	orb    $0x1,0x47(%eax)
			return;
   13479:	e9 e7 fc ff ff       	jmp    13165 <handle_ra_input+0x19b>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
   1347e:	81 ff 20 1c 00 00    	cmp    $0x1c20,%edi
   13484:	76 08                	jbe    1348e <handle_ra_input+0x4c4>
			net_if_ipv6_addr_update_lifetime(
   13486:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13489:	ff 70 02             	pushl  0x2(%eax)
   1348c:	eb 66                	jmp    134f4 <handle_ra_input+0x52a>
	if (ifaddr->lifetime.timer_timeout == 0) {
   1348e:	8b 45 94             	mov    -0x6c(%ebp),%eax
   13491:	8b 48 1c             	mov    0x1c(%eax),%ecx
		return 0;
   13494:	31 c0                	xor    %eax,%eax
	if (ifaddr->lifetime.timer_timeout == 0) {
   13496:	85 c9                	test   %ecx,%ecx
   13498:	74 51                	je     134eb <handle_ra_input+0x521>
		(u64_t)ifaddr->lifetime.wrap_counter *
   1349a:	8b 5d 94             	mov    -0x6c(%ebp),%ebx
   1349d:	b8 9b ff ff 7f       	mov    $0x7fffff9b,%eax
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134a2:	89 4d 88             	mov    %ecx,-0x78(%ebp)
		(u64_t)ifaddr->lifetime.wrap_counter *
   134a5:	f7 6b 20             	imull  0x20(%ebx)
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134a8:	c1 f9 1f             	sar    $0x1f,%ecx
   134ab:	03 45 88             	add    -0x78(%ebp),%eax
   134ae:	89 4d 8c             	mov    %ecx,-0x74(%ebp)
   134b1:	89 45 88             	mov    %eax,-0x78(%ebp)
   134b4:	13 55 8c             	adc    -0x74(%ebp),%edx
		(u64_t)time_diff(k_uptime_get_32(),
   134b7:	8b 45 94             	mov    -0x6c(%ebp),%eax
   134ba:	8b 40 18             	mov    0x18(%eax),%eax
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134bd:	89 55 8c             	mov    %edx,-0x74(%ebp)
		(u64_t)time_diff(k_uptime_get_32(),
   134c0:	89 c3                	mov    %eax,%ebx
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
   134c2:	e8 2b 14 01 00       	call   248f2 <z_impl_k_uptime_get_32>
	return (u32_t)abs((s32_t)time1 - (s32_t)time2);
   134c7:	29 d8                	sub    %ebx,%eax
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134c9:	8b 4d 88             	mov    -0x78(%ebp),%ecx
	return (u32_t)abs((s32_t)time1 - (s32_t)time2);
   134cc:	99                   	cltd   
   134cd:	31 d0                	xor    %edx,%eax
	return (u32_t)(remaining / K_MSEC(1000));
   134cf:	6a 00                	push   $0x0
	return (u32_t)abs((s32_t)time1 - (s32_t)time2);
   134d1:	29 d0                	sub    %edx,%eax
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134d3:	8b 5d 8c             	mov    -0x74(%ebp),%ebx
		(u64_t)time_diff(k_uptime_get_32(),
   134d6:	31 d2                	xor    %edx,%edx
	remaining = (u64_t)ifaddr->lifetime.timer_timeout +
   134d8:	29 c1                	sub    %eax,%ecx
   134da:	19 d3                	sbb    %edx,%ebx
	return (u32_t)(remaining / K_MSEC(1000));
   134dc:	68 e8 03 00 00       	push   $0x3e8
   134e1:	53                   	push   %ebx
   134e2:	51                   	push   %ecx
   134e3:	e8 05 dd fe ff       	call   11ed <__udivdi3>
   134e8:	83 c4 10             	add    $0x10,%esp
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
   134eb:	39 f8                	cmp    %edi,%eax
   134ed:	72 97                	jb     13486 <handle_ra_input+0x4bc>
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
   134ef:	68 20 1c 00 00       	push   $0x1c20
   134f4:	ff 75 94             	pushl  -0x6c(%ebp)
   134f7:	e8 60 ac ff ff       	call   e15c <net_if_ipv6_addr_update_lifetime>
   134fc:	8b 45 94             	mov    -0x6c(%ebp),%eax
   134ff:	5b                   	pop    %ebx
   13500:	5f                   	pop    %edi
   13501:	80 60 47 fe          	andb   $0xfe,0x47(%eax)
   13505:	e9 5b fc ff ff       	jmp    13165 <handle_ra_input+0x19b>
		if (prefix_info->valid_lifetime ==
   1350a:	8b 46 24             	mov    0x24(%esi),%eax
   1350d:	83 ff ff             	cmp    $0xffffffff,%edi
   13510:	8d 55 c4             	lea    -0x3c(%ebp),%edx
   13513:	75 04                	jne    13519 <handle_ra_input+0x54f>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
   13515:	6a 00                	push   $0x0
   13517:	eb 01                	jmp    1351a <handle_ra_input+0x550>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
   13519:	57                   	push   %edi
   1351a:	6a 01                	push   $0x1
   1351c:	52                   	push   %edx
   1351d:	50                   	push   %eax
   1351e:	e8 0d ad ff ff       	call   e230 <net_if_ipv6_addr_add>
   13523:	83 c4 10             	add    $0x10,%esp
   13526:	e9 3a fc ff ff       	jmp    13165 <handle_ra_input+0x19b>
			if (net_pkt_skip(pkt, nd_opt_hdr->len * 8 - 2)) {
   1352b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   1352f:	8d 04 c5 fe ff ff ff 	lea    -0x2(,%eax,8),%eax
   13536:	50                   	push   %eax
   13537:	56                   	push   %esi
   13538:	e8 a3 cd ff ff       	call   102e0 <net_pkt_skip>
   1353d:	5a                   	pop    %edx
   1353e:	85 c0                	test   %eax,%eax
   13540:	59                   	pop    %ecx
   13541:	0f 84 1e fc ff ff    	je     13165 <handle_ra_input+0x19b>
   13547:	e9 83 fc ff ff       	jmp    131cf <handle_ra_input+0x205>
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ip_hdr->src);
   1354c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1354f:	8d 58 08             	lea    0x8(%eax),%ebx
   13552:	53                   	push   %ebx
   13553:	ff 76 24             	pushl  0x24(%esi)
   13556:	e8 c4 b9 ff ff       	call   ef1f <net_if_ipv6_router_lookup>
   1355b:	5a                   	pop    %edx
	if (router) {
   1355c:	85 c0                	test   %eax,%eax
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt), &ip_hdr->src);
   1355e:	59                   	pop    %ecx
	if (router) {
   1355f:	74 30                	je     13591 <handle_ra_input+0x5c7>
		if (!ra_hdr->router_lifetime) {
   13561:	8b 7d 98             	mov    -0x68(%ebp),%edi
   13564:	0f b7 57 02          	movzwl 0x2(%edi),%edx
   13568:	66 85 d2             	test   %dx,%dx
   1356b:	75 09                	jne    13576 <handle_ra_input+0x5ac>
			net_if_ipv6_router_rm(router);
   1356d:	50                   	push   %eax
   1356e:	e8 65 bb ff ff       	call   f0d8 <net_if_ipv6_router_rm>
   13573:	58                   	pop    %eax
   13574:	eb 2f                	jmp    135a5 <handle_ra_input+0x5db>
			if (nbr) {
   13576:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
   1357a:	74 0a                	je     13586 <handle_ra_input+0x5bc>
				net_ipv6_nbr_data(nbr)->is_router = true;
   1357c:	8b 7d 9c             	mov    -0x64(%ebp),%edi
   1357f:	8b 4f 0c             	mov    0xc(%edi),%ecx
   13582:	c6 41 2f 01          	movb   $0x1,0x2f(%ecx)
			net_if_ipv6_router_update_lifetime(
   13586:	52                   	push   %edx
   13587:	50                   	push   %eax
   13588:	e8 6e ba ff ff       	call   effb <net_if_ipv6_router_update_lifetime>
   1358d:	5b                   	pop    %ebx
   1358e:	5f                   	pop    %edi
   1358f:	eb 14                	jmp    135a5 <handle_ra_input+0x5db>
		net_if_ipv6_router_add(net_pkt_iface(pkt),
   13591:	8b 45 98             	mov    -0x68(%ebp),%eax
   13594:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   13598:	50                   	push   %eax
   13599:	53                   	push   %ebx
   1359a:	ff 76 24             	pushl  0x24(%esi)
   1359d:	e8 6c ba ff ff       	call   f00e <net_if_ipv6_router_add>
   135a2:	83 c4 0c             	add    $0xc,%esp
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
   135a5:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
   135a9:	74 30                	je     135db <handle_ra_input+0x611>
   135ab:	8b 45 9c             	mov    -0x64(%ebp),%eax
   135ae:	8b 40 0c             	mov    0xc(%eax),%eax
   135b1:	8b 00                	mov    (%eax),%eax
   135b3:	85 c0                	test   %eax,%eax
   135b5:	74 24                	je     135db <handle_ra_input+0x611>
		if (net_send_data(net_ipv6_nbr_data(nbr)->pending) < 0) {
   135b7:	50                   	push   %eax
   135b8:	e8 90 a2 ff ff       	call   d84d <net_send_data>
   135bd:	59                   	pop    %ecx
   135be:	85 c0                	test   %eax,%eax
   135c0:	79 0e                	jns    135d0 <handle_ra_input+0x606>
			net_pkt_unref(net_ipv6_nbr_data(nbr)->pending);
   135c2:	8b 45 9c             	mov    -0x64(%ebp),%eax
   135c5:	8b 40 0c             	mov    0xc(%eax),%eax
   135c8:	ff 30                	pushl  (%eax)
   135ca:	e8 32 c8 ff ff       	call   fe01 <net_pkt_unref>
   135cf:	5a                   	pop    %edx
		nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
   135d0:	8b 45 9c             	mov    -0x64(%ebp),%eax
   135d3:	8b 40 0c             	mov    0xc(%eax),%eax
   135d6:	e8 28 ed ff ff       	call   12303 <nbr_clear_ns_pending>
	k_delayed_work_cancel(&net_pkt_iface(pkt)->config.ip.ipv6->rs_timer);
   135db:	8b 46 24             	mov    0x24(%esi),%eax
   135de:	8b 40 04             	mov    0x4(%eax),%eax
   135e1:	05 58 01 00 00       	add    $0x158,%eax
   135e6:	50                   	push   %eax
   135e7:	e8 bb 0f 01 00       	call   245a7 <k_delayed_work_cancel>
	net_pkt_unref(pkt);
   135ec:	89 34 24             	mov    %esi,(%esp)
   135ef:	e8 0d c8 ff ff       	call   fe01 <net_pkt_unref>
   135f4:	58                   	pop    %eax
	return NET_OK;
   135f5:	31 c0                	xor    %eax,%eax
}
   135f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   135fa:	5b                   	pop    %ebx
   135fb:	5e                   	pop    %esi
   135fc:	5f                   	pop    %edi
   135fd:	5d                   	pop    %ebp
   135fe:	c3                   	ret    

000135ff <handle_ns_input>:
{
   135ff:	55                   	push   %ebp
   13600:	89 e5                	mov    %esp,%ebp
   13602:	57                   	push   %edi
   13603:	56                   	push   %esi
	size_t bytes = 0;
   13604:	31 f6                	xor    %esi,%esi
   13606:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   13607:	8d 45 92             	lea    -0x6e(%ebp),%eax
{
   1360a:	83 ec 74             	sub    $0x74,%esp
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   1360d:	89 45 9c             	mov    %eax,-0x64(%ebp)
{
   13610:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
   13613:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
   1361a:	c7 45 98 14 00 00 00 	movl   $0x14,-0x68(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
   13621:	c7 45 a0 02 00 00 00 	movl   $0x2,-0x60(%ebp)
	u16_t length = net_pkt_get_len(pkt);
   13628:	8b 43 14             	mov    0x14(%ebx),%eax
	while (buf) {
   1362b:	85 c0                	test   %eax,%eax
   1362d:	74 0a                	je     13639 <handle_ns_input+0x3a>
		bytes += buf->len;
   1362f:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   13633:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   13635:	01 d6                	add    %edx,%esi
		buf = buf->frags;
   13637:	eb f2                	jmp    1362b <handle_ns_input+0x2c>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
   13639:	8d 45 94             	lea    -0x6c(%ebp),%eax
	u16_t length = net_pkt_get_len(pkt);
   1363c:	89 f7                	mov    %esi,%edi
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
   1363e:	50                   	push   %eax
   1363f:	53                   	push   %ebx
   13640:	e8 22 cf ff ff       	call   10567 <net_pkt_get_data>
   13645:	59                   	pop    %ecx
   13646:	89 45 88             	mov    %eax,-0x78(%ebp)
   13649:	5a                   	pop    %edx
	if (!ns_hdr) {
   1364a:	85 c0                	test   %eax,%eax
   1364c:	75 2b                	jne    13679 <handle_ns_input+0x7a>
		NET_ERR("DROP: NULL NS header");
   1364e:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   13655:	0f 84 ee 01 00 00    	je     13849 <handle_ns_input+0x24a>
   1365b:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   13660:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   13665:	c1 e8 03             	shr    $0x3,%eax
   13668:	c1 e0 06             	shl    $0x6,%eax
   1366b:	83 c8 01             	or     $0x1,%eax
   1366e:	50                   	push   %eax
   1366f:	68 10 7d 02 00       	push   $0x27d10
   13674:	e9 2f 01 00 00       	jmp    137a8 <handle_ns_input+0x1a9>
	if (((length < (sizeof(struct net_ipv6_hdr) +
   13679:	66 83 fe 3f          	cmp    $0x3f,%si
   1367d:	76 09                	jbe    13688 <handle_ns_input+0x89>
			  sizeof(struct net_icmpv6_ns_hdr))) ||
   1367f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13682:	80 78 07 ff          	cmpb   $0xff,0x7(%eax)
   13686:	74 16                	je     1369e <handle_ns_input+0x9f>
	    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&
   13688:	8b 45 88             	mov    -0x78(%ebp),%eax
   1368b:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
   1368f:	75 0d                	jne    1369e <handle_ns_input+0x9f>
	    (net_ipv6_is_addr_mcast(&ns_hdr->tgt) && icmp_hdr->code != 0)) {
   13691:	8b 45 10             	mov    0x10(%ebp),%eax
   13694:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   13698:	0f 85 ab 01 00 00    	jne    13849 <handle_ns_input+0x24a>
   1369e:	ff 75 98             	pushl  -0x68(%ebp)
   136a1:	53                   	push   %ebx
   136a2:	e8 39 cc ff ff       	call   102e0 <net_pkt_skip>
   136a7:	58                   	pop    %eax
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
   136a8:	8d 47 d4             	lea    -0x2c(%edi),%eax
   136ab:	5a                   	pop    %edx
   136ac:	66 89 45 8c          	mov    %ax,-0x74(%ebp)
	pkt->ipv6_ext_opt_len = len;
   136b0:	c6 43 46 14          	movb   $0x14,0x46(%ebx)
	nd_opt_hdr = (struct net_icmpv6_nd_opt_hdr *)
   136b4:	eb 70                	jmp    13726 <handle_ns_input+0x127>
	lladdr.len = 8 * ll_len - 2;
   136b6:	8d 04 c5 fe ff ff ff 	lea    -0x2(,%eax,8),%eax
	if (net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
   136bd:	8d 7d e6             	lea    -0x1a(%ebp),%edi
	lladdr.len = 8 * ll_len - 2;
   136c0:	88 45 e5             	mov    %al,-0x1b(%ebp)
	if (net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
   136c3:	0f b6 c0             	movzbl %al,%eax
   136c6:	50                   	push   %eax
   136c7:	57                   	push   %edi
   136c8:	53                   	push   %ebx
   136c9:	e8 4a cc ff ff       	call   10318 <net_pkt_read>
   136ce:	83 c4 0c             	add    $0xc,%esp
   136d1:	85 c0                	test   %eax,%eax
   136d3:	0f 85 70 01 00 00    	jne    13849 <handle_ns_input+0x24a>
	nbr_lladdr.len = lladdr.len;
   136d9:	8a 55 e5             	mov    -0x1b(%ebp),%dl
	if (net_pkt_lladdr_src(pkt)->len < nbr_lladdr.len) {
   136dc:	8a 43 30             	mov    0x30(%ebx),%al
	nbr_lladdr.len = lladdr.len;
   136df:	88 55 d8             	mov    %dl,-0x28(%ebp)
	nbr_lladdr.addr = lladdr.addr;
   136e2:	89 7d d4             	mov    %edi,-0x2c(%ebp)
	if (net_pkt_lladdr_src(pkt)->len < nbr_lladdr.len) {
   136e5:	38 c2                	cmp    %al,%dl
   136e7:	76 03                	jbe    136ec <handle_ns_input+0xed>
		nbr_lladdr.len = net_pkt_lladdr_src(pkt)->len;
   136e9:	88 45 d8             	mov    %al,-0x28(%ebp)
	return net_ipv6_nbr_add(net_pkt_iface(pkt), &NET_IPV6_HDR(pkt)->src,
   136ec:	6a 00                	push   $0x0
   136ee:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   136f1:	6a 00                	push   $0x0
   136f3:	50                   	push   %eax
	return pkt->frags->data;
   136f4:	8b 43 14             	mov    0x14(%ebx),%eax
   136f7:	8b 40 08             	mov    0x8(%eax),%eax
   136fa:	83 c0 08             	add    $0x8,%eax
   136fd:	50                   	push   %eax
   136fe:	ff 73 24             	pushl  0x24(%ebx)
   13701:	e8 87 f7 ff ff       	call   12e8d <net_ipv6_nbr_add>
   13706:	83 c4 14             	add    $0x14,%esp
			if (!handle_ns_neighbor(pkt, nd_opt_hdr->len)) {
   13709:	85 c0                	test   %eax,%eax
   1370b:	0f 84 38 01 00 00    	je     13849 <handle_ns_input+0x24a>
					     (nd_opt_hdr->len << 3));
   13711:	0f b6 46 01          	movzbl 0x1(%esi),%eax
		prev_opt_len = net_pkt_ipv6_ext_opt_len(pkt);
   13715:	8a 53 46             	mov    0x46(%ebx),%dl
					     net_pkt_ipv6_ext_opt_len(pkt) +
   13718:	8d 04 c2             	lea    (%edx,%eax,8),%eax
	pkt->ipv6_ext_opt_len = len;
   1371b:	88 43 46             	mov    %al,0x46(%ebx)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
   1371e:	38 d0                	cmp    %dl,%al
   13720:	0f 86 8e 00 00 00    	jbe    137b4 <handle_ns_input+0x1b5>
					net_pkt_get_data(pkt, &nd_access);
   13726:	8d 45 9c             	lea    -0x64(%ebp),%eax
   13729:	50                   	push   %eax
   1372a:	53                   	push   %ebx
   1372b:	e8 37 ce ff ff       	call   10567 <net_pkt_get_data>
   13730:	5a                   	pop    %edx
   13731:	89 c6                	mov    %eax,%esi
   13733:	59                   	pop    %ecx
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
   13734:	85 c0                	test   %eax,%eax
   13736:	0f 84 a0 00 00 00    	je     137dc <handle_ns_input+0x1dd>
   1373c:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   13740:	0f 84 96 00 00 00    	je     137dc <handle_ns_input+0x1dd>
	       net_pkt_ipv6_ext_opt_len(pkt) < length) {
   13746:	0f b6 43 46          	movzbl 0x46(%ebx),%eax
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
   1374a:	66 3b 45 8c          	cmp    -0x74(%ebp),%ax
   1374e:	0f 83 88 00 00 00    	jae    137dc <handle_ns_input+0x1dd>
	return net_pkt_skip(pkt, access->size);
   13754:	ff 75 a0             	pushl  -0x60(%ebp)
   13757:	53                   	push   %ebx
   13758:	e8 83 cb ff ff       	call   102e0 <net_pkt_skip>
   1375d:	5f                   	pop    %edi
		switch (nd_opt_hdr->type) {
   1375e:	80 3e 01             	cmpb   $0x1,(%esi)
   13761:	58                   	pop    %eax
   13762:	75 ad                	jne    13711 <handle_ns_input+0x112>
			if (net_ipv6_is_addr_unspecified(&ip_hdr->src)) {
   13764:	8b 45 0c             	mov    0xc(%ebp),%eax
   13767:	83 c0 08             	add    $0x8,%eax
   1376a:	e8 20 eb ff ff       	call   1228f <net_ipv6_is_addr_unspecified>
   1376f:	84 c0                	test   %al,%al
   13771:	0f 85 d2 00 00 00    	jne    13849 <handle_ns_input+0x24a>
			if (nd_opt_hdr->len > 2) {
   13777:	8a 46 01             	mov    0x1(%esi),%al
   1377a:	3c 02                	cmp    $0x2,%al
   1377c:	0f 86 34 ff ff ff    	jbe    136b6 <handle_ns_input+0xb7>
				NET_ERR("DROP: Too long source ll address "
   13782:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   13789:	0f 84 ba 00 00 00    	je     13849 <handle_ns_input+0x24a>
   1378f:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   13794:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   13799:	c1 e8 03             	shr    $0x3,%eax
   1379c:	c1 e0 06             	shl    $0x6,%eax
   1379f:	83 c8 01             	or     $0x1,%eax
   137a2:	50                   	push   %eax
   137a3:	68 25 7d 02 00       	push   $0x27d25
			NET_ERR("DROP: Corrupted NS message");
   137a8:	e8 dd fc fe ff       	call   348a <log_0>
   137ad:	5b                   	pop    %ebx
   137ae:	5e                   	pop    %esi
   137af:	e9 95 00 00 00       	jmp    13849 <handle_ns_input+0x24a>
   137b4:	f6 05 9c a8 40 00 07 	testb  $0x7,0x40a89c
   137bb:	0f 84 88 00 00 00    	je     13849 <handle_ns_input+0x24a>
   137c1:	b8 bc 51 02 00       	mov    $0x251bc,%eax
   137c6:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   137cb:	c1 e8 03             	shr    $0x3,%eax
   137ce:	c1 e0 06             	shl    $0x6,%eax
   137d1:	83 c8 01             	or     $0x1,%eax
   137d4:	50                   	push   %eax
   137d5:	68 53 7d 02 00       	push   $0x27d53
   137da:	eb cc                	jmp    137a8 <handle_ns_input+0x1a9>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
   137dc:	8b 45 88             	mov    -0x78(%ebp),%eax
   137df:	83 c0 04             	add    $0x4,%eax
   137e2:	50                   	push   %eax
   137e3:	89 45 80             	mov    %eax,-0x80(%ebp)
   137e6:	ff 73 24             	pushl  0x24(%ebx)
   137e9:	e8 17 a9 ff ff       	call   e105 <net_if_ipv6_addr_lookup_by_iface>
   137ee:	5e                   	pop    %esi
   137ef:	89 c1                	mov    %eax,%ecx
   137f1:	5f                   	pop    %edi
	if (!ifaddr) {
   137f2:	85 c0                	test   %eax,%eax
   137f4:	74 53                	je     13849 <handle_ns_input+0x24a>
		tgt = &ifaddr->address.in6_addr;
   137f6:	8d 40 04             	lea    0x4(%eax),%eax
   137f9:	89 45 84             	mov    %eax,-0x7c(%ebp)
		src = &ip_hdr->src;
   137fc:	8b 45 0c             	mov    0xc(%ebp),%eax
   137ff:	83 c0 08             	add    $0x8,%eax
   13802:	89 45 8c             	mov    %eax,-0x74(%ebp)
	if (net_ipv6_is_addr_unspecified(&ip_hdr->src)) {
   13805:	e8 85 ea ff ff       	call   1228f <net_ipv6_is_addr_unspecified>
   1380a:	84 c0                	test   %al,%al
   1380c:	0f 84 81 00 00 00    	je     13893 <handle_ns_input+0x294>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
   13812:	8b 45 0c             	mov    0xc(%ebp),%eax
   13815:	81 78 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%eax)
   1381c:	75 2b                	jne    13849 <handle_ns_input+0x24a>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
   1381e:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   13822:	75 25                	jne    13849 <handle_ns_input+0x24a>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
   13824:	81 78 20 00 00 00 01 	cmpl   $0x1000000,0x20(%eax)
   1382b:	75 1c                	jne    13849 <handle_ns_input+0x24a>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
   1382d:	0f b6 40 24          	movzbl 0x24(%eax),%eax
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
   13831:	3d ff 00 00 00       	cmp    $0xff,%eax
   13836:	75 11                	jne    13849 <handle_ns_input+0x24a>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
   13838:	8b 43 24             	mov    0x24(%ebx),%eax
   1383b:	80 79 45 00          	cmpb   $0x0,0x45(%ecx)
   1383f:	75 12                	jne    13853 <handle_ns_input+0x254>
			dad_failed(net_pkt_iface(pkt),
   13841:	8b 55 84             	mov    -0x7c(%ebp),%edx
   13844:	e8 1e ed ff ff       	call   12567 <dad_failed>
	return NET_DROP;
   13849:	b8 02 00 00 00       	mov    $0x2,%eax
			goto drop;
   1384e:	e9 3a 01 00 00       	jmp    1398d <handle_ns_input+0x38e>
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
   13853:	8b 55 0c             	mov    0xc(%ebp),%edx
		net_ipaddr_copy(&ip_hdr->src,
   13856:	8d 7d a4             	lea    -0x5c(%ebp),%edi
		if (!net_ipv6_is_addr_solicited_node(&ip_hdr->dst)) {
   13859:	83 c2 18             	add    $0x18,%edx
   1385c:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
   13863:	c7 42 0c 00 00 00 01 	movl   $0x1000000,0xc(%edx)
		net_ipaddr_copy(&ip_hdr->src,
   1386a:	52                   	push   %edx
   1386b:	50                   	push   %eax
   1386c:	e8 1a b9 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   13871:	5a                   	pop    %edx
   13872:	89 c6                	mov    %eax,%esi
   13874:	59                   	pop    %ecx
   13875:	b9 04 00 00 00       	mov    $0x4,%ecx
   1387a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1387c:	8d 75 a4             	lea    -0x5c(%ebp),%esi
   1387f:	b9 04 00 00 00       	mov    $0x4,%ecx
   13884:	8b 7d 8c             	mov    -0x74(%ebp),%edi
		flags = NET_ICMPV6_NA_FLAG_OVERRIDE;
   13887:	b8 20 00 00 00       	mov    $0x20,%eax
		net_ipaddr_copy(&ip_hdr->src,
   1388c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		goto send_na;
   1388e:	e9 d0 00 00 00       	jmp    13963 <handle_ns_input+0x364>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
   13893:	6a 00                	push   $0x0
   13895:	ff 75 8c             	pushl  -0x74(%ebp)
   13898:	e8 a3 a7 ff ff       	call   e040 <net_if_ipv6_addr_lookup>
   1389d:	5e                   	pop    %esi
	if (net_ipv6_is_my_addr(&ip_hdr->src)) {
   1389e:	85 c0                	test   %eax,%eax
   138a0:	5f                   	pop    %edi
   138a1:	75 a6                	jne    13849 <handle_ns_input+0x24a>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
   138a3:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (net_ipv6_is_addr_solicited_node(&ip_hdr->dst)) {
   138a6:	8b 45 0c             	mov    0xc(%ebp),%eax
   138a9:	83 c0 18             	add    $0x18,%eax
   138ac:	81 7a 18 ff 02 00 00 	cmpl   $0x2ff,0x18(%edx)
   138b3:	75 1b                	jne    138d0 <handle_ns_input+0x2d1>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
   138b5:	83 7a 1c 00          	cmpl   $0x0,0x1c(%edx)
   138b9:	75 15                	jne    138d0 <handle_ns_input+0x2d1>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
   138bb:	81 7a 20 00 00 00 01 	cmpl   $0x1000000,0x20(%edx)
   138c2:	75 0c                	jne    138d0 <handle_ns_input+0x2d1>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
   138c4:	0f b6 52 24          	movzbl 0x24(%edx),%edx
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
   138c8:	81 fa ff 00 00 00    	cmp    $0xff,%edx
   138ce:	74 5b                	je     1392b <handle_ns_input+0x32c>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
   138d0:	50                   	push   %eax
   138d1:	ff 73 24             	pushl  0x24(%ebx)
   138d4:	e8 2c a8 ff ff       	call   e105 <net_if_ipv6_addr_lookup_by_iface>
   138d9:	5a                   	pop    %edx
	if (ifaddr) {
   138da:	85 c0                	test   %eax,%eax
		ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
   138dc:	59                   	pop    %ecx
	if (ifaddr) {
   138dd:	0f 84 66 ff ff ff    	je     13849 <handle_ns_input+0x24a>
		net_ipaddr_copy(&ip_hdr->dst, &ip_hdr->src);
   138e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   138e6:	8d 7d d4             	lea    -0x2c(%ebp),%edi
		net_ipaddr_copy(&ip_hdr->src, &ns_hdr->tgt);
   138e9:	8b 55 0c             	mov    0xc(%ebp),%edx
		tgt = &ifaddr->address.in6_addr;
   138ec:	83 c0 04             	add    $0x4,%eax
		net_ipaddr_copy(&ip_hdr->dst, &ip_hdr->src);
   138ef:	8d 71 08             	lea    0x8(%ecx),%esi
   138f2:	b9 04 00 00 00       	mov    $0x4,%ecx
   138f7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   138f9:	8b 7d 0c             	mov    0xc(%ebp),%edi
   138fc:	8d 75 d4             	lea    -0x2c(%ebp),%esi
   138ff:	83 c7 18             	add    $0x18,%edi
   13902:	b9 04 00 00 00       	mov    $0x4,%ecx
   13907:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		net_ipaddr_copy(&ip_hdr->src, &ns_hdr->tgt);
   13909:	8b 75 88             	mov    -0x78(%ebp),%esi
   1390c:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   1390f:	83 c6 04             	add    $0x4,%esi
   13912:	b9 04 00 00 00       	mov    $0x4,%ecx
   13917:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   13919:	8d 7a 08             	lea    0x8(%edx),%edi
   1391c:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   1391f:	b9 04 00 00 00       	mov    $0x4,%ecx
		tgt = &ifaddr->address.in6_addr;
   13924:	89 45 84             	mov    %eax,-0x7c(%ebp)
		net_ipaddr_copy(&ip_hdr->src, &ns_hdr->tgt);
   13927:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		tgt = &ifaddr->address.in6_addr;
   13929:	eb 33                	jmp    1395e <handle_ns_input+0x35f>
		net_ipaddr_copy(&ip_hdr->dst, &ip_hdr->src);
   1392b:	8d 7d b4             	lea    -0x4c(%ebp),%edi
   1392e:	b9 04 00 00 00       	mov    $0x4,%ecx
   13933:	8b 75 8c             	mov    -0x74(%ebp),%esi
   13936:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   13938:	8d 75 b4             	lea    -0x4c(%ebp),%esi
   1393b:	b9 04 00 00 00       	mov    $0x4,%ecx
   13940:	89 c7                	mov    %eax,%edi
   13942:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		net_ipaddr_copy(&ip_hdr->src, &ns_hdr->tgt);
   13944:	8d 7d c4             	lea    -0x3c(%ebp),%edi
   13947:	b9 04 00 00 00       	mov    $0x4,%ecx
   1394c:	8b 75 80             	mov    -0x80(%ebp),%esi
   1394f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   13951:	8d 75 c4             	lea    -0x3c(%ebp),%esi
   13954:	b9 04 00 00 00       	mov    $0x4,%ecx
   13959:	8b 7d 8c             	mov    -0x74(%ebp),%edi
   1395c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		flags = NET_ICMPV6_NA_FLAG_SOLICITED |
   1395e:	b8 60 00 00 00       	mov    $0x60,%eax
	if (!net_ipv6_send_na(net_pkt_iface(pkt), src,
   13963:	50                   	push   %eax
			      &ip_hdr->dst, tgt, flags)) {
   13964:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (!net_ipv6_send_na(net_pkt_iface(pkt), src,
   13967:	ff 75 84             	pushl  -0x7c(%ebp)
			      &ip_hdr->dst, tgt, flags)) {
   1396a:	83 c0 18             	add    $0x18,%eax
	if (!net_ipv6_send_na(net_pkt_iface(pkt), src,
   1396d:	50                   	push   %eax
   1396e:	ff 75 8c             	pushl  -0x74(%ebp)
   13971:	ff 73 24             	pushl  0x24(%ebx)
   13974:	e8 89 ed ff ff       	call   12702 <net_ipv6_send_na>
   13979:	83 c4 14             	add    $0x14,%esp
   1397c:	85 c0                	test   %eax,%eax
   1397e:	0f 85 c5 fe ff ff    	jne    13849 <handle_ns_input+0x24a>
		net_pkt_unref(pkt);
   13984:	53                   	push   %ebx
   13985:	e8 77 c4 ff ff       	call   fe01 <net_pkt_unref>
   1398a:	58                   	pop    %eax
		return NET_OK;
   1398b:	31 c0                	xor    %eax,%eax
}
   1398d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13990:	5b                   	pop    %ebx
   13991:	5e                   	pop    %esi
   13992:	5f                   	pop    %edi
   13993:	5d                   	pop    %ebp
   13994:	c3                   	ret    

00013995 <net_ipv6_start_dad>:
{
   13995:	55                   	push   %ebp
   13996:	89 e5                	mov    %esp,%ebp
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
   13998:	6a 01                	push   $0x1
				&ifaddr->address.in6_addr, true);
   1399a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1399d:	83 c0 04             	add    $0x4,%eax
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
   139a0:	50                   	push   %eax
   139a1:	6a 00                	push   $0x0
   139a3:	6a 00                	push   $0x0
   139a5:	6a 00                	push   $0x0
   139a7:	ff 75 08             	pushl  0x8(%ebp)
   139aa:	e8 72 f2 ff ff       	call   12c21 <net_ipv6_send_ns>
   139af:	83 c4 18             	add    $0x18,%esp
}
   139b2:	c9                   	leave  
   139b3:	c3                   	ret    

000139b4 <net_ipv6_prepare_for_send>:
{
   139b4:	55                   	push   %ebp
   139b5:	89 e5                	mov    %esp,%ebp
   139b7:	57                   	push   %edi
   139b8:	56                   	push   %esi
   139b9:	53                   	push   %ebx
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   139ba:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   139bd:	83 ec 14             	sub    $0x14,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   139c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   139c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
   139ca:	c7 45 f0 28 00 00 00 	movl   $0x28,-0x10(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   139d1:	50                   	push   %eax
	struct net_if *iface = NULL;
   139d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
   139d9:	53                   	push   %ebx
   139da:	e8 88 cb ff ff       	call   10567 <net_pkt_get_data>
   139df:	5e                   	pop    %esi
   139e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   139e3:	5f                   	pop    %edi
		return NET_DROP;
   139e4:	b8 02 00 00 00       	mov    $0x2,%eax
	if (!ip_hdr) {
   139e9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   139ed:	0f 84 67 01 00 00    	je     13b5a <net_ipv6_prepare_for_send+0x1a6>
	if ((net_pkt_lladdr_dst(pkt)->addr &&
   139f3:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
   139f7:	0f 85 3c 01 00 00    	jne    13b39 <net_ipv6_prepare_for_send+0x185>
	      !IS_ENABLED(CONFIG_NET_ROUTING))) ||
   139fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13a00:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
   13a04:	0f 84 2f 01 00 00    	je     13b39 <net_ipv6_prepare_for_send+0x185>
	    atomic_test_bit(net_pkt_iface(pkt)->if_dev->flags,
   13a0a:	8b 43 24             	mov    0x24(%ebx),%eax
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13a0d:	8b 00                	mov    (%eax),%eax
   13a0f:	8b 40 0c             	mov    0xc(%eax),%eax
	    net_ipv6_is_addr_mcast(&ip_hdr->dst) ||
   13a12:	a8 02                	test   $0x2,%al
   13a14:	0f 85 1f 01 00 00    	jne    13b39 <net_ipv6_prepare_for_send+0x185>
	if (net_if_ipv6_addr_onlink(&iface, &ip_hdr->dst)) {
   13a1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13a1d:	8d 7d e8             	lea    -0x18(%ebp),%edi
   13a20:	8d 70 18             	lea    0x18(%eax),%esi
   13a23:	56                   	push   %esi
   13a24:	57                   	push   %edi
   13a25:	e8 ae b2 ff ff       	call   ecd8 <net_if_ipv6_addr_onlink>
   13a2a:	5a                   	pop    %edx
   13a2b:	84 c0                	test   %al,%al
   13a2d:	59                   	pop    %ecx
   13a2e:	74 1c                	je     13a4c <net_ipv6_prepare_for_send+0x98>
		net_pkt_set_iface(pkt, iface);
   13a30:	8b 45 e8             	mov    -0x18(%ebp),%eax
	pkt->iface = iface;
   13a33:	89 43 24             	mov    %eax,0x24(%ebx)
	if (iface) {
   13a36:	85 c0                	test   %eax,%eax
   13a38:	74 55                	je     13a8f <net_ipv6_prepare_for_send+0xdb>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   13a3a:	8b 10                	mov    (%eax),%edx
   13a3c:	8a 52 15             	mov    0x15(%edx),%dl
   13a3f:	88 53 31             	mov    %dl,0x31(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   13a42:	8b 00                	mov    (%eax),%eax
   13a44:	8a 40 15             	mov    0x15(%eax),%al
   13a47:	88 43 39             	mov    %al,0x39(%ebx)
   13a4a:	eb 43                	jmp    13a8f <net_ipv6_prepare_for_send+0xdb>
	route = net_route_lookup(iface, dst);
   13a4c:	56                   	push   %esi
   13a4d:	6a 00                	push   $0x0
   13a4f:	e8 46 0c 00 00       	call   1469a <net_route_lookup>
   13a54:	5a                   	pop    %edx
	if (route) {
   13a55:	85 c0                	test   %eax,%eax
	route = net_route_lookup(iface, dst);
   13a57:	59                   	pop    %ecx
	if (route) {
   13a58:	74 24                	je     13a7e <net_ipv6_prepare_for_send+0xca>
		nexthop = net_route_get_nexthop(route);
   13a5a:	50                   	push   %eax
   13a5b:	89 45 e0             	mov    %eax,-0x20(%ebp)
   13a5e:	e8 fb 0d 00 00       	call   1485e <net_route_get_nexthop>
   13a63:	5e                   	pop    %esi
		if (!nexthop) {
   13a64:	85 c0                	test   %eax,%eax
		nexthop = net_route_get_nexthop(route);
   13a66:	89 c6                	mov    %eax,%esi
		if (!nexthop) {
   13a68:	8b 55 e0             	mov    -0x20(%ebp),%edx
   13a6b:	75 22                	jne    13a8f <net_ipv6_prepare_for_send+0xdb>
			net_route_del(route);
   13a6d:	52                   	push   %edx
   13a6e:	e8 15 0d 00 00       	call   14788 <net_route_del>
   13a73:	5b                   	pop    %ebx
			return NET_DROP;
   13a74:	b8 02 00 00 00       	mov    $0x2,%eax
   13a79:	e9 dc 00 00 00       	jmp    13b5a <net_ipv6_prepare_for_send+0x1a6>
		router = net_if_ipv6_router_find_default(NULL, dst);
   13a7e:	56                   	push   %esi
   13a7f:	6a 00                	push   $0x0
   13a81:	e8 0d b5 ff ff       	call   ef93 <net_if_ipv6_router_find_default>
   13a86:	5a                   	pop    %edx
		if (!router) {
   13a87:	85 c0                	test   %eax,%eax
		router = net_if_ipv6_router_find_default(NULL, dst);
   13a89:	59                   	pop    %ecx
		if (!router) {
   13a8a:	74 38                	je     13ac4 <net_ipv6_prepare_for_send+0x110>
		nexthop = &router->address.in6_addr;
   13a8c:	8d 70 24             	lea    0x24(%eax),%esi
	if (!iface) {
   13a8f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13a93:	75 2f                	jne    13ac4 <net_ipv6_prepare_for_send+0x110>
		if (net_if_ipv6_addr_onlink(&iface, nexthop)) {
   13a95:	56                   	push   %esi
   13a96:	57                   	push   %edi
   13a97:	e8 3c b2 ff ff       	call   ecd8 <net_if_ipv6_addr_onlink>
   13a9c:	59                   	pop    %ecx
   13a9d:	84 c0                	test   %al,%al
   13a9f:	5f                   	pop    %edi
   13aa0:	74 1c                	je     13abe <net_ipv6_prepare_for_send+0x10a>
			net_pkt_set_iface(pkt, iface);
   13aa2:	8b 45 e8             	mov    -0x18(%ebp),%eax
	pkt->iface = iface;
   13aa5:	89 43 24             	mov    %eax,0x24(%ebx)
	if (iface) {
   13aa8:	85 c0                	test   %eax,%eax
   13aaa:	74 18                	je     13ac4 <net_ipv6_prepare_for_send+0x110>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   13aac:	8b 10                	mov    (%eax),%edx
   13aae:	8a 52 15             	mov    0x15(%edx),%dl
   13ab1:	88 53 31             	mov    %dl,0x31(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   13ab4:	8b 00                	mov    (%eax),%eax
   13ab6:	8a 40 15             	mov    0x15(%eax),%al
   13ab9:	88 43 39             	mov    %al,0x39(%ebx)
   13abc:	eb 06                	jmp    13ac4 <net_ipv6_prepare_for_send+0x110>
			iface = net_pkt_iface(pkt);
   13abe:	8b 43 24             	mov    0x24(%ebx),%eax
   13ac1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	nbr = nbr_lookup(&net_neighbor.table, iface, nexthop);
   13ac4:	89 f2                	mov    %esi,%edx
   13ac6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13ac9:	e8 3b ea ff ff       	call   12509 <nbr_lookup.isra.12>
   13ace:	89 c7                	mov    %eax,%edi
	if (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
   13ad0:	85 c0                	test   %eax,%eax
   13ad2:	74 69                	je     13b3d <net_ipv6_prepare_for_send+0x189>
   13ad4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   13ad8:	3c ff                	cmp    $0xff,%al
   13ada:	74 61                	je     13b3d <net_ipv6_prepare_for_send+0x189>
		lladdr = net_nbr_get_lladdr(nbr->idx);
   13adc:	50                   	push   %eax
   13add:	e8 1d e2 ff ff       	call   11cff <net_nbr_get_lladdr>
   13ae2:	5a                   	pop    %edx
		net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
   13ae3:	8d 50 02             	lea    0x2(%eax),%edx
   13ae6:	89 53 34             	mov    %edx,0x34(%ebx)
		net_pkt_lladdr_dst(pkt)->len = lladdr->len;
   13ae9:	8a 40 01             	mov    0x1(%eax),%al
   13aec:	88 43 38             	mov    %al,0x38(%ebx)
		if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
   13aef:	8b 47 0c             	mov    0xc(%edi),%eax
   13af2:	83 78 28 02          	cmpl   $0x2,0x28(%eax)
   13af6:	75 41                	jne    13b39 <net_ipv6_prepare_for_send+0x185>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);
   13af8:	ba 03 00 00 00       	mov    $0x3,%edx
   13afd:	89 f8                	mov    %edi,%eax
   13aff:	e8 ad e7 ff ff       	call   122b1 <ipv6_nbr_set_state>
			net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
   13b04:	8b 5f 0c             	mov    0xc(%edi),%ebx
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   13b07:	e8 05 0e 01 00       	call   24911 <z_impl_k_uptime_get>
   13b0c:	89 43 14             	mov    %eax,0x14(%ebx)
			net_ipv6_nbr_data(nbr)->reachable_timeout =
   13b0f:	8b 47 0c             	mov    0xc(%edi),%eax
			net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
   13b12:	89 53 18             	mov    %edx,0x18(%ebx)
			net_ipv6_nbr_data(nbr)->reachable_timeout =
   13b15:	c7 40 1c 88 13 00 00 	movl   $0x1388,0x1c(%eax)
			if (!k_delayed_work_remaining_get(
   13b1c:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   13b21:	e8 85 e8 ff ff       	call   123ab <k_delayed_work_remaining_get>
   13b26:	85 c0                	test   %eax,%eax
   13b28:	75 0f                	jne    13b39 <net_ipv6_prepare_for_send+0x185>
				k_delayed_work_submit(
   13b2a:	ba 88 13 00 00       	mov    $0x1388,%edx
   13b2f:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   13b34:	e8 9a e8 ff ff       	call   123d3 <k_delayed_work_submit>
		return NET_OK;
   13b39:	31 c0                	xor    %eax,%eax
   13b3b:	eb 1d                	jmp    13b5a <net_ipv6_prepare_for_send+0x1a6>
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
   13b3d:	6a 00                	push   $0x0
			       &ip_hdr->src, NULL, nexthop, false);
   13b3f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
   13b42:	56                   	push   %esi
			       &ip_hdr->src, NULL, nexthop, false);
   13b43:	83 c7 08             	add    $0x8,%edi
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
   13b46:	6a 00                	push   $0x0
   13b48:	57                   	push   %edi
   13b49:	53                   	push   %ebx
   13b4a:	ff 73 24             	pushl  0x24(%ebx)
   13b4d:	e8 cf f0 ff ff       	call   12c21 <net_ipv6_send_ns>
   13b52:	83 c4 18             	add    $0x18,%esp
	return NET_CONTINUE;
   13b55:	b8 01 00 00 00       	mov    $0x1,%eax
}
   13b5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13b5d:	5b                   	pop    %ebx
   13b5e:	5e                   	pop    %esi
   13b5f:	5f                   	pop    %edi
   13b60:	5d                   	pop    %ebp
   13b61:	c3                   	ret    

00013b62 <ipv6_nd_reachable_timeout>:
{
   13b62:	55                   	push   %ebp
   13b63:	89 e5                	mov    %esp,%ebp
   13b65:	57                   	push   %edi
   13b66:	56                   	push   %esi
   13b67:	53                   	push   %ebx
   13b68:	bb 00 a0 40 00       	mov    $0x40a000,%ebx
   13b6d:	83 ec 10             	sub    $0x10,%esp
   13b70:	e8 9c 0d 01 00       	call   24911 <z_impl_k_uptime_get>
   13b75:	89 45 ec             	mov    %eax,-0x14(%ebp)
   13b78:	89 55 f0             	mov    %edx,-0x10(%ebp)
		if (!nbr || !nbr->ref) {
   13b7b:	80 3b 00             	cmpb   $0x0,(%ebx)
   13b7e:	0f 84 32 01 00 00    	je     13cb6 <ipv6_nd_reachable_timeout+0x154>
		data = net_ipv6_nbr_data(nbr);
   13b84:	8b 43 0c             	mov    0xc(%ebx),%eax
		if (!data) {
   13b87:	85 c0                	test   %eax,%eax
   13b89:	0f 84 27 01 00 00    	je     13cb6 <ipv6_nd_reachable_timeout+0x154>
		if (!data->reachable) {
   13b8f:	8b 48 18             	mov    0x18(%eax),%ecx
   13b92:	8b 50 14             	mov    0x14(%eax),%edx
   13b95:	89 cf                	mov    %ecx,%edi
   13b97:	09 d7                	or     %edx,%edi
   13b99:	0f 84 17 01 00 00    	je     13cb6 <ipv6_nd_reachable_timeout+0x154>
		remaining = data->reachable + data->reachable_timeout - current;
   13b9f:	8b 70 1c             	mov    0x1c(%eax),%esi
   13ba2:	89 f7                	mov    %esi,%edi
   13ba4:	c1 ff 1f             	sar    $0x1f,%edi
   13ba7:	2b 55 ec             	sub    -0x14(%ebp),%edx
   13baa:	1b 4d f0             	sbb    -0x10(%ebp),%ecx
   13bad:	01 f2                	add    %esi,%edx
   13baf:	11 f9                	adc    %edi,%ecx
		if (remaining > 0) {
   13bb1:	31 f6                	xor    %esi,%esi
   13bb3:	39 d6                	cmp    %edx,%esi
   13bb5:	19 ce                	sbb    %ecx,%esi
   13bb7:	7d 20                	jge    13bd9 <ipv6_nd_reachable_timeout+0x77>
			if (!k_delayed_work_remaining_get(
   13bb9:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   13bbe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   13bc1:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   13bc4:	e8 e2 e7 ff ff       	call   123ab <k_delayed_work_remaining_get>
   13bc9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13bcc:	85 c0                	test   %eax,%eax
   13bce:	0f 85 e2 00 00 00    	jne    13cb6 <ipv6_nd_reachable_timeout+0x154>
   13bd4:	e9 d3 00 00 00       	jmp    13cac <ipv6_nd_reachable_timeout+0x14a>
		data->reachable = 0;
   13bd9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   13be0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		switch (data->state) {
   13be7:	83 78 28 04          	cmpl   $0x4,0x28(%eax)
   13beb:	0f 87 c5 00 00 00    	ja     13cb6 <ipv6_nd_reachable_timeout+0x154>
   13bf1:	8b 50 28             	mov    0x28(%eax),%edx
   13bf4:	ff 24 95 4c 60 02 00 	jmp    *0x2604c(,%edx,4)
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
   13bfb:	8a 50 2e             	mov    0x2e(%eax),%dl
   13bfe:	80 fa 02             	cmp    $0x2,%dl
   13c01:	77 5f                	ja     13c62 <ipv6_nd_reachable_timeout+0x100>
				data->ns_count++;
   13c03:	42                   	inc    %edx
						       NULL, &data->addr,
   13c04:	83 c0 04             	add    $0x4,%eax
				data->ns_count++;
   13c07:	88 50 2a             	mov    %dl,0x2a(%eax)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
   13c0a:	6a 00                	push   $0x0
   13c0c:	50                   	push   %eax
   13c0d:	6a 00                	push   $0x0
   13c0f:	6a 00                	push   $0x0
   13c11:	6a 00                	push   $0x0
   13c13:	ff 73 08             	pushl  0x8(%ebx)
   13c16:	e8 06 f0 ff ff       	call   12c21 <net_ipv6_send_ns>
   13c1b:	83 c4 18             	add    $0x18,%esp
				if (ret < 0) {
   13c1e:	e9 93 00 00 00       	jmp    13cb6 <ipv6_nd_reachable_timeout+0x154>
			data->state = NET_IPV6_NBR_STATE_STALE;
   13c23:	c7 40 28 02 00 00 00 	movl   $0x2,0x28(%eax)
			NET_DBG("nbr %p moving %s state to STALE (%d)",
   13c2a:	e9 87 00 00 00       	jmp    13cb6 <ipv6_nd_reachable_timeout+0x154>
			data->state = NET_IPV6_NBR_STATE_PROBE;
   13c2f:	c7 40 28 04 00 00 00 	movl   $0x4,0x28(%eax)
			data->ns_count = 0U;
   13c36:	c6 40 2e 00          	movb   $0x0,0x2e(%eax)
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
   13c3a:	8a 50 2e             	mov    0x2e(%eax),%dl
   13c3d:	8d 70 04             	lea    0x4(%eax),%esi
   13c40:	8b 4b 08             	mov    0x8(%ebx),%ecx
   13c43:	80 fa 02             	cmp    $0x2,%dl
   13c46:	76 23                	jbe    13c6b <ipv6_nd_reachable_timeout+0x109>
				router = net_if_ipv6_router_lookup(nbr->iface,
   13c48:	56                   	push   %esi
   13c49:	51                   	push   %ecx
   13c4a:	e8 d0 b2 ff ff       	call   ef1f <net_if_ipv6_router_lookup>
   13c4f:	5a                   	pop    %edx
				if (router && !router->is_infinite) {
   13c50:	85 c0                	test   %eax,%eax
				router = net_if_ipv6_router_lookup(nbr->iface,
   13c52:	59                   	pop    %ecx
				if (router && !router->is_infinite) {
   13c53:	74 61                	je     13cb6 <ipv6_nd_reachable_timeout+0x154>
   13c55:	f6 40 38 04          	testb  $0x4,0x38(%eax)
   13c59:	75 5b                	jne    13cb6 <ipv6_nd_reachable_timeout+0x154>
					net_if_ipv6_router_rm(router);
   13c5b:	50                   	push   %eax
   13c5c:	e8 77 b4 ff ff       	call   f0d8 <net_if_ipv6_router_rm>
   13c61:	58                   	pop    %eax
					nbr_free(nbr);
   13c62:	89 d8                	mov    %ebx,%eax
   13c64:	e8 c7 e6 ff ff       	call   12330 <nbr_free>
   13c69:	eb 4b                	jmp    13cb6 <ipv6_nd_reachable_timeout+0x154>
				data->ns_count++;
   13c6b:	42                   	inc    %edx
   13c6c:	88 50 2e             	mov    %dl,0x2e(%eax)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
   13c6f:	6a 00                	push   $0x0
   13c71:	56                   	push   %esi
   13c72:	6a 00                	push   $0x0
   13c74:	6a 00                	push   $0x0
   13c76:	6a 00                	push   $0x0
   13c78:	51                   	push   %ecx
   13c79:	e8 a3 ef ff ff       	call   12c21 <net_ipv6_send_ns>
   13c7e:	83 c4 18             	add    $0x18,%esp
				net_ipv6_nbr_data(nbr)->reachable =
   13c81:	8b 73 0c             	mov    0xc(%ebx),%esi
   13c84:	e8 88 0c 01 00       	call   24911 <z_impl_k_uptime_get>
   13c89:	89 46 14             	mov    %eax,0x14(%esi)
				net_ipv6_nbr_data(nbr)->reachable_timeout =
   13c8c:	8b 43 0c             	mov    0xc(%ebx),%eax
				net_ipv6_nbr_data(nbr)->reachable =
   13c8f:	89 56 18             	mov    %edx,0x18(%esi)
				net_ipv6_nbr_data(nbr)->reachable_timeout =
   13c92:	c7 40 1c e8 03 00 00 	movl   $0x3e8,0x1c(%eax)
				if (!k_delayed_work_remaining_get(
   13c99:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   13c9e:	e8 08 e7 ff ff       	call   123ab <k_delayed_work_remaining_get>
   13ca3:	85 c0                	test   %eax,%eax
   13ca5:	75 0f                	jne    13cb6 <ipv6_nd_reachable_timeout+0x154>
					k_delayed_work_submit(
   13ca7:	ba e8 03 00 00       	mov    $0x3e8,%edx
   13cac:	b8 80 0f 40 00       	mov    $0x400f80,%eax
   13cb1:	e8 1d e7 ff ff       	call   123d3 <k_delayed_work_submit>
   13cb6:	83 c3 44             	add    $0x44,%ebx
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
   13cb9:	81 fb 20 a2 40 00    	cmp    $0x40a220,%ebx
   13cbf:	0f 85 b6 fe ff ff    	jne    13b7b <ipv6_nd_reachable_timeout+0x19>
}
   13cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13cc8:	5b                   	pop    %ebx
   13cc9:	5e                   	pop    %esi
   13cca:	5f                   	pop    %edi
   13ccb:	5d                   	pop    %ebp
   13ccc:	c3                   	ret    

00013ccd <net_ipv6_send_rs>:
{
   13ccd:	55                   	push   %ebp
   13cce:	89 e5                	mov    %esp,%ebp
   13cd0:	57                   	push   %edi
   13cd1:	56                   	push   %esi
   13cd2:	53                   	push   %ebx
	src = net_if_ipv6_select_src_addr(iface, &dst);
   13cd3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
{
   13cd6:	83 ec 1c             	sub    $0x1c,%esp
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
   13cd9:	c7 45 e4 ff 02 00 00 	movl   $0x2ff,-0x1c(%ebp)
   13ce0:	8b 75 08             	mov    0x8(%ebp),%esi
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
   13ce3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	src = net_if_ipv6_select_src_addr(iface, &dst);
   13cea:	50                   	push   %eax
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
   13ceb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   13cf2:	56                   	push   %esi
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
   13cf3:	c7 45 f0 00 00 00 01 	movl   $0x1000000,-0x10(%ebp)
   13cfa:	e8 8c b4 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   13cff:	59                   	pop    %ecx
   13d00:	5b                   	pop    %ebx
   13d01:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
   13d04:	e8 86 e5 ff ff       	call   1228f <net_ipv6_is_addr_unspecified>
	u8_t llao_len = 0U;
   13d09:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
	if (!net_ipv6_is_addr_unspecified(src)) {
   13d0d:	84 c0                	test   %al,%al
   13d0f:	75 18                	jne    13d29 <net_ipv6_send_rs+0x5c>
	if (net_if_get_link_addr(iface)->len == 6) {
   13d11:	8b 06                	mov    (%esi),%eax
		return 8;
   13d13:	c6 45 e3 08          	movb   $0x8,-0x1d(%ebp)
	if (net_if_get_link_addr(iface)->len == 6) {
   13d17:	8a 40 14             	mov    0x14(%eax),%al
   13d1a:	3c 06                	cmp    $0x6,%al
   13d1c:	74 0b                	je     13d29 <net_ipv6_send_rs+0x5c>
		return 16;
   13d1e:	3c 08                	cmp    $0x8,%al
   13d20:	0f 94 c0             	sete   %al
   13d23:	c1 e0 04             	shl    $0x4,%eax
   13d26:	88 45 e3             	mov    %al,-0x1d(%ebp)
	pkt = net_pkt_alloc_with_buffer(iface,
   13d29:	6a 64                	push   $0x64
		return -ENOMEM;
   13d2b:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	pkt = net_pkt_alloc_with_buffer(iface,
   13d30:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
   13d34:	6a 3a                	push   $0x3a
   13d36:	89 45 d8             	mov    %eax,-0x28(%ebp)
   13d39:	6a 02                	push   $0x2
   13d3b:	83 c0 04             	add    $0x4,%eax
   13d3e:	50                   	push   %eax
   13d3f:	56                   	push   %esi
   13d40:	e8 70 c5 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   13d45:	83 c4 14             	add    $0x14,%esp
   13d48:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
   13d4a:	85 c0                	test   %eax,%eax
   13d4c:	0f 84 92 00 00 00    	je     13de4 <net_ipv6_send_rs+0x117>
	pkt->ipv6_hop_limit = hop_limit;
   13d52:	c6 40 41 ff          	movb   $0xff,0x41(%eax)
	if (net_ipv6_create(pkt, src, &dst) ||
   13d56:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   13d59:	50                   	push   %eax
   13d5a:	ff 75 dc             	pushl  -0x24(%ebp)
   13d5d:	53                   	push   %ebx
   13d5e:	e8 d8 df ff ff       	call   11d3b <net_ipv6_create>
   13d63:	83 c4 0c             	add    $0xc,%esp
   13d66:	85 c0                	test   %eax,%eax
   13d68:	74 07                	je     13d71 <net_ipv6_send_rs+0xa4>
	int ret = -ENOBUFS;
   13d6a:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
   13d6f:	eb 6c                	jmp    13ddd <net_ipv6_send_rs+0x110>
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
   13d71:	6a 00                	push   $0x0
   13d73:	68 85 00 00 00       	push   $0x85
   13d78:	53                   	push   %ebx
   13d79:	e8 a1 d9 ff ff       	call   1171f <net_icmpv6_create>
   13d7e:	83 c4 0c             	add    $0xc,%esp
	if (net_ipv6_create(pkt, src, &dst) ||
   13d81:	85 c0                	test   %eax,%eax
   13d83:	75 e5                	jne    13d6a <net_ipv6_send_rs+0x9d>
	    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {
   13d85:	6a 04                	push   $0x4
   13d87:	6a 00                	push   $0x0
   13d89:	53                   	push   %ebx
   13d8a:	e8 70 c5 ff ff       	call   102ff <net_pkt_memset>
   13d8f:	83 c4 0c             	add    $0xc,%esp
   13d92:	89 c7                	mov    %eax,%edi
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
   13d94:	85 c0                	test   %eax,%eax
   13d96:	75 d2                	jne    13d6a <net_ipv6_send_rs+0x9d>
	if (llao_len > 0) {
   13d98:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
   13d9c:	75 27                	jne    13dc5 <net_ipv6_send_rs+0xf8>
	net_pkt_cursor_init(pkt);
   13d9e:	53                   	push   %ebx
   13d9f:	e8 c9 c1 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   13da4:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   13dab:	53                   	push   %ebx
   13dac:	e8 3a e0 ff ff       	call   11deb <net_ipv6_finalize>
   13db1:	59                   	pop    %ecx
   13db2:	5e                   	pop    %esi
	if (net_send_data(pkt) < 0) {
   13db3:	53                   	push   %ebx
   13db4:	e8 94 9a ff ff       	call   d84d <net_send_data>
   13db9:	5a                   	pop    %edx
   13dba:	85 c0                	test   %eax,%eax
   13dbc:	79 26                	jns    13de4 <net_ipv6_send_rs+0x117>
		ret = -EINVAL;
   13dbe:	bf ea ff ff ff       	mov    $0xffffffea,%edi
   13dc3:	eb 18                	jmp    13ddd <net_ipv6_send_rs+0x110>
	return &iface->if_dev->link_addr;
   13dc5:	8b 16                	mov    (%esi),%edx
		if (!set_llao(pkt, net_if_get_link_addr(iface),
   13dc7:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   13dca:	83 c2 10             	add    $0x10,%edx
   13dcd:	89 d8                	mov    %ebx,%eax
   13dcf:	6a 01                	push   $0x1
   13dd1:	e8 c8 e6 ff ff       	call   1249e <set_llao>
   13dd6:	5a                   	pop    %edx
   13dd7:	84 c0                	test   %al,%al
   13dd9:	75 c3                	jne    13d9e <net_ipv6_send_rs+0xd1>
   13ddb:	eb 8d                	jmp    13d6a <net_ipv6_send_rs+0x9d>
	net_pkt_unref(pkt);
   13ddd:	53                   	push   %ebx
   13dde:	e8 1e c0 ff ff       	call   fe01 <net_pkt_unref>
   13de3:	58                   	pop    %eax
}
   13de4:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13de7:	89 f8                	mov    %edi,%eax
   13de9:	5b                   	pop    %ebx
   13dea:	5e                   	pop    %esi
   13deb:	5f                   	pop    %edi
   13dec:	5d                   	pop    %ebp
   13ded:	c3                   	ret    

00013dee <net_ipv6_start_rs>:
	return net_ipv6_send_rs(iface);
   13dee:	e9 da fe ff ff       	jmp    13ccd <net_ipv6_send_rs>

00013df3 <net_ipv6_nbr_init>:
	.handler = handle_ra_input,
};
#endif /* CONFIG_NET_IPV6_ND */

void net_ipv6_nbr_init(void)
{
   13df3:	55                   	push   %ebp
   13df4:	89 e5                	mov    %esp,%ebp
#if defined(CONFIG_NET_IPV6_NBR_CACHE)
	net_icmpv6_register_handler(&ns_input_handler);
   13df6:	68 c0 a6 40 00       	push   $0x40a6c0
   13dfb:	e8 5d d8 ff ff       	call   1165d <net_icmpv6_register_handler>
	net_icmpv6_register_handler(&na_input_handler);
   13e00:	c7 04 24 b4 a6 40 00 	movl   $0x40a6b4,(%esp)
   13e07:	e8 51 d8 ff ff       	call   1165d <net_icmpv6_register_handler>
	k_delayed_work_init(&ipv6_ns_reply_timer, ipv6_ns_reply_timeout);
   13e0c:	c7 04 24 e7 23 01 00 	movl   $0x123e7,(%esp)
   13e13:	68 60 0f 40 00       	push   $0x400f60
   13e18:	e8 88 06 01 00       	call   244a5 <k_delayed_work_init>
   13e1d:	58                   	pop    %eax
   13e1e:	5a                   	pop    %edx
#endif
#if defined(CONFIG_NET_IPV6_ND)
	net_icmpv6_register_handler(&ra_input_handler);
   13e1f:	68 a8 a6 40 00       	push   $0x40a6a8
   13e24:	e8 34 d8 ff ff       	call   1165d <net_icmpv6_register_handler>
	k_delayed_work_init(&ipv6_nd_reachable_timer,
   13e29:	c7 04 24 62 3b 01 00 	movl   $0x13b62,(%esp)
   13e30:	68 80 0f 40 00       	push   $0x400f80
   13e35:	e8 6b 06 01 00       	call   244a5 <k_delayed_work_init>
   13e3a:	59                   	pop    %ecx
   13e3b:	58                   	pop    %eax
			    ipv6_nd_reachable_timeout);
#endif
}
   13e3c:	c9                   	leave  
   13e3d:	c3                   	ret    

00013e3e <net_pkt_write_be16>:
{
   13e3e:	55                   	push   %ebp
	u16_t data_be16 = htons(data);
   13e3f:	86 f2                	xchg   %dh,%dl
{
   13e41:	89 e5                	mov    %esp,%ebp
   13e43:	51                   	push   %ecx
	return net_pkt_write(pkt, &data_be16, sizeof(u16_t));
   13e44:	6a 02                	push   $0x2
	u16_t data_be16 = htons(data);
   13e46:	66 89 55 fe          	mov    %dx,-0x2(%ebp)
	return net_pkt_write(pkt, &data_be16, sizeof(u16_t));
   13e4a:	8d 55 fe             	lea    -0x2(%ebp),%edx
   13e4d:	52                   	push   %edx
   13e4e:	50                   	push   %eax
   13e4f:	e8 c3 c6 ff ff       	call   10517 <net_pkt_write>
   13e54:	83 c4 0c             	add    $0xc,%esp
}
   13e57:	c9                   	leave  
   13e58:	c3                   	ret    

00013e59 <mld_create>:

static int mld_create(struct net_pkt *pkt,
		      const struct in6_addr *addr,
		      u8_t record_type,
		      u16_t num_sources)
{
   13e59:	55                   	push   %ebp
   13e5a:	89 e5                	mov    %esp,%ebp
   13e5c:	57                   	push   %edi
   13e5d:	56                   	push   %esi
   13e5e:	89 d6                	mov    %edx,%esi
   13e60:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
				   struct net_icmpv6_mld_mcast_record);
	struct net_icmpv6_mld_mcast_record *mld;

	mld = (struct net_icmpv6_mld_mcast_record *)
				net_pkt_get_data(pkt, &mld_access);
   13e61:	8d 55 c8             	lea    -0x38(%ebp),%edx
{
   13e64:	83 ec 34             	sub    $0x34,%esp
   13e67:	89 c3                	mov    %eax,%ebx
   13e69:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6c:	89 4d c0             	mov    %ecx,-0x40(%ebp)
				net_pkt_get_data(pkt, &mld_access);
   13e6f:	52                   	push   %edx
{
   13e70:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
   13e73:	8d 45 e0             	lea    -0x20(%ebp),%eax
				net_pkt_get_data(pkt, &mld_access);
   13e76:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
   13e77:	89 45 c8             	mov    %eax,-0x38(%ebp)
   13e7a:	c7 45 cc 14 00 00 00 	movl   $0x14,-0x34(%ebp)
				net_pkt_get_data(pkt, &mld_access);
   13e81:	e8 e1 c6 ff ff       	call   10567 <net_pkt_get_data>
   13e86:	5f                   	pop    %edi
   13e87:	5a                   	pop    %edx
	if (!mld) {
   13e88:	85 c0                	test   %eax,%eax
   13e8a:	74 59                	je     13ee5 <mld_create+0x8c>
		return -ENOBUFS;
	}

	mld->record_type = record_type;
   13e8c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
	mld->aux_data_len = 0;
   13e8f:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	mld->record_type = record_type;
   13e93:	88 08                	mov    %cl,(%eax)
	mld->num_sources = htons(num_sources);

	net_ipaddr_copy(&mld->mcast_address, addr);
   13e95:	8d 7d d0             	lea    -0x30(%ebp),%edi
	mld->num_sources = htons(num_sources);
   13e98:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
   13e9c:	c1 e1 08             	shl    $0x8,%ecx

	if (net_pkt_set_data(pkt, &mld_access)) {
   13e9f:	8d 55 c8             	lea    -0x38(%ebp),%edx
	mld->num_sources = htons(num_sources);
   13ea2:	66 89 48 02          	mov    %cx,0x2(%eax)
	net_ipaddr_copy(&mld->mcast_address, addr);
   13ea6:	b9 04 00 00 00       	mov    $0x4,%ecx
   13eab:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   13ead:	8d 78 04             	lea    0x4(%eax),%edi
   13eb0:	8d 75 d0             	lea    -0x30(%ebp),%esi
   13eb3:	b9 04 00 00 00       	mov    $0x4,%ecx
   13eb8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (net_pkt_set_data(pkt, &mld_access)) {
   13eba:	52                   	push   %edx
   13ebb:	53                   	push   %ebx
   13ebc:	e8 3d c7 ff ff       	call   105fe <net_pkt_set_data>
   13ec1:	5a                   	pop    %edx
   13ec2:	89 c6                	mov    %eax,%esi
   13ec4:	59                   	pop    %ecx
   13ec5:	85 c0                	test   %eax,%eax
   13ec7:	75 1c                	jne    13ee5 <mld_create+0x8c>
		return -ENOBUFS;
	}

	if (num_sources > 0) {
   13ec9:	66 83 7d c4 00       	cmpw   $0x0,-0x3c(%ebp)
   13ece:	74 1a                	je     13eea <mld_create+0x91>
		/* All source addresses, RFC 3810 ch 3 */
		if (net_pkt_write(pkt,
				  net_ipv6_unspecified_address()->s6_addr,
   13ed0:	e8 60 de ff ff       	call   11d35 <net_ipv6_unspecified_address>
		if (net_pkt_write(pkt,
   13ed5:	6a 10                	push   $0x10
   13ed7:	50                   	push   %eax
   13ed8:	53                   	push   %ebx
   13ed9:	e8 39 c6 ff ff       	call   10517 <net_pkt_write>
   13ede:	83 c4 0c             	add    $0xc,%esp
   13ee1:	85 c0                	test   %eax,%eax
   13ee3:	74 05                	je     13eea <mld_create+0x91>
				  sizeof(struct in6_addr))) {
			return -ENOBUFS;
   13ee5:	be c9 ff ff ff       	mov    $0xffffffc9,%esi
		}
	}

	return 0;
}
   13eea:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13eed:	89 f0                	mov    %esi,%eax
   13eef:	5b                   	pop    %ebx
   13ef0:	5e                   	pop    %esi
   13ef1:	5f                   	pop    %edi
   13ef2:	5d                   	pop    %ebp
   13ef3:	c3                   	ret    

00013ef4 <mld_send>:

	return 0;
}

static int mld_send(struct net_pkt *pkt)
{
   13ef4:	55                   	push   %ebp
   13ef5:	89 e5                	mov    %esp,%ebp
   13ef7:	53                   	push   %ebx
	net_pkt_cursor_init(pkt);
   13ef8:	50                   	push   %eax
{
   13ef9:	89 c3                	mov    %eax,%ebx
	net_pkt_cursor_init(pkt);
   13efb:	e8 6d c0 ff ff       	call   ff6d <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
   13f00:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
   13f07:	53                   	push   %ebx
   13f08:	e8 de de ff ff       	call   11deb <net_ipv6_finalize>
   13f0d:	5a                   	pop    %edx
   13f0e:	59                   	pop    %ecx

	if (net_send_data(pkt) < 0) {
   13f0f:	53                   	push   %ebx
   13f10:	e8 38 99 ff ff       	call   d84d <net_send_data>
   13f15:	5a                   	pop    %edx
   13f16:	85 c0                	test   %eax,%eax
   13f18:	79 0c                	jns    13f26 <mld_send+0x32>
		net_stats_update_icmp_drop(net_pkt_iface(pkt));
		net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

		net_pkt_unref(pkt);
   13f1a:	53                   	push   %ebx
   13f1b:	e8 e1 be ff ff       	call   fe01 <net_pkt_unref>
   13f20:	58                   	pop    %eax

		return -1;
   13f21:	83 c8 ff             	or     $0xffffffff,%eax
   13f24:	eb 02                	jmp    13f28 <mld_send+0x34>
	}

	net_stats_update_icmp_sent(net_pkt_iface(pkt));
	net_stats_update_ipv6_mld_sent(net_pkt_iface(pkt));

	return 0;
   13f26:	31 c0                	xor    %eax,%eax
}
   13f28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   13f2b:	c9                   	leave  
   13f2c:	c3                   	ret    

00013f2d <mld_create_packet>:
{
   13f2d:	55                   	push   %ebp
   13f2e:	89 e5                	mov    %esp,%ebp
   13f30:	57                   	push   %edi
   13f31:	56                   	push   %esi
   13f32:	89 d6                	mov    %edx,%esi
   13f34:	53                   	push   %ebx
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
   13f35:	8d 7d e4             	lea    -0x1c(%ebp),%edi
{
   13f38:	83 ec 14             	sub    $0x14,%esp
	pkt->ipv6_hop_limit = hop_limit;
   13f3b:	c6 40 41 01          	movb   $0x1,0x41(%eax)
   13f3f:	89 c3                	mov    %eax,%ebx
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
   13f41:	c7 45 e4 ff 02 00 00 	movl   $0x2ff,-0x1c(%ebp)
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
   13f48:	57                   	push   %edi
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
   13f49:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   13f50:	ff 70 24             	pushl  0x24(%eax)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
   13f53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
   13f5a:	c7 45 f0 00 00 00 16 	movl   $0x16000000,-0x10(%ebp)
   13f61:	e8 25 b2 ff ff       	call   f18b <net_if_ipv6_select_src_addr>
   13f66:	5a                   	pop    %edx
   13f67:	59                   	pop    %ecx
   13f68:	57                   	push   %edi
   13f69:	50                   	push   %eax
   13f6a:	53                   	push   %ebx
   13f6b:	e8 cb dd ff ff       	call   11d3b <net_ipv6_create>
   13f70:	83 c4 0c             	add    $0xc,%esp
   13f73:	85 c0                	test   %eax,%eax
   13f75:	74 0a                	je     13f81 <mld_create_packet+0x54>
		return -ENOBUFS;
   13f77:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
   13f7c:	e9 96 00 00 00       	jmp    14017 <mld_create_packet+0xea>
	return net_pkt_write(pkt, &data, sizeof(u8_t));
   13f81:	6a 01                	push   $0x1
   13f83:	8d 7d e3             	lea    -0x1d(%ebp),%edi
   13f86:	57                   	push   %edi
   13f87:	c6 45 e3 3a          	movb   $0x3a,-0x1d(%ebp)
   13f8b:	53                   	push   %ebx
   13f8c:	e8 86 c5 ff ff       	call   10517 <net_pkt_write>
   13f91:	83 c4 0c             	add    $0xc,%esp
	if (net_pkt_write_u8(pkt, IPPROTO_ICMPV6) ||
   13f94:	85 c0                	test   %eax,%eax
   13f96:	75 df                	jne    13f77 <mld_create_packet+0x4a>
   13f98:	6a 01                	push   $0x1
   13f9a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
   13f9e:	57                   	push   %edi
   13f9f:	53                   	push   %ebx
   13fa0:	e8 72 c5 ff ff       	call   10517 <net_pkt_write>
   13fa5:	83 c4 0c             	add    $0xc,%esp
   13fa8:	85 c0                	test   %eax,%eax
   13faa:	75 cb                	jne    13f77 <mld_create_packet+0x4a>
	if (net_pkt_write_be16(pkt, 0x0502) ||
   13fac:	ba 02 05 00 00       	mov    $0x502,%edx
   13fb1:	89 d8                	mov    %ebx,%eax
   13fb3:	e8 86 fe ff ff       	call   13e3e <net_pkt_write_be16>
   13fb8:	85 c0                	test   %eax,%eax
   13fba:	75 bb                	jne    13f77 <mld_create_packet+0x4a>
	    net_pkt_write_be16(pkt, 0) ||
   13fbc:	31 d2                	xor    %edx,%edx
   13fbe:	89 d8                	mov    %ebx,%eax
   13fc0:	e8 79 fe ff ff       	call   13e3e <net_pkt_write_be16>
	if (net_pkt_write_be16(pkt, 0x0502) ||
   13fc5:	85 c0                	test   %eax,%eax
   13fc7:	75 ae                	jne    13f77 <mld_create_packet+0x4a>
	    net_pkt_write_be16(pkt, 0)) {
   13fc9:	31 d2                	xor    %edx,%edx
   13fcb:	89 d8                	mov    %ebx,%eax
   13fcd:	e8 6c fe ff ff       	call   13e3e <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
   13fd2:	85 c0                	test   %eax,%eax
   13fd4:	75 a1                	jne    13f77 <mld_create_packet+0x4a>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
   13fd6:	6a 00                	push   $0x0
	pkt->ipv6_ext_len = len;
   13fd8:	66 c7 43 42 08 00    	movw   $0x8,0x42(%ebx)
   13fde:	68 8f 00 00 00       	push   $0x8f
   13fe3:	53                   	push   %ebx
   13fe4:	e8 36 d7 ff ff       	call   1171f <net_icmpv6_create>
   13fe9:	83 c4 0c             	add    $0xc,%esp
   13fec:	85 c0                	test   %eax,%eax
   13fee:	75 87                	jne    13f77 <mld_create_packet+0x4a>
	    net_pkt_write_be16(pkt, 0) ||
   13ff0:	31 d2                	xor    %edx,%edx
   13ff2:	89 d8                	mov    %ebx,%eax
   13ff4:	e8 45 fe ff ff       	call   13e3e <net_pkt_write_be16>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
   13ff9:	85 c0                	test   %eax,%eax
   13ffb:	0f 85 76 ff ff ff    	jne    13f77 <mld_create_packet+0x4a>
	    net_pkt_write_be16(pkt, count)) {
   14001:	0f b7 d6             	movzwl %si,%edx
   14004:	89 d8                	mov    %ebx,%eax
   14006:	e8 33 fe ff ff       	call   13e3e <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
   1400b:	85 c0                	test   %eax,%eax
   1400d:	0f 85 64 ff ff ff    	jne    13f77 <mld_create_packet+0x4a>
	pkt->ipv6_next_hdr = next_hdr;
   14013:	c6 43 47 00          	movb   $0x0,0x47(%ebx)
}
   14017:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1401a:	5b                   	pop    %ebx
   1401b:	5e                   	pop    %esi
   1401c:	5f                   	pop    %edi
   1401d:	5d                   	pop    %ebp
   1401e:	c3                   	ret    

0001401f <mld_send_generic>:

static int mld_send_generic(struct net_if *iface,
			    const struct in6_addr *addr,
			    u8_t mode)
{
   1401f:	55                   	push   %ebp
   14020:	89 e5                	mov    %esp,%ebp
   14022:	57                   	push   %edi
   14023:	56                   	push   %esi
   14024:	89 d7                	mov    %edx,%edi
   14026:	53                   	push   %ebx
   14027:	89 ce                	mov    %ecx,%esi
   14029:	53                   	push   %ebx
	struct net_pkt *pkt;
	int ret;

	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
   1402a:	6a 32                	push   $0x32
   1402c:	6a 3a                	push   $0x3a
   1402e:	6a 02                	push   $0x2
   14030:	6a 30                	push   $0x30
   14032:	50                   	push   %eax
   14033:	e8 7d c2 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   14038:	83 c4 14             	add    $0x14,%esp
					NET_ICMPV6_UNUSED_LEN +
					MLDv2_MCAST_RECORD_LEN +
					sizeof(struct in6_addr),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
   1403b:	85 c0                	test   %eax,%eax
   1403d:	74 46                	je     14085 <mld_send_generic+0x66>
		return -ENOMEM;
	}

	if (mld_create_packet(pkt, 1) ||
   1403f:	ba 01 00 00 00       	mov    $0x1,%edx
   14044:	89 c3                	mov    %eax,%ebx
   14046:	e8 e2 fe ff ff       	call   13f2d <mld_create_packet>
   1404b:	85 c0                	test   %eax,%eax
   1404d:	74 07                	je     14056 <mld_send_generic+0x37>
	    mld_create(pkt, addr, mode, 1)) {
		ret = -ENOBUFS;
   1404f:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
   14054:	eb 20                	jmp    14076 <mld_send_generic+0x57>
	    mld_create(pkt, addr, mode, 1)) {
   14056:	89 f0                	mov    %esi,%eax
   14058:	89 fa                	mov    %edi,%edx
   1405a:	0f b6 c8             	movzbl %al,%ecx
   1405d:	89 d8                	mov    %ebx,%eax
   1405f:	6a 01                	push   $0x1
   14061:	e8 f3 fd ff ff       	call   13e59 <mld_create>
   14066:	5a                   	pop    %edx
	if (mld_create_packet(pkt, 1) ||
   14067:	85 c0                	test   %eax,%eax
   14069:	75 e4                	jne    1404f <mld_send_generic+0x30>
		goto drop;
	}

	ret = mld_send(pkt);
   1406b:	89 d8                	mov    %ebx,%eax
   1406d:	e8 82 fe ff ff       	call   13ef4 <mld_send>
	if (ret) {
   14072:	85 c0                	test   %eax,%eax
   14074:	74 14                	je     1408a <mld_send_generic+0x6b>
	}

	return 0;

drop:
	net_pkt_unref(pkt);
   14076:	53                   	push   %ebx
   14077:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1407a:	e8 82 bd ff ff       	call   fe01 <net_pkt_unref>
   1407f:	58                   	pop    %eax

	return ret;
   14080:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14083:	eb 05                	jmp    1408a <mld_send_generic+0x6b>
		return -ENOMEM;
   14085:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
   1408a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1408d:	5b                   	pop    %ebx
   1408e:	5e                   	pop    %esi
   1408f:	5f                   	pop    %edi
   14090:	5d                   	pop    %ebp
   14091:	c3                   	ret    

00014092 <handle_mld_query>:
	dbg_addr("Received", pkt_str, src, dst)

static enum net_verdict handle_mld_query(struct net_pkt *pkt,
					 struct net_ipv6_hdr *ip_hdr,
					 struct net_icmp_hdr *icmp_hdr)
{
   14092:	55                   	push   %ebp
   14093:	89 e5                	mov    %esp,%ebp
   14095:	57                   	push   %edi
   14096:	56                   	push   %esi
	size_t bytes = 0;
   14097:	31 ff                	xor    %edi,%edi
   14099:	53                   	push   %ebx
   1409a:	83 ec 0c             	sub    $0xc,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
   1409d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
   140a4:	8b 75 08             	mov    0x8(%ebp),%esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
   140a7:	c7 45 f0 18 00 00 00 	movl   $0x18,-0x10(%ebp)
					      struct net_icmpv6_mld_query);
	u16_t length = net_pkt_get_len(pkt);
   140ae:	8b 46 14             	mov    0x14(%esi),%eax
	while (buf) {
   140b1:	85 c0                	test   %eax,%eax
   140b3:	74 0a                	je     140bf <handle_mld_query+0x2d>
		bytes += buf->len;
   140b5:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
   140b9:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
   140bb:	01 d7                	add    %edx,%edi
		buf = buf->frags;
   140bd:	eb f2                	jmp    140b1 <handle_mld_query+0x1f>
	struct net_icmpv6_mld_query *mld_query;
	u16_t pkt_len;

	mld_query = (struct net_icmpv6_mld_query *)
				net_pkt_get_data(pkt, &mld_access);
   140bf:	8d 45 ec             	lea    -0x14(%ebp),%eax
   140c2:	50                   	push   %eax
   140c3:	56                   	push   %esi
   140c4:	e8 9e c4 ff ff       	call   10567 <net_pkt_get_data>
   140c9:	59                   	pop    %ecx
	if (!mld_query) {
   140ca:	85 c0                	test   %eax,%eax
				net_pkt_get_data(pkt, &mld_access);
   140cc:	5b                   	pop    %ebx
   140cd:	89 c3                	mov    %eax,%ebx
	if (!mld_query) {
   140cf:	75 0a                	jne    140db <handle_mld_query+0x49>
	return NET_OK;

drop:
	net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

	return NET_DROP;
   140d1:	b8 02 00 00 00       	mov    $0x2,%eax
   140d6:	e9 1c 01 00 00       	jmp    141f7 <handle_mld_query+0x165>
	return net_pkt_skip(pkt, access->size);
   140db:	ff 75 f0             	pushl  -0x10(%ebp)
   140de:	56                   	push   %esi
   140df:	e8 fc c1 ff ff       	call   102e0 <net_pkt_skip>
   140e4:	58                   	pop    %eax
	mld_query->num_sources = ntohs(mld_query->num_sources);
   140e5:	66 8b 43 16          	mov    0x16(%ebx),%ax
   140e9:	86 e0                	xchg   %ah,%al
   140eb:	5a                   	pop    %edx
   140ec:	66 89 43 16          	mov    %ax,0x16(%ebx)
		sizeof(struct in6_addr) * mld_query->num_sources;
   140f0:	c1 e0 04             	shl    $0x4,%eax
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
   140f3:	66 8b 56 42          	mov    0x42(%esi),%dx
   140f7:	8d 44 02 44          	lea    0x44(%edx,%eax,1),%eax
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
   140fb:	66 39 f8             	cmp    %di,%ax
   140fe:	77 d1                	ja     140d1 <handle_mld_query+0x3f>
   14100:	66 3d 00 05          	cmp    $0x500,%ax
   14104:	77 cb                	ja     140d1 <handle_mld_query+0x3f>
   14106:	8b 45 0c             	mov    0xc(%ebp),%eax
   14109:	80 78 07 01          	cmpb   $0x1,0x7(%eax)
   1410d:	75 c2                	jne    140d1 <handle_mld_query+0x3f>
	    ip_hdr->hop_limit != 1 || icmp_hdr->code != 0) {
   1410f:	8b 45 10             	mov    0x10(%ebp),%eax
   14112:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
   14116:	75 b9                	jne    140d1 <handle_mld_query+0x3f>
	if (!net_ipv6_addr_cmp(&mld_query->mcast_address,
   14118:	e8 18 dc ff ff       	call   11d35 <net_ipv6_unspecified_address>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
   1411d:	6a 10                	push   $0x10
   1411f:	50                   	push   %eax
   14120:	83 c3 04             	add    $0x4,%ebx
   14123:	53                   	push   %ebx
   14124:	e8 9d 67 ff ff       	call   a8c6 <memcmp>
   14129:	83 c4 0c             	add    $0xc,%esp
   1412c:	89 c2                	mov    %eax,%edx
   1412e:	85 c0                	test   %eax,%eax
   14130:	75 9f                	jne    140d1 <handle_mld_query+0x3f>
	send_mld_report(net_pkt_iface(pkt));
   14132:	8b 4e 24             	mov    0x24(%esi),%ecx
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
   14135:	8b 59 04             	mov    0x4(%ecx),%ebx
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
   14138:	8a 83 ec 00 00 00    	mov    0xec(%ebx),%al
   1413e:	a8 01                	test   $0x1,%al
   14140:	74 07                	je     14149 <handle_mld_query+0xb7>
   14142:	d0 e8                	shr    %al
   14144:	88 c2                	mov    %al,%dl
	int i, count = 0;
   14146:	83 e2 01             	and    $0x1,%edx
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
   14149:	8a 83 04 01 00 00    	mov    0x104(%ebx),%al
   1414f:	a8 01                	test   $0x1,%al
   14151:	74 0a                	je     1415d <handle_mld_query+0xcb>
   14153:	d0 e8                	shr    %al
   14155:	83 e0 01             	and    $0x1,%eax
		count++;
   14158:	3c 01                	cmp    $0x1,%al
   1415a:	83 da ff             	sbb    $0xffffffff,%edx
					count * MLDv2_MCAST_RECORD_LEN,
   1415d:	6b c2 14             	imul   $0x14,%edx,%eax
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
   14160:	6a 32                	push   $0x32
   14162:	83 c0 0c             	add    $0xc,%eax
   14165:	6a 3a                	push   $0x3a
					count * MLDv2_MCAST_RECORD_LEN,
   14167:	89 55 e8             	mov    %edx,-0x18(%ebp)
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
   1416a:	6a 02                	push   $0x2
   1416c:	50                   	push   %eax
   1416d:	51                   	push   %ecx
   1416e:	e8 42 c1 ff ff       	call   102b5 <net_pkt_alloc_with_buffer>
   14173:	83 c4 14             	add    $0x14,%esp
   14176:	89 c7                	mov    %eax,%edi
	if (!pkt) {
   14178:	85 c0                	test   %eax,%eax
   1417a:	74 72                	je     141ee <handle_mld_query+0x15c>
	if (mld_create_packet(pkt, count)) {
   1417c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1417f:	e8 a9 fd ff ff       	call   13f2d <mld_create_packet>
   14184:	85 c0                	test   %eax,%eax
   14186:	74 09                	je     14191 <handle_mld_query+0xff>
	net_pkt_unref(pkt);
   14188:	57                   	push   %edi
   14189:	e8 73 bc ff ff       	call   fe01 <net_pkt_unref>
   1418e:	5b                   	pop    %ebx
   1418f:	eb 5d                	jmp    141ee <handle_mld_query+0x15c>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
   14191:	8a 83 ec 00 00 00    	mov    0xec(%ebx),%al
   14197:	a8 01                	test   $0x1,%al
   14199:	74 1d                	je     141b8 <handle_mld_query+0x126>
   1419b:	a8 02                	test   $0x2,%al
   1419d:	74 19                	je     141b8 <handle_mld_query+0x126>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
   1419f:	b9 02 00 00 00       	mov    $0x2,%ecx
   141a4:	8d 93 dc 00 00 00    	lea    0xdc(%ebx),%edx
   141aa:	89 f8                	mov    %edi,%eax
   141ac:	6a 00                	push   $0x0
   141ae:	e8 a6 fc ff ff       	call   13e59 <mld_create>
   141b3:	59                   	pop    %ecx
   141b4:	85 c0                	test   %eax,%eax
   141b6:	74 d0                	je     14188 <handle_mld_query+0xf6>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
   141b8:	8a 83 04 01 00 00    	mov    0x104(%ebx),%al
   141be:	a8 01                	test   $0x1,%al
   141c0:	75 0d                	jne    141cf <handle_mld_query+0x13d>
	if (!mld_send(pkt)) {
   141c2:	89 f8                	mov    %edi,%eax
   141c4:	e8 2b fd ff ff       	call   13ef4 <mld_send>
   141c9:	85 c0                	test   %eax,%eax
   141cb:	75 bb                	jne    14188 <handle_mld_query+0xf6>
   141cd:	eb 1f                	jmp    141ee <handle_mld_query+0x15c>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
   141cf:	a8 02                	test   $0x2,%al
   141d1:	74 ef                	je     141c2 <handle_mld_query+0x130>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
   141d3:	8d 93 f4 00 00 00    	lea    0xf4(%ebx),%edx
   141d9:	b9 02 00 00 00       	mov    $0x2,%ecx
   141de:	89 f8                	mov    %edi,%eax
   141e0:	6a 00                	push   $0x0
   141e2:	e8 72 fc ff ff       	call   13e59 <mld_create>
   141e7:	5a                   	pop    %edx
   141e8:	85 c0                	test   %eax,%eax
   141ea:	75 d6                	jne    141c2 <handle_mld_query+0x130>
   141ec:	eb 9a                	jmp    14188 <handle_mld_query+0xf6>
	net_pkt_unref(pkt);
   141ee:	56                   	push   %esi
   141ef:	e8 0d bc ff ff       	call   fe01 <net_pkt_unref>
   141f4:	58                   	pop    %eax
	return NET_OK;
   141f5:	31 c0                	xor    %eax,%eax
}
   141f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   141fa:	5b                   	pop    %ebx
   141fb:	5e                   	pop    %esi
   141fc:	5f                   	pop    %edi
   141fd:	5d                   	pop    %ebp
   141fe:	c3                   	ret    

000141ff <net_ipv6_mld_join>:
{
   141ff:	55                   	push   %ebp
   14200:	89 e5                	mov    %esp,%ebp
   14202:	56                   	push   %esi
   14203:	53                   	push   %ebx
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
   14204:	8d 45 08             	lea    0x8(%ebp),%eax
{
   14207:	53                   	push   %ebx
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
   14208:	50                   	push   %eax
{
   14209:	8b 75 0c             	mov    0xc(%ebp),%esi
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
   1420c:	56                   	push   %esi
   1420d:	e8 bd a7 ff ff       	call   e9cf <net_if_ipv6_maddr_lookup>
   14212:	5a                   	pop    %edx
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
   14213:	85 c0                	test   %eax,%eax
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
   14215:	59                   	pop    %ecx
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
   14216:	74 0f                	je     14227 <net_ipv6_mld_join+0x28>
   14218:	89 c3                	mov    %eax,%ebx
		return -EALREADY;
   1421a:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
   1421f:	f6 43 14 02          	testb  $0x2,0x14(%ebx)
   14223:	74 18                	je     1423d <net_ipv6_mld_join+0x3e>
   14225:	eb 55                	jmp    1427c <net_ipv6_mld_join+0x7d>
		maddr = net_if_ipv6_maddr_add(iface, addr);
   14227:	56                   	push   %esi
   14228:	ff 75 08             	pushl  0x8(%ebp)
   1422b:	e8 dd a3 ff ff       	call   e60d <net_if_ipv6_maddr_add>
   14230:	5a                   	pop    %edx
   14231:	89 c3                	mov    %eax,%ebx
   14233:	59                   	pop    %ecx
			return -ENOMEM;
   14234:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (!maddr) {
   14239:	85 db                	test   %ebx,%ebx
   1423b:	74 3f                	je     1427c <net_ipv6_mld_join+0x7d>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_EXCLUDE);
   1423d:	b9 02 00 00 00       	mov    $0x2,%ecx
   14242:	89 f2                	mov    %esi,%edx
   14244:	8b 45 08             	mov    0x8(%ebp),%eax
   14247:	e8 d3 fd ff ff       	call   1401f <mld_send_generic>
	if (ret < 0) {
   1424c:	85 c0                	test   %eax,%eax
   1424e:	78 2c                	js     1427c <net_ipv6_mld_join+0x7d>
	addr->is_joined = true;
   14250:	80 4b 14 02          	orb    $0x2,0x14(%ebx)
	net_if_mcast_monitor(iface, addr, true);
   14254:	6a 01                	push   $0x1
   14256:	89 45 f4             	mov    %eax,-0xc(%ebp)
   14259:	56                   	push   %esi
   1425a:	ff 75 08             	pushl  0x8(%ebp)
   1425d:	e8 14 a8 ff ff       	call   ea76 <net_if_mcast_monitor>
   14262:	83 c4 0c             	add    $0xc,%esp
   14265:	6a 00                	push   $0x0
   14267:	6a 00                	push   $0x0
   14269:	ff 75 08             	pushl  0x8(%ebp)
   1426c:	68 07 00 60 f0       	push   $0xf0600007
   14271:	e8 4d 02 00 00       	call   144c3 <net_mgmt_event_notify_with_info>
   14276:	83 c4 10             	add    $0x10,%esp
   14279:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1427c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1427f:	5b                   	pop    %ebx
   14280:	5e                   	pop    %esi
   14281:	5d                   	pop    %ebp
   14282:	c3                   	ret    

00014283 <net_ipv6_mld_leave>:
{
   14283:	55                   	push   %ebp
   14284:	89 e5                	mov    %esp,%ebp
   14286:	57                   	push   %edi
   14287:	56                   	push   %esi
		return -EINVAL;
   14288:	be ea ff ff ff       	mov    $0xffffffea,%esi
{
   1428d:	53                   	push   %ebx
   1428e:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
   14291:	57                   	push   %edi
{
   14292:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
   14295:	53                   	push   %ebx
   14296:	e8 fd a3 ff ff       	call   e698 <net_if_ipv6_maddr_rm>
   1429b:	5a                   	pop    %edx
   1429c:	84 c0                	test   %al,%al
   1429e:	59                   	pop    %ecx
   1429f:	74 32                	je     142d3 <net_ipv6_mld_leave+0x50>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_INCLUDE);
   142a1:	b9 01 00 00 00       	mov    $0x1,%ecx
   142a6:	89 fa                	mov    %edi,%edx
   142a8:	89 d8                	mov    %ebx,%eax
   142aa:	e8 70 fd ff ff       	call   1401f <mld_send_generic>
   142af:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   142b1:	85 c0                	test   %eax,%eax
   142b3:	78 1e                	js     142d3 <net_ipv6_mld_leave+0x50>
	net_if_mcast_monitor(iface, addr, false);
   142b5:	6a 00                	push   $0x0
   142b7:	57                   	push   %edi
   142b8:	53                   	push   %ebx
   142b9:	e8 b8 a7 ff ff       	call   ea76 <net_if_mcast_monitor>
   142be:	83 c4 0c             	add    $0xc,%esp
   142c1:	6a 00                	push   $0x0
   142c3:	6a 00                	push   $0x0
   142c5:	53                   	push   %ebx
   142c6:	68 08 00 60 f0       	push   $0xf0600008
   142cb:	e8 f3 01 00 00       	call   144c3 <net_mgmt_event_notify_with_info>
   142d0:	83 c4 10             	add    $0x10,%esp
}
   142d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
   142d6:	89 f0                	mov    %esi,%eax
   142d8:	5b                   	pop    %ebx
   142d9:	5e                   	pop    %esi
   142da:	5f                   	pop    %edi
   142db:	5d                   	pop    %ebp
   142dc:	c3                   	ret    

000142dd <net_ipv6_mld_init>:
	.code = 0,
	.handler = handle_mld_query,
};

void net_ipv6_mld_init(void)
{
   142dd:	55                   	push   %ebp
   142de:	89 e5                	mov    %esp,%ebp
	net_icmpv6_register_handler(&mld_query_input_handler);
   142e0:	68 d8 a6 40 00       	push   $0x40a6d8
   142e5:	e8 73 d3 ff ff       	call   1165d <net_icmpv6_register_handler>
   142ea:	58                   	pop    %eax
}
   142eb:	c9                   	leave  
   142ec:	c3                   	ret    

000142ed <mgmt_thread>:
			  K_THREAD_STACK_SIZEOF(mgmt_stack));
#endif
}

static void mgmt_thread(void)
{
   142ed:	55                   	push   %ebp
   142ee:	89 e5                	mov    %esp,%ebp
   142f0:	57                   	push   %edi
   142f1:	56                   	push   %esi
   142f2:	53                   	push   %ebx
   142f3:	83 ec 08             	sub    $0x8,%esp
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   142f6:	6a ff                	push   $0xffffffff
   142f8:	68 a0 a9 40 00       	push   $0x40a9a0
   142fd:	e8 40 fd 00 00       	call   24042 <z_impl_k_sem_take>
   14302:	5b                   	pop    %ebx
   14303:	5e                   	pop    %esi
   14304:	6a ff                	push   $0xffffffff
   14306:	68 80 a9 40 00       	push   $0x40a980
   1430b:	e8 32 fd 00 00       	call   24042 <z_impl_k_sem_take>
   14310:	5f                   	pop    %edi
   14311:	58                   	pop    %eax
	if (out_event < 0 || !events[out_event].event) {
   14312:	66 a1 4c 45 40 00    	mov    0x40454c,%ax
   14318:	66 85 c0             	test   %ax,%ax
   1431b:	78 78                	js     14395 <mgmt_thread+0xa8>
   1431d:	0f bf f0             	movswl %ax,%esi
   14320:	83 3c f5 ec 42 40 00 	cmpl   $0x0,0x4042ec(,%esi,8)
   14327:	00 
   14328:	74 6b                	je     14395 <mgmt_thread+0xa8>
	if (o_idx == in_event) {
   1432a:	66 3b 05 4e 45 40 00 	cmp    0x40454e,%ax
	out_event++;
   14331:	8d 50 01             	lea    0x1(%eax),%edx
   14334:	66 89 15 4c 45 40 00 	mov    %dx,0x40454c
	if (o_idx == in_event) {
   1433b:	75 14                	jne    14351 <mgmt_thread+0x64>
		in_event = -1;
   1433d:	66 c7 05 4e 45 40 00 	movw   $0xffff,0x40454e
   14344:	ff ff 
		out_event = -1;
   14346:	66 c7 05 4c 45 40 00 	movw   $0xffff,0x40454c
   1434d:	ff ff 
   1434f:	eb 0f                	jmp    14360 <mgmt_thread+0x73>
	} else if (out_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
   14351:	66 83 fa 02          	cmp    $0x2,%dx
   14355:	75 09                	jne    14360 <mgmt_thread+0x73>
		out_event = 0;
   14357:	66 c7 05 4c 45 40 00 	movw   $0x0,0x40454c
   1435e:	00 00 
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
   14360:	8b 1d e0 42 40 00    	mov    0x4042e0,%ebx
   14366:	85 db                	test   %ebx,%ebx
   14368:	75 4c                	jne    143b6 <mgmt_thread+0xc9>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   1436a:	68 80 a9 40 00       	push   $0x40a980
	mgmt_event->event = 0U;
   1436f:	c7 04 f5 ec 42 40 00 	movl   $0x0,0x4042ec(,%esi,8)
   14376:	00 00 00 00 
	mgmt_event->iface = NULL;
   1437a:	c7 04 f5 f0 42 40 00 	movl   $0x0,0x4042f0(,%esi,8)
   14381:	00 00 00 00 
   14385:	e8 4f fc 00 00       	call   23fd9 <z_impl_k_sem_give>
   1438a:	59                   	pop    %ecx
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
   1438b:	e8 b2 fa 00 00       	call   23e42 <z_impl_k_yield>
   14390:	e9 61 ff ff ff       	jmp    142f6 <mgmt_thread+0x9>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
   14395:	6a ff                	push   $0xffffffff
   14397:	6a 00                	push   $0x0
   14399:	68 a0 a9 40 00       	push   $0x40a9a0
   1439e:	e8 05 fc 00 00       	call   23fa8 <z_impl_k_sem_init>
   143a3:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   143a6:	68 80 a9 40 00       	push   $0x40a980
   143ab:	e8 29 fc 00 00       	call   23fd9 <z_impl_k_sem_give>
   143b0:	5a                   	pop    %edx
				k_sem_count_get(&network_event));

			k_sem_init(&network_event, 0, UINT_MAX);
			k_sem_give(&net_mgmt_lock);

			continue;
   143b1:	e9 40 ff ff ff       	jmp    142f6 <mgmt_thread+0x9>
   143b6:	8b 03                	mov    (%ebx),%eax
   143b8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   143bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
   143c2:	8b 53 08             	mov    0x8(%ebx),%edx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
   143c5:	8b 04 f5 ec 42 40 00 	mov    0x4042ec(,%esi,8),%eax
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
   143cc:	89 d1                	mov    %edx,%ecx
   143ce:	31 c1                	xor    %eax,%ecx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
   143d0:	c1 e9 1c             	shr    $0x1c,%ecx
   143d3:	83 e1 03             	and    $0x3,%ecx
   143d6:	89 cf                	mov    %ecx,%edi
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
   143d8:	89 d1                	mov    %edx,%ecx
   143da:	31 c1                	xor    %eax,%ecx
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
   143dc:	c1 e9 10             	shr    $0x10,%ecx
   143df:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
   143e5:	09 cf                	or     %ecx,%edi
   143e7:	75 79                	jne    14462 <mgmt_thread+0x175>
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
   143e9:	66 85 c0             	test   %ax,%ax
   143ec:	74 0e                	je     143fc <mgmt_thread+0x10f>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
   143ee:	66 85 d2             	test   %dx,%dx
   143f1:	74 09                	je     143fc <mgmt_thread+0x10f>
		     !(NET_MGMT_GET_COMMAND(mgmt_event->event) &
   143f3:	89 c1                	mov    %eax,%ecx
   143f5:	21 d1                	and    %edx,%ecx
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
   143f7:	66 85 c9             	test   %cx,%cx
   143fa:	74 66                	je     14462 <mgmt_thread+0x175>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
   143fc:	8b 4b 04             	mov    0x4(%ebx),%ecx
   143ff:	8b 3c f5 f0 42 40 00 	mov    0x4042f0(,%esi,8),%edi
   14406:	0f ba e2 1b          	bt     $0x1b,%edx
   1440a:	73 4b                	jae    14457 <mgmt_thread+0x16a>
			if (sync_data->iface &&
   1440c:	8b 51 20             	mov    0x20(%ecx),%edx
   1440f:	85 d2                	test   %edx,%edx
   14411:	74 04                	je     14417 <mgmt_thread+0x12a>
   14413:	39 fa                	cmp    %edi,%edx
   14415:	75 4b                	jne    14462 <mgmt_thread+0x175>
			cb->raised_event = mgmt_event->event;
   14417:	89 43 08             	mov    %eax,0x8(%ebx)
			sync_data->iface = mgmt_event->iface;
   1441a:	89 79 20             	mov    %edi,0x20(%ecx)
Z_GENLIST_REMOVE(slist, snode)
   1441d:	8b 03                	mov    (%ebx),%eax
   1441f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14423:	75 0f                	jne    14434 <mgmt_thread+0x147>
	list->head = node;
   14425:	a3 e0 42 40 00       	mov    %eax,0x4042e0
Z_GENLIST_REMOVE(slist, snode)
   1442a:	3b 1d e4 42 40 00    	cmp    0x4042e4,%ebx
   14430:	75 16                	jne    14448 <mgmt_thread+0x15b>
   14432:	eb 0f                	jmp    14443 <mgmt_thread+0x156>
	parent->next = child;
   14434:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14437:	89 02                	mov    %eax,(%edx)
Z_GENLIST_REMOVE(slist, snode)
   14439:	3b 1d e4 42 40 00    	cmp    0x4042e4,%ebx
   1443f:	75 07                	jne    14448 <mgmt_thread+0x15b>
	list->tail = node;
   14441:	89 d0                	mov    %edx,%eax
   14443:	a3 e4 42 40 00       	mov    %eax,0x4042e4
	parent->next = child;
   14448:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   1444e:	51                   	push   %ecx
   1444f:	e8 85 fb 00 00       	call   23fd9 <z_impl_k_sem_give>
   14454:	58                   	pop    %eax
   14455:	eb 0b                	jmp    14462 <mgmt_thread+0x175>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
   14457:	57                   	push   %edi
   14458:	50                   	push   %eax
   14459:	53                   	push   %ebx
   1445a:	ff d1                	call   *%ecx
   1445c:	83 c4 0c             	add    $0xc,%esp
			prev = &cb->node;
   1445f:	89 5d ec             	mov    %ebx,-0x14(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
   14462:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14466:	0f 84 fe fe ff ff    	je     1436a <mgmt_thread+0x7d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1446c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1446f:	8b 03                	mov    (%ebx),%eax
   14471:	89 45 f0             	mov    %eax,-0x10(%ebp)
   14474:	e9 49 ff ff ff       	jmp    143c2 <mgmt_thread+0xd5>

00014479 <net_mgmt_add_event_callback>:

	return ret;
}

void net_mgmt_add_event_callback(struct net_mgmt_event_callback *cb)
{
   14479:	55                   	push   %ebp
   1447a:	89 e5                	mov    %esp,%ebp
   1447c:	53                   	push   %ebx
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   1447d:	6a ff                	push   $0xffffffff
   1447f:	8b 5d 08             	mov    0x8(%ebp),%ebx
   14482:	68 80 a9 40 00       	push   $0x40a980
   14487:	e8 b6 fb 00 00       	call   24042 <z_impl_k_sem_take>
   1448c:	58                   	pop    %eax
Z_GENLIST_PREPEND(slist, snode)
   1448d:	a1 e0 42 40 00       	mov    0x4042e0,%eax
   14492:	5a                   	pop    %edx
	parent->next = child;
   14493:	89 03                	mov    %eax,(%ebx)
	list->head = node;
   14495:	89 1d e0 42 40 00    	mov    %ebx,0x4042e0
Z_GENLIST_PREPEND(slist, snode)
   1449b:	83 3d e4 42 40 00 00 	cmpl   $0x0,0x4042e4
   144a2:	75 06                	jne    144aa <net_mgmt_add_event_callback+0x31>
	list->tail = node;
   144a4:	89 1d e4 42 40 00    	mov    %ebx,0x4042e4
	global_event_mask |= event_mask;
   144aa:	8b 43 08             	mov    0x8(%ebx),%eax
	sys_slist_prepend(&event_callbacks, &cb->node);

	mgmt_add_event_mask(cb->event_mask);

	k_sem_give(&net_mgmt_lock);
}
   144ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	global_event_mask |= event_mask;
   144b0:	09 05 e8 42 40 00    	or     %eax,0x4042e8
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   144b6:	c7 45 08 80 a9 40 00 	movl   $0x40a980,0x8(%ebp)
}
   144bd:	c9                   	leave  
   144be:	e9 16 fb 00 00       	jmp    23fd9 <z_impl_k_sem_give>

000144c3 <net_mgmt_event_notify_with_info>:
	k_sem_give(&net_mgmt_lock);
}

void net_mgmt_event_notify_with_info(u32_t mgmt_event, struct net_if *iface,
				     void *info, size_t length)
{
   144c3:	55                   	push   %ebp
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144c4:	a1 e8 42 40 00       	mov    0x4042e8,%eax
{
   144c9:	89 e5                	mov    %esp,%ebp
   144cb:	57                   	push   %edi
   144cc:	56                   	push   %esi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144cd:	89 c2                	mov    %eax,%edx
{
   144cf:	53                   	push   %ebx
   144d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144d3:	c1 ea 1c             	shr    $0x1c,%edx
	return (((NET_MGMT_GET_LAYER(mgmt_event) &
   144d6:	89 d9                	mov    %ebx,%ecx
   144d8:	c1 e9 1c             	shr    $0x1c,%ecx
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
   144db:	89 df                	mov    %ebx,%edi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144dd:	f7 d2                	not    %edx
   144df:	21 ca                	and    %ecx,%edx
{
   144e1:	8b 75 0c             	mov    0xc(%ebp),%esi
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
   144e4:	c1 ef 10             	shr    $0x10,%edi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144e7:	89 d1                	mov    %edx,%ecx
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
   144e9:	89 c2                	mov    %eax,%edx
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
   144eb:	83 e1 03             	and    $0x3,%ecx
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
   144ee:	c1 ea 10             	shr    $0x10,%edx
   144f1:	f7 d2                	not    %edx
   144f3:	21 fa                	and    %edi,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
   144f5:	f7 d0                	not    %eax
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
   144f7:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
   144fd:	21 d8                	and    %ebx,%eax
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
   144ff:	09 ca                	or     %ecx,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
   14501:	0f b7 c0             	movzwl %ax,%eax
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
   14504:	09 c2                	or     %eax,%edx
   14506:	0f 85 8a 00 00 00    	jne    14596 <net_mgmt_event_notify_with_info+0xd3>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   1450c:	6a ff                	push   $0xffffffff
   1450e:	68 80 a9 40 00       	push   $0x40a980
   14513:	e8 2a fb 00 00       	call   24042 <z_impl_k_sem_take>
	i_idx = in_event + 1;
   14518:	66 a1 4e 45 40 00    	mov    0x40454e,%ax
   1451e:	5a                   	pop    %edx
   1451f:	40                   	inc    %eax
   14520:	59                   	pop    %ecx
	if (i_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
   14521:	66 83 f8 02          	cmp    $0x2,%ax
   14525:	75 02                	jne    14529 <net_mgmt_event_notify_with_info+0x66>
		i_idx = 0;
   14527:	31 c0                	xor    %eax,%eax
	events[i_idx].event = mgmt_event;
   14529:	0f bf d0             	movswl %ax,%edx
   1452c:	89 1c d5 ec 42 40 00 	mov    %ebx,0x4042ec(,%edx,8)
	events[i_idx].iface = iface;
   14533:	89 34 d5 f0 42 40 00 	mov    %esi,0x4042f0(,%edx,8)
	if (i_idx == out_event) {
   1453a:	66 8b 15 4c 45 40 00 	mov    0x40454c,%dx
   14541:	66 39 d0             	cmp    %dx,%ax
   14544:	75 21                	jne    14567 <net_mgmt_event_notify_with_info+0xa4>
		u16_t o_idx = out_event + 1;
   14546:	8d 50 01             	lea    0x1(%eax),%edx
		if (o_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
   14549:	66 83 fa 02          	cmp    $0x2,%dx
   1454d:	75 02                	jne    14551 <net_mgmt_event_notify_with_info+0x8e>
			o_idx = 0U;
   1454f:	31 d2                	xor    %edx,%edx
		if (events[o_idx].event) {
   14551:	0f b7 ca             	movzwl %dx,%ecx
   14554:	83 3c cd ec 42 40 00 	cmpl   $0x0,0x4042ec(,%ecx,8)
   1455b:	00 
   1455c:	74 14                	je     14572 <net_mgmt_event_notify_with_info+0xaf>
			out_event = o_idx;
   1455e:	66 89 15 4c 45 40 00 	mov    %dx,0x40454c
   14565:	eb 0b                	jmp    14572 <net_mgmt_event_notify_with_info+0xaf>
	} else if (out_event < 0) {
   14567:	66 85 d2             	test   %dx,%dx
   1456a:	79 06                	jns    14572 <net_mgmt_event_notify_with_info+0xaf>
		out_event = i_idx;
   1456c:	66 a3 4c 45 40 00    	mov    %ax,0x40454c
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   14572:	68 80 a9 40 00       	push   $0x40a980
	in_event = i_idx;
   14577:	66 a3 4e 45 40 00    	mov    %ax,0x40454e
   1457d:	e8 57 fa 00 00       	call   23fd9 <z_impl_k_sem_give>
   14582:	c7 45 08 a0 a9 40 00 	movl   $0x40a9a0,0x8(%ebp)
   14589:	58                   	pop    %eax
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface, info, length);
		k_sem_give(&network_event);
	}
}
   1458a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1458d:	5b                   	pop    %ebx
   1458e:	5e                   	pop    %esi
   1458f:	5f                   	pop    %edi
   14590:	5d                   	pop    %ebp
   14591:	e9 43 fa 00 00       	jmp    23fd9 <z_impl_k_sem_give>
   14596:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14599:	5b                   	pop    %ebx
   1459a:	5e                   	pop    %esi
   1459b:	5f                   	pop    %edi
   1459c:	5d                   	pop    %ebp
   1459d:	c3                   	ret    

0001459e <net_mgmt_event_init>:
	return mgmt_event_wait_call(iface, mgmt_event_mask,
				    raised_event, NULL, info, timeout);
}

void net_mgmt_event_init(void)
{
   1459e:	55                   	push   %ebp
	list->head = NULL;
   1459f:	c7 05 e0 42 40 00 00 	movl   $0x0,0x4042e0
   145a6:	00 00 00 
   145a9:	89 e5                	mov    %esp,%ebp
	global_event_mask = 0U;

	in_event = -1;
	out_event = -1;

	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
   145ab:	6a 10                	push   $0x10
   145ad:	6a 00                	push   $0x0
	list->tail = NULL;
   145af:	c7 05 e4 42 40 00 00 	movl   $0x0,0x4042e4
   145b6:	00 00 00 
   145b9:	68 ec 42 40 00       	push   $0x4042ec
	global_event_mask = 0U;
   145be:	c7 05 e8 42 40 00 00 	movl   $0x0,0x4042e8
   145c5:	00 00 00 
	in_event = -1;
   145c8:	66 c7 05 4e 45 40 00 	movw   $0xffff,0x40454e
   145cf:	ff ff 
	out_event = -1;
   145d1:	66 c7 05 4c 45 40 00 	movw   $0xffff,0x40454c
   145d8:	ff ff 
	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
   145da:	e8 c1 63 ff ff       	call   a9a0 <memset>
   145df:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
   145e2:	6a 00                	push   $0x0
   145e4:	6a 00                	push   $0x0
   145e6:	6a f7                	push   $0xfffffff7
   145e8:	6a 00                	push   $0x0
   145ea:	6a 00                	push   $0x0
   145ec:	6a 00                	push   $0x0
   145ee:	68 ed 42 01 00       	push   $0x142ed
   145f3:	68 00 02 00 00       	push   $0x200
   145f8:	68 10 79 40 00       	push   $0x407910
   145fd:	68 a0 0f 40 00       	push   $0x400fa0
   14602:	e8 15 fc 00 00       	call   2421c <z_impl_k_thread_create>
   14607:	83 c4 28             	add    $0x28,%esp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   1460a:	68 9c 7d 02 00       	push   $0x27d9c
   1460f:	68 a0 0f 40 00       	push   $0x400fa0
   14614:	e8 86 fb 00 00       	call   2419f <z_impl_k_thread_name_set>
   14619:	58                   	pop    %eax
   1461a:	5a                   	pop    %edx
	k_thread_name_set(&mgmt_thread_data, "net_mgmt");

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
   1461b:	c9                   	leave  
   1461c:	c3                   	ret    

0001461d <sys_slist_find_and_remove.constprop.11>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1461d:	8b 15 fc 42 40 00    	mov    0x4042fc,%edx
   14623:	31 c9                	xor    %ecx,%ecx
   14625:	85 d2                	test   %edx,%edx
   14627:	74 3f                	je     14668 <sys_slist_find_and_remove.constprop.11+0x4b>
   14629:	39 c2                	cmp    %eax,%edx
   1462b:	75 35                	jne    14662 <sys_slist_find_and_remove.constprop.11+0x45>
Z_GENLIST_REMOVE(slist, snode)
   1462d:	8b 10                	mov    (%eax),%edx
   1462f:	85 c9                	test   %ecx,%ecx
   14631:	75 16                	jne    14649 <sys_slist_find_and_remove.constprop.11+0x2c>
	list->head = node;
   14633:	89 15 fc 42 40 00    	mov    %edx,0x4042fc
Z_GENLIST_REMOVE(slist, snode)
   14639:	3b 05 00 43 40 00    	cmp    0x404300,%eax
   1463f:	75 18                	jne    14659 <sys_slist_find_and_remove.constprop.11+0x3c>
	list->tail = node;
   14641:	89 15 00 43 40 00    	mov    %edx,0x404300
   14647:	eb 10                	jmp    14659 <sys_slist_find_and_remove.constprop.11+0x3c>
	parent->next = child;
   14649:	89 11                	mov    %edx,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
   1464b:	3b 05 00 43 40 00    	cmp    0x404300,%eax
   14651:	75 06                	jne    14659 <sys_slist_find_and_remove.constprop.11+0x3c>
	list->tail = node;
   14653:	89 0d 00 43 40 00    	mov    %ecx,0x404300
	parent->next = child;
   14659:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1465f:	b0 01                	mov    $0x1,%al
   14661:	c3                   	ret    
   14662:	89 d1                	mov    %edx,%ecx
   14664:	8b 12                	mov    (%edx),%edx
   14666:	eb bd                	jmp    14625 <sys_slist_find_and_remove.constprop.11+0x8>
   14668:	31 c0                	xor    %eax,%eax
   1466a:	c3                   	ret    

0001466b <net_route_entry_remove>:
   1466b:	c3                   	ret    

0001466c <net_route_get_nbr>:
{
	return (struct net_route_entry *)nbr->data;
}

struct net_nbr *net_route_get_nbr(struct net_route_entry *route)
{
   1466c:	55                   	push   %ebp
   1466d:	ba 20 a2 40 00       	mov    $0x40a220,%edx
   14672:	89 e5                	mov    %esp,%ebp
	int i;

	NET_ASSERT(route);

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
   14674:	31 c0                	xor    %eax,%eax
{
   14676:	8b 4d 08             	mov    0x8(%ebp),%ecx
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
   14679:	80 3a 00             	cmpb   $0x0,(%edx)
   1467c:	74 05                	je     14683 <net_route_get_nbr+0x17>
			continue;
		}

		if (nbr->data == (u8_t *)route) {
   1467e:	39 4a 0c             	cmp    %ecx,0xc(%edx)
   14681:	74 0d                	je     14690 <net_route_get_nbr+0x24>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
   14683:	40                   	inc    %eax
   14684:	83 c2 38             	add    $0x38,%edx
   14687:	83 f8 08             	cmp    $0x8,%eax
   1468a:	75 ed                	jne    14679 <net_route_get_nbr+0xd>

			return nbr;
		}
	}

	return NULL;
   1468c:	31 c0                	xor    %eax,%eax
   1468e:	eb 08                	jmp    14698 <net_route_get_nbr+0x2c>
	return &net_route_entries_pool[idx].nbr;
   14690:	6b c0 38             	imul   $0x38,%eax,%eax
   14693:	05 20 a2 40 00       	add    $0x40a220,%eax
}
   14698:	5d                   	pop    %ebp
   14699:	c3                   	ret    

0001469a <net_route_lookup>:
	sys_slist_prepend(&routes, &route->node);
}

struct net_route_entry *net_route_lookup(struct net_if *iface,
					 struct in6_addr *dst)
{
   1469a:	55                   	push   %ebp
   1469b:	89 e5                	mov    %esp,%ebp
   1469d:	57                   	push   %edi
   1469e:	56                   	push   %esi
   1469f:	53                   	push   %ebx
	struct net_route_entry *route, *found = NULL;
   146a0:	31 db                	xor    %ebx,%ebx
{
   146a2:	83 ec 08             	sub    $0x8,%esp
	u8_t longest_match = 0U;
	int i;

	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
   146a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	u8_t longest_match = 0U;
   146ac:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
   146b0:	6b 45 ec 38          	imul   $0x38,-0x14(%ebp),%eax
   146b4:	80 b8 20 a2 40 00 00 	cmpb   $0x0,0x40a220(%eax)
   146bb:	0f 84 83 00 00 00    	je     14744 <net_route_lookup+0xaa>
			continue;
		}

		if (iface && nbr->iface != iface) {
   146c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   146c5:	74 0b                	je     146d2 <net_route_lookup+0x38>
   146c7:	8b 75 08             	mov    0x8(%ebp),%esi
   146ca:	39 b0 28 a2 40 00    	cmp    %esi,0x40a228(%eax)
   146d0:	75 72                	jne    14744 <net_route_lookup+0xaa>
			continue;
		}

		route = net_route_data(nbr);
   146d2:	8b b0 2c a2 40 00    	mov    0x40a22c(%eax),%esi

		if (route->prefix_len >= longest_match &&
   146d8:	8a 56 20             	mov    0x20(%esi),%dl
   146db:	3a 55 f3             	cmp    -0xd(%ebp),%dl
   146de:	72 64                	jb     14744 <net_route_lookup+0xaa>
	if (length > 128) {
   146e0:	80 fa 80             	cmp    $0x80,%dl
   146e3:	77 5f                	ja     14744 <net_route_lookup+0xaa>
	u8_t bytes = length / 8;
   146e5:	88 d0                	mov    %dl,%al
		    net_ipv6_is_prefix((u8_t *)dst,
				       (u8_t *)&route->addr,
   146e7:	8d 4e 10             	lea    0x10(%esi),%ecx
   146ea:	c0 e8 03             	shr    $0x3,%al
   146ed:	88 55 f2             	mov    %dl,-0xe(%ebp)
	if (memcmp(addr1, addr2, bytes)) {
   146f0:	0f b6 f8             	movzbl %al,%edi
   146f3:	57                   	push   %edi
   146f4:	51                   	push   %ecx
   146f5:	ff 75 0c             	pushl  0xc(%ebp)
   146f8:	e8 c9 61 ff ff       	call   a8c6 <memcmp>
   146fd:	83 c4 0c             	add    $0xc,%esp
   14700:	85 c0                	test   %eax,%eax
   14702:	75 40                	jne    14744 <net_route_lookup+0xaa>
	u8_t bits = 128 - length;
   14704:	8a 55 f2             	mov    -0xe(%ebp),%dl
   14707:	88 d0                	mov    %dl,%al
   14709:	f7 d8                	neg    %eax
	if (!remain) {
   1470b:	24 07                	and    $0x7,%al
   1470d:	74 2d                	je     1473c <net_route_lookup+0xa2>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
   1470f:	8b 55 0c             	mov    0xc(%ebp),%edx
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
   14712:	0f b6 c8             	movzbl %al,%ecx
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
   14715:	8a 14 3a             	mov    (%edx,%edi,1),%dl
   14718:	32 54 3e 10          	xor    0x10(%esi,%edi,1),%dl
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
   1471c:	bf 08 00 00 00       	mov    $0x8,%edi
   14721:	29 cf                	sub    %ecx,%edi
   14723:	89 f9                	mov    %edi,%ecx
   14725:	bf ff 00 00 00       	mov    $0xff,%edi
   1472a:	d3 e7                	shl    %cl,%edi
   1472c:	81 f7 ff 00 00 00    	xor    $0xff,%edi
   14732:	88 c1                	mov    %al,%cl
   14734:	d3 e7                	shl    %cl,%edi
   14736:	89 f8                	mov    %edi,%eax
		if (route->prefix_len >= longest_match &&
   14738:	84 c2                	test   %al,%dl
   1473a:	75 08                	jne    14744 <net_route_lookup+0xaa>
				       route->prefix_len)) {
			found = route;
			longest_match = route->prefix_len;
   1473c:	8a 46 20             	mov    0x20(%esi),%al
   1473f:	89 f3                	mov    %esi,%ebx
   14741:	88 45 f3             	mov    %al,-0xd(%ebp)
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
   14744:	ff 45 ec             	incl   -0x14(%ebp)
   14747:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   1474b:	7f 0a                	jg     14757 <net_route_lookup+0xbd>
   1474d:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
   14751:	0f 89 59 ff ff ff    	jns    146b0 <net_route_lookup+0x16>
		}
	}

	if (found) {
   14757:	85 db                	test   %ebx,%ebx
   14759:	74 23                	je     1477e <net_route_lookup+0xe4>
	sys_slist_find_and_remove(&routes, &route->node);
   1475b:	89 d8                	mov    %ebx,%eax
   1475d:	e8 bb fe ff ff       	call   1461d <sys_slist_find_and_remove.constprop.11>
Z_GENLIST_PREPEND(slist, snode)
   14762:	a1 fc 42 40 00       	mov    0x4042fc,%eax
	parent->next = child;
   14767:	89 03                	mov    %eax,(%ebx)
	list->head = node;
   14769:	89 1d fc 42 40 00    	mov    %ebx,0x4042fc
Z_GENLIST_PREPEND(slist, snode)
   1476f:	83 3d 00 43 40 00 00 	cmpl   $0x0,0x404300
   14776:	75 06                	jne    1477e <net_route_lookup+0xe4>
	list->tail = node;
   14778:	89 1d 00 43 40 00    	mov    %ebx,0x404300

		update_route_access(found);
	}

	return found;
}
   1477e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14781:	89 d8                	mov    %ebx,%eax
   14783:	5b                   	pop    %ebx
   14784:	5e                   	pop    %esi
   14785:	5f                   	pop    %edi
   14786:	5d                   	pop    %ebp
   14787:	c3                   	ret    

00014788 <net_route_del>:

	return route;
}

int net_route_del(struct net_route_entry *route)
{
   14788:	55                   	push   %ebp
#if defined(CONFIG_NET_MGMT_EVENT_INFO)
       struct net_event_ipv6_route info;
#endif

	if (!route) {
		return -EINVAL;
   14789:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
   1478e:	89 e5                	mov    %esp,%ebp
   14790:	56                   	push   %esi
   14791:	53                   	push   %ebx
   14792:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!route) {
   14795:	85 db                	test   %ebx,%ebx
   14797:	74 51                	je     147ea <net_route_del+0x62>
   14799:	6a 00                	push   $0x0
   1479b:	6a 00                	push   $0x0
   1479d:	ff 73 0c             	pushl  0xc(%ebx)
   147a0:	68 0c 00 60 f0       	push   $0xf060000c
   147a5:	e8 19 fd ff ff       	call   144c3 <net_mgmt_event_notify_with_info>
   147aa:	83 c4 10             	add    $0x10,%esp
					sizeof(struct net_event_ipv6_route));
#else
	net_mgmt_event_notify(NET_EVENT_IPV6_ROUTE_DEL, route->iface);
#endif

	sys_slist_find_and_remove(&routes, &route->node);
   147ad:	89 d8                	mov    %ebx,%eax
   147af:	e8 69 fe ff ff       	call   1461d <sys_slist_find_and_remove.constprop.11>

	nbr = net_route_get_nbr(route);
   147b4:	53                   	push   %ebx
   147b5:	e8 b2 fe ff ff       	call   1466c <net_route_get_nbr>
   147ba:	89 c6                	mov    %eax,%esi
   147bc:	59                   	pop    %ecx
	if (!nbr) {
		return -ENOENT;
   147bd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!nbr) {
   147c2:	85 f6                	test   %esi,%esi
   147c4:	74 24                	je     147ea <net_route_del+0x62>
	}

	net_route_info("Deleted", route, &route->addr);

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
   147c6:	8b 5b 04             	mov    0x4(%ebx),%ebx
   147c9:	85 db                	test   %ebx,%ebx
   147cb:	75 0b                	jne    147d8 <net_route_del+0x50>
	net_nbr_unref(nbr);
   147cd:	56                   	push   %esi
   147ce:	e8 b9 d3 ff ff       	call   11b8c <net_nbr_unref>
   147d3:	5a                   	pop    %edx
		nbr_nexthop_put(nexthop_route->nbr);
	}

	nbr_free(nbr);

	return 0;
   147d4:	31 c0                	xor    %eax,%eax
   147d6:	eb 12                	jmp    147ea <net_route_del+0x62>
		if (!nexthop_route->nbr) {
   147d8:	8b 43 04             	mov    0x4(%ebx),%eax
   147db:	85 c0                	test   %eax,%eax
   147dd:	74 07                	je     147e6 <net_route_del+0x5e>
	net_nbr_unref(nbr);
   147df:	50                   	push   %eax
   147e0:	e8 a7 d3 ff ff       	call   11b8c <net_nbr_unref>
   147e5:	58                   	pop    %eax
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   147e6:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
   147e8:	eb df                	jmp    147c9 <net_route_del+0x41>
}
   147ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
   147ed:	5b                   	pop    %ebx
   147ee:	5e                   	pop    %esi
   147ef:	5d                   	pop    %ebp
   147f0:	c3                   	ret    

000147f1 <net_route_del_by_nexthop>:

int net_route_del_by_nexthop(struct net_if *iface, struct in6_addr *nexthop)
{
   147f1:	55                   	push   %ebp
   147f2:	89 e5                	mov    %esp,%ebp
   147f4:	57                   	push   %edi
   147f5:	56                   	push   %esi
	int count = 0, status = 0;
   147f6:	31 ff                	xor    %edi,%edi
{
   147f8:	53                   	push   %ebx
   147f9:	51                   	push   %ecx
	int i, ret;

	NET_ASSERT(iface);
	NET_ASSERT(nexthop);

	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
   147fa:	ff 75 0c             	pushl  0xc(%ebp)
   147fd:	ff 75 08             	pushl  0x8(%ebp)
   14800:	e8 ee de ff ff       	call   126f3 <net_ipv6_nbr_lookup>
   14805:	5b                   	pop    %ebx
   14806:	89 c2                	mov    %eax,%edx
   14808:	5e                   	pop    %esi
	int count = 0, status = 0;
   14809:	31 db                	xor    %ebx,%ebx
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
   1480b:	31 f6                	xor    %esi,%esi

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
		struct net_nbr *nbr = get_nbr(i);
		struct net_route_entry *route = net_route_data(nbr);
   1480d:	8b 8e 2c a2 40 00    	mov    0x40a22c(%esi),%ecx

		if (!route) {
   14813:	85 c9                	test   %ecx,%ecx
   14815:	74 26                	je     1483d <net_route_del_by_nexthop+0x4c>
			continue;
		}

		SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route,
   14817:	8b 41 04             	mov    0x4(%ecx),%eax
   1481a:	85 c0                	test   %eax,%eax
   1481c:	74 1f                	je     1483d <net_route_del_by_nexthop+0x4c>
					     node) {
			if (nexthop_route->nbr == nbr_nexthop) {
   1481e:	39 50 04             	cmp    %edx,0x4(%eax)
   14821:	75 14                	jne    14837 <net_route_del_by_nexthop+0x46>
   14823:	89 55 f0             	mov    %edx,-0x10(%ebp)
				/* This route contains this nexthop */
				ret = net_route_del(route);
   14826:	51                   	push   %ecx
   14827:	e8 5c ff ff ff       	call   14788 <net_route_del>
   1482c:	5a                   	pop    %edx
				if (!ret) {
   1482d:	85 c0                	test   %eax,%eax
   1482f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14832:	75 07                	jne    1483b <net_route_del_by_nexthop+0x4a>
					count++;
   14834:	43                   	inc    %ebx
   14835:	eb 06                	jmp    1483d <net_route_del_by_nexthop+0x4c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14837:	8b 00                	mov    (%eax),%eax
	return node->next;
   14839:	eb df                	jmp    1481a <net_route_del_by_nexthop+0x29>
   1483b:	89 c7                	mov    %eax,%edi
   1483d:	83 c6 38             	add    $0x38,%esi
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
   14840:	81 fe c0 01 00 00    	cmp    $0x1c0,%esi
   14846:	75 c5                	jne    1480d <net_route_del_by_nexthop+0x1c>
				break;
			}
		}
	}

	if (count) {
   14848:	85 db                	test   %ebx,%ebx
   1484a:	75 08                	jne    14854 <net_route_del_by_nexthop+0x63>
		return count;
	} else if (status < 0) {
   1484c:	89 fb                	mov    %edi,%ebx
   1484e:	85 ff                	test   %edi,%edi
   14850:	7e 02                	jle    14854 <net_route_del_by_nexthop+0x63>
   14852:	31 db                	xor    %ebx,%ebx
		return status;
	}

	return 0;
}
   14854:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14857:	89 d8                	mov    %ebx,%eax
   14859:	5b                   	pop    %ebx
   1485a:	5e                   	pop    %esi
   1485b:	5f                   	pop    %edi
   1485c:	5d                   	pop    %ebp
   1485d:	c3                   	ret    

0001485e <net_route_get_nexthop>:

	return status;
}

struct in6_addr *net_route_get_nexthop(struct net_route_entry *route)
{
   1485e:	55                   	push   %ebp
   1485f:	89 e5                	mov    %esp,%ebp
   14861:	56                   	push   %esi
   14862:	53                   	push   %ebx
   14863:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_route_nexthop *nexthop_route;
	struct net_ipv6_nbr_data *ipv6_nbr_data;

	if (!route) {
   14866:	85 c0                	test   %eax,%eax
   14868:	75 04                	jne    1486e <net_route_get_nexthop+0x10>
		return NULL;
   1486a:	31 c0                	xor    %eax,%eax
   1486c:	eb 50                	jmp    148be <net_route_get_nexthop+0x60>
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
   1486e:	8b 70 04             	mov    0x4(%eax),%esi
   14871:	85 f6                	test   %esi,%esi
   14873:	74 f5                	je     1486a <net_route_get_nexthop+0xc>
   14875:	bb 34 52 02 00       	mov    $0x25234,%ebx
   1487a:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   14880:	c1 eb 03             	shr    $0x3,%ebx
			addr = &ipv6_nbr_data->addr;
			NET_ASSERT(addr);

			return addr;
		} else {
			NET_ERR("could not get neighbor data from next hop");
   14883:	c1 e3 06             	shl    $0x6,%ebx
		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
   14886:	8b 46 04             	mov    0x4(%esi),%eax
   14889:	80 78 01 ff          	cmpb   $0xff,0x1(%eax)
   1488d:	74 27                	je     148b6 <net_route_get_nexthop+0x58>
		ipv6_nbr_data = net_ipv6_nbr_data(nexthop_route->nbr);
   1488f:	8b 40 0c             	mov    0xc(%eax),%eax
		if (ipv6_nbr_data) {
   14892:	85 c0                	test   %eax,%eax
   14894:	74 05                	je     1489b <net_route_get_nexthop+0x3d>
			addr = &ipv6_nbr_data->addr;
   14896:	83 c0 04             	add    $0x4,%eax
			return addr;
   14899:	eb 23                	jmp    148be <net_route_get_nexthop+0x60>
			NET_ERR("could not get neighbor data from next hop");
   1489b:	f6 05 d8 a8 40 00 07 	testb  $0x7,0x40a8d8
   148a2:	74 12                	je     148b6 <net_route_get_nexthop+0x58>
   148a4:	89 d8                	mov    %ebx,%eax
   148a6:	83 c8 01             	or     $0x1,%eax
   148a9:	50                   	push   %eax
   148aa:	68 b5 7d 02 00       	push   $0x27db5
   148af:	e8 d6 eb fe ff       	call   348a <log_0>
   148b4:	58                   	pop    %eax
   148b5:	5a                   	pop    %edx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   148b6:	8b 36                	mov    (%esi),%esi
	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
   148b8:	85 f6                	test   %esi,%esi
   148ba:	75 ca                	jne    14886 <net_route_get_nexthop+0x28>
   148bc:	eb ac                	jmp    1486a <net_route_get_nexthop+0xc>
		}
	}

	return NULL;
}
   148be:	8d 65 f8             	lea    -0x8(%ebp),%esp
   148c1:	5b                   	pop    %ebx
   148c2:	5e                   	pop    %esi
   148c3:	5d                   	pop    %ebp
   148c4:	c3                   	ret    

000148c5 <net_route_foreach>:

int net_route_foreach(net_route_cb_t cb, void *user_data)
{
   148c5:	55                   	push   %ebp
   148c6:	89 e5                	mov    %esp,%ebp
   148c8:	56                   	push   %esi
   148c9:	53                   	push   %ebx
	int i, ret = 0;
   148ca:	31 f6                	xor    %esi,%esi
{
   148cc:	31 db                	xor    %ebx,%ebx
		nbr = get_nbr(i);
		if (!nbr) {
			continue;
		}

		route = net_route_data(nbr);
   148ce:	8b 83 2c a2 40 00    	mov    0x40a22c(%ebx),%eax
		if (!route) {
   148d4:	85 c0                	test   %eax,%eax
   148d6:	74 0a                	je     148e2 <net_route_foreach+0x1d>
			continue;
		}

		cb(route, user_data);
   148d8:	ff 75 0c             	pushl  0xc(%ebp)

		ret++;
   148db:	46                   	inc    %esi
		cb(route, user_data);
   148dc:	50                   	push   %eax
   148dd:	ff 55 08             	call   *0x8(%ebp)
   148e0:	58                   	pop    %eax
   148e1:	5a                   	pop    %edx
		ret++;
   148e2:	83 c3 38             	add    $0x38,%ebx
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
   148e5:	81 fb c0 01 00 00    	cmp    $0x1c0,%ebx
   148eb:	75 e1                	jne    148ce <net_route_foreach+0x9>
	}

	return ret;
}
   148ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
   148f0:	89 f0                	mov    %esi,%eax
   148f2:	5b                   	pop    %ebx
   148f3:	5e                   	pop    %esi
   148f4:	5d                   	pop    %ebp
   148f5:	c3                   	ret    

000148f6 <net_route_get_info>:

bool net_route_get_info(struct net_if *iface,
			struct in6_addr *dst,
			struct net_route_entry **route,
			struct in6_addr **nexthop)
{
   148f6:	55                   	push   %ebp
   148f7:	89 e5                	mov    %esp,%ebp
   148f9:	57                   	push   %edi
   148fa:	56                   	push   %esi
   148fb:	53                   	push   %ebx
   148fc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct net_if_router *router;

	/* Search in neighbor table first, if not search in routing table. */
	if (net_ipv6_nbr_lookup(iface, dst)) {
   148ff:	53                   	push   %ebx
{
   14900:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (net_ipv6_nbr_lookup(iface, dst)) {
   14903:	57                   	push   %edi
{
   14904:	8b 75 14             	mov    0x14(%ebp),%esi
	if (net_ipv6_nbr_lookup(iface, dst)) {
   14907:	e8 e7 dd ff ff       	call   126f3 <net_ipv6_nbr_lookup>
   1490c:	59                   	pop    %ecx
   1490d:	5a                   	pop    %edx
   1490e:	85 c0                	test   %eax,%eax
   14910:	74 0d                	je     1491f <net_route_get_info+0x29>
		/* Found nexthop, no need to look into routing table. */
		*route = NULL;
   14912:	8b 45 10             	mov    0x10(%ebp),%eax
   14915:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		*nexthop = dst;
   1491b:	89 1e                	mov    %ebx,(%esi)

		return true;
   1491d:	eb 37                	jmp    14956 <net_route_get_info+0x60>
	}

	*route = net_route_lookup(iface, dst);
   1491f:	53                   	push   %ebx
   14920:	57                   	push   %edi
   14921:	e8 74 fd ff ff       	call   1469a <net_route_lookup>
   14926:	8b 4d 10             	mov    0x10(%ebp),%ecx
   14929:	5f                   	pop    %edi
   1492a:	5a                   	pop    %edx
	if (*route) {
   1492b:	85 c0                	test   %eax,%eax
	*route = net_route_lookup(iface, dst);
   1492d:	89 01                	mov    %eax,(%ecx)
	if (*route) {
   1492f:	74 10                	je     14941 <net_route_get_info+0x4b>
		*nexthop = net_route_get_nexthop(*route);
   14931:	50                   	push   %eax
   14932:	e8 27 ff ff ff       	call   1485e <net_route_get_nexthop>
   14937:	5b                   	pop    %ebx
		if (!*nexthop) {
   14938:	85 c0                	test   %eax,%eax
		*nexthop = net_route_get_nexthop(*route);
   1493a:	89 06                	mov    %eax,(%esi)
		if (!*nexthop) {
   1493c:	0f 95 c2             	setne  %dl
   1493f:	eb 17                	jmp    14958 <net_route_get_info+0x62>
		return true;
	} else {
		/* No specific route to this host, use the default
		 * route instead.
		 */
		router = net_if_ipv6_router_find_default(NULL, dst);
   14941:	53                   	push   %ebx
   14942:	6a 00                	push   $0x0
   14944:	e8 4a a6 ff ff       	call   ef93 <net_if_ipv6_router_find_default>
   14949:	5a                   	pop    %edx
		if (!router) {
			return false;
   1494a:	31 d2                	xor    %edx,%edx
		router = net_if_ipv6_router_find_default(NULL, dst);
   1494c:	59                   	pop    %ecx
		if (!router) {
   1494d:	85 c0                	test   %eax,%eax
   1494f:	74 07                	je     14958 <net_route_get_info+0x62>
		}

		*nexthop = &router->address.in6_addr;
   14951:	83 c0 24             	add    $0x24,%eax
   14954:	89 06                	mov    %eax,(%esi)

		return true;
   14956:	b2 01                	mov    $0x1,%dl
	}

	return false;
}
   14958:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1495b:	88 d0                	mov    %dl,%al
   1495d:	5b                   	pop    %ebx
   1495e:	5e                   	pop    %esi
   1495f:	5f                   	pop    %edi
   14960:	5d                   	pop    %ebp
   14961:	c3                   	ret    

00014962 <net_route_packet>:

int net_route_packet(struct net_pkt *pkt, struct in6_addr *nexthop)
{
   14962:	55                   	push   %ebp
   14963:	89 e5                	mov    %esp,%ebp
   14965:	57                   	push   %edi
   14966:	56                   	push   %esi
   14967:	53                   	push   %ebx
   14968:	53                   	push   %ebx
	struct net_linkaddr_storage *lladdr;
	struct net_nbr *nbr;

	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
   14969:	ff 75 0c             	pushl  0xc(%ebp)
{
   1496c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
   1496f:	6a 00                	push   $0x0
   14971:	e8 7d dd ff ff       	call   126f3 <net_ipv6_nbr_lookup>
   14976:	5e                   	pop    %esi
	if (!nbr) {
   14977:	85 c0                	test   %eax,%eax
	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
   14979:	5f                   	pop    %edi
	if (!nbr) {
   1497a:	0f 84 bc 00 00 00    	je     14a3c <net_route_packet+0xda>
   14980:	89 c7                	mov    %eax,%edi
		NET_DBG("Cannot find %s neighbor",
			log_strdup(net_sprint_ipv6_addr(nexthop)));
		return -ENOENT;
	}

	lladdr = net_nbr_get_lladdr(nbr->idx);
   14982:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14986:	50                   	push   %eax
   14987:	e8 73 d3 ff ff       	call   11cff <net_nbr_get_lladdr>
   1498c:	59                   	pop    %ecx
   1498d:	89 c6                	mov    %eax,%esi
	if (!lladdr) {
   1498f:	85 c0                	test   %eax,%eax
   14991:	0f 84 ac 00 00 00    	je     14a43 <net_route_packet+0xe1>
	 * link layer. This is done at runtime because we can have multiple
	 * network technologies enabled.
	 */
	if (net_if_l2(net_pkt_iface(pkt)) != &NET_L2_GET_NAME(DUMMY)) {
#endif
		if (!net_pkt_lladdr_src(pkt)->addr) {
   14997:	8b 43 2c             	mov    0x2c(%ebx),%eax
   1499a:	85 c0                	test   %eax,%eax
   1499c:	74 45                	je     149e3 <net_route_packet+0x81>
		}

		/* Sanitycheck: If src and dst ll addresses are going to be
		 * same, then something went wrong in route lookup.
		 */
		if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
   1499e:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
   149a2:	8d 56 02             	lea    0x2(%esi),%edx
   149a5:	51                   	push   %ecx
   149a6:	52                   	push   %edx
   149a7:	89 55 f0             	mov    %edx,-0x10(%ebp)
   149aa:	50                   	push   %eax
   149ab:	e8 16 5f ff ff       	call   a8c6 <memcmp>
   149b0:	83 c4 0c             	add    $0xc,%esp
   149b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   149b6:	85 c0                	test   %eax,%eax
   149b8:	75 30                	jne    149ea <net_route_packet+0x88>
			    lladdr->len)) {
			NET_ERR("Src ll and Dst ll are same");
   149ba:	f6 05 d8 a8 40 00 07 	testb  $0x7,0x40a8d8
   149c1:	74 20                	je     149e3 <net_route_packet+0x81>
   149c3:	b8 34 52 02 00       	mov    $0x25234,%eax
   149c8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   149cd:	c1 e8 03             	shr    $0x3,%eax
   149d0:	c1 e0 06             	shl    $0x6,%eax
   149d3:	83 c8 01             	or     $0x1,%eax
   149d6:	50                   	push   %eax
   149d7:	68 df 7d 02 00       	push   $0x27ddf
   149dc:	e8 a9 ea fe ff       	call   348a <log_0>
   149e1:	58                   	pop    %eax
   149e2:	5a                   	pop    %edx
			return -EINVAL;
   149e3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   149e8:	eb 5e                	jmp    14a48 <net_route_packet+0xe6>
	pkt->forwarding = forward;
   149ea:	80 4b 3f 01          	orb    $0x1,0x3f(%ebx)
	return net_if_get_link_addr(pkt->iface);
   149ee:	8b 43 24             	mov    0x24(%ebx),%eax
   149f1:	8b 08                	mov    (%eax),%ecx
	net_pkt_set_forwarding(pkt, true);

	/* Set the destination and source ll address in the packet.
	 * We set the destination address to be the nexthop recipient.
	 */
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
   149f3:	8b 41 10             	mov    0x10(%ecx),%eax
   149f6:	89 43 2c             	mov    %eax,0x2c(%ebx)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
   149f9:	8a 41 15             	mov    0x15(%ecx),%al
   149fc:	88 43 31             	mov    %al,0x31(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
   149ff:	8a 41 14             	mov    0x14(%ecx),%al

	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
   14a02:	89 53 34             	mov    %edx,0x34(%ebx)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
   14a05:	88 43 30             	mov    %al,0x30(%ebx)
	net_pkt_lladdr_dst(pkt)->type = lladdr->type;
   14a08:	8a 06                	mov    (%esi),%al
   14a0a:	88 43 39             	mov    %al,0x39(%ebx)
	net_pkt_lladdr_dst(pkt)->len = lladdr->len;
   14a0d:	8a 46 01             	mov    0x1(%esi),%al
   14a10:	88 43 38             	mov    %al,0x38(%ebx)

	net_pkt_set_iface(pkt, nbr->iface);
   14a13:	8b 47 08             	mov    0x8(%edi),%eax
	pkt->iface = iface;
   14a16:	89 43 24             	mov    %eax,0x24(%ebx)
	if (iface) {
   14a19:	85 c0                	test   %eax,%eax
   14a1b:	74 10                	je     14a2d <net_route_packet+0xcb>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   14a1d:	8b 10                	mov    (%eax),%edx
   14a1f:	8a 52 15             	mov    0x15(%edx),%dl
   14a22:	88 53 31             	mov    %dl,0x31(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   14a25:	8b 00                	mov    (%eax),%eax
   14a27:	8a 40 15             	mov    0x15(%eax),%al
   14a2a:	88 43 39             	mov    %al,0x39(%ebx)

	return net_send_data(pkt);
   14a2d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   14a30:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14a33:	5b                   	pop    %ebx
   14a34:	5e                   	pop    %esi
   14a35:	5f                   	pop    %edi
   14a36:	5d                   	pop    %ebp
	return net_send_data(pkt);
   14a37:	e9 11 8e ff ff       	jmp    d84d <net_send_data>
		return -ENOENT;
   14a3c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   14a41:	eb 05                	jmp    14a48 <net_route_packet+0xe6>
		return -ESRCH;
   14a43:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
   14a48:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14a4b:	5b                   	pop    %ebx
   14a4c:	5e                   	pop    %esi
   14a4d:	5f                   	pop    %edi
   14a4e:	5d                   	pop    %ebp
   14a4f:	c3                   	ret    

00014a50 <net_route_init>:
	NET_DBG("Allocated %d routing entries (%zu bytes)",
		CONFIG_NET_MAX_ROUTES, sizeof(net_route_entries_pool));

	NET_DBG("Allocated %d nexthop entries (%zu bytes)",
		CONFIG_NET_MAX_NEXTHOPS, sizeof(net_route_nexthop_pool));
}
   14a50:	c3                   	ret    

00014a51 <cmd_net_tcp>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	return 0;
}
   14a51:	31 c0                	xor    %eax,%eax
   14a53:	c3                   	ret    

00014a54 <cmd_net_vlan>:
	(*count)++;
}
#endif /* CONFIG_NET_VLAN */

static int cmd_net_vlan(const struct shell *shell, size_t argc, char *argv[])
{
   14a54:	55                   	push   %ebp
   14a55:	89 e5                	mov    %esp,%ebp
	user_data.shell = shell;
	user_data.user_data = &count;

	net_if_foreach(iface_vlan_cb, &user_data);
#else
	PR_INFO("Set CONFIG_NET_VLAN to enable virtual LAN support.\n");
   14a57:	68 04 7e 02 00       	push   $0x27e04
   14a5c:	6a 03                	push   $0x3
   14a5e:	ff 75 08             	pushl  0x8(%ebp)
   14a61:	e8 5c 11 ff ff       	call   5bc2 <shell_fprintf>
   14a66:	83 c4 0c             	add    $0xc,%esp
#endif /* CONFIG_NET_VLAN */

	return 0;
}
   14a69:	31 c0                	xor    %eax,%eax
   14a6b:	c9                   	leave  
   14a6c:	c3                   	ret    

00014a6d <cmd_net_tcp_connect>:
{
   14a6d:	55                   	push   %ebp
   14a6e:	89 e5                	mov    %esp,%ebp
	PR_INFO("TCP not enabled. Set CONFIG_NET_TCP to enable it.\n");
   14a70:	68 38 7e 02 00       	push   $0x27e38
   14a75:	6a 03                	push   $0x3
   14a77:	ff 75 08             	pushl  0x8(%ebp)
   14a7a:	e8 43 11 ff ff       	call   5bc2 <shell_fprintf>
   14a7f:	83 c4 0c             	add    $0xc,%esp
}
   14a82:	31 c0                	xor    %eax,%eax
   14a84:	c9                   	leave  
   14a85:	c3                   	ret    

00014a86 <cmd_net_stats_all>:
{
   14a86:	55                   	push   %ebp
   14a87:	89 e5                	mov    %esp,%ebp
	PR_INFO("Network statistics not enabled. Set CONFIG_NET_STATISTICS "
   14a89:	68 6b 7e 02 00       	push   $0x27e6b
   14a8e:	6a 03                	push   $0x3
   14a90:	ff 75 08             	pushl  0x8(%ebp)
   14a93:	e8 2a 11 ff ff       	call   5bc2 <shell_fprintf>
   14a98:	83 c4 0c             	add    $0xc,%esp
}
   14a9b:	31 c0                	xor    %eax,%eax
   14a9d:	c9                   	leave  
   14a9e:	c3                   	ret    

00014a9f <cmd_net_stacks>:
{
   14a9f:	55                   	push   %ebp
   14aa0:	89 e5                	mov    %esp,%ebp
   14aa2:	56                   	push   %esi
   14aa3:	53                   	push   %ebx
	for (info = __net_stack_start; info != __net_stack_end; info++) {
   14aa4:	bb e0 aa 40 00       	mov    $0x40aae0,%ebx
{
   14aa9:	8b 75 08             	mov    0x8(%ebp),%esi
	for (info = __net_stack_start; info != __net_stack_end; info++) {
   14aac:	81 fb 40 ab 40 00    	cmp    $0x40ab40,%ebx
   14ab2:	74 1e                	je     14ad2 <cmd_net_stacks+0x33>
		PR("%s [%s] stack size %zu usage not available\n",
   14ab4:	ff 73 0c             	pushl  0xc(%ebx)
   14ab7:	ff 73 08             	pushl  0x8(%ebx)
   14aba:	ff 73 04             	pushl  0x4(%ebx)
	for (info = __net_stack_start; info != __net_stack_end; info++) {
   14abd:	83 c3 20             	add    $0x20,%ebx
		PR("%s [%s] stack size %zu usage not available\n",
   14ac0:	68 b4 7e 02 00       	push   $0x27eb4
   14ac5:	6a 00                	push   $0x0
   14ac7:	56                   	push   %esi
   14ac8:	e8 f5 10 ff ff       	call   5bc2 <shell_fprintf>
   14acd:	83 c4 18             	add    $0x18,%esp
   14ad0:	eb da                	jmp    14aac <cmd_net_stacks+0xd>
	PR_INFO("Enable CONFIG_INIT_STACKS to see usage information.\n");
   14ad2:	68 e0 7e 02 00       	push   $0x27ee0
   14ad7:	6a 03                	push   $0x3
   14ad9:	56                   	push   %esi
   14ada:	e8 e3 10 ff ff       	call   5bc2 <shell_fprintf>
   14adf:	83 c4 0c             	add    $0xc,%esp
}
   14ae2:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14ae5:	31 c0                	xor    %eax,%eax
   14ae7:	5b                   	pop    %ebx
   14ae8:	5e                   	pop    %esi
   14ae9:	5d                   	pop    %ebp
   14aea:	c3                   	ret    

00014aeb <cmd_net_gptp_port>:
{
   14aeb:	55                   	push   %ebp
   14aec:	89 e5                	mov    %esp,%ebp
	PR_INFO("gPTP not supported, set CONFIG_NET_GPTP to enable it.\n");
   14aee:	68 15 7f 02 00       	push   $0x27f15
   14af3:	6a 03                	push   $0x3
   14af5:	ff 75 08             	pushl  0x8(%ebp)
   14af8:	e8 c5 10 ff ff       	call   5bc2 <shell_fprintf>
   14afd:	83 c4 0c             	add    $0xc,%esp
}
   14b00:	31 c0                	xor    %eax,%eax
   14b02:	c9                   	leave  
   14b03:	c3                   	ret    

00014b04 <cmd_net_dns_cancel>:
{
   14b04:	55                   	push   %ebp
   14b05:	89 e5                	mov    %esp,%ebp
	PR_INFO("DNS resolver not supported. Set CONFIG_DNS_RESOLVER to "
   14b07:	68 4c 7f 02 00       	push   $0x27f4c
   14b0c:	6a 03                	push   $0x3
   14b0e:	ff 75 08             	pushl  0x8(%ebp)
   14b11:	e8 ac 10 ff ff       	call   5bc2 <shell_fprintf>
   14b16:	83 c4 0c             	add    $0xc,%esp
}
   14b19:	31 c0                	xor    %eax,%eax
   14b1b:	c9                   	leave  
   14b1c:	c3                   	ret    

00014b1d <cmd_net_allocs>:
{
   14b1d:	55                   	push   %ebp
   14b1e:	89 e5                	mov    %esp,%ebp
	PR_INFO("Enable CONFIG_NET_DEBUG_NET_PKT_ALLOC to see allocations.\n");
   14b20:	68 8f 7f 02 00       	push   $0x27f8f
   14b25:	6a 03                	push   $0x3
   14b27:	ff 75 08             	pushl  0x8(%ebp)
   14b2a:	e8 93 10 ff ff       	call   5bc2 <shell_fprintf>
   14b2f:	83 c4 0c             	add    $0xc,%esp
}
   14b32:	31 c0                	xor    %eax,%eax
   14b34:	c9                   	leave  
   14b35:	c3                   	ret    

00014b36 <cmd_net_route>:
{
   14b36:	55                   	push   %ebp
   14b37:	89 e5                	mov    %esp,%ebp
   14b39:	83 ec 08             	sub    $0x8,%esp
	user_data.shell = shell;
   14b3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b3f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	net_if_foreach(iface_per_route_cb, &user_data);
   14b42:	8d 45 f8             	lea    -0x8(%ebp),%eax
   14b45:	50                   	push   %eax
   14b46:	68 11 58 01 00       	push   $0x15811
   14b4b:	e8 4f ad ff ff       	call   f89f <net_if_foreach>
   14b50:	5a                   	pop    %edx
}
   14b51:	31 c0                	xor    %eax,%eax
	net_if_foreach(iface_per_route_cb, &user_data);
   14b53:	59                   	pop    %ecx
}
   14b54:	c9                   	leave  
   14b55:	c3                   	ret    

00014b56 <cmd_net_ipv6>:
{
   14b56:	55                   	push   %ebp
   14b57:	89 e5                	mov    %esp,%ebp
   14b59:	53                   	push   %ebx
   14b5a:	83 ec 08             	sub    $0x8,%esp
   14b5d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	PR("IPv6 support                              : %s\n",
   14b60:	68 30 6a 02 00       	push   $0x26a30
   14b65:	68 ca 7f 02 00       	push   $0x27fca
   14b6a:	6a 00                	push   $0x0
   14b6c:	53                   	push   %ebx
   14b6d:	e8 50 10 ff ff       	call   5bc2 <shell_fprintf>
   14b72:	83 c4 10             	add    $0x10,%esp
	PR("IPv6 fragmentation support                : %s\n",
   14b75:	68 38 6a 02 00       	push   $0x26a38
   14b7a:	68 fa 7f 02 00       	push   $0x27ffa
   14b7f:	6a 00                	push   $0x0
   14b81:	53                   	push   %ebx
   14b82:	e8 3b 10 ff ff       	call   5bc2 <shell_fprintf>
   14b87:	83 c4 10             	add    $0x10,%esp
	PR("Multicast Listener Discovery support      : %s\n",
   14b8a:	68 30 6a 02 00       	push   $0x26a30
   14b8f:	68 2a 80 02 00       	push   $0x2802a
   14b94:	6a 00                	push   $0x0
   14b96:	53                   	push   %ebx
   14b97:	e8 26 10 ff ff       	call   5bc2 <shell_fprintf>
   14b9c:	83 c4 10             	add    $0x10,%esp
	PR("Neighbor cache support                    : %s\n",
   14b9f:	68 30 6a 02 00       	push   $0x26a30
   14ba4:	68 5a 80 02 00       	push   $0x2805a
   14ba9:	6a 00                	push   $0x0
   14bab:	53                   	push   %ebx
   14bac:	e8 11 10 ff ff       	call   5bc2 <shell_fprintf>
   14bb1:	83 c4 10             	add    $0x10,%esp
	PR("Neighbor discovery support                : %s\n",
   14bb4:	68 30 6a 02 00       	push   $0x26a30
   14bb9:	68 8a 80 02 00       	push   $0x2808a
   14bbe:	6a 00                	push   $0x0
   14bc0:	53                   	push   %ebx
   14bc1:	e8 fc 0f ff ff       	call   5bc2 <shell_fprintf>
   14bc6:	83 c4 10             	add    $0x10,%esp
	PR("Duplicate address detection (DAD) support : %s\n",
   14bc9:	68 30 6a 02 00       	push   $0x26a30
   14bce:	68 ba 80 02 00       	push   $0x280ba
   14bd3:	6a 00                	push   $0x0
   14bd5:	53                   	push   %ebx
   14bd6:	e8 e7 0f ff ff       	call   5bc2 <shell_fprintf>
   14bdb:	83 c4 10             	add    $0x10,%esp
	PR("Router advertisement RDNSS option support : %s\n",
   14bde:	68 30 6a 02 00       	push   $0x26a30
   14be3:	68 ea 80 02 00       	push   $0x280ea
   14be8:	6a 00                	push   $0x0
   14bea:	53                   	push   %ebx
   14beb:	e8 d2 0f ff ff       	call   5bc2 <shell_fprintf>
   14bf0:	83 c4 10             	add    $0x10,%esp
	PR("6lo header compression support            : %s\n",
   14bf3:	68 38 6a 02 00       	push   $0x26a38
   14bf8:	68 1a 81 02 00       	push   $0x2811a
   14bfd:	6a 00                	push   $0x0
   14bff:	53                   	push   %ebx
   14c00:	e8 bd 0f ff ff       	call   5bc2 <shell_fprintf>
   14c05:	83 c4 10             	add    $0x10,%esp
	PR("Max number of IPv6 network interfaces "
   14c08:	6a 01                	push   $0x1
   14c0a:	68 4a 81 02 00       	push   $0x2814a
   14c0f:	6a 00                	push   $0x0
   14c11:	53                   	push   %ebx
   14c12:	e8 ab 0f ff ff       	call   5bc2 <shell_fprintf>
   14c17:	83 c4 10             	add    $0x10,%esp
	PR("Max number of unicast IPv6 addresses "
   14c1a:	6a 03                	push   $0x3
   14c1c:	68 8d 81 02 00       	push   $0x2818d
   14c21:	6a 00                	push   $0x0
   14c23:	53                   	push   %ebx
   14c24:	e8 99 0f ff ff       	call   5bc2 <shell_fprintf>
   14c29:	83 c4 10             	add    $0x10,%esp
	PR("Max number of multicast IPv6 addresses "
   14c2c:	6a 02                	push   $0x2
   14c2e:	68 d0 81 02 00       	push   $0x281d0
   14c33:	6a 00                	push   $0x0
   14c35:	53                   	push   %ebx
   14c36:	e8 87 0f ff ff       	call   5bc2 <shell_fprintf>
   14c3b:	83 c4 10             	add    $0x10,%esp
	PR("Max number of IPv6 prefixes per network "
   14c3e:	6a 02                	push   $0x2
   14c40:	68 13 82 02 00       	push   $0x28213
   14c45:	6a 00                	push   $0x0
   14c47:	53                   	push   %ebx
   14c48:	e8 75 0f ff ff       	call   5bc2 <shell_fprintf>
   14c4d:	83 c4 10             	add    $0x10,%esp
	net_if_foreach(address_lifetime_cb, &user_data);
   14c50:	8d 45 f4             	lea    -0xc(%ebp),%eax
	user_data.shell = shell;
   14c53:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	user_data.user_data = NULL;
   14c56:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	net_if_foreach(address_lifetime_cb, &user_data);
   14c5d:	50                   	push   %eax
   14c5e:	68 d1 5f 01 00       	push   $0x15fd1
   14c63:	e8 37 ac ff ff       	call   f89f <net_if_foreach>
   14c68:	5a                   	pop    %edx
}
   14c69:	31 c0                	xor    %eax,%eax
	net_if_foreach(address_lifetime_cb, &user_data);
   14c6b:	59                   	pop    %ecx
}
   14c6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14c6f:	c9                   	leave  
   14c70:	c3                   	ret    

00014c71 <cmd_net_nbr_rm>:
{
   14c71:	55                   	push   %ebp
   14c72:	89 e5                	mov    %esp,%ebp
   14c74:	57                   	push   %edi
   14c75:	56                   	push   %esi
   14c76:	53                   	push   %ebx
   14c77:	83 ec 10             	sub    $0x10,%esp
   14c7a:	8b 7d 10             	mov    0x10(%ebp),%edi
   14c7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!argv[1]) {
   14c80:	8b 47 04             	mov    0x4(%edi),%eax
   14c83:	85 c0                	test   %eax,%eax
   14c85:	75 12                	jne    14c99 <cmd_net_nbr_rm+0x28>
		PR_WARNING("Neighbor IPv6 address missing.\n");
   14c87:	68 56 82 02 00       	push   $0x28256
   14c8c:	6a 04                	push   $0x4
   14c8e:	53                   	push   %ebx
   14c8f:	e8 2e 0f ff ff       	call   5bc2 <shell_fprintf>
   14c94:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
   14c97:	eb 46                	jmp    14cdf <cmd_net_nbr_rm+0x6e>
	ret = net_addr_pton(AF_INET6, argv[1], &addr);
   14c99:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   14c9c:	56                   	push   %esi
   14c9d:	50                   	push   %eax
   14c9e:	6a 02                	push   $0x2
   14ca0:	e8 2c be ff ff       	call   10ad1 <net_addr_pton>
   14ca5:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   14ca8:	85 c0                	test   %eax,%eax
   14caa:	79 0a                	jns    14cb6 <cmd_net_nbr_rm+0x45>
		PR_WARNING("Cannot parse '%s'\n", argv[1]);
   14cac:	ff 77 04             	pushl  0x4(%edi)
   14caf:	68 76 82 02 00       	push   $0x28276
   14cb4:	eb 1e                	jmp    14cd4 <cmd_net_nbr_rm+0x63>
	if (!net_ipv6_nbr_rm(NULL, &addr)) {
   14cb6:	56                   	push   %esi
   14cb7:	6a 00                	push   $0x0
   14cb9:	e8 ec d9 ff ff       	call   126aa <net_ipv6_nbr_rm>
   14cbe:	5a                   	pop    %edx
   14cbf:	84 c0                	test   %al,%al
   14cc1:	59                   	pop    %ecx
   14cc2:	75 22                	jne    14ce6 <cmd_net_nbr_rm+0x75>
		PR_WARNING("Cannot remove neighbor %s\n",
   14cc4:	56                   	push   %esi
   14cc5:	6a 02                	push   $0x2
   14cc7:	e8 d2 bd ff ff       	call   10a9e <net_sprint_addr>
   14ccc:	5e                   	pop    %esi
   14ccd:	5f                   	pop    %edi
   14cce:	50                   	push   %eax
   14ccf:	68 89 82 02 00       	push   $0x28289
   14cd4:	6a 04                	push   $0x4
   14cd6:	53                   	push   %ebx
   14cd7:	e8 e6 0e ff ff       	call   5bc2 <shell_fprintf>
   14cdc:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
   14cdf:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   14ce4:	eb 1d                	jmp    14d03 <cmd_net_nbr_rm+0x92>
		PR("Neighbor %s removed.\n", net_sprint_ipv6_addr(&addr));
   14ce6:	56                   	push   %esi
   14ce7:	6a 02                	push   $0x2
   14ce9:	e8 b0 bd ff ff       	call   10a9e <net_sprint_addr>
   14cee:	5a                   	pop    %edx
   14cef:	59                   	pop    %ecx
   14cf0:	50                   	push   %eax
   14cf1:	68 a4 82 02 00       	push   $0x282a4
   14cf6:	6a 00                	push   $0x0
   14cf8:	53                   	push   %ebx
   14cf9:	e8 c4 0e ff ff       	call   5bc2 <shell_fprintf>
   14cfe:	83 c4 10             	add    $0x10,%esp
	return 0;
   14d01:	31 c0                	xor    %eax,%eax
}
   14d03:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14d06:	5b                   	pop    %ebx
   14d07:	5e                   	pop    %esi
   14d08:	5f                   	pop    %edi
   14d09:	5d                   	pop    %ebp
   14d0a:	c3                   	ret    

00014d0b <nbr_address_get>:
SHELL_DYNAMIC_CMD_CREATE(nbr_address, nbr_address_get);

#define NBR_ADDRESS_CMD &nbr_address

static void nbr_address_get(size_t idx, struct shell_static_entry *entry)
{
   14d0b:	55                   	push   %ebp
   14d0c:	89 e5                	mov    %esp,%ebp
   14d0e:	56                   	push   %esi
   14d0f:	53                   	push   %ebx
   14d10:	51                   	push   %ecx
   14d11:	8b 75 0c             	mov    0xc(%ebp),%esi
   14d14:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (idx == 0) {
   14d17:	85 db                	test   %ebx,%ebx
	entry->handler = NULL;
   14d19:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
	entry->help  = NULL;
   14d20:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
	entry->subcmd = &nbr_address;
   14d27:	c7 46 08 d8 60 02 00 	movl   $0x260d8,0x8(%esi)
	if (idx == 0) {
   14d2e:	75 2d                	jne    14d5d <nbr_address_get+0x52>
		memset(nbr_address_buffer, 0, sizeof(nbr_address_buffer));
   14d30:	68 40 01 00 00       	push   $0x140
   14d35:	6a 00                	push   $0x0
   14d37:	68 e0 0f 40 00       	push   $0x400fe0
   14d3c:	e8 5f 5c ff ff       	call   a9a0 <memset>
   14d41:	83 c4 0c             	add    $0xc,%esp
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
   14d44:	8d 45 f4             	lea    -0xc(%ebp),%eax
	int count = 0;
   14d47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
   14d4e:	50                   	push   %eax
   14d4f:	68 40 4f 01 00       	push   $0x14f40
   14d54:	e8 2d d9 ff ff       	call   12686 <net_ipv6_nbr_foreach>
   14d59:	58                   	pop    %eax
   14d5a:	5a                   	pop    %edx
	if (idx >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
   14d5b:	eb 09                	jmp    14d66 <nbr_address_get+0x5b>
   14d5d:	83 fb 07             	cmp    $0x7,%ebx
   14d60:	76 04                	jbe    14d66 <nbr_address_get+0x5b>
		return NULL;
   14d62:	31 c0                	xor    %eax,%eax
   14d64:	eb 12                	jmp    14d78 <nbr_address_get+0x6d>
	if (!nbr_address_buffer[idx][0]) {
   14d66:	6b db 28             	imul   $0x28,%ebx,%ebx
   14d69:	8d 83 e0 0f 40 00    	lea    0x400fe0(%ebx),%eax
   14d6f:	80 bb e0 0f 40 00 00 	cmpb   $0x0,0x400fe0(%ebx)
   14d76:	74 ea                	je     14d62 <nbr_address_get+0x57>
	entry->syntax = set_nbr_address(idx);
   14d78:	89 06                	mov    %eax,(%esi)
}
   14d7a:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14d7d:	5b                   	pop    %ebx
   14d7e:	5e                   	pop    %esi
   14d7f:	5d                   	pop    %ebp
   14d80:	c3                   	ret    

00014d81 <cmd_net_mem>:
{
   14d81:	55                   	push   %ebp
   14d82:	89 e5                	mov    %esp,%ebp
   14d84:	53                   	push   %ebx
   14d85:	83 ec 10             	sub    $0x10,%esp
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
   14d88:	8d 45 f8             	lea    -0x8(%ebp),%eax
{
   14d8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
   14d8e:	50                   	push   %eax
   14d8f:	8d 45 f4             	lea    -0xc(%ebp),%eax
   14d92:	50                   	push   %eax
   14d93:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14d96:	50                   	push   %eax
   14d97:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14d9a:	50                   	push   %eax
   14d9b:	e8 cf b0 ff ff       	call   fe6f <net_pkt_get_info>
   14da0:	83 c4 10             	add    $0x10,%esp
	PR("Fragment length %d bytes\n", CONFIG_NET_BUF_DATA_SIZE);
   14da3:	68 80 00 00 00       	push   $0x80
   14da8:	68 ba 82 02 00       	push   $0x282ba
   14dad:	6a 00                	push   $0x0
   14daf:	53                   	push   %ebx
   14db0:	e8 0d 0e ff ff       	call   5bc2 <shell_fprintf>
   14db5:	83 c4 10             	add    $0x10,%esp
	PR("Network buffer pools:\n");
   14db8:	68 d4 82 02 00       	push   $0x282d4
   14dbd:	6a 00                	push   $0x0
   14dbf:	53                   	push   %ebx
   14dc0:	e8 fd 0d ff ff       	call   5bc2 <shell_fprintf>
   14dc5:	83 c4 0c             	add    $0xc,%esp
	PR("(CONFIG_NET_BUF_POOL_USAGE to see free #s)\n");
   14dc8:	68 eb 82 02 00       	push   $0x282eb
   14dcd:	6a 00                	push   $0x0
   14dcf:	53                   	push   %ebx
   14dd0:	e8 ed 0d ff ff       	call   5bc2 <shell_fprintf>
   14dd5:	83 c4 0c             	add    $0xc,%esp
	PR("Address\t\tTotal\tName\n");
   14dd8:	68 17 83 02 00       	push   $0x28317
   14ddd:	6a 00                	push   $0x0
   14ddf:	53                   	push   %ebx
   14de0:	e8 dd 0d ff ff       	call   5bc2 <shell_fprintf>
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
   14de5:	8b 45 ec             	mov    -0x14(%ebp),%eax
	PR("Address\t\tTotal\tName\n");
   14de8:	83 c4 0c             	add    $0xc,%esp
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
   14deb:	ff 70 10             	pushl  0x10(%eax)
   14dee:	50                   	push   %eax
   14def:	68 2c 83 02 00       	push   $0x2832c
   14df4:	6a 00                	push   $0x0
   14df6:	53                   	push   %ebx
   14df7:	e8 c6 0d ff ff       	call   5bc2 <shell_fprintf>
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
   14dfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
   14dff:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
   14e02:	ff 70 10             	pushl  0x10(%eax)
   14e05:	50                   	push   %eax
   14e06:	68 36 83 02 00       	push   $0x28336
   14e0b:	6a 00                	push   $0x0
   14e0d:	53                   	push   %ebx
   14e0e:	e8 af 0d ff ff       	call   5bc2 <shell_fprintf>
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
   14e13:	8b 45 f4             	mov    -0xc(%ebp),%eax
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
   14e16:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
   14e19:	0f b7 50 18          	movzwl 0x18(%eax),%edx
   14e1d:	52                   	push   %edx
   14e1e:	50                   	push   %eax
   14e1f:	68 40 83 02 00       	push   $0x28340
   14e24:	6a 00                	push   $0x0
   14e26:	53                   	push   %ebx
   14e27:	e8 96 0d ff ff       	call   5bc2 <shell_fprintf>
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
   14e2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
   14e2f:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
   14e32:	0f b7 50 18          	movzwl 0x18(%eax),%edx
   14e36:	52                   	push   %edx
   14e37:	50                   	push   %eax
   14e38:	68 4f 83 02 00       	push   $0x2834f
   14e3d:	6a 00                	push   $0x0
   14e3f:	53                   	push   %ebx
   14e40:	e8 7d 0d ff ff       	call   5bc2 <shell_fprintf>
   14e45:	83 c4 14             	add    $0x14,%esp
}
   14e48:	31 c0                	xor    %eax,%eax
   14e4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14e4d:	c9                   	leave  
   14e4e:	c3                   	ret    

00014e4f <iface_index_get>:
{
   14e4f:	55                   	push   %ebp
   14e50:	89 e5                	mov    %esp,%ebp
   14e52:	57                   	push   %edi
   14e53:	56                   	push   %esi
   14e54:	8b 75 0c             	mov    0xc(%ebp),%esi
   14e57:	53                   	push   %ebx
   14e58:	8b 5d 08             	mov    0x8(%ebp),%ebx
	entry->handler = NULL;
   14e5b:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
	struct net_if *iface = net_if_get_by_index(idx);
   14e62:	53                   	push   %ebx
   14e63:	e8 f3 a9 ff ff       	call   f85b <net_if_get_by_index>
   14e68:	59                   	pop    %ecx
	if (!iface) {
   14e69:	85 c0                	test   %eax,%eax
   14e6b:	74 32                	je     14e9f <iface_index_get+0x50>
	return iface->if_dev->l2;
   14e6d:	8b 08                	mov    (%eax),%ecx
		return "Ethernet";
   14e6f:	ba 5e 83 02 00       	mov    $0x2835e,%edx
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
   14e74:	81 79 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%ecx)
   14e7b:	74 05                	je     14e82 <iface_index_get+0x33>
	return "<unknown type>";
   14e7d:	ba 67 83 02 00       	mov    $0x28367,%edx
	snprintk(iface_help_buffer[idx], MAX_IFACE_HELP_STR_LEN,
   14e82:	6b fb 1c             	imul   $0x1c,%ebx,%edi
   14e85:	50                   	push   %eax
   14e86:	81 c7 20 43 40 00    	add    $0x404320,%edi
   14e8c:	52                   	push   %edx
   14e8d:	68 76 83 02 00       	push   $0x28376
   14e92:	6a 1c                	push   $0x1c
   14e94:	57                   	push   %edi
   14e95:	e8 43 dd fe ff       	call   2bdd <snprintk>
   14e9a:	83 c4 14             	add    $0x14,%esp
	return iface_help_buffer[idx];
   14e9d:	89 f8                	mov    %edi,%eax
	entry->help  = set_iface_index_help(idx);
   14e9f:	89 46 04             	mov    %eax,0x4(%esi)
	entry->subcmd = &iface_index;
   14ea2:	c7 46 08 e8 60 02 00 	movl   $0x260e8,0x8(%esi)
	struct net_if *iface = net_if_get_by_index(idx);
   14ea9:	53                   	push   %ebx
   14eaa:	e8 ac a9 ff ff       	call   f85b <net_if_get_by_index>
   14eaf:	5a                   	pop    %edx
   14eb0:	89 c7                	mov    %eax,%edi
	if (!iface) {
   14eb2:	85 c0                	test   %eax,%eax
   14eb4:	74 18                	je     14ece <iface_index_get+0x7f>
	snprintk(iface_index_buffer[idx], MAX_IFACE_STR_LEN, "%zu", idx);
   14eb6:	53                   	push   %ebx
   14eb7:	8d 3c 9d 1c 43 40 00 	lea    0x40431c(,%ebx,4),%edi
   14ebe:	68 7e 83 02 00       	push   $0x2837e
   14ec3:	6a 04                	push   $0x4
   14ec5:	57                   	push   %edi
   14ec6:	e8 12 dd fe ff       	call   2bdd <snprintk>
   14ecb:	83 c4 10             	add    $0x10,%esp
	entry->syntax = set_iface_index_buffer(idx);
   14ece:	89 3e                	mov    %edi,(%esi)
}
   14ed0:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14ed3:	5b                   	pop    %ebx
   14ed4:	5e                   	pop    %esi
   14ed5:	5f                   	pop    %edi
   14ed6:	5d                   	pop    %ebp
   14ed7:	c3                   	ret    

00014ed8 <cmd_net_arp_flush>:
{
   14ed8:	55                   	push   %ebp
   14ed9:	89 e5                	mov    %esp,%ebp
	PR("Flushing ARP cache.\n");
   14edb:	68 82 83 02 00       	push   $0x28382
   14ee0:	6a 00                	push   $0x0
   14ee2:	ff 75 08             	pushl  0x8(%ebp)
   14ee5:	e8 d8 0c ff ff       	call   5bc2 <shell_fprintf>
   14eea:	83 c4 0c             	add    $0xc,%esp
	net_arp_clear_cache(NULL);
   14eed:	6a 00                	push   $0x0
   14eef:	e8 6e 73 ff ff       	call   c262 <net_arp_clear_cache>
   14ef4:	58                   	pop    %eax
}
   14ef5:	31 c0                	xor    %eax,%eax
   14ef7:	c9                   	leave  
   14ef8:	c3                   	ret    

00014ef9 <cmd_net_nbr>:
{
   14ef9:	55                   	push   %ebp
   14efa:	89 e5                	mov    %esp,%ebp
   14efc:	53                   	push   %ebx
   14efd:	83 ec 0c             	sub    $0xc,%esp
	user_data.user_data = &count;
   14f00:	8d 45 f0             	lea    -0x10(%ebp),%eax
{
   14f03:	8b 5d 08             	mov    0x8(%ebp),%ebx
	user_data.user_data = &count;
   14f06:	89 45 f8             	mov    %eax,-0x8(%ebp)
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
   14f09:	8d 45 f4             	lea    -0xc(%ebp),%eax
   14f0c:	50                   	push   %eax
	int count = 0;
   14f0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
   14f14:	68 16 59 01 00       	push   $0x15916
	user_data.shell = shell;
   14f19:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
   14f1c:	e8 65 d7 ff ff       	call   12686 <net_ipv6_nbr_foreach>
   14f21:	58                   	pop    %eax
   14f22:	5a                   	pop    %edx
	if (count == 0) {
   14f23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14f27:	75 10                	jne    14f39 <cmd_net_nbr+0x40>
		PR("No neighbors.\n");
   14f29:	68 97 83 02 00       	push   $0x28397
   14f2e:	6a 00                	push   $0x0
   14f30:	53                   	push   %ebx
   14f31:	e8 8c 0c ff ff       	call   5bc2 <shell_fprintf>
   14f36:	83 c4 0c             	add    $0xc,%esp
}
   14f39:	31 c0                	xor    %eax,%eax
   14f3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14f3e:	c9                   	leave  
   14f3f:	c3                   	ret    

00014f40 <nbr_address_cb>:
{
   14f40:	55                   	push   %ebp
   14f41:	89 e5                	mov    %esp,%ebp
   14f43:	53                   	push   %ebx
   14f44:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (*count >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
   14f47:	83 3b 07             	cmpl   $0x7,(%ebx)
   14f4a:	7f 2e                	jg     14f7a <nbr_address_cb+0x3a>
		 "%s", net_sprint_ipv6_addr(&net_ipv6_nbr_data(nbr)->addr));
   14f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14f4f:	8b 40 0c             	mov    0xc(%eax),%eax
   14f52:	83 c0 04             	add    $0x4,%eax
	snprintk(nbr_address_buffer[*count], NET_IPV6_ADDR_LEN,
   14f55:	50                   	push   %eax
   14f56:	6a 02                	push   $0x2
   14f58:	e8 41 bb ff ff       	call   10a9e <net_sprint_addr>
   14f5d:	5a                   	pop    %edx
   14f5e:	59                   	pop    %ecx
   14f5f:	50                   	push   %eax
   14f60:	6b 03 28             	imul   $0x28,(%ebx),%eax
   14f63:	68 6a a5 02 00       	push   $0x2a56a
   14f68:	05 e0 0f 40 00       	add    $0x400fe0,%eax
   14f6d:	6a 28                	push   $0x28
   14f6f:	50                   	push   %eax
   14f70:	e8 68 dc fe ff       	call   2bdd <snprintk>
	(*count)++;
   14f75:	ff 03                	incl   (%ebx)
	snprintk(nbr_address_buffer[*count], NET_IPV6_ADDR_LEN,
   14f77:	83 c4 10             	add    $0x10,%esp
}
   14f7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14f7d:	c9                   	leave  
   14f7e:	c3                   	ret    

00014f7f <get_iface_idx>:
{
   14f7f:	55                   	push   %ebp
	if (!index_str) {
   14f80:	85 d2                	test   %edx,%edx
{
   14f82:	89 e5                	mov    %esp,%ebp
   14f84:	56                   	push   %esi
   14f85:	53                   	push   %ebx
   14f86:	89 c3                	mov    %eax,%ebx
   14f88:	51                   	push   %ecx
	if (!index_str) {
   14f89:	75 17                	jne    14fa2 <get_iface_idx+0x23>
		PR_WARNING("Interface index is missing.\n");
   14f8b:	68 a6 83 02 00       	push   $0x283a6
   14f90:	6a 04                	push   $0x4
   14f92:	50                   	push   %eax
   14f93:	e8 2a 0c ff ff       	call   5bc2 <shell_fprintf>
   14f98:	83 c4 0c             	add    $0xc,%esp
   14f9b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   14fa0:	eb 4e                	jmp    14ff0 <get_iface_idx+0x71>
	idx = strtol(index_str, &endptr, 10);
   14fa2:	6a 0a                	push   $0xa
   14fa4:	8d 45 f4             	lea    -0xc(%ebp),%eax
   14fa7:	50                   	push   %eax
   14fa8:	89 d6                	mov    %edx,%esi
   14faa:	52                   	push   %edx
   14fab:	e8 3b 55 ff ff       	call   a4eb <strtol>
	if (*endptr != '\0') {
   14fb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
	idx = strtol(index_str, &endptr, 10);
   14fb3:	83 c4 0c             	add    $0xc,%esp
	if (*endptr != '\0') {
   14fb6:	80 3a 00             	cmpb   $0x0,(%edx)
   14fb9:	74 18                	je     14fd3 <get_iface_idx+0x54>
		PR_WARNING("Invalid index %s\n", index_str);
   14fbb:	56                   	push   %esi
   14fbc:	68 c3 83 02 00       	push   $0x283c3
   14fc1:	6a 04                	push   $0x4
   14fc3:	53                   	push   %ebx
   14fc4:	e8 f9 0b ff ff       	call   5bc2 <shell_fprintf>
   14fc9:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
   14fcc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   14fd1:	eb 1d                	jmp    14ff0 <get_iface_idx+0x71>
	if (idx < 0 || idx > 255) {
   14fd3:	3d ff 00 00 00       	cmp    $0xff,%eax
   14fd8:	76 16                	jbe    14ff0 <get_iface_idx+0x71>
		PR_WARNING("Invalid index %d\n", idx);
   14fda:	50                   	push   %eax
   14fdb:	68 d5 83 02 00       	push   $0x283d5
   14fe0:	6a 04                	push   $0x4
   14fe2:	53                   	push   %ebx
   14fe3:	e8 da 0b ff ff       	call   5bc2 <shell_fprintf>
   14fe8:	83 c4 10             	add    $0x10,%esp
		return -ERANGE;
   14feb:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
   14ff0:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14ff3:	5b                   	pop    %ebx
   14ff4:	5e                   	pop    %esi
   14ff5:	5d                   	pop    %ebp
   14ff6:	c3                   	ret    

00014ff7 <cmd_net_iface>:
{
   14ff7:	55                   	push   %ebp
   14ff8:	89 e5                	mov    %esp,%ebp
   14ffa:	56                   	push   %esi
   14ffb:	53                   	push   %ebx
   14ffc:	83 ec 08             	sub    $0x8,%esp
	if (argv[1]) {
   14fff:	8b 45 10             	mov    0x10(%ebp),%eax
{
   15002:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (argv[1]) {
   15005:	8b 40 04             	mov    0x4(%eax),%eax
   15008:	85 c0                	test   %eax,%eax
   1500a:	74 37                	je     15043 <cmd_net_iface+0x4c>
		idx = get_iface_idx(shell, argv[1]);
   1500c:	89 c2                	mov    %eax,%edx
   1500e:	89 d8                	mov    %ebx,%eax
   15010:	e8 6a ff ff ff       	call   14f7f <get_iface_idx>
   15015:	89 c6                	mov    %eax,%esi
			return -ENOEXEC;
   15017:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
		if (idx < 0) {
   1501c:	85 f6                	test   %esi,%esi
   1501e:	78 3b                	js     1505b <cmd_net_iface+0x64>
		iface = net_if_get_by_index(idx);
   15020:	56                   	push   %esi
   15021:	e8 35 a8 ff ff       	call   f85b <net_if_get_by_index>
   15026:	59                   	pop    %ecx
		if (!iface) {
   15027:	85 c0                	test   %eax,%eax
   15029:	75 18                	jne    15043 <cmd_net_iface+0x4c>
			PR_WARNING("No such interface in index %d\n", idx);
   1502b:	56                   	push   %esi
   1502c:	68 e7 83 02 00       	push   $0x283e7
   15031:	6a 04                	push   $0x4
   15033:	53                   	push   %ebx
   15034:	e8 89 0b ff ff       	call   5bc2 <shell_fprintf>
   15039:	83 c4 10             	add    $0x10,%esp
			return -ENOEXEC;
   1503c:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   15041:	eb 18                	jmp    1505b <cmd_net_iface+0x64>
	user_data.user_data = iface;
   15043:	89 45 f4             	mov    %eax,-0xc(%ebp)
	net_if_foreach(iface_cb, &user_data);
   15046:	8d 45 f0             	lea    -0x10(%ebp),%eax
   15049:	50                   	push   %eax
	user_data.shell = shell;
   1504a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	net_if_foreach(iface_cb, &user_data);
   1504d:	68 46 5a 01 00       	push   $0x15a46
   15052:	e8 48 a8 ff ff       	call   f89f <net_if_foreach>
   15057:	58                   	pop    %eax
	return 0;
   15058:	31 c0                	xor    %eax,%eax
	net_if_foreach(iface_cb, &user_data);
   1505a:	5a                   	pop    %edx
}
   1505b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1505e:	5b                   	pop    %ebx
   1505f:	5e                   	pop    %esi
   15060:	5d                   	pop    %ebp
   15061:	c3                   	ret    

00015062 <cmd_net_iface_down>:
{
   15062:	55                   	push   %ebp
   15063:	89 e5                	mov    %esp,%ebp
   15065:	56                   	push   %esi
   15066:	53                   	push   %ebx
   15067:	53                   	push   %ebx
	idx = get_iface_idx(shell, argv[1]);
   15068:	8b 45 10             	mov    0x10(%ebp),%eax
{
   1506b:	8b 75 08             	mov    0x8(%ebp),%esi
	idx = get_iface_idx(shell, argv[1]);
   1506e:	8b 50 04             	mov    0x4(%eax),%edx
   15071:	89 f0                	mov    %esi,%eax
   15073:	e8 07 ff ff ff       	call   14f7f <get_iface_idx>
   15078:	89 c3                	mov    %eax,%ebx
		return -ENOEXEC;
   1507a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	if (idx < 0) {
   1507f:	85 db                	test   %ebx,%ebx
   15081:	78 59                	js     150dc <cmd_net_iface_down+0x7a>
	iface = net_if_get_by_index(idx);
   15083:	53                   	push   %ebx
   15084:	e8 d2 a7 ff ff       	call   f85b <net_if_get_by_index>
   15089:	59                   	pop    %ecx
	if (!iface) {
   1508a:	85 c0                	test   %eax,%eax
   1508c:	75 13                	jne    150a1 <cmd_net_iface_down+0x3f>
		PR_WARNING("No such interface in index %d\n", idx);
   1508e:	53                   	push   %ebx
   1508f:	68 e7 83 02 00       	push   $0x283e7
   15094:	6a 04                	push   $0x4
   15096:	56                   	push   %esi
   15097:	e8 26 0b ff ff       	call   5bc2 <shell_fprintf>
   1509c:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
   1509f:	eb 1d                	jmp    150be <cmd_net_iface_down+0x5c>
	ret = net_if_down(iface);
   150a1:	50                   	push   %eax
   150a2:	e8 79 a8 ff ff       	call   f920 <net_if_down>
   150a7:	5a                   	pop    %edx
	if (ret) {
   150a8:	85 c0                	test   %eax,%eax
   150aa:	74 19                	je     150c5 <cmd_net_iface_down+0x63>
		PR_WARNING("Cannot take interface %d down (%d)\n", idx, ret);
   150ac:	50                   	push   %eax
   150ad:	53                   	push   %ebx
   150ae:	68 06 84 02 00       	push   $0x28406
   150b3:	6a 04                	push   $0x4
   150b5:	56                   	push   %esi
   150b6:	e8 07 0b ff ff       	call   5bc2 <shell_fprintf>
   150bb:	83 c4 14             	add    $0x14,%esp
		return -ENOEXEC;
   150be:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   150c3:	eb 17                	jmp    150dc <cmd_net_iface_down+0x7a>
		PR("Interface %d is down\n", idx);
   150c5:	53                   	push   %ebx
   150c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   150c9:	68 2a 84 02 00       	push   $0x2842a
   150ce:	6a 00                	push   $0x0
   150d0:	56                   	push   %esi
   150d1:	e8 ec 0a ff ff       	call   5bc2 <shell_fprintf>
   150d6:	83 c4 10             	add    $0x10,%esp
   150d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   150dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
   150df:	5b                   	pop    %ebx
   150e0:	5e                   	pop    %esi
   150e1:	5d                   	pop    %ebp
   150e2:	c3                   	ret    

000150e3 <cmd_net_conn>:
{
   150e3:	55                   	push   %ebp
   150e4:	89 e5                	mov    %esp,%ebp
   150e6:	53                   	push   %ebx
   150e7:	83 ec 0c             	sub    $0xc,%esp
   150ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int count = 0;
   150ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	PR("     Context   \tIface         Flags Local           \tRemote\n");
   150f4:	68 40 84 02 00       	push   $0x28440
   150f9:	6a 00                	push   $0x0
   150fb:	53                   	push   %ebx
   150fc:	e8 c1 0a ff ff       	call   5bc2 <shell_fprintf>
   15101:	83 c4 0c             	add    $0xc,%esp
	user_data.user_data = &count;
   15104:	8d 45 f0             	lea    -0x10(%ebp),%eax
   15107:	89 45 f8             	mov    %eax,-0x8(%ebp)
	net_context_foreach(context_cb, &user_data);
   1510a:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1510d:	50                   	push   %eax
	user_data.shell = shell;
   1510e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	net_context_foreach(context_cb, &user_data);
   15111:	68 88 51 01 00       	push   $0x15188
   15116:	e8 b2 85 ff ff       	call   d6cd <net_context_foreach>
   1511b:	58                   	pop    %eax
   1511c:	5a                   	pop    %edx
	if (count == 0) {
   1511d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15121:	75 10                	jne    15133 <cmd_net_conn+0x50>
		PR("No connections\n");
   15123:	68 7d 84 02 00       	push   $0x2847d
   15128:	6a 00                	push   $0x0
   1512a:	53                   	push   %ebx
   1512b:	e8 92 0a ff ff       	call   5bc2 <shell_fprintf>
   15130:	83 c4 0c             	add    $0xc,%esp
}
   15133:	31 c0                	xor    %eax,%eax
   15135:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15138:	c9                   	leave  
   15139:	c3                   	ret    

0001513a <cmd_net_arp>:
{
   1513a:	55                   	push   %ebp
   1513b:	89 e5                	mov    %esp,%ebp
   1513d:	53                   	push   %ebx
   1513e:	83 ec 0c             	sub    $0xc,%esp
	if (!argv[arg]) {
   15141:	8b 45 10             	mov    0x10(%ebp),%eax
{
   15144:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!argv[arg]) {
   15147:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   1514b:	75 34                	jne    15181 <cmd_net_arp+0x47>
		user_data.user_data = &count;
   1514d:	8d 45 f0             	lea    -0x10(%ebp),%eax
		int count = 0;
   15150:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		user_data.user_data = &count;
   15157:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
   1515a:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1515d:	50                   	push   %eax
		user_data.shell = shell;
   1515e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
   15161:	68 1f 55 01 00       	push   $0x1551f
   15166:	e8 e4 71 ff ff       	call   c34f <net_arp_foreach>
   1516b:	5a                   	pop    %edx
   1516c:	85 c0                	test   %eax,%eax
   1516e:	59                   	pop    %ecx
   1516f:	75 10                	jne    15181 <cmd_net_arp+0x47>
			PR("ARP cache is empty.\n");
   15171:	68 8d 84 02 00       	push   $0x2848d
   15176:	6a 00                	push   $0x0
   15178:	53                   	push   %ebx
   15179:	e8 44 0a ff ff       	call   5bc2 <shell_fprintf>
   1517e:	83 c4 0c             	add    $0xc,%esp
}
   15181:	31 c0                	xor    %eax,%eax
   15183:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15186:	c9                   	leave  
   15187:	c3                   	ret    

00015188 <context_cb>:
{
   15188:	55                   	push   %ebp
	char addr_remote[ADDR_LEN + 7] = "";
   15189:	b9 2b 00 00 00       	mov    $0x2b,%ecx
{
   1518e:	89 e5                	mov    %esp,%ebp
   15190:	57                   	push   %edi
   15191:	56                   	push   %esi
   15192:	53                   	push   %ebx
   15193:	83 ec 6c             	sub    $0x6c,%esp
	char addr_remote[ADDR_LEN + 7] = "";
   15196:	c7 45 c5 00 00 00 00 	movl   $0x0,-0x3b(%ebp)
{
   1519d:	8b 45 0c             	mov    0xc(%ebp),%eax
   151a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct shell *shell = data->shell;
   151a3:	8b 38                	mov    (%eax),%edi
	int *count = data->user_data;
   151a5:	8b 40 04             	mov    0x4(%eax),%eax
	const struct shell *shell = data->shell;
   151a8:	89 7d 8c             	mov    %edi,-0x74(%ebp)
	int *count = data->user_data;
   151ab:	89 45 90             	mov    %eax,-0x70(%ebp)
	char addr_remote[ADDR_LEN + 7] = "";
   151ae:	8d 7d c9             	lea    -0x37(%ebp),%edi
   151b1:	31 c0                	xor    %eax,%eax
   151b3:	f3 aa                	rep stos %al,%es:(%edi)
	if (context->local.family == AF_INET6) {
   151b5:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
   151b9:	66 83 f8 02          	cmp    $0x2,%ax
   151bd:	75 4d                	jne    1520c <context_cb+0x84>
			 ntohs(net_sin6_ptr(&context->local)->sin6_port));
   151bf:	66 8b 73 26          	mov    0x26(%ebx),%si
		snprintk(addr_local, local_len, "[%s]:%u",
   151c3:	ff 73 28             	pushl  0x28(%ebx)
			 ntohs(net_sin6_ptr(&context->local)->sin6_port));
   151c6:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_local, local_len, "[%s]:%u",
   151ca:	6a 02                	push   $0x2
   151cc:	e8 cd b8 ff ff       	call   10a9e <net_sprint_addr>
   151d1:	59                   	pop    %ecx
   151d2:	5f                   	pop    %edi
   151d3:	0f b7 f6             	movzwl %si,%esi
   151d6:	56                   	push   %esi
   151d7:	50                   	push   %eax
   151d8:	8d 45 96             	lea    -0x6a(%ebp),%eax
   151db:	68 a2 84 02 00       	push   $0x284a2
   151e0:	6a 2f                	push   $0x2f
   151e2:	50                   	push   %eax
   151e3:	e8 f5 d9 fe ff       	call   2bdd <snprintk>
   151e8:	83 c4 14             	add    $0x14,%esp
			 net_sprint_ipv6_addr(
   151eb:	8d 43 34             	lea    0x34(%ebx),%eax
			 ntohs(net_sin6(&context->remote)->sin6_port));
   151ee:	66 8b 73 32          	mov    0x32(%ebx),%si
		snprintk(addr_remote, remote_len, "[%s]:%u",
   151f2:	50                   	push   %eax
   151f3:	6a 02                	push   $0x2
   151f5:	e8 a4 b8 ff ff       	call   10a9e <net_sprint_addr>
			 ntohs(net_sin6(&context->remote)->sin6_port));
   151fa:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_remote, remote_len, "[%s]:%u",
   151fe:	5a                   	pop    %edx
   151ff:	59                   	pop    %ecx
   15200:	0f b7 f6             	movzwl %si,%esi
   15203:	56                   	push   %esi
   15204:	50                   	push   %eax
   15205:	68 a2 84 02 00       	push   $0x284a2
   1520a:	eb 51                	jmp    1525d <context_cb+0xd5>
	if (context->local.family == AF_INET) {
   1520c:	66 83 f8 01          	cmp    $0x1,%ax
   15210:	75 5b                	jne    1526d <context_cb+0xe5>
			 ntohs(net_sin_ptr(&context->local)->sin_port));
   15212:	66 8b 73 26          	mov    0x26(%ebx),%si
		snprintk(addr_local, local_len, "%s:%d",
   15216:	ff 73 28             	pushl  0x28(%ebx)
			 ntohs(net_sin_ptr(&context->local)->sin_port));
   15219:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_local, local_len, "%s:%d",
   1521d:	6a 01                	push   $0x1
   1521f:	e8 7a b8 ff ff       	call   10a9e <net_sprint_addr>
   15224:	5a                   	pop    %edx
   15225:	59                   	pop    %ecx
   15226:	0f b7 f6             	movzwl %si,%esi
   15229:	56                   	push   %esi
   1522a:	50                   	push   %eax
   1522b:	8d 45 96             	lea    -0x6a(%ebp),%eax
   1522e:	68 aa 84 02 00       	push   $0x284aa
   15233:	6a 2f                	push   $0x2f
   15235:	50                   	push   %eax
   15236:	e8 a2 d9 fe ff       	call   2bdd <snprintk>
   1523b:	83 c4 14             	add    $0x14,%esp
			 net_sprint_ipv4_addr(
   1523e:	8d 43 34             	lea    0x34(%ebx),%eax
			 ntohs(net_sin(&context->remote)->sin_port));
   15241:	66 8b 73 32          	mov    0x32(%ebx),%si
		snprintk(addr_remote, remote_len, "%s:%d",
   15245:	50                   	push   %eax
   15246:	6a 01                	push   $0x1
   15248:	e8 51 b8 ff ff       	call   10a9e <net_sprint_addr>
			 ntohs(net_sin(&context->remote)->sin_port));
   1524d:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_remote, remote_len, "%s:%d",
   15251:	5f                   	pop    %edi
   15252:	5a                   	pop    %edx
   15253:	0f b7 f6             	movzwl %si,%esi
   15256:	56                   	push   %esi
   15257:	50                   	push   %eax
   15258:	68 aa 84 02 00       	push   $0x284aa
   1525d:	6a 2f                	push   $0x2f
   1525f:	8d 45 c5             	lea    -0x3b(%ebp),%eax
   15262:	50                   	push   %eax
   15263:	e8 75 d9 fe ff       	call   2bdd <snprintk>
   15268:	83 c4 14             	add    $0x14,%esp
   1526b:	eb 45                	jmp    152b2 <context_cb+0x12a>
	if (context->local.family == AF_UNSPEC) {
   1526d:	66 85 c0             	test   %ax,%ax
   15270:	8d 55 96             	lea    -0x6a(%ebp),%edx
   15273:	75 07                	jne    1527c <context_cb+0xf4>
		snprintk(addr_local, local_len, "AF_UNSPEC");
   15275:	68 b0 84 02 00       	push   $0x284b0
   1527a:	eb 18                	jmp    15294 <context_cb+0x10c>
	} else if (context->local.family == AF_PACKET) {
   1527c:	66 83 f8 03          	cmp    $0x3,%ax
   15280:	75 07                	jne    15289 <context_cb+0x101>
		snprintk(addr_local, local_len, "AF_PACKET");
   15282:	68 ba 84 02 00       	push   $0x284ba
   15287:	eb 0b                	jmp    15294 <context_cb+0x10c>
	} else if (context->local.family == AF_CAN) {
   15289:	66 83 f8 04          	cmp    $0x4,%ax
   1528d:	75 12                	jne    152a1 <context_cb+0x119>
		snprintk(addr_local, local_len, "AF_CAN");
   1528f:	68 c4 84 02 00       	push   $0x284c4
   15294:	6a 2f                	push   $0x2f
   15296:	52                   	push   %edx
   15297:	e8 41 d9 fe ff       	call   2bdd <snprintk>
   1529c:	83 c4 0c             	add    $0xc,%esp
   1529f:	eb 11                	jmp    152b2 <context_cb+0x12a>
		snprintk(addr_local, local_len, "AF_UNK(%d)",
   152a1:	50                   	push   %eax
   152a2:	68 cb 84 02 00       	push   $0x284cb
   152a7:	6a 2f                	push   $0x2f
   152a9:	52                   	push   %edx
   152aa:	e8 2e d9 fe ff       	call   2bdd <snprintk>
   152af:	83 c4 10             	add    $0x10,%esp
	PR("[%2d] %p\t%p    %c%c%c   %16s\t%16s\n",
   152b2:	66 8b 83 90 00 00 00 	mov    0x90(%ebx),%ax
   152b9:	ba 55 00 00 00       	mov    $0x55,%edx
   152be:	66 83 f8 11          	cmp    $0x11,%ax
   152c2:	74 10                	je     152d4 <context_cb+0x14c>
   152c4:	31 d2                	xor    %edx,%edx
   152c6:	66 83 f8 06          	cmp    $0x6,%ax
   152ca:	0f 94 c2             	sete   %dl
   152cd:	4a                   	dec    %edx
   152ce:	83 e2 cc             	and    $0xffffffcc,%edx
   152d1:	83 c2 54             	add    $0x54,%edx
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   152d4:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
   152db:	89 c1                	mov    %eax,%ecx
   152dd:	be 44 00 00 00       	mov    $0x44,%esi
   152e2:	c1 e9 06             	shr    $0x6,%ecx
   152e5:	83 e1 03             	and    $0x3,%ecx
   152e8:	83 f9 02             	cmp    $0x2,%ecx
   152eb:	74 1c                	je     15309 <context_cb+0x181>
   152ed:	be 53 00 00 00       	mov    $0x53,%esi
   152f2:	83 f9 01             	cmp    $0x1,%ecx
   152f5:	74 12                	je     15309 <context_cb+0x181>
   152f7:	83 f9 03             	cmp    $0x3,%ecx
   152fa:	0f 94 c1             	sete   %cl
   152fd:	0f b6 c9             	movzbl %cl,%ecx
   15300:	89 ce                	mov    %ecx,%esi
   15302:	4e                   	dec    %esi
   15303:	83 e6 ce             	and    $0xffffffce,%esi
   15306:	83 c6 52             	add    $0x52,%esi
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   15309:	c1 e8 03             	shr    $0x3,%eax
   1530c:	bf 36 00 00 00       	mov    $0x36,%edi
   15311:	83 e0 07             	and    $0x7,%eax
   15314:	66 83 f8 02          	cmp    $0x2,%ax
   15318:	74 11                	je     1532b <context_cb+0x1a3>
   1531a:	66 48                	dec    %ax
   1531c:	0f 94 c0             	sete   %al
   1531f:	0f b6 c0             	movzbl %al,%eax
   15322:	89 c7                	mov    %eax,%edi
   15324:	4f                   	dec    %edi
   15325:	83 e7 ec             	and    $0xffffffec,%edi
   15328:	83 c7 34             	add    $0x34,%edi
	return net_if_get_by_index(context->iface);
   1532b:	0f be 83 94 00 00 00 	movsbl 0x94(%ebx),%eax
   15332:	89 55 88             	mov    %edx,-0x78(%ebp)
   15335:	50                   	push   %eax
   15336:	e8 20 a5 ff ff       	call   f85b <net_if_get_by_index>
   1533b:	8d 4d c5             	lea    -0x3b(%ebp),%ecx
   1533e:	89 0c 24             	mov    %ecx,(%esp)
   15341:	8d 4d 96             	lea    -0x6a(%ebp),%ecx
   15344:	51                   	push   %ecx
   15345:	8b 55 88             	mov    -0x78(%ebp),%edx
   15348:	52                   	push   %edx
   15349:	56                   	push   %esi
   1534a:	57                   	push   %edi
   1534b:	50                   	push   %eax
   1534c:	8b 45 90             	mov    -0x70(%ebp),%eax
   1534f:	53                   	push   %ebx
   15350:	8b 00                	mov    (%eax),%eax
   15352:	89 45 88             	mov    %eax,-0x78(%ebp)
   15355:	40                   	inc    %eax
   15356:	50                   	push   %eax
   15357:	68 d6 84 02 00       	push   $0x284d6
   1535c:	6a 00                	push   $0x0
   1535e:	ff 75 8c             	pushl  -0x74(%ebp)
   15361:	e8 5c 08 ff ff       	call   5bc2 <shell_fprintf>
	(*count)++;
   15366:	8b 45 90             	mov    -0x70(%ebp),%eax
   15369:	ff 00                	incl   (%eax)
	PR("[%2d] %p\t%p    %c%c%c   %16s\t%16s\n",
   1536b:	83 c4 2c             	add    $0x2c,%esp
}
   1536e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15371:	5b                   	pop    %ebx
   15372:	5e                   	pop    %esi
   15373:	5f                   	pop    %edi
   15374:	5d                   	pop    %ebp
   15375:	c3                   	ret    

00015376 <cmd_net_vlan_del>:
   15376:	55                   	push   %ebp
   15377:	89 e5                	mov    %esp,%ebp
   15379:	68 04 7e 02 00       	push   $0x27e04
   1537e:	6a 03                	push   $0x3
   15380:	ff 75 08             	pushl  0x8(%ebp)
   15383:	e8 3a 08 ff ff       	call   5bc2 <shell_fprintf>
   15388:	83 c4 0c             	add    $0xc,%esp
   1538b:	31 c0                	xor    %eax,%eax
   1538d:	c9                   	leave  
   1538e:	c3                   	ret    

0001538f <cmd_net_dns_query>:
   1538f:	55                   	push   %ebp
   15390:	89 e5                	mov    %esp,%ebp
   15392:	68 4c 7f 02 00       	push   $0x27f4c
   15397:	6a 03                	push   $0x3
   15399:	ff 75 08             	pushl  0x8(%ebp)
   1539c:	e8 21 08 ff ff       	call   5bc2 <shell_fprintf>
   153a1:	83 c4 0c             	add    $0xc,%esp
   153a4:	31 c0                	xor    %eax,%eax
   153a6:	c9                   	leave  
   153a7:	c3                   	ret    

000153a8 <cmd_net_dns>:
   153a8:	55                   	push   %ebp
   153a9:	89 e5                	mov    %esp,%ebp
   153ab:	68 4c 7f 02 00       	push   $0x27f4c
   153b0:	6a 03                	push   $0x3
   153b2:	ff 75 08             	pushl  0x8(%ebp)
   153b5:	e8 08 08 ff ff       	call   5bc2 <shell_fprintf>
   153ba:	83 c4 0c             	add    $0xc,%esp
   153bd:	31 c0                	xor    %eax,%eax
   153bf:	c9                   	leave  
   153c0:	c3                   	ret    

000153c1 <cmd_net_gptp>:
   153c1:	55                   	push   %ebp
   153c2:	89 e5                	mov    %esp,%ebp
   153c4:	68 15 7f 02 00       	push   $0x27f15
   153c9:	6a 03                	push   $0x3
   153cb:	ff 75 08             	pushl  0x8(%ebp)
   153ce:	e8 ef 07 ff ff       	call   5bc2 <shell_fprintf>
   153d3:	83 c4 0c             	add    $0xc,%esp
   153d6:	31 c0                	xor    %eax,%eax
   153d8:	c9                   	leave  
   153d9:	c3                   	ret    

000153da <cmd_net_stats_iface>:
   153da:	55                   	push   %ebp
   153db:	89 e5                	mov    %esp,%ebp
   153dd:	68 6b 7e 02 00       	push   $0x27e6b
   153e2:	6a 03                	push   $0x3
   153e4:	ff 75 08             	pushl  0x8(%ebp)
   153e7:	e8 d6 07 ff ff       	call   5bc2 <shell_fprintf>
   153ec:	83 c4 0c             	add    $0xc,%esp
   153ef:	31 c0                	xor    %eax,%eax
   153f1:	c9                   	leave  
   153f2:	c3                   	ret    

000153f3 <cmd_net_stats>:
   153f3:	55                   	push   %ebp
   153f4:	89 e5                	mov    %esp,%ebp
   153f6:	68 6b 7e 02 00       	push   $0x27e6b
   153fb:	6a 03                	push   $0x3
   153fd:	ff 75 08             	pushl  0x8(%ebp)
   15400:	e8 bd 07 ff ff       	call   5bc2 <shell_fprintf>
   15405:	83 c4 0c             	add    $0xc,%esp
   15408:	31 c0                	xor    %eax,%eax
   1540a:	c9                   	leave  
   1540b:	c3                   	ret    

0001540c <cmd_net_tcp_send>:
   1540c:	55                   	push   %ebp
   1540d:	89 e5                	mov    %esp,%ebp
   1540f:	68 38 7e 02 00       	push   $0x27e38
   15414:	6a 03                	push   $0x3
   15416:	ff 75 08             	pushl  0x8(%ebp)
   15419:	e8 a4 07 ff ff       	call   5bc2 <shell_fprintf>
   1541e:	83 c4 0c             	add    $0xc,%esp
   15421:	31 c0                	xor    %eax,%eax
   15423:	c9                   	leave  
   15424:	c3                   	ret    

00015425 <cmd_net_tcp_close>:
   15425:	55                   	push   %ebp
   15426:	89 e5                	mov    %esp,%ebp
   15428:	68 38 7e 02 00       	push   $0x27e38
   1542d:	6a 03                	push   $0x3
   1542f:	ff 75 08             	pushl  0x8(%ebp)
   15432:	e8 8b 07 ff ff       	call   5bc2 <shell_fprintf>
   15437:	83 c4 0c             	add    $0xc,%esp
   1543a:	31 c0                	xor    %eax,%eax
   1543c:	c9                   	leave  
   1543d:	c3                   	ret    

0001543e <cmd_net_vlan_add>:
   1543e:	55                   	push   %ebp
   1543f:	89 e5                	mov    %esp,%ebp
   15441:	68 04 7e 02 00       	push   $0x27e04
   15446:	6a 03                	push   $0x3
   15448:	ff 75 08             	pushl  0x8(%ebp)
   1544b:	e8 72 07 ff ff       	call   5bc2 <shell_fprintf>
   15450:	83 c4 0c             	add    $0xc,%esp
   15453:	31 c0                	xor    %eax,%eax
   15455:	c9                   	leave  
   15456:	c3                   	ret    

00015457 <_handle_ipv6_echo_reply>:
{
   15457:	55                   	push   %ebp
   15458:	89 e5                	mov    %esp,%ebp
   1545a:	56                   	push   %esi
   1545b:	53                   	push   %ebx
   1545c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PR_SHELL(shell_for_ping, "Received echo reply from %s to %s\n",
   1545f:	8d 43 18             	lea    0x18(%ebx),%eax
   15462:	83 c3 08             	add    $0x8,%ebx
   15465:	50                   	push   %eax
   15466:	6a 02                	push   $0x2
   15468:	e8 31 b6 ff ff       	call   10a9e <net_sprint_addr>
   1546d:	5a                   	pop    %edx
   1546e:	89 c6                	mov    %eax,%esi
   15470:	59                   	pop    %ecx
   15471:	53                   	push   %ebx
   15472:	6a 02                	push   $0x2
   15474:	e8 25 b6 ff ff       	call   10a9e <net_sprint_addr>
   15479:	5b                   	pop    %ebx
   1547a:	5a                   	pop    %edx
   1547b:	56                   	push   %esi
   1547c:	50                   	push   %eax
   1547d:	68 f9 84 02 00       	push   $0x284f9
   15482:	6a 00                	push   $0x0
   15484:	ff 35 3c 43 40 00    	pushl  0x40433c
   1548a:	e8 33 07 ff ff       	call   5bc2 <shell_fprintf>
   1548f:	83 c4 14             	add    $0x14,%esp
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   15492:	68 c0 a9 40 00       	push   $0x40a9c0
   15497:	e8 3d eb 00 00       	call   23fd9 <z_impl_k_sem_give>
	net_icmpv6_unregister_handler(&ping6_handler);
   1549c:	c7 04 24 f0 a6 40 00 	movl   $0x40a6f0,(%esp)
   154a3:	e8 d8 c1 ff ff       	call   11680 <net_icmpv6_unregister_handler>
   154a8:	59                   	pop    %ecx
	net_pkt_unref(pkt);
   154a9:	ff 75 08             	pushl  0x8(%ebp)
   154ac:	e8 50 a9 ff ff       	call   fe01 <net_pkt_unref>
}
   154b1:	31 c0                	xor    %eax,%eax
	net_pkt_unref(pkt);
   154b3:	5b                   	pop    %ebx
}
   154b4:	8d 65 f8             	lea    -0x8(%ebp),%esp
   154b7:	5b                   	pop    %ebx
   154b8:	5e                   	pop    %esi
   154b9:	5d                   	pop    %ebp
   154ba:	c3                   	ret    

000154bb <_handle_ipv4_echo_reply>:
{
   154bb:	55                   	push   %ebp
   154bc:	89 e5                	mov    %esp,%ebp
   154be:	56                   	push   %esi
   154bf:	53                   	push   %ebx
   154c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PR_SHELL(shell_for_ping, "Received echo reply from %s to %s\n",
   154c3:	8d 43 10             	lea    0x10(%ebx),%eax
   154c6:	83 c3 0c             	add    $0xc,%ebx
   154c9:	50                   	push   %eax
   154ca:	6a 01                	push   $0x1
   154cc:	e8 cd b5 ff ff       	call   10a9e <net_sprint_addr>
   154d1:	5a                   	pop    %edx
   154d2:	89 c6                	mov    %eax,%esi
   154d4:	59                   	pop    %ecx
   154d5:	53                   	push   %ebx
   154d6:	6a 01                	push   $0x1
   154d8:	e8 c1 b5 ff ff       	call   10a9e <net_sprint_addr>
   154dd:	5b                   	pop    %ebx
   154de:	5a                   	pop    %edx
   154df:	56                   	push   %esi
   154e0:	50                   	push   %eax
   154e1:	68 f9 84 02 00       	push   $0x284f9
   154e6:	6a 00                	push   $0x0
   154e8:	ff 35 3c 43 40 00    	pushl  0x40433c
   154ee:	e8 cf 06 ff ff       	call   5bc2 <shell_fprintf>
   154f3:	83 c4 14             	add    $0x14,%esp
   154f6:	68 c0 a9 40 00       	push   $0x40a9c0
   154fb:	e8 d9 ea 00 00       	call   23fd9 <z_impl_k_sem_give>
	net_icmpv4_unregister_handler(&ping4_handler);
   15500:	c7 04 24 e4 a6 40 00 	movl   $0x40a6e4,(%esp)
   15507:	e8 3c bd ff ff       	call   11248 <net_icmpv4_unregister_handler>
   1550c:	59                   	pop    %ecx
	net_pkt_unref(pkt);
   1550d:	ff 75 08             	pushl  0x8(%ebp)
   15510:	e8 ec a8 ff ff       	call   fe01 <net_pkt_unref>
}
   15515:	31 c0                	xor    %eax,%eax
	net_pkt_unref(pkt);
   15517:	5b                   	pop    %ebx
}
   15518:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1551b:	5b                   	pop    %ebx
   1551c:	5e                   	pop    %esi
   1551d:	5d                   	pop    %ebp
   1551e:	c3                   	ret    

0001551f <arp_cb>:
{
   1551f:	55                   	push   %ebp
   15520:	89 e5                	mov    %esp,%ebp
   15522:	57                   	push   %edi
   15523:	56                   	push   %esi
   15524:	53                   	push   %ebx
   15525:	53                   	push   %ebx
   15526:	8b 45 0c             	mov    0xc(%ebp),%eax
   15529:	8b 75 08             	mov    0x8(%ebp),%esi
	int *count = data->user_data;
   1552c:	8b 58 04             	mov    0x4(%eax),%ebx
	const struct shell *shell = data->shell;
   1552f:	8b 38                	mov    (%eax),%edi
	if (*count == 0) {
   15531:	83 3b 00             	cmpl   $0x0,(%ebx)
   15534:	75 10                	jne    15546 <arp_cb+0x27>
		PR("     Interface  Link              Address\n");
   15536:	68 1c 85 02 00       	push   $0x2851c
   1553b:	6a 00                	push   $0x0
   1553d:	57                   	push   %edi
   1553e:	e8 7f 06 ff ff       	call   5bc2 <shell_fprintf>
   15543:	83 c4 0c             	add    $0xc,%esp
	PR("[%2d] %p %s %s\n", *count, entry->iface,
   15546:	8d 46 10             	lea    0x10(%esi),%eax
   15549:	50                   	push   %eax
   1554a:	6a 01                	push   $0x1
   1554c:	e8 4d b5 ff ff       	call   10a9e <net_sprint_addr>
   15551:	5a                   	pop    %edx
   15552:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15555:	59                   	pop    %ecx
   15556:	8d 46 14             	lea    0x14(%esi),%eax
   15559:	6a 18                	push   $0x18
   1555b:	68 04 43 40 00       	push   $0x404304
   15560:	6a 06                	push   $0x6
   15562:	50                   	push   %eax
   15563:	e8 8f b2 ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   15568:	83 c4 10             	add    $0x10,%esp
   1556b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1556e:	52                   	push   %edx
   1556f:	50                   	push   %eax
   15570:	ff 76 0c             	pushl  0xc(%esi)
   15573:	ff 33                	pushl  (%ebx)
   15575:	68 47 85 02 00       	push   $0x28547
   1557a:	6a 00                	push   $0x0
   1557c:	57                   	push   %edi
   1557d:	e8 40 06 ff ff       	call   5bc2 <shell_fprintf>
	(*count)++;
   15582:	ff 03                	incl   (%ebx)
	PR("[%2d] %p %s %s\n", *count, entry->iface,
   15584:	83 c4 1c             	add    $0x1c,%esp
}
   15587:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1558a:	5b                   	pop    %ebx
   1558b:	5e                   	pop    %esi
   1558c:	5f                   	pop    %edi
   1558d:	5d                   	pop    %ebp
   1558e:	c3                   	ret    

0001558f <route_cb>:
{
   1558f:	55                   	push   %ebp
   15590:	89 e5                	mov    %esp,%ebp
   15592:	57                   	push   %edi
   15593:	56                   	push   %esi
   15594:	8b 45 0c             	mov    0xc(%ebp),%eax
   15597:	53                   	push   %ebx
   15598:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (entry->iface != iface) {
   1559b:	8b 48 04             	mov    0x4(%eax),%ecx
   1559e:	39 4b 0c             	cmp    %ecx,0xc(%ebx)
   155a1:	0f 85 b2 00 00 00    	jne    15659 <route_cb+0xca>
	const struct shell *shell = data->shell;
   155a7:	8b 30                	mov    (%eax),%esi
	PR("IPv6 prefix : %s/%d\n", net_sprint_ipv6_addr(&entry->addr),
   155a9:	8d 43 10             	lea    0x10(%ebx),%eax
   155ac:	0f b6 7b 20          	movzbl 0x20(%ebx),%edi
   155b0:	50                   	push   %eax
   155b1:	6a 02                	push   $0x2
   155b3:	e8 e6 b4 ff ff       	call   10a9e <net_sprint_addr>
   155b8:	5a                   	pop    %edx
   155b9:	59                   	pop    %ecx
   155ba:	57                   	push   %edi
   155bb:	31 ff                	xor    %edi,%edi
   155bd:	50                   	push   %eax
   155be:	68 57 85 02 00       	push   $0x28557
   155c3:	6a 00                	push   $0x0
   155c5:	56                   	push   %esi
   155c6:	e8 f7 05 ff ff       	call   5bc2 <shell_fprintf>
	SYS_SLIST_FOR_EACH_CONTAINER(&entry->nexthop, nexthop_route, node) {
   155cb:	8b 5b 04             	mov    0x4(%ebx),%ebx
	PR("IPv6 prefix : %s/%d\n", net_sprint_ipv6_addr(&entry->addr),
   155ce:	83 c4 14             	add    $0x14,%esp
	SYS_SLIST_FOR_EACH_CONTAINER(&entry->nexthop, nexthop_route, node) {
   155d1:	85 db                	test   %ebx,%ebx
   155d3:	74 74                	je     15649 <route_cb+0xba>
		if (!nexthop_route->nbr) {
   155d5:	8b 43 04             	mov    0x4(%ebx),%eax
   155d8:	85 c0                	test   %eax,%eax
   155da:	74 63                	je     1563f <route_cb+0xb0>
		PR("\tneighbor : %p\t", nexthop_route->nbr);
   155dc:	50                   	push   %eax
   155dd:	68 6c 85 02 00       	push   $0x2856c
   155e2:	6a 00                	push   $0x0
   155e4:	56                   	push   %esi
   155e5:	e8 d8 05 ff ff       	call   5bc2 <shell_fprintf>
		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
   155ea:	8b 43 04             	mov    0x4(%ebx),%eax
		PR("\tneighbor : %p\t", nexthop_route->nbr);
   155ed:	83 c4 10             	add    $0x10,%esp
		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
   155f0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   155f4:	3c ff                	cmp    $0xff,%al
   155f6:	75 12                	jne    1560a <route_cb+0x7b>
			PR("addr : <unknown>\n");
   155f8:	68 7c 85 02 00       	push   $0x2857c
   155fd:	6a 00                	push   $0x0
   155ff:	56                   	push   %esi
   15600:	e8 bd 05 ff ff       	call   5bc2 <shell_fprintf>
   15605:	83 c4 0c             	add    $0xc,%esp
   15608:	eb 34                	jmp    1563e <route_cb+0xaf>
			lladdr = net_nbr_get_lladdr(nexthop_route->nbr->idx);
   1560a:	50                   	push   %eax
   1560b:	e8 ef c6 ff ff       	call   11cff <net_nbr_get_lladdr>
   15610:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
   15617:	68 04 43 40 00       	push   $0x404304
			PR("addr : %s\n", net_sprint_ll_addr(lladdr->addr,
   1561c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   15620:	83 c0 02             	add    $0x2,%eax
   15623:	52                   	push   %edx
   15624:	50                   	push   %eax
   15625:	e8 cd b1 ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   1562a:	83 c4 10             	add    $0x10,%esp
   1562d:	50                   	push   %eax
   1562e:	68 76 87 02 00       	push   $0x28776
   15633:	6a 00                	push   $0x0
   15635:	56                   	push   %esi
   15636:	e8 87 05 ff ff       	call   5bc2 <shell_fprintf>
   1563b:	83 c4 10             	add    $0x10,%esp
		count++;
   1563e:	47                   	inc    %edi
   1563f:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&entry->nexthop, nexthop_route, node) {
   15641:	85 db                	test   %ebx,%ebx
   15643:	75 90                	jne    155d5 <route_cb+0x46>
	if (count == 0) {
   15645:	85 ff                	test   %edi,%edi
   15647:	75 10                	jne    15659 <route_cb+0xca>
		PR("\t<none>\n");
   15649:	68 8e 85 02 00       	push   $0x2858e
   1564e:	6a 00                	push   $0x0
   15650:	56                   	push   %esi
   15651:	e8 6c 05 ff ff       	call   5bc2 <shell_fprintf>
   15656:	83 c4 0c             	add    $0xc,%esp
}
   15659:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1565c:	5b                   	pop    %ebx
   1565d:	5e                   	pop    %esi
   1565e:	5f                   	pop    %edi
   1565f:	5d                   	pop    %ebp
   15660:	c3                   	ret    

00015661 <cmd_net_ping>:
{
   15661:	55                   	push   %ebp
   15662:	89 e5                	mov    %esp,%ebp
   15664:	57                   	push   %edi
   15665:	56                   	push   %esi
   15666:	53                   	push   %ebx
   15667:	83 ec 18             	sub    $0x18,%esp
	host = argv[1];
   1566a:	8b 45 10             	mov    0x10(%ebp),%eax
{
   1566d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	host = argv[1];
   15670:	8b 78 04             	mov    0x4(%eax),%edi
	if (!host) {
   15673:	85 ff                	test   %edi,%edi
   15675:	75 0a                	jne    15681 <cmd_net_ping+0x20>
		PR_WARNING("Target host missing\n");
   15677:	68 97 85 02 00       	push   $0x28597
   1567c:	e9 9e 00 00 00       	jmp    1571f <cmd_net_ping+0xbe>
	shell_for_ping = shell;
   15681:	89 1d 3c 43 40 00    	mov    %ebx,0x40433c
	struct net_if *iface = net_if_get_default();
   15687:	e8 f7 88 ff ff       	call   df83 <net_if_get_default>
	if (net_addr_pton(AF_INET6, host, &ipv6_target) < 0) {
   1568c:	8d 75 e4             	lea    -0x1c(%ebp),%esi
	struct net_if *iface = net_if_get_default();
   1568f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (net_addr_pton(AF_INET6, host, &ipv6_target) < 0) {
   15692:	56                   	push   %esi
   15693:	57                   	push   %edi
   15694:	6a 02                	push   $0x2
   15696:	e8 36 b4 ff ff       	call   10ad1 <net_addr_pton>
   1569b:	83 c4 0c             	add    $0xc,%esp
   1569e:	85 c0                	test   %eax,%eax
   156a0:	0f 88 8e 00 00 00    	js     15734 <cmd_net_ping+0xd3>
	net_icmpv6_register_handler(&ping6_handler);
   156a6:	68 f0 a6 40 00       	push   $0x40a6f0
   156ab:	e8 ad bf ff ff       	call   1165d <net_icmpv6_register_handler>
	nbr = net_ipv6_nbr_lookup(NULL, &ipv6_target);
   156b0:	89 34 24             	mov    %esi,(%esp)
   156b3:	6a 00                	push   $0x0
   156b5:	e8 39 d0 ff ff       	call   126f3 <net_ipv6_nbr_lookup>
   156ba:	5a                   	pop    %edx
   156bb:	59                   	pop    %ecx
	if (nbr) {
   156bc:	85 c0                	test   %eax,%eax
   156be:	74 06                	je     156c6 <cmd_net_ping+0x65>
		iface = nbr->iface;
   156c0:	8b 40 08             	mov    0x8(%eax),%eax
   156c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	route = net_route_lookup(NULL, &ipv6_target);
   156c6:	56                   	push   %esi
   156c7:	6a 00                	push   $0x0
   156c9:	e8 cc ef ff ff       	call   1469a <net_route_lookup>
   156ce:	5a                   	pop    %edx
	if (route) {
   156cf:	85 c0                	test   %eax,%eax
	route = net_route_lookup(NULL, &ipv6_target);
   156d1:	59                   	pop    %ecx
	if (route) {
   156d2:	74 06                	je     156da <cmd_net_ping+0x79>
		iface = route->iface;
   156d4:	8b 40 0c             	mov    0xc(%eax),%eax
   156d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
					   sys_rand32_get());
   156da:	e8 2d 3f ff ff       	call   960c <sys_rand32_get>
   156df:	89 45 dc             	mov    %eax,-0x24(%ebp)
					   sys_rand32_get(),
   156e2:	e8 25 3f ff ff       	call   960c <sys_rand32_get>
	ret = net_icmpv6_send_echo_request(iface,
   156e7:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   156eb:	0f b7 c0             	movzwl %ax,%eax
   156ee:	52                   	push   %edx
   156ef:	50                   	push   %eax
   156f0:	56                   	push   %esi
   156f1:	ff 75 e0             	pushl  -0x20(%ebp)
   156f4:	e8 18 c3 ff ff       	call   11a11 <net_icmpv6_send_echo_request>
   156f9:	83 c4 10             	add    $0x10,%esp
	if (ret) {
   156fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
   156ff:	85 c0                	test   %eax,%eax
   15701:	0f 84 95 00 00 00    	je     1579c <cmd_net_ping+0x13b>
	net_icmpv6_unregister_handler(&ping6_handler);
   15707:	68 f0 a6 40 00       	push   $0x40a6f0
   1570c:	e8 6f bf ff ff       	call   11680 <net_icmpv6_unregister_handler>
   15711:	58                   	pop    %eax
		} else if (ret == -EIO) {
   15712:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15715:	83 f8 fb             	cmp    $0xfffffffb,%eax
   15718:	75 1a                	jne    15734 <cmd_net_ping+0xd3>
			PR_WARNING("Cannot send IPv6 ping\n");
   1571a:	68 bf 85 02 00       	push   $0x285bf
   1571f:	6a 04                	push   $0x4
   15721:	53                   	push   %ebx
   15722:	e8 9b 04 ff ff       	call   5bc2 <shell_fprintf>
   15727:	83 c4 0c             	add    $0xc,%esp
			return -ENOEXEC;
   1572a:	ba f8 ff ff ff       	mov    $0xfffffff8,%edx
   1572f:	e9 d3 00 00 00       	jmp    15807 <cmd_net_ping+0x1a6>
	if (net_addr_pton(AF_INET, host, &ipv4_target) < 0) {
   15734:	56                   	push   %esi
   15735:	57                   	push   %edi
   15736:	6a 01                	push   $0x1
   15738:	e8 94 b3 ff ff       	call   10ad1 <net_addr_pton>
   1573d:	83 c4 0c             	add    $0xc,%esp
   15740:	85 c0                	test   %eax,%eax
   15742:	0f 88 b5 00 00 00    	js     157fd <cmd_net_ping+0x19c>
	net_icmpv4_register_handler(&ping4_handler);
   15748:	68 e4 a6 40 00       	push   $0x40a6e4
   1574d:	e8 d3 ba ff ff       	call   11225 <net_icmpv4_register_handler>
   15752:	58                   	pop    %eax
		sys_rand32_get());
   15753:	e8 b4 3e ff ff       	call   960c <sys_rand32_get>
   15758:	89 45 e0             	mov    %eax,-0x20(%ebp)
		sys_rand32_get(),
   1575b:	e8 ac 3e ff ff       	call   960c <sys_rand32_get>
	ret = net_icmpv4_send_echo_request(
   15760:	56                   	push   %esi
		sys_rand32_get(),
   15761:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ret = net_icmpv4_send_echo_request(
   15764:	e8 39 9c ff ff       	call   f3a2 <net_if_ipv4_select_src_iface>
   15769:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   1576d:	89 14 24             	mov    %edx,(%esp)
   15770:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   15774:	52                   	push   %edx
   15775:	56                   	push   %esi
   15776:	50                   	push   %eax
   15777:	e8 65 b8 ff ff       	call   10fe1 <net_icmpv4_send_echo_request>
   1577c:	83 c4 10             	add    $0x10,%esp
   1577f:	89 c6                	mov    %eax,%esi
	if (ret) {
   15781:	85 c0                	test   %eax,%eax
   15783:	74 17                	je     1579c <cmd_net_ping+0x13b>
	net_icmpv4_unregister_handler(&ping4_handler);
   15785:	68 e4 a6 40 00       	push   $0x40a6e4
   1578a:	e8 b9 ba ff ff       	call   11248 <net_icmpv4_unregister_handler>
   1578f:	5f                   	pop    %edi
			if (ret == -EIO) {
   15790:	83 fe fb             	cmp    $0xfffffffb,%esi
   15793:	75 5e                	jne    157f3 <cmd_net_ping+0x192>
				PR_WARNING("Cannot send IPv4 ping\n");
   15795:	68 d6 85 02 00       	push   $0x285d6
   1579a:	eb 83                	jmp    1571f <cmd_net_ping+0xbe>
		PR("Sent a ping to %s\n", host);
   1579c:	57                   	push   %edi
   1579d:	68 ac 85 02 00       	push   $0x285ac
   157a2:	6a 00                	push   $0x0
   157a4:	53                   	push   %ebx
   157a5:	e8 18 04 ff ff       	call   5bc2 <shell_fprintf>
   157aa:	83 c4 10             	add    $0x10,%esp
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   157ad:	68 d0 07 00 00       	push   $0x7d0
   157b2:	68 c0 a9 40 00       	push   $0x40a9c0
   157b7:	e8 86 e8 00 00       	call   24042 <z_impl_k_sem_take>
   157bc:	5a                   	pop    %edx
	return 0;
   157bd:	31 d2                	xor    %edx,%edx
   157bf:	59                   	pop    %ecx
	if (ret == -EAGAIN) {
   157c0:	83 f8 f5             	cmp    $0xfffffff5,%eax
   157c3:	75 42                	jne    15807 <cmd_net_ping+0x1a6>
		PR_INFO("Ping timeout\n");
   157c5:	68 01 86 02 00       	push   $0x28601
   157ca:	6a 03                	push   $0x3
   157cc:	53                   	push   %ebx
   157cd:	e8 f0 03 ff ff       	call   5bc2 <shell_fprintf>
   157d2:	83 c4 0c             	add    $0xc,%esp
	net_icmpv6_unregister_handler(&ping6_handler);
   157d5:	68 f0 a6 40 00       	push   $0x40a6f0
   157da:	e8 a1 be ff ff       	call   11680 <net_icmpv6_unregister_handler>
	net_icmpv4_unregister_handler(&ping4_handler);
   157df:	c7 04 24 e4 a6 40 00 	movl   $0x40a6e4,(%esp)
   157e6:	e8 5d ba ff ff       	call   11248 <net_icmpv4_unregister_handler>
   157eb:	58                   	pop    %eax
		return -ETIMEDOUT;
   157ec:	ba c4 ff ff ff       	mov    $0xffffffc4,%edx
   157f1:	eb 14                	jmp    15807 <cmd_net_ping+0x1a6>
			return -ENOEXEC;
   157f3:	ba f8 ff ff ff       	mov    $0xfffffff8,%edx
			} else if (ret == -EINVAL) {
   157f8:	83 fe ea             	cmp    $0xffffffea,%esi
   157fb:	75 0a                	jne    15807 <cmd_net_ping+0x1a6>
				PR_WARNING("Invalid IP address\n");
   157fd:	68 ed 85 02 00       	push   $0x285ed
   15802:	e9 18 ff ff ff       	jmp    1571f <cmd_net_ping+0xbe>
}
   15807:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1580a:	89 d0                	mov    %edx,%eax
   1580c:	5b                   	pop    %ebx
   1580d:	5e                   	pop    %esi
   1580e:	5f                   	pop    %edi
   1580f:	5d                   	pop    %ebp
   15810:	c3                   	ret    

00015811 <iface_per_route_cb>:
{
   15811:	55                   	push   %ebp
   15812:	89 e5                	mov    %esp,%ebp
   15814:	57                   	push   %edi
   15815:	56                   	push   %esi
   15816:	53                   	push   %ebx
   15817:	50                   	push   %eax
   15818:	8b 75 08             	mov    0x8(%ebp),%esi
   1581b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1581e:	8b 06                	mov    (%esi),%eax
	const struct shell *shell = data->shell;
   15820:	8b 3b                	mov    (%ebx),%edi
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
   15822:	81 78 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%eax)
   15829:	74 0c                	je     15837 <iface_per_route_cb+0x26>
		*extra = "==============";
   1582b:	b8 0f 86 02 00       	mov    $0x2860f,%eax
	return "<unknown type>";
   15830:	ba 67 83 02 00       	mov    $0x28367,%edx
   15835:	eb 0a                	jmp    15841 <iface_per_route_cb+0x30>
			*extra = "========";
   15837:	b8 15 86 02 00       	mov    $0x28615,%eax
		return "Ethernet";
   1583c:	ba 5e 83 02 00       	mov    $0x2835e,%edx
	PR("\nIPv6 routes for interface %p (%s)\n", iface,
   15841:	52                   	push   %edx
   15842:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15845:	56                   	push   %esi
   15846:	68 1e 86 02 00       	push   $0x2861e
   1584b:	6a 00                	push   $0x0
   1584d:	57                   	push   %edi
   1584e:	e8 6f 03 ff ff       	call   5bc2 <shell_fprintf>
   15853:	83 c4 14             	add    $0x14,%esp
	PR("=======================================%s\n", extra);
   15856:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15859:	50                   	push   %eax
   1585a:	68 6d 89 02 00       	push   $0x2896d
   1585f:	6a 00                	push   $0x0
   15861:	57                   	push   %edi
   15862:	e8 5b 03 ff ff       	call   5bc2 <shell_fprintf>
	data->user_data = iface;
   15867:	89 73 04             	mov    %esi,0x4(%ebx)
	PR("=======================================%s\n", extra);
   1586a:	83 c4 10             	add    $0x10,%esp
	net_route_foreach(route_cb, data);
   1586d:	89 5d 0c             	mov    %ebx,0xc(%ebp)
   15870:	c7 45 08 8f 55 01 00 	movl   $0x1558f,0x8(%ebp)
}
   15877:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1587a:	5b                   	pop    %ebx
   1587b:	5e                   	pop    %esi
   1587c:	5f                   	pop    %edi
   1587d:	5d                   	pop    %ebp
	net_route_foreach(route_cb, data);
   1587e:	e9 42 f0 ff ff       	jmp    148c5 <net_route_foreach>

00015883 <cmd_net_iface_up>:
{
   15883:	55                   	push   %ebp
   15884:	89 e5                	mov    %esp,%ebp
   15886:	56                   	push   %esi
   15887:	53                   	push   %ebx
   15888:	53                   	push   %ebx
	idx = get_iface_idx(shell, argv[1]);
   15889:	8b 45 10             	mov    0x10(%ebp),%eax
{
   1588c:	8b 75 08             	mov    0x8(%ebp),%esi
	idx = get_iface_idx(shell, argv[1]);
   1588f:	8b 50 04             	mov    0x4(%eax),%edx
   15892:	89 f0                	mov    %esi,%eax
   15894:	e8 e6 f6 ff ff       	call   14f7f <get_iface_idx>
   15899:	89 c3                	mov    %eax,%ebx
		return -ENOEXEC;
   1589b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	if (idx < 0) {
   158a0:	85 db                	test   %ebx,%ebx
   158a2:	78 6b                	js     1590f <cmd_net_iface_up+0x8c>
	iface = net_if_get_by_index(idx);
   158a4:	53                   	push   %ebx
   158a5:	e8 b1 9f ff ff       	call   f85b <net_if_get_by_index>
   158aa:	59                   	pop    %ecx
	if (!iface) {
   158ab:	85 c0                	test   %eax,%eax
   158ad:	75 08                	jne    158b7 <cmd_net_iface_up+0x34>
		PR_WARNING("No such interface in index %d\n", idx);
   158af:	53                   	push   %ebx
   158b0:	68 e7 83 02 00       	push   $0x283e7
   158b5:	eb 10                	jmp    158c7 <cmd_net_iface_up+0x44>
   158b7:	8b 10                	mov    (%eax),%edx
   158b9:	8b 52 0c             	mov    0xc(%edx),%edx
	if (net_if_is_up(iface)) {
   158bc:	80 e2 01             	and    $0x1,%dl
   158bf:	74 18                	je     158d9 <cmd_net_iface_up+0x56>
		PR_WARNING("Interface %d is already up.\n", idx);
   158c1:	53                   	push   %ebx
   158c2:	68 42 86 02 00       	push   $0x28642
   158c7:	6a 04                	push   $0x4
   158c9:	56                   	push   %esi
   158ca:	e8 f3 02 ff ff       	call   5bc2 <shell_fprintf>
   158cf:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
   158d2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   158d7:	eb 36                	jmp    1590f <cmd_net_iface_up+0x8c>
	ret = net_if_up(iface);
   158d9:	50                   	push   %eax
   158da:	e8 e4 9f ff ff       	call   f8c3 <net_if_up>
   158df:	5a                   	pop    %edx
	if (ret) {
   158e0:	85 c0                	test   %eax,%eax
   158e2:	74 14                	je     158f8 <cmd_net_iface_up+0x75>
		PR_WARNING("Cannot take interface %d up (%d)\n", idx, ret);
   158e4:	50                   	push   %eax
   158e5:	53                   	push   %ebx
   158e6:	68 5f 86 02 00       	push   $0x2865f
   158eb:	6a 04                	push   $0x4
   158ed:	56                   	push   %esi
   158ee:	e8 cf 02 ff ff       	call   5bc2 <shell_fprintf>
   158f3:	83 c4 14             	add    $0x14,%esp
		return -ENOEXEC;
   158f6:	eb da                	jmp    158d2 <cmd_net_iface_up+0x4f>
		PR("Interface %d is up\n", idx);
   158f8:	53                   	push   %ebx
   158f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   158fc:	68 81 86 02 00       	push   $0x28681
   15901:	6a 00                	push   $0x0
   15903:	56                   	push   %esi
   15904:	e8 b9 02 ff ff       	call   5bc2 <shell_fprintf>
   15909:	83 c4 10             	add    $0x10,%esp
   1590c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1590f:	8d 65 f8             	lea    -0x8(%ebp),%esp
   15912:	5b                   	pop    %ebx
   15913:	5e                   	pop    %esi
   15914:	5d                   	pop    %ebp
   15915:	c3                   	ret    

00015916 <nbr_cb>:
{
   15916:	55                   	push   %ebp
   15917:	89 e5                	mov    %esp,%ebp
   15919:	57                   	push   %edi
   1591a:	56                   	push   %esi
   1591b:	53                   	push   %ebx
   1591c:	83 ec 18             	sub    $0x18,%esp
   1591f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15922:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct shell *shell = data->shell;
   15925:	8b 08                	mov    (%eax),%ecx
	int *count = data->user_data;
   15927:	8b 40 04             	mov    0x4(%eax),%eax
	const struct shell *shell = data->shell;
   1592a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	int *count = data->user_data;
   1592d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (*count == 0) {
   15930:	83 38 00             	cmpl   $0x0,(%eax)
   15933:	75 15                	jne    1594a <nbr_cb+0x34>
		PR("     Neighbor   Interface        Flags State     "
   15935:	68 7b 85 02 00       	push   $0x2857b
   1593a:	68 9c 86 02 00       	push   $0x2869c
   1593f:	6a 00                	push   $0x0
   15941:	51                   	push   %ecx
   15942:	e8 7b 02 ff ff       	call   5bc2 <shell_fprintf>
   15947:	83 c4 10             	add    $0x10,%esp
	(*count)++;
   1594a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1594d:	ff 00                	incl   (%eax)
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
   1594f:	8b 43 0c             	mov    0xc(%ebx),%eax
   15952:	ff 70 28             	pushl  0x28(%eax)
   15955:	e8 13 cd ff ff       	call   1266d <net_ipv6_nbr_state2str>
	if (strlen(state_str) == 5) {
   1595a:	89 04 24             	mov    %eax,(%esp)
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
   1595d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strlen(state_str) == 5) {
   15960:	e8 fe 4e ff ff       	call   a863 <strlen>
   15965:	5a                   	pop    %edx
	char *state_pad = "";
   15966:	c7 45 ec 7b 85 02 00 	movl   $0x2857b,-0x14(%ebp)
	if (strlen(state_str) == 5) {
   1596d:	83 f8 05             	cmp    $0x5,%eax
   15970:	75 07                	jne    15979 <nbr_cb+0x63>
		state_pad = "    ";
   15972:	c7 45 ec 95 86 02 00 	movl   $0x28695,-0x14(%ebp)
	remaining = net_ipv6_nbr_data(nbr)->reachable +
   15979:	8b 43 0c             	mov    0xc(%ebx),%eax
		    net_ipv6_nbr_data(nbr)->reachable_timeout -
   1597c:	8b 70 1c             	mov    0x1c(%eax),%esi
   1597f:	89 f7                	mov    %esi,%edi
   15981:	c1 ff 1f             	sar    $0x1f,%edi
	remaining = net_ipv6_nbr_data(nbr)->reachable +
   15984:	03 70 14             	add    0x14(%eax),%esi
   15987:	13 78 18             	adc    0x18(%eax),%edi
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   1598a:	e8 82 ef 00 00       	call   24911 <z_impl_k_uptime_get>
   1598f:	29 c6                	sub    %eax,%esi
	PR("[%2d] %p %p %5d/%d/%d/%d %s%s %6d  %17s%s %s\n",
   15991:	8b 43 0c             	mov    0xc(%ebx),%eax
	remaining = net_ipv6_nbr_data(nbr)->reachable +
   15994:	19 d7                	sbb    %edx,%edi
	PR("[%2d] %p %p %5d/%d/%d/%d %s%s %6d  %17s%s %s\n",
   15996:	83 c0 04             	add    $0x4,%eax
   15999:	50                   	push   %eax
	remaining = net_ipv6_nbr_data(nbr)->reachable +
   1599a:	89 75 dc             	mov    %esi,-0x24(%ebp)
	PR("[%2d] %p %p %5d/%d/%d/%d %s%s %6d  %17s%s %s\n",
   1599d:	6a 02                	push   $0x2
	remaining = net_ipv6_nbr_data(nbr)->reachable +
   1599f:	89 7d e0             	mov    %edi,-0x20(%ebp)
	PR("[%2d] %p %p %5d/%d/%d/%d %s%s %6d  %17s%s %s\n",
   159a2:	e8 f7 b0 ff ff       	call   10a9e <net_sprint_addr>
   159a7:	5a                   	pop    %edx
   159a8:	89 c6                	mov    %eax,%esi
   159aa:	59                   	pop    %ecx
   159ab:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   159af:	50                   	push   %eax
   159b0:	e8 4a c3 ff ff       	call   11cff <net_nbr_get_lladdr>
   159b5:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
   159b9:	5f                   	pop    %edi
   159ba:	b8 9a 86 02 00       	mov    $0x2869a,%eax
   159bf:	80 fa ff             	cmp    $0xff,%dl
   159c2:	74 2f                	je     159f3 <nbr_cb+0xdd>
   159c4:	52                   	push   %edx
   159c5:	e8 35 c3 ff ff       	call   11cff <net_nbr_get_lladdr>
   159ca:	0f b6 78 01          	movzbl 0x1(%eax),%edi
   159ce:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   159d2:	89 04 24             	mov    %eax,(%esp)
   159d5:	e8 25 c3 ff ff       	call   11cff <net_nbr_get_lladdr>
   159da:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
   159e1:	68 04 43 40 00       	push   $0x404304
   159e6:	57                   	push   %edi
   159e7:	83 c0 02             	add    $0x2,%eax
   159ea:	50                   	push   %eax
   159eb:	e8 07 ae ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   159f0:	83 c4 10             	add    $0x10,%esp
   159f3:	8b 53 0c             	mov    0xc(%ebx),%edx
   159f6:	56                   	push   %esi
   159f7:	68 7b 85 02 00       	push   $0x2857b
   159fc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   159ff:	50                   	push   %eax
   15a00:	85 c9                	test   %ecx,%ecx
   15a02:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15a05:	79 02                	jns    15a09 <nbr_cb+0xf3>
   15a07:	31 c0                	xor    %eax,%eax
   15a09:	50                   	push   %eax
   15a0a:	ff 75 ec             	pushl  -0x14(%ebp)
   15a0d:	ff 75 e4             	pushl  -0x1c(%ebp)
   15a10:	0f b6 42 2f          	movzbl 0x2f(%edx),%eax
   15a14:	50                   	push   %eax
   15a15:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
   15a19:	50                   	push   %eax
   15a1a:	0f b6 03             	movzbl (%ebx),%eax
   15a1d:	50                   	push   %eax
   15a1e:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
   15a22:	50                   	push   %eax
   15a23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a26:	ff 73 08             	pushl  0x8(%ebx)
   15a29:	53                   	push   %ebx
   15a2a:	ff 30                	pushl  (%eax)
   15a2c:	68 f2 86 02 00       	push   $0x286f2
   15a31:	6a 00                	push   $0x0
   15a33:	ff 75 e8             	pushl  -0x18(%ebp)
   15a36:	e8 87 01 ff ff       	call   5bc2 <shell_fprintf>
   15a3b:	83 c4 40             	add    $0x40,%esp
}
   15a3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15a41:	5b                   	pop    %ebx
   15a42:	5e                   	pop    %esi
   15a43:	5f                   	pop    %edi
   15a44:	5d                   	pop    %ebp
   15a45:	c3                   	ret    

00015a46 <iface_cb>:
{
   15a46:	55                   	push   %ebp
   15a47:	89 e5                	mov    %esp,%ebp
   15a49:	57                   	push   %edi
   15a4a:	56                   	push   %esi
   15a4b:	53                   	push   %ebx
   15a4c:	83 ec 1c             	sub    $0x1c,%esp
   15a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a52:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (data->user_data && data->user_data != iface) {
   15a55:	8b 50 04             	mov    0x4(%eax),%edx
   15a58:	39 da                	cmp    %ebx,%edx
   15a5a:	74 08                	je     15a64 <iface_cb+0x1e>
   15a5c:	85 d2                	test   %edx,%edx
   15a5e:	0f 85 65 05 00 00    	jne    15fc9 <iface_cb+0x583>
	const struct shell *shell = data->shell;
   15a64:	8b 30                	mov    (%eax),%esi
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
   15a66:	53                   	push   %ebx
   15a67:	e8 0f 9e ff ff       	call   f87b <net_if_get_by_iface>
   15a6c:	5a                   	pop    %edx
   15a6d:	8b 13                	mov    (%ebx),%edx
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
   15a6f:	81 7a 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%edx)
   15a76:	74 0c                	je     15a84 <iface_cb+0x3e>
		*extra = "==============";
   15a78:	bf 0f 86 02 00       	mov    $0x2860f,%edi
	return "<unknown type>";
   15a7d:	ba 67 83 02 00       	mov    $0x28367,%edx
   15a82:	eb 0a                	jmp    15a8e <iface_cb+0x48>
			*extra = "========";
   15a84:	bf 15 86 02 00       	mov    $0x28615,%edi
		return "Ethernet";
   15a89:	ba 5e 83 02 00       	mov    $0x2835e,%edx
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
   15a8e:	50                   	push   %eax
   15a8f:	52                   	push   %edx
   15a90:	53                   	push   %ebx
   15a91:	68 44 87 02 00       	push   $0x28744
   15a96:	6a 00                	push   $0x0
   15a98:	56                   	push   %esi
   15a99:	e8 24 01 ff ff       	call   5bc2 <shell_fprintf>
   15a9e:	83 c4 18             	add    $0x18,%esp
	PR("===========================%s\n", extra);
   15aa1:	57                   	push   %edi
   15aa2:	68 79 89 02 00       	push   $0x28979
   15aa7:	6a 00                	push   $0x0
   15aa9:	56                   	push   %esi
   15aaa:	e8 13 01 ff ff       	call   5bc2 <shell_fprintf>
   15aaf:	8b 03                	mov    (%ebx),%eax
   15ab1:	83 c4 10             	add    $0x10,%esp
   15ab4:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_is_up(iface)) {
   15ab7:	a8 01                	test   $0x1,%al
   15ab9:	75 15                	jne    15ad0 <iface_cb+0x8a>
		PR_INFO("Interface is down.\n");
   15abb:	68 5d 87 02 00       	push   $0x2875d
   15ac0:	6a 03                	push   $0x3
   15ac2:	56                   	push   %esi
   15ac3:	e8 fa 00 ff ff       	call   5bc2 <shell_fprintf>
   15ac8:	83 c4 0c             	add    $0xc,%esp
		return;
   15acb:	e9 f9 04 00 00       	jmp    15fc9 <iface_cb+0x583>
	if (net_if_get_link_addr(iface) &&
   15ad0:	8b 03                	mov    (%ebx),%eax
   15ad2:	83 f8 f0             	cmp    $0xfffffff0,%eax
   15ad5:	74 2d                	je     15b04 <iface_cb+0xbe>
	    net_if_get_link_addr(iface)->addr) {
   15ad7:	8b 50 10             	mov    0x10(%eax),%edx
	if (net_if_get_link_addr(iface) &&
   15ada:	85 d2                	test   %edx,%edx
   15adc:	74 26                	je     15b04 <iface_cb+0xbe>
   15ade:	6a 18                	push   $0x18
   15ae0:	68 04 43 40 00       	push   $0x404304
		PR("Link addr : %s\n",
   15ae5:	0f b6 40 14          	movzbl 0x14(%eax),%eax
   15ae9:	50                   	push   %eax
   15aea:	52                   	push   %edx
   15aeb:	e8 07 ad ff ff       	call   107f7 <net_sprint_ll_addr_buf>
   15af0:	83 c4 10             	add    $0x10,%esp
   15af3:	50                   	push   %eax
   15af4:	68 71 87 02 00       	push   $0x28771
   15af9:	6a 00                	push   $0x0
   15afb:	56                   	push   %esi
   15afc:	e8 c1 00 ff ff       	call   5bc2 <shell_fprintf>
   15b01:	83 c4 10             	add    $0x10,%esp
	return iface->if_dev->mtu;
   15b04:	8b 03                	mov    (%ebx),%eax
	PR("MTU       : %d\n", net_if_get_mtu(iface));
   15b06:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   15b0a:	50                   	push   %eax
   15b0b:	68 81 87 02 00       	push   $0x28781
   15b10:	6a 00                	push   $0x0
   15b12:	56                   	push   %esi
   15b13:	e8 aa 00 ff ff       	call   5bc2 <shell_fprintf>
	return iface->if_dev->l2;
   15b18:	8b 03                	mov    (%ebx),%eax
   15b1a:	83 c4 10             	add    $0x10,%esp
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
   15b1d:	81 78 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%eax)
   15b24:	75 52                	jne    15b78 <iface_cb+0x132>
		PR("Ethernet capabilities supported:\n");
   15b26:	68 91 87 02 00       	push   $0x28791
   15b2b:	6a 00                	push   $0x0
   15b2d:	56                   	push   %esi
   15b2e:	e8 8f 00 ff ff       	call   5bc2 <shell_fprintf>
	return iface->if_dev->dev;
   15b33:	8b 03                	mov    (%ebx),%eax
   15b35:	83 c4 0c             	add    $0xc,%esp
   15b38:	8b 08                	mov    (%eax),%ecx
	if (!eth->get_capabilities) {
   15b3a:	8b 41 04             	mov    0x4(%ecx),%eax
   15b3d:	8b 50 0c             	mov    0xc(%eax),%edx
		return 0;
   15b40:	31 c0                	xor    %eax,%eax
	if (!eth->get_capabilities) {
   15b42:	85 d2                	test   %edx,%edx
   15b44:	74 04                	je     15b4a <iface_cb+0x104>
	return eth->get_capabilities(net_if_get_device(iface));
   15b46:	51                   	push   %ecx
   15b47:	ff d2                	call   *%edx
   15b49:	5f                   	pop    %edi
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
   15b4a:	31 ff                	xor    %edi,%edi
		if (caps & eth_hw_caps[i].capability) {
   15b4c:	85 04 fd c0 59 02 00 	test   %eax,0x259c0(,%edi,8)
   15b53:	74 1d                	je     15b72 <iface_cb+0x12c>
			PR("\t%s\n", eth_hw_caps[i].description);
   15b55:	ff 34 fd c4 59 02 00 	pushl  0x259c4(,%edi,8)
   15b5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15b5f:	68 b3 87 02 00       	push   $0x287b3
   15b64:	6a 00                	push   $0x0
   15b66:	56                   	push   %esi
   15b67:	e8 56 00 ff ff       	call   5bc2 <shell_fprintf>
   15b6c:	83 c4 10             	add    $0x10,%esp
   15b6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
   15b72:	47                   	inc    %edi
   15b73:	83 ff 0d             	cmp    $0xd,%edi
   15b76:	75 d4                	jne    15b4c <iface_cb+0x106>
	ipv6 = iface->config.ip.ipv6;
   15b78:	8b 7b 04             	mov    0x4(%ebx),%edi
	PR("IPv6 unicast addresses (max %d):\n", NET_IF_MAX_IPV6_ADDR);
   15b7b:	6a 03                	push   $0x3
   15b7d:	68 b8 87 02 00       	push   $0x287b8
   15b82:	6a 00                	push   $0x0
   15b84:	56                   	push   %esi
   15b85:	e8 38 00 ff ff       	call   5bc2 <shell_fprintf>
   15b8a:	83 c4 10             	add    $0x10,%esp
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
   15b8d:	8d 57 04             	lea    0x4(%edi),%edx
	count = 0;
   15b90:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
   15b97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15b9e:	85 ff                	test   %edi,%edi
   15ba0:	0f 95 45 ec          	setne  -0x14(%ebp)
   15ba4:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
   15ba8:	0f 8f ad 00 00 00    	jg     15c5b <iface_cb+0x215>
   15bae:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
   15bb2:	0f 84 a3 00 00 00    	je     15c5b <iface_cb+0x215>
		if (!unicast->is_used) {
   15bb8:	6b 45 f0 48          	imul   $0x48,-0x10(%ebp),%eax
   15bbc:	8a 44 07 47          	mov    0x47(%edi,%eax,1),%al
   15bc0:	a8 02                	test   $0x2,%al
   15bc2:	0f 84 88 00 00 00    	je     15c50 <iface_cb+0x20a>
		PR("\t%s %s %s%s%s\n",
   15bc8:	c7 45 ec 20 87 02 00 	movl   $0x28720,-0x14(%ebp)
   15bcf:	a8 04                	test   $0x4,%al
   15bd1:	75 07                	jne    15bda <iface_cb+0x194>
   15bd3:	c7 45 ec 7b 85 02 00 	movl   $0x2857b,-0x14(%ebp)
   15bda:	c7 45 e4 2b 87 02 00 	movl   $0x2872b,-0x1c(%ebp)
   15be1:	a8 01                	test   $0x1,%al
   15be3:	75 07                	jne    15bec <iface_cb+0x1a6>
   15be5:	c7 45 e4 7b 85 02 00 	movl   $0x2857b,-0x1c(%ebp)
	switch (addr_state) {
   15bec:	8a 42 41             	mov    0x41(%edx),%al
   15bef:	b9 3a 7c 02 00       	mov    $0x27c3a,%ecx
   15bf4:	40                   	inc    %eax
   15bf5:	3c 03                	cmp    $0x3,%al
   15bf7:	77 0a                	ja     15c03 <iface_cb+0x1bd>
   15bf9:	0f b6 c0             	movzbl %al,%eax
   15bfc:	8b 0c 85 78 60 02 00 	mov    0x26078(,%eax,4),%ecx
		PR("\t%s %s %s%s%s\n",
   15c03:	0f b6 42 40          	movzbl 0x40(%edx),%eax
   15c07:	c7 45 e0 35 87 02 00 	movl   $0x28735,-0x20(%ebp)
   15c0e:	3c 04                	cmp    $0x4,%al
   15c10:	77 0a                	ja     15c1c <iface_cb+0x1d6>
   15c12:	8b 04 85 88 60 02 00 	mov    0x26088(,%eax,4),%eax
   15c19:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15c1c:	52                   	push   %edx
   15c1d:	89 4d d8             	mov    %ecx,-0x28(%ebp)
   15c20:	6a 02                	push   $0x2
   15c22:	89 55 dc             	mov    %edx,-0x24(%ebp)
   15c25:	e8 74 ae ff ff       	call   10a9e <net_sprint_addr>
   15c2a:	5a                   	pop    %edx
   15c2b:	59                   	pop    %ecx
   15c2c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   15c2f:	ff 75 ec             	pushl  -0x14(%ebp)
   15c32:	ff 75 e4             	pushl  -0x1c(%ebp)
   15c35:	51                   	push   %ecx
   15c36:	ff 75 e0             	pushl  -0x20(%ebp)
   15c39:	50                   	push   %eax
   15c3a:	68 da 87 02 00       	push   $0x287da
   15c3f:	6a 00                	push   $0x0
   15c41:	56                   	push   %esi
   15c42:	e8 7b ff fe ff       	call   5bc2 <shell_fprintf>
		count++;
   15c47:	ff 45 e8             	incl   -0x18(%ebp)
		PR("\t%s %s %s%s%s\n",
   15c4a:	83 c4 20             	add    $0x20,%esp
		count++;
   15c4d:	8b 55 dc             	mov    -0x24(%ebp),%edx
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
   15c50:	ff 45 f0             	incl   -0x10(%ebp)
   15c53:	83 c2 48             	add    $0x48,%edx
   15c56:	e9 43 ff ff ff       	jmp    15b9e <iface_cb+0x158>
	if (count == 0) {
   15c5b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c5f:	75 10                	jne    15c71 <iface_cb+0x22b>
		PR("\t<none>\n");
   15c61:	68 8e 85 02 00       	push   $0x2858e
   15c66:	6a 00                	push   $0x0
   15c68:	56                   	push   %esi
   15c69:	e8 54 ff fe ff       	call   5bc2 <shell_fprintf>
   15c6e:	83 c4 0c             	add    $0xc,%esp
	PR("IPv6 multicast addresses (max %d):\n", NET_IF_MAX_IPV6_MADDR);
   15c71:	6a 02                	push   $0x2
   15c73:	68 e9 87 02 00       	push   $0x287e9
   15c78:	6a 00                	push   $0x0
   15c7a:	56                   	push   %esi
   15c7b:	e8 42 ff fe ff       	call   5bc2 <shell_fprintf>
   15c80:	83 c4 10             	add    $0x10,%esp
	count = 0;
   15c83:	31 c9                	xor    %ecx,%ecx
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
   15c85:	31 d2                	xor    %edx,%edx
   15c87:	83 fa 01             	cmp    $0x1,%edx
   15c8a:	7f 45                	jg     15cd1 <iface_cb+0x28b>
   15c8c:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
   15c90:	74 3f                	je     15cd1 <iface_cb+0x28b>
		if (!mcast->is_used) {
   15c92:	6b c2 18             	imul   $0x18,%edx,%eax
   15c95:	f6 84 07 ec 00 00 00 	testb  $0x1,0xec(%edi,%eax,1)
   15c9c:	01 
   15c9d:	74 2f                	je     15cce <iface_cb+0x288>
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
   15c9f:	8d 84 07 dc 00 00 00 	lea    0xdc(%edi,%eax,1),%eax
   15ca6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   15ca9:	50                   	push   %eax
   15caa:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15cad:	6a 02                	push   $0x2
   15caf:	e8 ea ad ff ff       	call   10a9e <net_sprint_addr>
   15cb4:	5a                   	pop    %edx
   15cb5:	59                   	pop    %ecx
   15cb6:	50                   	push   %eax
   15cb7:	68 b3 87 02 00       	push   $0x287b3
   15cbc:	6a 00                	push   $0x0
   15cbe:	56                   	push   %esi
   15cbf:	e8 fe fe fe ff       	call   5bc2 <shell_fprintf>
		count++;
   15cc4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
   15cc7:	83 c4 10             	add    $0x10,%esp
		count++;
   15cca:	41                   	inc    %ecx
   15ccb:	8b 55 f0             	mov    -0x10(%ebp),%edx
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
   15cce:	42                   	inc    %edx
   15ccf:	eb b6                	jmp    15c87 <iface_cb+0x241>
	if (count == 0) {
   15cd1:	85 c9                	test   %ecx,%ecx
   15cd3:	75 10                	jne    15ce5 <iface_cb+0x29f>
		PR("\t<none>\n");
   15cd5:	68 8e 85 02 00       	push   $0x2858e
   15cda:	6a 00                	push   $0x0
   15cdc:	56                   	push   %esi
   15cdd:	e8 e0 fe fe ff       	call   5bc2 <shell_fprintf>
   15ce2:	83 c4 0c             	add    $0xc,%esp
	PR("IPv6 prefixes (max %d):\n", NET_IF_MAX_IPV6_PREFIX);
   15ce5:	6a 02                	push   $0x2
   15ce7:	68 0d 88 02 00       	push   $0x2880d
   15cec:	6a 00                	push   $0x0
   15cee:	56                   	push   %esi
   15cef:	e8 ce fe fe ff       	call   5bc2 <shell_fprintf>
   15cf4:	83 c4 10             	add    $0x10,%esp
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
   15cf7:	8d 97 18 01 00 00    	lea    0x118(%edi),%edx
	count = 0;
   15cfd:	31 c9                	xor    %ecx,%ecx
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
   15cff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15d06:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
   15d0a:	7f 64                	jg     15d70 <iface_cb+0x32a>
   15d0c:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
   15d10:	74 5e                	je     15d70 <iface_cb+0x32a>
		if (!prefix->is_used) {
   15d12:	6b 45 f0 28          	imul   $0x28,-0x10(%ebp),%eax
   15d16:	8a 84 07 2d 01 00 00 	mov    0x12d(%edi,%eax,1),%al
   15d1d:	a8 02                	test   $0x2,%al
   15d1f:	74 47                	je     15d68 <iface_cb+0x322>
		PR("\t%s/%d%s\n",
   15d21:	c7 45 e8 2b 87 02 00 	movl   $0x2872b,-0x18(%ebp)
   15d28:	a8 01                	test   $0x1,%al
   15d2a:	75 07                	jne    15d33 <iface_cb+0x2ed>
   15d2c:	c7 45 e8 7b 85 02 00 	movl   $0x2857b,-0x18(%ebp)
   15d33:	0f b6 42 14          	movzbl 0x14(%edx),%eax
   15d37:	52                   	push   %edx
   15d38:	89 4d dc             	mov    %ecx,-0x24(%ebp)
   15d3b:	6a 02                	push   $0x2
   15d3d:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15d40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15d43:	e8 56 ad ff ff       	call   10a9e <net_sprint_addr>
   15d48:	5a                   	pop    %edx
   15d49:	59                   	pop    %ecx
   15d4a:	ff 75 e8             	pushl  -0x18(%ebp)
   15d4d:	ff 75 e4             	pushl  -0x1c(%ebp)
   15d50:	50                   	push   %eax
   15d51:	68 26 88 02 00       	push   $0x28826
   15d56:	6a 00                	push   $0x0
   15d58:	56                   	push   %esi
   15d59:	e8 64 fe fe ff       	call   5bc2 <shell_fprintf>
		count++;
   15d5e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
		PR("\t%s/%d%s\n",
   15d61:	83 c4 18             	add    $0x18,%esp
		count++;
   15d64:	41                   	inc    %ecx
   15d65:	8b 55 e0             	mov    -0x20(%ebp),%edx
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
   15d68:	ff 45 f0             	incl   -0x10(%ebp)
   15d6b:	83 c2 28             	add    $0x28,%edx
   15d6e:	eb 96                	jmp    15d06 <iface_cb+0x2c0>
	if (count == 0) {
   15d70:	85 c9                	test   %ecx,%ecx
   15d72:	75 10                	jne    15d84 <iface_cb+0x33e>
		PR("\t<none>\n");
   15d74:	68 8e 85 02 00       	push   $0x2858e
   15d79:	6a 00                	push   $0x0
   15d7b:	56                   	push   %esi
   15d7c:	e8 41 fe fe ff       	call   5bc2 <shell_fprintf>
   15d81:	83 c4 0c             	add    $0xc,%esp
	router = net_if_ipv6_router_find_default(iface, NULL);
   15d84:	6a 00                	push   $0x0
   15d86:	53                   	push   %ebx
   15d87:	e8 07 92 ff ff       	call   ef93 <net_if_ipv6_router_find_default>
   15d8c:	5a                   	pop    %edx
	if (router) {
   15d8d:	85 c0                	test   %eax,%eax
	router = net_if_ipv6_router_find_default(iface, NULL);
   15d8f:	59                   	pop    %ecx
	if (router) {
   15d90:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15d93:	74 48                	je     15ddd <iface_cb+0x397>
		PR("IPv6 default router :\n");
   15d95:	68 30 88 02 00       	push   $0x28830
   15d9a:	6a 00                	push   $0x0
   15d9c:	56                   	push   %esi
   15d9d:	e8 20 fe fe ff       	call   5bc2 <shell_fprintf>
		PR("\t%s%s\n",
   15da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
		PR("IPv6 default router :\n");
   15da5:	83 c4 0c             	add    $0xc,%esp
		PR("\t%s%s\n",
   15da8:	ba 2b 87 02 00       	mov    $0x2872b,%edx
   15dad:	f6 40 38 04          	testb  $0x4,0x38(%eax)
   15db1:	75 05                	jne    15db8 <iface_cb+0x372>
   15db3:	ba 7b 85 02 00       	mov    $0x2857b,%edx
   15db8:	83 c0 24             	add    $0x24,%eax
   15dbb:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15dbe:	50                   	push   %eax
   15dbf:	6a 02                	push   $0x2
   15dc1:	e8 d8 ac ff ff       	call   10a9e <net_sprint_addr>
   15dc6:	5a                   	pop    %edx
   15dc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15dca:	59                   	pop    %ecx
   15dcb:	52                   	push   %edx
   15dcc:	50                   	push   %eax
   15dcd:	68 47 88 02 00       	push   $0x28847
   15dd2:	6a 00                	push   $0x0
   15dd4:	56                   	push   %esi
   15dd5:	e8 e8 fd fe ff       	call   5bc2 <shell_fprintf>
   15dda:	83 c4 14             	add    $0x14,%esp
	if (ipv6) {
   15ddd:	85 ff                	test   %edi,%edi
   15ddf:	74 5a                	je     15e3b <iface_cb+0x3f5>
		PR("IPv6 hop limit           : %d\n",
   15de1:	0f b6 87 84 01 00 00 	movzbl 0x184(%edi),%eax
   15de8:	50                   	push   %eax
   15de9:	68 4e 88 02 00       	push   $0x2884e
   15dee:	6a 00                	push   $0x0
   15df0:	56                   	push   %esi
   15df1:	e8 cc fd fe ff       	call   5bc2 <shell_fprintf>
   15df6:	83 c4 10             	add    $0x10,%esp
		PR("IPv6 base reachable time : %d\n",
   15df9:	ff b7 78 01 00 00    	pushl  0x178(%edi)
   15dff:	68 6d 88 02 00       	push   $0x2886d
   15e04:	6a 00                	push   $0x0
   15e06:	56                   	push   %esi
   15e07:	e8 b6 fd fe ff       	call   5bc2 <shell_fprintf>
   15e0c:	83 c4 10             	add    $0x10,%esp
		PR("IPv6 reachable time      : %d\n",
   15e0f:	ff b7 7c 01 00 00    	pushl  0x17c(%edi)
   15e15:	68 8c 88 02 00       	push   $0x2888c
   15e1a:	6a 00                	push   $0x0
   15e1c:	56                   	push   %esi
   15e1d:	e8 a0 fd fe ff       	call   5bc2 <shell_fprintf>
   15e22:	83 c4 10             	add    $0x10,%esp
		PR("IPv6 retransmit timer    : %d\n",
   15e25:	ff b7 80 01 00 00    	pushl  0x180(%edi)
   15e2b:	68 ab 88 02 00       	push   $0x288ab
   15e30:	6a 00                	push   $0x0
   15e32:	56                   	push   %esi
   15e33:	e8 8a fd fe ff       	call   5bc2 <shell_fprintf>
   15e38:	83 c4 10             	add    $0x10,%esp
	ipv4 = iface->config.ip.ipv4;
   15e3b:	8b 7b 08             	mov    0x8(%ebx),%edi
	PR("IPv4 unicast addresses (max %d):\n", NET_IF_MAX_IPV4_ADDR);
   15e3e:	6a 03                	push   $0x3
   15e40:	68 ca 88 02 00       	push   $0x288ca
   15e45:	6a 00                	push   $0x0
   15e47:	56                   	push   %esi
   15e48:	e8 75 fd fe ff       	call   5bc2 <shell_fprintf>
   15e4d:	83 c4 10             	add    $0x10,%esp
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
   15e50:	8d 57 04             	lea    0x4(%edi),%edx
	count = 0;
   15e53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
   15e5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15e61:	85 ff                	test   %edi,%edi
   15e63:	0f 95 c3             	setne  %bl
   15e66:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
   15e6a:	0f 8f 8b 00 00 00    	jg     15efb <iface_cb+0x4b5>
   15e70:	84 db                	test   %bl,%bl
   15e72:	0f 84 83 00 00 00    	je     15efb <iface_cb+0x4b5>
		if (!unicast->is_used) {
   15e78:	6b 45 f0 48          	imul   $0x48,-0x10(%ebp),%eax
   15e7c:	8a 44 07 47          	mov    0x47(%edi,%eax,1),%al
   15e80:	a8 02                	test   $0x2,%al
   15e82:	74 6c                	je     15ef0 <iface_cb+0x4aa>
		PR("\t%s %s %s%s\n",
   15e84:	c7 45 e8 2b 87 02 00 	movl   $0x2872b,-0x18(%ebp)
   15e8b:	a8 01                	test   $0x1,%al
   15e8d:	75 07                	jne    15e96 <iface_cb+0x450>
   15e8f:	c7 45 e8 7b 85 02 00 	movl   $0x2857b,-0x18(%ebp)
	switch (addr_state) {
   15e96:	8a 42 41             	mov    0x41(%edx),%al
   15e99:	b9 3a 7c 02 00       	mov    $0x27c3a,%ecx
   15e9e:	40                   	inc    %eax
   15e9f:	3c 03                	cmp    $0x3,%al
   15ea1:	77 0a                	ja     15ead <iface_cb+0x467>
   15ea3:	0f b6 c0             	movzbl %al,%eax
   15ea6:	8b 0c 85 78 60 02 00 	mov    0x26078(,%eax,4),%ecx
		PR("\t%s %s %s%s\n",
   15ead:	0f b6 42 40          	movzbl 0x40(%edx),%eax
   15eb1:	bb 35 87 02 00       	mov    $0x28735,%ebx
   15eb6:	3c 04                	cmp    $0x4,%al
   15eb8:	77 07                	ja     15ec1 <iface_cb+0x47b>
   15eba:	8b 1c 85 88 60 02 00 	mov    0x26088(,%eax,4),%ebx
   15ec1:	52                   	push   %edx
   15ec2:	89 4d e0             	mov    %ecx,-0x20(%ebp)
   15ec5:	6a 01                	push   $0x1
   15ec7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15eca:	e8 cf ab ff ff       	call   10a9e <net_sprint_addr>
   15ecf:	5a                   	pop    %edx
   15ed0:	59                   	pop    %ecx
   15ed1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15ed4:	ff 75 e8             	pushl  -0x18(%ebp)
   15ed7:	51                   	push   %ecx
   15ed8:	53                   	push   %ebx
   15ed9:	50                   	push   %eax
   15eda:	68 ec 88 02 00       	push   $0x288ec
   15edf:	6a 00                	push   $0x0
   15ee1:	56                   	push   %esi
   15ee2:	e8 db fc fe ff       	call   5bc2 <shell_fprintf>
		count++;
   15ee7:	ff 45 ec             	incl   -0x14(%ebp)
		PR("\t%s %s %s%s\n",
   15eea:	83 c4 1c             	add    $0x1c,%esp
		count++;
   15eed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
   15ef0:	ff 45 f0             	incl   -0x10(%ebp)
   15ef3:	83 c2 48             	add    $0x48,%edx
   15ef6:	e9 66 ff ff ff       	jmp    15e61 <iface_cb+0x41b>
	if (count == 0) {
   15efb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15eff:	75 10                	jne    15f11 <iface_cb+0x4cb>
		PR("\t<none>\n");
   15f01:	68 8e 85 02 00       	push   $0x2858e
   15f06:	6a 00                	push   $0x0
   15f08:	56                   	push   %esi
   15f09:	e8 b4 fc fe ff       	call   5bc2 <shell_fprintf>
   15f0e:	83 c4 0c             	add    $0xc,%esp
	PR("IPv4 multicast addresses (max %d):\n", NET_IF_MAX_IPV4_MADDR);
   15f11:	6a 02                	push   $0x2
   15f13:	68 f9 88 02 00       	push   $0x288f9
   15f18:	6a 00                	push   $0x0
   15f1a:	56                   	push   %esi
   15f1b:	e8 a2 fc fe ff       	call   5bc2 <shell_fprintf>
   15f20:	83 c4 10             	add    $0x10,%esp
	count = 0;
   15f23:	31 c9                	xor    %ecx,%ecx
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_MADDR; i++) {
   15f25:	31 d2                	xor    %edx,%edx
   15f27:	83 fa 01             	cmp    $0x1,%edx
   15f2a:	7f 43                	jg     15f6f <iface_cb+0x529>
   15f2c:	84 db                	test   %bl,%bl
   15f2e:	74 3f                	je     15f6f <iface_cb+0x529>
		if (!mcast->is_used) {
   15f30:	6b c2 18             	imul   $0x18,%edx,%eax
   15f33:	f6 84 07 ec 00 00 00 	testb  $0x1,0xec(%edi,%eax,1)
   15f3a:	01 
   15f3b:	74 2f                	je     15f6c <iface_cb+0x526>
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
   15f3d:	8d 84 07 dc 00 00 00 	lea    0xdc(%edi,%eax,1),%eax
   15f44:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   15f47:	50                   	push   %eax
   15f48:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15f4b:	6a 01                	push   $0x1
   15f4d:	e8 4c ab ff ff       	call   10a9e <net_sprint_addr>
   15f52:	5a                   	pop    %edx
   15f53:	59                   	pop    %ecx
   15f54:	50                   	push   %eax
   15f55:	68 b3 87 02 00       	push   $0x287b3
   15f5a:	6a 00                	push   $0x0
   15f5c:	56                   	push   %esi
   15f5d:	e8 60 fc fe ff       	call   5bc2 <shell_fprintf>
		count++;
   15f62:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
   15f65:	83 c4 10             	add    $0x10,%esp
		count++;
   15f68:	41                   	inc    %ecx
   15f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_MADDR; i++) {
   15f6c:	42                   	inc    %edx
   15f6d:	eb b8                	jmp    15f27 <iface_cb+0x4e1>
	if (count == 0) {
   15f6f:	85 c9                	test   %ecx,%ecx
   15f71:	75 10                	jne    15f83 <iface_cb+0x53d>
		PR("\t<none>\n");
   15f73:	68 8e 85 02 00       	push   $0x2858e
   15f78:	6a 00                	push   $0x0
   15f7a:	56                   	push   %esi
   15f7b:	e8 42 fc fe ff       	call   5bc2 <shell_fprintf>
   15f80:	83 c4 0c             	add    $0xc,%esp
	if (ipv4) {
   15f83:	85 ff                	test   %edi,%edi
   15f85:	74 42                	je     15fc9 <iface_cb+0x583>
		PR("IPv4 gateway : %s\n",
   15f87:	8d 87 08 01 00 00    	lea    0x108(%edi),%eax
		PR("IPv4 netmask : %s\n",
   15f8d:	81 c7 0c 01 00 00    	add    $0x10c,%edi
		PR("IPv4 gateway : %s\n",
   15f93:	50                   	push   %eax
   15f94:	6a 01                	push   $0x1
   15f96:	e8 03 ab ff ff       	call   10a9e <net_sprint_addr>
   15f9b:	5a                   	pop    %edx
   15f9c:	59                   	pop    %ecx
   15f9d:	50                   	push   %eax
   15f9e:	68 1d 89 02 00       	push   $0x2891d
   15fa3:	6a 00                	push   $0x0
   15fa5:	56                   	push   %esi
   15fa6:	e8 17 fc fe ff       	call   5bc2 <shell_fprintf>
   15fab:	83 c4 10             	add    $0x10,%esp
		PR("IPv4 netmask : %s\n",
   15fae:	57                   	push   %edi
   15faf:	6a 01                	push   $0x1
   15fb1:	e8 e8 aa ff ff       	call   10a9e <net_sprint_addr>
   15fb6:	5b                   	pop    %ebx
   15fb7:	5f                   	pop    %edi
   15fb8:	50                   	push   %eax
   15fb9:	68 30 89 02 00       	push   $0x28930
   15fbe:	6a 00                	push   $0x0
   15fc0:	56                   	push   %esi
   15fc1:	e8 fc fb fe ff       	call   5bc2 <shell_fprintf>
   15fc6:	83 c4 10             	add    $0x10,%esp
}
   15fc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15fcc:	5b                   	pop    %ebx
   15fcd:	5e                   	pop    %esi
   15fce:	5f                   	pop    %edi
   15fcf:	5d                   	pop    %ebp
   15fd0:	c3                   	ret    

00015fd1 <address_lifetime_cb>:
{
   15fd1:	55                   	push   %ebp
   15fd2:	89 e5                	mov    %esp,%ebp
   15fd4:	57                   	push   %edi
   15fd5:	56                   	push   %esi
   15fd6:	53                   	push   %ebx
   15fd7:	83 ec 28             	sub    $0x28,%esp
	const struct shell *shell = data->shell;
   15fda:	8b 45 0c             	mov    0xc(%ebp),%eax
   15fdd:	8b 38                	mov    (%eax),%edi
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
   15fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   15fe2:	8b 40 04             	mov    0x4(%eax),%eax
   15fe5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return iface->if_dev->l2;
   15fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   15feb:	8b 00                	mov    (%eax),%eax
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
   15fed:	81 78 04 2c 51 02 00 	cmpl   $0x2512c,0x4(%eax)
   15ff4:	74 0c                	je     16002 <address_lifetime_cb+0x31>
		*extra = "==============";
   15ff6:	bb 0f 86 02 00       	mov    $0x2860f,%ebx
	return "<unknown type>";
   15ffb:	b8 67 83 02 00       	mov    $0x28367,%eax
   16000:	eb 0a                	jmp    1600c <address_lifetime_cb+0x3b>
			*extra = "========";
   16002:	bb 15 86 02 00       	mov    $0x28615,%ebx
		return "Ethernet";
   16007:	b8 5e 83 02 00       	mov    $0x2835e,%eax
	PR("\nIPv6 addresses for interface %p (%s)\n", iface,
   1600c:	50                   	push   %eax
   1600d:	ff 75 08             	pushl  0x8(%ebp)
   16010:	68 43 89 02 00       	push   $0x28943
   16015:	6a 00                	push   $0x0
   16017:	57                   	push   %edi
   16018:	e8 a5 fb fe ff       	call   5bc2 <shell_fprintf>
   1601d:	83 c4 14             	add    $0x14,%esp
	PR("==========================================%s\n", extra);
   16020:	53                   	push   %ebx
   16021:	68 6a 89 02 00       	push   $0x2896a
   16026:	6a 00                	push   $0x0
   16028:	57                   	push   %edi
   16029:	e8 94 fb fe ff       	call   5bc2 <shell_fprintf>
   1602e:	83 c4 10             	add    $0x10,%esp
	if (!ipv6) {
   16031:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16035:	75 15                	jne    1604c <address_lifetime_cb+0x7b>
		PR("No IPv6 config found for this interface.\n");
   16037:	68 98 89 02 00       	push   $0x28998
   1603c:	6a 00                	push   $0x0
   1603e:	57                   	push   %edi
   1603f:	e8 7e fb fe ff       	call   5bc2 <shell_fprintf>
   16044:	83 c4 0c             	add    $0xc,%esp
		return;
   16047:	e9 4a 01 00 00       	jmp    16196 <address_lifetime_cb+0x1c5>
	PR("Type      \tState    \tLifetime (sec)\tAddress\n");
   1604c:	68 c2 89 02 00       	push   $0x289c2
   16051:	6a 00                	push   $0x0
   16053:	57                   	push   %edi
   16054:	e8 69 fb fe ff       	call   5bc2 <shell_fprintf>
   16059:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
   1605c:	8b 75 e0             	mov    -0x20(%ebp),%esi
   1605f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		if (!ipv6->unicast[i].is_used ||
   16066:	6b 45 e4 48          	imul   $0x48,-0x1c(%ebp),%eax
   1606a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
   1606d:	f6 44 03 47 02       	testb  $0x2,0x47(%ebx,%eax,1)
   16072:	0f 84 0e 01 00 00    	je     16186 <address_lifetime_cb+0x1b5>
   16078:	66 83 3e 02          	cmpw   $0x2,(%esi)
   1607c:	0f 85 04 01 00 00    	jne    16186 <address_lifetime_cb+0x1b5>
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   16082:	8b 46 1c             	mov    0x1c(%esi),%eax
			(u64_t)ipv6->unicast[i].lifetime.wrap_counter *
   16085:	8b 5e 20             	mov    0x20(%esi),%ebx
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   16088:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			(u64_t)time_diff(k_uptime_get_32(),
   1608b:	8b 46 18             	mov    0x18(%esi),%eax
   1608e:	89 45 d0             	mov    %eax,-0x30(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
   16091:	e8 5c e8 00 00       	call   248f2 <z_impl_k_uptime_get_32>
   16096:	89 45 cc             	mov    %eax,-0x34(%ebp)
		prefix = net_if_ipv6_prefix_get(iface,
   16099:	8d 46 04             	lea    0x4(%esi),%eax
   1609c:	50                   	push   %eax
   1609d:	89 45 d8             	mov    %eax,-0x28(%ebp)
   160a0:	ff 75 08             	pushl  0x8(%ebp)
   160a3:	e8 2e 8b ff ff       	call   ebd6 <net_if_ipv6_prefix_get>
			prefix_len = 128U;
   160a8:	c6 45 dc 80          	movb   $0x80,-0x24(%ebp)
		prefix = net_if_ipv6_prefix_get(iface,
   160ac:	5a                   	pop    %edx
		if (prefix) {
   160ad:	85 c0                	test   %eax,%eax
		prefix = net_if_ipv6_prefix_get(iface,
   160af:	59                   	pop    %ecx
		if (prefix) {
   160b0:	74 06                	je     160b8 <address_lifetime_cb+0xe7>
			prefix_len = prefix->len;
   160b2:	8a 40 24             	mov    0x24(%eax),%al
   160b5:	88 45 dc             	mov    %al,-0x24(%ebp)
		if (ipv6->unicast[i].is_infinite) {
   160b8:	6b 45 e4 48          	imul   $0x48,-0x1c(%ebp),%eax
   160bc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   160bf:	f6 44 01 47 01       	testb  $0x1,0x47(%ecx,%eax,1)
   160c4:	74 15                	je     160db <address_lifetime_cb+0x10a>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
   160c6:	68 2c 87 02 00       	push   $0x2872c
   160cb:	8d 45 e8             	lea    -0x18(%ebp),%eax
   160ce:	6a 0b                	push   $0xb
   160d0:	50                   	push   %eax
   160d1:	e8 07 cb fe ff       	call   2bdd <snprintk>
   160d6:	83 c4 0c             	add    $0xc,%esp
   160d9:	eb 4f                	jmp    1612a <address_lifetime_cb+0x159>
			(u64_t)ipv6->unicast[i].lifetime.wrap_counter *
   160db:	b9 9b ff ff 7f       	mov    $0x7fffff9b,%ecx
				 "%u", (u32_t)(remaining / 1000));
   160e0:	6a 00                	push   $0x0
			(u64_t)ipv6->unicast[i].lifetime.wrap_counter *
   160e2:	89 c8                	mov    %ecx,%eax
				 "%u", (u32_t)(remaining / 1000));
   160e4:	68 e8 03 00 00       	push   $0x3e8
			(u64_t)ipv6->unicast[i].lifetime.wrap_counter *
   160e9:	f7 eb                	imul   %ebx
   160eb:	89 c1                	mov    %eax,%ecx
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   160ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
			(u64_t)ipv6->unicast[i].lifetime.wrap_counter *
   160f0:	89 d3                	mov    %edx,%ebx
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   160f2:	99                   	cltd   
   160f3:	01 c8                	add    %ecx,%eax
	return (u32_t)abs((s32_t)time1 - (s32_t)time2);
   160f5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   160f8:	11 da                	adc    %ebx,%edx
	return (u32_t)abs((s32_t)time1 - (s32_t)time2);
   160fa:	2b 4d d0             	sub    -0x30(%ebp),%ecx
   160fd:	89 cb                	mov    %ecx,%ebx
   160ff:	c1 fb 1f             	sar    $0x1f,%ebx
   16102:	31 d9                	xor    %ebx,%ecx
   16104:	29 d9                	sub    %ebx,%ecx
			(u64_t)time_diff(k_uptime_get_32(),
   16106:	31 db                	xor    %ebx,%ebx
		remaining = (u64_t)ipv6->unicast[i].lifetime.timer_timeout +
   16108:	29 c8                	sub    %ecx,%eax
   1610a:	19 da                	sbb    %ebx,%edx
				 "%u", (u32_t)(remaining / 1000));
   1610c:	52                   	push   %edx
   1610d:	50                   	push   %eax
   1610e:	e8 da b0 fe ff       	call   11ed <__udivdi3>
   16113:	83 c4 10             	add    $0x10,%esp
			snprintk(remaining_str, sizeof(remaining_str) - 1,
   16116:	50                   	push   %eax
   16117:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1611a:	68 50 a3 02 00       	push   $0x2a350
   1611f:	6a 0b                	push   $0xb
   16121:	50                   	push   %eax
   16122:	e8 b6 ca fe ff       	call   2bdd <snprintk>
   16127:	83 c4 10             	add    $0x10,%esp
		PR("%s  \t%s\t%s    \t%s/%d\n",
   1612a:	ff 75 d8             	pushl  -0x28(%ebp)
   1612d:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
   16131:	6a 02                	push   $0x2
   16133:	89 45 dc             	mov    %eax,-0x24(%ebp)
   16136:	e8 63 a9 ff ff       	call   10a9e <net_sprint_addr>
   1613b:	8a 5e 45             	mov    0x45(%esi),%bl
   1613e:	5a                   	pop    %edx
   1613f:	8d 53 01             	lea    0x1(%ebx),%edx
   16142:	59                   	pop    %ecx
	switch (addr_state) {
   16143:	bb 3a 7c 02 00       	mov    $0x27c3a,%ebx
   16148:	80 fa 03             	cmp    $0x3,%dl
   1614b:	77 0a                	ja     16157 <address_lifetime_cb+0x186>
   1614d:	0f b6 d2             	movzbl %dl,%edx
   16150:	8b 1c 95 78 60 02 00 	mov    0x26078(,%edx,4),%ebx
		PR("%s  \t%s\t%s    \t%s/%d\n",
   16157:	0f b6 56 44          	movzbl 0x44(%esi),%edx
   1615b:	b9 35 87 02 00       	mov    $0x28735,%ecx
   16160:	80 fa 04             	cmp    $0x4,%dl
   16163:	77 07                	ja     1616c <address_lifetime_cb+0x19b>
   16165:	8b 0c 95 88 60 02 00 	mov    0x26088(,%edx,4),%ecx
   1616c:	ff 75 dc             	pushl  -0x24(%ebp)
   1616f:	50                   	push   %eax
   16170:	8d 45 e8             	lea    -0x18(%ebp),%eax
   16173:	50                   	push   %eax
   16174:	53                   	push   %ebx
   16175:	51                   	push   %ecx
   16176:	68 ef 89 02 00       	push   $0x289ef
   1617b:	6a 00                	push   $0x0
   1617d:	57                   	push   %edi
   1617e:	e8 3f fa fe ff       	call   5bc2 <shell_fprintf>
   16183:	83 c4 20             	add    $0x20,%esp
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
   16186:	ff 45 e4             	incl   -0x1c(%ebp)
   16189:	83 c6 48             	add    $0x48,%esi
   1618c:	83 7d e4 03          	cmpl   $0x3,-0x1c(%ebp)
   16190:	0f 85 d0 fe ff ff    	jne    16066 <address_lifetime_cb+0x95>
}
   16196:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16199:	5b                   	pop    %ebx
   1619a:	5e                   	pop    %esi
   1619b:	5f                   	pop    %edi
   1619c:	5d                   	pop    %ebp
   1619d:	c3                   	ret    

0001619e <net_shell_init>:
SHELL_CMD_REGISTER(net, &net_commands, "Networking commands", NULL);

int net_shell_init(void)
{
	return 0;
}
   1619e:	31 c0                	xor    %eax,%eax
   161a0:	c3                   	ret    

000161a1 <net_ipv6_is_addr_unspecified>:
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   161a1:	31 d2                	xor    %edx,%edx
   161a3:	83 38 00             	cmpl   $0x0,(%eax)
   161a6:	75 15                	jne    161bd <net_ipv6_is_addr_unspecified+0x1c>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
   161a8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   161ac:	75 0f                	jne    161bd <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
   161ae:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   161b2:	75 09                	jne    161bd <net_ipv6_is_addr_unspecified+0x1c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
   161b4:	31 d2                	xor    %edx,%edx
   161b6:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
   161ba:	0f 94 c2             	sete   %dl
   161bd:	88 d0                	mov    %dl,%al
   161bf:	83 e0 01             	and    $0x1,%eax
}
   161c2:	c3                   	ret    

000161c3 <check_addr>:

static bool check_addr(struct net_pkt *pkt,
		       union net_ip_header *ip_hdr,
		       struct sockaddr *addr,
		       bool is_remote)
{
   161c3:	55                   	push   %ebp
   161c4:	89 e5                	mov    %esp,%ebp
   161c6:	57                   	push   %edi
   161c7:	56                   	push   %esi
   161c8:	53                   	push   %ebx
   161c9:	8b 75 08             	mov    0x8(%ebp),%esi
	return pkt->family;
   161cc:	8a 40 3f             	mov    0x3f(%eax),%al
	if (addr->sa_family != net_pkt_family(pkt)) {
   161cf:	8b 19                	mov    (%ecx),%ebx
   161d1:	d0 e8                	shr    %al
   161d3:	83 e0 07             	and    $0x7,%eax
   161d6:	0f b6 f8             	movzbl %al,%edi
   161d9:	66 39 fb             	cmp    %di,%bx
   161dc:	75 62                	jne    16240 <check_addr+0x7d>
		return false;
	}

#if defined(CONFIG_NET_IPV6)
	if (net_pkt_family(pkt) == AF_INET6 && addr->sa_family == AF_INET6) {
   161de:	3c 02                	cmp    $0x2,%al
   161e0:	75 34                	jne    16216 <check_addr+0x53>
   161e2:	66 83 fb 02          	cmp    $0x2,%bx
			}
		}
	}
#endif /* CONFIG_NET_IPV4 */

	return true;
   161e6:	b0 01                	mov    $0x1,%al
	if (net_pkt_family(pkt) == AF_INET6 && addr->sa_family == AF_INET6) {
   161e8:	75 5c                	jne    16246 <check_addr+0x83>
		if (is_remote) {
   161ea:	8b 02                	mov    (%edx),%eax
   161ec:	89 f2                	mov    %esi,%edx
   161ee:	84 d2                	test   %dl,%dl
			addr6 = &ip_hdr->ipv6->dst;
   161f0:	8d 58 18             	lea    0x18(%eax),%ebx
		if (is_remote) {
   161f3:	74 03                	je     161f8 <check_addr+0x35>
			addr6 = &ip_hdr->ipv6->src;
   161f5:	8d 58 08             	lea    0x8(%eax),%ebx
			    &net_sin6(addr)->sin6_addr)) {
   161f8:	83 c1 04             	add    $0x4,%ecx
		if (!net_ipv6_is_addr_unspecified(
   161fb:	89 c8                	mov    %ecx,%eax
   161fd:	e8 9f ff ff ff       	call   161a1 <net_ipv6_is_addr_unspecified>
   16202:	84 c0                	test   %al,%al
   16204:	75 40                	jne    16246 <check_addr+0x83>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
   16206:	6a 10                	push   $0x10
   16208:	53                   	push   %ebx
   16209:	51                   	push   %ecx
   1620a:	e8 b7 46 ff ff       	call   a8c6 <memcmp>
   1620f:	83 c4 0c             	add    $0xc,%esp
			if (!net_ipv6_addr_cmp(&net_sin6(addr)->sin6_addr,
   16212:	85 c0                	test   %eax,%eax
   16214:	eb 25                	jmp    1623b <check_addr+0x78>
	if (net_pkt_family(pkt) == AF_INET && addr->sa_family == AF_INET) {
   16216:	66 4b                	dec    %bx
   16218:	0f 94 c3             	sete   %bl
   1621b:	fe c8                	dec    %al
   1621d:	0f 94 c0             	sete   %al
   16220:	20 d8                	and    %bl,%al
   16222:	74 20                	je     16244 <check_addr+0x81>
		if (is_remote) {
   16224:	8b 3a                	mov    (%edx),%edi
   16226:	89 f2                	mov    %esi,%edx
   16228:	84 d2                	test   %dl,%dl
			addr4 = &ip_hdr->ipv4->dst;
   1622a:	8d 5f 10             	lea    0x10(%edi),%ebx
		if (is_remote) {
   1622d:	74 03                	je     16232 <check_addr+0x6f>
			addr4 = &ip_hdr->ipv4->src;
   1622f:	8d 5f 0c             	lea    0xc(%edi),%ebx
		if (net_sin(addr)->sin_addr.s_addr) {
   16232:	8b 51 04             	mov    0x4(%ecx),%edx
   16235:	85 d2                	test   %edx,%edx
   16237:	74 0d                	je     16246 <check_addr+0x83>
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
   16239:	39 13                	cmp    %edx,(%ebx)
   1623b:	0f 94 c0             	sete   %al
   1623e:	eb 06                	jmp    16246 <check_addr+0x83>
		return false;
   16240:	31 c0                	xor    %eax,%eax
   16242:	eb 02                	jmp    16246 <check_addr+0x83>
	return true;
   16244:	b0 01                	mov    $0x1,%al
}
   16246:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16249:	5b                   	pop    %ebx
   1624a:	5e                   	pop    %esi
   1624b:	5f                   	pop    %edi
   1624c:	5d                   	pop    %ebp
   1624d:	c3                   	ret    

0001624e <net_conn_unregister>:
{
   1624e:	55                   	push   %ebp
   1624f:	89 e5                	mov    %esp,%ebp
   16251:	8b 55 08             	mov    0x8(%ebp),%edx
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
   16254:	81 fa 20 11 40 00    	cmp    $0x401120,%edx
   1625a:	72 24                	jb     16280 <net_conn_unregister+0x32>
   1625c:	81 fa 20 13 40 00    	cmp    $0x401320,%edx
   16262:	77 1c                	ja     16280 <net_conn_unregister+0x32>
		return -ENOENT;
   16264:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(conn->flags & NET_CONN_IN_USE)) {
   16269:	f6 42 3b 01          	testb  $0x1,0x3b(%edx)
   1626d:	74 16                	je     16285 <net_conn_unregister+0x37>
	(void)memset(conn, 0, sizeof(*conn));
   1626f:	6a 40                	push   $0x40
   16271:	6a 00                	push   $0x0
   16273:	52                   	push   %edx
   16274:	e8 27 47 ff ff       	call   a9a0 <memset>
   16279:	83 c4 0c             	add    $0xc,%esp
	return 0;
   1627c:	31 c0                	xor    %eax,%eax
   1627e:	eb 05                	jmp    16285 <net_conn_unregister+0x37>
		return -EINVAL;
   16280:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   16285:	c9                   	leave  
   16286:	c3                   	ret    

00016287 <net_conn_register>:
{
   16287:	55                   	push   %ebp
   16288:	89 e5                	mov    %esp,%ebp
   1628a:	57                   	push   %edi
   1628b:	56                   	push   %esi
   1628c:	bf 20 11 40 00       	mov    $0x401120,%edi
   16291:	53                   	push   %ebx
   16292:	83 ec 1c             	sub    $0x1c,%esp
   16295:	8b 45 08             	mov    0x8(%ebp),%eax
   16298:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1629b:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1629e:	8b 45 0c             	mov    0xc(%ebp),%eax
   162a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
   162a4:	8b 45 18             	mov    0x18(%ebp),%eax
   162a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   162aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   162ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
   162b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   162b3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
   162b7:	8a 45 e8             	mov    -0x18(%ebp),%al
   162ba:	88 45 db             	mov    %al,-0x25(%ebp)
   162bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162c0:	86 e0                	xchg   %ah,%al
   162c2:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
   162c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162c9:	8b 75 14             	mov    0x14(%ebp),%esi
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
   162cc:	86 e0                	xchg   %ah,%al
   162ce:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
   162d2:	8a 47 3b             	mov    0x3b(%edi),%al
   162d5:	a8 01                	test   $0x1,%al
   162d7:	75 13                	jne    162ec <net_conn_register+0x65>
   162d9:	83 c7 40             	add    $0x40,%edi
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
   162dc:	b8 20 13 40 00       	mov    $0x401320,%eax
   162e1:	39 f8                	cmp    %edi,%eax
   162e3:	75 ed                	jne    162d2 <net_conn_register+0x4b>
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
   162e5:	31 ff                	xor    %edi,%edi
   162e7:	e9 d2 00 00 00       	jmp    163be <net_conn_register+0x137>
		if (conns[i].proto != proto) {
   162ec:	8b 55 dc             	mov    -0x24(%ebp),%edx
   162ef:	66 3b 57 38          	cmp    0x38(%edi),%dx
   162f3:	75 e4                	jne    162d9 <net_conn_register+0x52>
		if (conns[i].family != family) {
   162f5:	8a 55 db             	mov    -0x25(%ebp),%dl
   162f8:	3a 57 3a             	cmp    0x3a(%edi),%dl
   162fb:	75 dc                	jne    162d9 <net_conn_register+0x52>
		if (remote_addr) {
   162fd:	83 e0 02             	and    $0x2,%eax
   16300:	85 db                	test   %ebx,%ebx
   16302:	74 3b                	je     1633f <net_conn_register+0xb8>
			if (!(conns[i].flags & NET_CONN_REMOTE_ADDR_SET)) {
   16304:	84 c0                	test   %al,%al
   16306:	74 d1                	je     162d9 <net_conn_register+0x52>
			if (remote_addr->sa_family == AF_INET6 &&
   16308:	66 8b 03             	mov    (%ebx),%ax
   1630b:	66 83 f8 02          	cmp    $0x2,%ax
   1630f:	75 1c                	jne    1632d <net_conn_register+0xa6>
   16311:	66 83 3f 02          	cmpw   $0x2,(%edi)
   16315:	75 c2                	jne    162d9 <net_conn_register+0x52>
   16317:	6a 10                	push   $0x10
   16319:	8d 47 04             	lea    0x4(%edi),%eax
   1631c:	50                   	push   %eax
					    &net_sin6(remote_addr)->sin6_addr,
   1631d:	8d 43 04             	lea    0x4(%ebx),%eax
   16320:	50                   	push   %eax
   16321:	e8 a0 45 ff ff       	call   a8c6 <memcmp>
   16326:	83 c4 0c             	add    $0xc,%esp
				if (!net_ipv6_addr_cmp(
   16329:	85 c0                	test   %eax,%eax
   1632b:	eb 14                	jmp    16341 <net_conn_register+0xba>
			if (remote_addr->sa_family == AF_INET &&
   1632d:	66 48                	dec    %ax
   1632f:	75 a8                	jne    162d9 <net_conn_register+0x52>
   16331:	66 83 3f 01          	cmpw   $0x1,(%edi)
   16335:	75 a2                	jne    162d9 <net_conn_register+0x52>
				if (!net_ipv4_addr_cmp(
   16337:	8b 47 04             	mov    0x4(%edi),%eax
   1633a:	39 43 04             	cmp    %eax,0x4(%ebx)
   1633d:	eb 02                	jmp    16341 <net_conn_register+0xba>
			if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
   1633f:	84 c0                	test   %al,%al
   16341:	75 96                	jne    162d9 <net_conn_register+0x52>
		if (local_addr) {
   16343:	8a 47 3b             	mov    0x3b(%edi),%al
   16346:	83 e0 04             	and    $0x4,%eax
   16349:	85 f6                	test   %esi,%esi
   1634b:	74 49                	je     16396 <net_conn_register+0x10f>
			if (!(conns[i].flags & NET_CONN_LOCAL_ADDR_SET)) {
   1634d:	84 c0                	test   %al,%al
   1634f:	74 88                	je     162d9 <net_conn_register+0x52>
			if (local_addr->sa_family == AF_INET6 &&
   16351:	66 8b 06             	mov    (%esi),%ax
   16354:	66 83 f8 02          	cmp    $0x2,%ax
   16358:	75 21                	jne    1637b <net_conn_register+0xf4>
   1635a:	66 83 7f 18 02       	cmpw   $0x2,0x18(%edi)
   1635f:	0f 85 74 ff ff ff    	jne    162d9 <net_conn_register+0x52>
   16365:	6a 10                	push   $0x10
   16367:	8d 47 1c             	lea    0x1c(%edi),%eax
   1636a:	50                   	push   %eax
					    &net_sin6(local_addr)->sin6_addr,
   1636b:	8d 46 04             	lea    0x4(%esi),%eax
   1636e:	50                   	push   %eax
   1636f:	e8 52 45 ff ff       	call   a8c6 <memcmp>
   16374:	83 c4 0c             	add    $0xc,%esp
				if (!net_ipv6_addr_cmp(
   16377:	85 c0                	test   %eax,%eax
   16379:	eb 1d                	jmp    16398 <net_conn_register+0x111>
			if (local_addr->sa_family == AF_INET &&
   1637b:	66 48                	dec    %ax
   1637d:	0f 85 56 ff ff ff    	jne    162d9 <net_conn_register+0x52>
   16383:	66 83 7f 18 01       	cmpw   $0x1,0x18(%edi)
   16388:	0f 85 4b ff ff ff    	jne    162d9 <net_conn_register+0x52>
				if (!net_ipv4_addr_cmp(
   1638e:	8b 47 1c             	mov    0x1c(%edi),%eax
   16391:	39 46 04             	cmp    %eax,0x4(%esi)
   16394:	eb 02                	jmp    16398 <net_conn_register+0x111>
			if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
   16396:	84 c0                	test   %al,%al
   16398:	0f 85 3b ff ff ff    	jne    162d9 <net_conn_register+0x52>
		if (net_sin(&conns[i].remote_addr)->sin_port !=
   1639e:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
   163a2:	66 3b 47 02          	cmp    0x2(%edi),%ax
   163a6:	0f 85 2d ff ff ff    	jne    162d9 <net_conn_register+0x52>
		if (net_sin(&conns[i].local_addr)->sin_port !=
   163ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   163af:	66 3b 47 1a          	cmp    0x1a(%edi),%ax
   163b3:	0f 84 06 02 00 00    	je     165bf <net_conn_register+0x338>
   163b9:	e9 1b ff ff ff       	jmp    162d9 <net_conn_register+0x52>
		if (conns[i].flags & NET_CONN_IN_USE) {
   163be:	89 f9                	mov    %edi,%ecx
   163c0:	c1 e1 06             	shl    $0x6,%ecx
   163c3:	8a 91 5b 11 40 00    	mov    0x40115b(%ecx),%dl
   163c9:	80 e2 01             	and    $0x1,%dl
   163cc:	74 10                	je     163de <net_conn_register+0x157>
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
   163ce:	47                   	inc    %edi
   163cf:	83 ff 08             	cmp    $0x8,%edi
   163d2:	75 ea                	jne    163be <net_conn_register+0x137>
	return -ENOENT;
   163d4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   163d9:	e9 11 02 00 00       	jmp    165ef <net_conn_register+0x368>
		if (remote_addr) {
   163de:	85 db                	test   %ebx,%ebx
   163e0:	0f 84 96 00 00 00    	je     1647c <net_conn_register+0x1f5>
			if (remote_addr->sa_family == AF_INET6) {
   163e6:	66 8b 03             	mov    (%ebx),%ax
   163e9:	66 83 f8 02          	cmp    $0x2,%ax
   163ed:	75 28                	jne    16417 <net_conn_register+0x190>
				memcpy(&conns[i].remote_addr, remote_addr,
   163ef:	6a 18                	push   $0x18
   163f1:	8d 81 20 11 40 00    	lea    0x401120(%ecx),%eax
   163f7:	53                   	push   %ebx
   163f8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
   163fb:	50                   	push   %eax
   163fc:	e8 30 45 ff ff       	call   a931 <memcpy>
   16401:	83 c4 0c             	add    $0xc,%esp
					    &net_sin6(remote_addr)->
   16404:	8d 43 04             	lea    0x4(%ebx),%eax
				if (net_ipv6_is_addr_unspecified(
   16407:	e8 95 fd ff ff       	call   161a1 <net_ipv6_is_addr_unspecified>
   1640c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1640f:	84 c0                	test   %al,%al
   16411:	75 26                	jne    16439 <net_conn_register+0x1b2>
					rank |= NET_RANK_REMOTE_SPEC_ADDR;
   16413:	b2 20                	mov    $0x20,%dl
   16415:	eb 59                	jmp    16470 <net_conn_register+0x1e9>
			if (remote_addr->sa_family == AF_INET) {
   16417:	66 48                	dec    %ax
   16419:	75 22                	jne    1643d <net_conn_register+0x1b6>
				memcpy(&conns[i].remote_addr, remote_addr,
   1641b:	6a 08                	push   $0x8
   1641d:	8d 81 20 11 40 00    	lea    0x401120(%ecx),%eax
   16423:	53                   	push   %ebx
   16424:	89 4d dc             	mov    %ecx,-0x24(%ebp)
   16427:	50                   	push   %eax
   16428:	e8 04 45 ff ff       	call   a931 <memcpy>
   1642d:	83 c4 0c             	add    $0xc,%esp
				if (!net_sin(remote_addr)->
   16430:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   16433:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
   16437:	75 da                	jne    16413 <net_conn_register+0x18c>
					rank |= NET_RANK_REMOTE_UNSPEC_ADDR;
   16439:	b2 08                	mov    $0x8,%dl
   1643b:	eb 33                	jmp    16470 <net_conn_register+0x1e9>
				NET_ERR("Remote address family not set");
   1643d:	f6 05 70 a8 40 00 07 	testb  $0x7,0x40a870
   16444:	74 20                	je     16466 <net_conn_register+0x1df>
   16446:	b8 64 51 02 00       	mov    $0x25164,%eax
   1644b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   16450:	c1 e8 03             	shr    $0x3,%eax
   16453:	c1 e0 06             	shl    $0x6,%eax
   16456:	83 c8 01             	or     $0x1,%eax
   16459:	50                   	push   %eax
   1645a:	68 54 91 02 00       	push   $0x29154
   1645f:	e8 26 d0 fe ff       	call   348a <log_0>
   16464:	58                   	pop    %eax
   16465:	5a                   	pop    %edx
				return -EINVAL;
   16466:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1646b:	e9 7f 01 00 00       	jmp    165ef <net_conn_register+0x368>
			conns[i].flags |= NET_CONN_REMOTE_ADDR_SET;
   16470:	89 f8                	mov    %edi,%eax
   16472:	c1 e0 06             	shl    $0x6,%eax
   16475:	80 88 5b 11 40 00 02 	orb    $0x2,0x40115b(%eax)
		if (local_addr) {
   1647c:	85 f6                	test   %esi,%esi
   1647e:	0f 84 d2 00 00 00    	je     16556 <net_conn_register+0x2cf>
			if (local_addr->sa_family == AF_INET6) {
   16484:	66 8b 06             	mov    (%esi),%ax
   16487:	88 55 db             	mov    %dl,-0x25(%ebp)
   1648a:	66 83 f8 02          	cmp    $0x2,%ax
   1648e:	75 29                	jne    164b9 <net_conn_register+0x232>
				memcpy(&conns[i].local_addr, local_addr,
   16490:	6a 18                	push   $0x18
   16492:	8d 81 38 11 40 00    	lea    0x401138(%ecx),%eax
   16498:	56                   	push   %esi
   16499:	89 4d dc             	mov    %ecx,-0x24(%ebp)
   1649c:	50                   	push   %eax
   1649d:	e8 8f 44 ff ff       	call   a931 <memcpy>
   164a2:	83 c4 0c             	add    $0xc,%esp
					    &net_sin6(local_addr)->
   164a5:	8d 46 04             	lea    0x4(%esi),%eax
				if (net_ipv6_is_addr_unspecified(
   164a8:	e8 f4 fc ff ff       	call   161a1 <net_ipv6_is_addr_unspecified>
   164ad:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   164b0:	84 c0                	test   %al,%al
   164b2:	8a 55 db             	mov    -0x25(%ebp),%dl
   164b5:	74 2c                	je     164e3 <net_conn_register+0x25c>
   164b7:	eb 25                	jmp    164de <net_conn_register+0x257>
			if (local_addr->sa_family == AF_INET) {
   164b9:	66 48                	dec    %ax
   164bb:	75 2b                	jne    164e8 <net_conn_register+0x261>
				memcpy(&conns[i].local_addr, local_addr,
   164bd:	6a 08                	push   $0x8
   164bf:	8d 81 38 11 40 00    	lea    0x401138(%ecx),%eax
   164c5:	56                   	push   %esi
   164c6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
   164c9:	50                   	push   %eax
   164ca:	e8 62 44 ff ff       	call   a931 <memcpy>
   164cf:	83 c4 0c             	add    $0xc,%esp
				if (!net_sin(local_addr)->sin_addr.s_addr) {
   164d2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   164d5:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
   164d9:	8a 55 db             	mov    -0x25(%ebp),%dl
   164dc:	75 05                	jne    164e3 <net_conn_register+0x25c>
					rank |= NET_RANK_LOCAL_UNSPEC_ADDR;
   164de:	83 ca 04             	or     $0x4,%edx
   164e1:	eb 30                	jmp    16513 <net_conn_register+0x28c>
					rank |= NET_RANK_LOCAL_SPEC_ADDR;
   164e3:	83 ca 10             	or     $0x10,%edx
   164e6:	eb 2b                	jmp    16513 <net_conn_register+0x28c>
				NET_ERR("Local address family not set");
   164e8:	f6 05 70 a8 40 00 07 	testb  $0x7,0x40a870
   164ef:	0f 84 71 ff ff ff    	je     16466 <net_conn_register+0x1df>
   164f5:	b8 64 51 02 00       	mov    $0x25164,%eax
   164fa:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   164ff:	c1 e8 03             	shr    $0x3,%eax
   16502:	c1 e0 06             	shl    $0x6,%eax
   16505:	83 c8 01             	or     $0x1,%eax
   16508:	50                   	push   %eax
   16509:	68 72 91 02 00       	push   $0x29172
   1650e:	e9 4c ff ff ff       	jmp    1645f <net_conn_register+0x1d8>
			conns[i].flags |= NET_CONN_LOCAL_ADDR_SET;
   16513:	89 f8                	mov    %edi,%eax
   16515:	c1 e0 06             	shl    $0x6,%eax
   16518:	80 88 5b 11 40 00 04 	orb    $0x4,0x40115b(%eax)
		if (remote_addr && local_addr) {
   1651f:	85 db                	test   %ebx,%ebx
   16521:	74 33                	je     16556 <net_conn_register+0x2cf>
			if (remote_addr->sa_family != local_addr->sa_family) {
   16523:	66 8b 06             	mov    (%esi),%ax
   16526:	66 39 03             	cmp    %ax,(%ebx)
   16529:	74 2b                	je     16556 <net_conn_register+0x2cf>
				NET_ERR("Address families different");
   1652b:	f6 05 70 a8 40 00 07 	testb  $0x7,0x40a870
   16532:	0f 84 2e ff ff ff    	je     16466 <net_conn_register+0x1df>
   16538:	b8 64 51 02 00       	mov    $0x25164,%eax
   1653d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   16542:	c1 e8 03             	shr    $0x3,%eax
   16545:	c1 e0 06             	shl    $0x6,%eax
   16548:	83 c8 01             	or     $0x1,%eax
   1654b:	50                   	push   %eax
   1654c:	68 8f 91 02 00       	push   $0x2918f
   16551:	e9 09 ff ff ff       	jmp    1645f <net_conn_register+0x1d8>
		if (remote_port) {
   16556:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
   1655b:	74 0e                	je     1656b <net_conn_register+0x2e4>
			net_sin(&conns[i].remote_addr)->sin_port =
   1655d:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
			rank |= NET_RANK_REMOTE_PORT;
   16561:	83 ca 02             	or     $0x2,%edx
			net_sin(&conns[i].remote_addr)->sin_port =
   16564:	66 89 81 22 11 40 00 	mov    %ax,0x401122(%ecx)
		if (local_port) {
   1656b:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
   16570:	74 0d                	je     1657f <net_conn_register+0x2f8>
			net_sin(&conns[i].local_addr)->sin_port =
   16572:	8b 45 f0             	mov    -0x10(%ebp),%eax
			rank |= NET_RANK_LOCAL_PORT;
   16575:	83 ca 01             	or     $0x1,%edx
			net_sin(&conns[i].local_addr)->sin_port =
   16578:	66 89 81 3a 11 40 00 	mov    %ax,0x40113a(%ecx)
		conns[i].flags |= NET_CONN_IN_USE;
   1657f:	c1 e7 06             	shl    $0x6,%edi
		conns[i].cb = cb;
   16582:	8b 45 20             	mov    0x20(%ebp),%eax
		conns[i].flags |= NET_CONN_IN_USE;
   16585:	81 c7 20 11 40 00    	add    $0x401120,%edi
		conns[i].cb = cb;
   1658b:	89 47 30             	mov    %eax,0x30(%edi)
		conns[i].user_data = user_data;
   1658e:	8b 45 24             	mov    0x24(%ebp),%eax
   16591:	89 47 34             	mov    %eax,0x34(%edi)
		conns[i].proto = proto;
   16594:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16597:	66 89 47 38          	mov    %ax,0x38(%edi)
		conns[i].family = family;
   1659b:	8a 45 e8             	mov    -0x18(%ebp),%al
		conns[i].flags |= NET_CONN_IN_USE;
   1659e:	80 4f 3b 01          	orb    $0x1,0x3b(%edi)
		conns[i].family = family;
   165a2:	88 47 3a             	mov    %al,0x3a(%edi)
		conns[i].rank = rank;
   165a5:	88 57 3c             	mov    %dl,0x3c(%edi)
		return 0;
   165a8:	31 c0                	xor    %eax,%eax
		if (handle) {
   165aa:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
   165ae:	74 3f                	je     165ef <net_conn_register+0x368>
			*handle = (struct net_conn_handle *)&conns[i];
   165b0:	8b 45 28             	mov    0x28(%ebp),%eax
   165b3:	81 c1 20 11 40 00    	add    $0x401120,%ecx
   165b9:	89 08                	mov    %ecx,(%eax)
		return 0;
   165bb:	31 c0                	xor    %eax,%eax
   165bd:	eb 30                	jmp    165ef <net_conn_register+0x368>
		NET_ERR("Identical connection handler %p already found.",
   165bf:	f6 05 70 a8 40 00 07 	testb  $0x7,0x40a870
   165c6:	74 22                	je     165ea <net_conn_register+0x363>
   165c8:	b8 64 51 02 00       	mov    $0x25164,%eax
   165cd:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   165d2:	c1 e8 03             	shr    $0x3,%eax
   165d5:	c1 e0 06             	shl    $0x6,%eax
   165d8:	83 c8 01             	or     $0x1,%eax
   165db:	50                   	push   %eax
   165dc:	57                   	push   %edi
   165dd:	68 25 91 02 00       	push   $0x29125
   165e2:	e8 c8 ce fe ff       	call   34af <log_1>
   165e7:	83 c4 0c             	add    $0xc,%esp
		return -EALREADY;
   165ea:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
}
   165ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
   165f2:	5b                   	pop    %ebx
   165f3:	5e                   	pop    %esi
   165f4:	5f                   	pop    %edi
   165f5:	5d                   	pop    %ebp
   165f6:	c3                   	ret    

000165f7 <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				u8_t proto,
				union net_proto_header *proto_hdr)
{
   165f7:	55                   	push   %ebp
   165f8:	89 e5                	mov    %esp,%ebp
   165fa:	57                   	push   %edi
   165fb:	56                   	push   %esi
   165fc:	53                   	push   %ebx
   165fd:	83 ec 14             	sub    $0x14,%esp
   16600:	8b 75 08             	mov    0x8(%ebp),%esi
   16603:	8b 7d 0c             	mov    0xc(%ebp),%edi
	enum net_verdict verdict;
	u32_t cache_value = 0U;
	s32_t pos;
#endif

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   16606:	80 7d 10 11          	cmpb   $0x11,0x10(%ebp)
   1660a:	0f 85 13 02 00 00    	jne    16823 <net_conn_input+0x22c>
		src_port = proto_hdr->udp->src_port;
   16610:	8b 45 14             	mov    0x14(%ebp),%eax
   16613:	8b 00                	mov    (%eax),%eax
   16615:	66 8b 08             	mov    (%eax),%cx
		dst_port = proto_hdr->udp->dst_port;
   16618:	66 8b 40 02          	mov    0x2(%eax),%ax
		src_port = proto_hdr->udp->src_port;
   1661c:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
		dst_port = proto_hdr->udp->dst_port;
   16620:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	if (src_port != dst_port) {
   16624:	66 39 45 e8          	cmp    %ax,-0x18(%ebp)
   16628:	0f 85 9a 00 00 00    	jne    166c8 <net_conn_input+0xd1>
   1662e:	8a 46 3f             	mov    0x3f(%esi),%al
   16631:	d0 e8                	shr    %al
   16633:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
   16636:	fe c8                	dec    %al
   16638:	74 12                	je     1664c <net_conn_input+0x55>
   1663a:	8a 46 3f             	mov    0x3f(%esi),%al
   1663d:	d0 e8                	shr    %al
   1663f:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
   16642:	3c 02                	cmp    $0x2,%al
   16644:	0f 85 d9 01 00 00    	jne    16823 <net_conn_input+0x22c>
   1664a:	eb 4c                	jmp    16698 <net_conn_input+0xa1>
		if (net_ipv4_addr_cmp(&ip_hdr->ipv4->src, &ip_hdr->ipv4->dst) ||
   1664c:	8b 1f                	mov    (%edi),%ebx
   1664e:	8b 43 10             	mov    0x10(%ebx),%eax
   16651:	39 43 0c             	cmp    %eax,0xc(%ebx)
   16654:	0f 84 c9 01 00 00    	je     16823 <net_conn_input+0x22c>
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   1665a:	6a 00                	push   $0x0
		    net_ipv4_is_my_addr(&ip_hdr->ipv4->src)) {
   1665c:	8d 43 0c             	lea    0xc(%ebx),%eax
   1665f:	50                   	push   %eax
   16660:	89 45 f0             	mov    %eax,-0x10(%ebp)
   16663:	e8 74 8e ff ff       	call   f4dc <net_if_ipv4_addr_lookup>
   16668:	5a                   	pop    %edx
   16669:	59                   	pop    %ecx
   1666a:	85 c0                	test   %eax,%eax
   1666c:	0f 95 c1             	setne  %cl
	if (!ret) {
   1666f:	75 1e                	jne    1668f <net_conn_input+0x98>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   16671:	e8 36 ae ff ff       	call   114ac <net_ipv4_broadcast_address>
   16676:	8b 00                	mov    (%eax),%eax
   16678:	39 43 0c             	cmp    %eax,0xc(%ebx)
   1667b:	0f 84 a2 01 00 00    	je     16823 <net_conn_input+0x22c>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   16681:	ff 75 f0             	pushl  -0x10(%ebp)
   16684:	6a 00                	push   $0x0
   16686:	e8 d9 8c ff ff       	call   f364 <net_if_ipv4_is_addr_bcast>
   1668b:	5a                   	pop    %edx
   1668c:	59                   	pop    %ecx
   1668d:	88 c1                	mov    %al,%cl
		if (net_ipv4_addr_cmp(&ip_hdr->ipv4->src, &ip_hdr->ipv4->dst) ||
   1668f:	84 c9                	test   %cl,%cl
   16691:	74 a7                	je     1663a <net_conn_input+0x43>
   16693:	e9 8b 01 00 00       	jmp    16823 <net_conn_input+0x22c>
		if (net_ipv6_addr_cmp(&ip_hdr->ipv6->src, &ip_hdr->ipv6->dst) ||
   16698:	8b 07                	mov    (%edi),%eax
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
   1669a:	6a 10                	push   $0x10
   1669c:	8d 50 18             	lea    0x18(%eax),%edx
   1669f:	83 c0 08             	add    $0x8,%eax
   166a2:	52                   	push   %edx
   166a3:	50                   	push   %eax
   166a4:	e8 1d 42 ff ff       	call   a8c6 <memcmp>
   166a9:	83 c4 0c             	add    $0xc,%esp
   166ac:	85 c0                	test   %eax,%eax
   166ae:	0f 84 6f 01 00 00    	je     16823 <net_conn_input+0x22c>
		    net_ipv6_is_my_addr(&ip_hdr->ipv6->src)) {
   166b4:	8b 07                	mov    (%edi),%eax
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
   166b6:	6a 00                	push   $0x0
   166b8:	83 c0 08             	add    $0x8,%eax
   166bb:	50                   	push   %eax
   166bc:	e8 7f 79 ff ff       	call   e040 <net_if_ipv6_addr_lookup>
   166c1:	5b                   	pop    %ebx
   166c2:	5e                   	pop    %esi
   166c3:	e9 5b 01 00 00       	jmp    16823 <net_conn_input+0x22c>
   166c8:	bb 20 11 40 00       	mov    $0x401120,%ebx
	if (src_port != dst_port) {
   166cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   166d4:	66 c7 45 ea ff ff    	movw   $0xffff,-0x16(%ebp)
   166da:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	NET_DBG("Check %s listener for pkt %p src port %u dst port %u"
		" family %d", net_proto2str(net_pkt_family(pkt), proto), pkt,
		ntohs(src_port), ntohs(dst_port), net_pkt_family(pkt));

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
   166e1:	8a 53 3b             	mov    0x3b(%ebx),%dl
   166e4:	f6 c2 01             	test   $0x1,%dl
   166e7:	0f 84 a9 00 00 00    	je     16796 <net_conn_input+0x19f>
			continue;
		}

		if (conns[i].proto != proto) {
   166ed:	66 83 7b 38 11       	cmpw   $0x11,0x38(%ebx)
   166f2:	0f 85 9e 00 00 00    	jne    16796 <net_conn_input+0x19f>
			continue;
		}

		if (conns[i].family != AF_UNSPEC &&
   166f8:	8a 4b 3a             	mov    0x3a(%ebx),%cl
   166fb:	84 c9                	test   %cl,%cl
   166fd:	74 10                	je     1670f <net_conn_input+0x118>
   166ff:	8a 46 3f             	mov    0x3f(%esi),%al
   16702:	d0 e8                	shr    %al
   16704:	83 e0 07             	and    $0x7,%eax
   16707:	38 c1                	cmp    %al,%cl
   16709:	0f 85 87 00 00 00    	jne    16796 <net_conn_input+0x19f>
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_UDP) ||
		    IS_ENABLED(CONFIG_NET_TCP)) {
			if (net_sin(&conns[i].remote_addr)->sin_port) {
   1670f:	66 8b 43 02          	mov    0x2(%ebx),%ax
				if (net_sin(&conns[i].remote_addr)->sin_port !=
   16713:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
   16717:	74 05                	je     1671e <net_conn_input+0x127>
   16719:	66 85 c0             	test   %ax,%ax
   1671c:	75 78                	jne    16796 <net_conn_input+0x19f>
				    src_port) {
					continue;
				}
			}

			if (net_sin(&conns[i].local_addr)->sin_port) {
   1671e:	8d 43 18             	lea    0x18(%ebx),%eax
   16721:	89 45 e0             	mov    %eax,-0x20(%ebp)
   16724:	66 8b 43 1a          	mov    0x1a(%ebx),%ax
				if (net_sin(&conns[i].local_addr)->sin_port !=
   16728:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
   1672c:	74 05                	je     16733 <net_conn_input+0x13c>
   1672e:	66 85 c0             	test   %ax,%ax
   16731:	75 63                	jne    16796 <net_conn_input+0x19f>
				    dst_port) {
					continue;
				}
			}

			if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
   16733:	80 e2 02             	and    $0x2,%dl
   16736:	75 08                	jne    16740 <net_conn_input+0x149>
						true)) {
					continue;
				}
			}

			if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
   16738:	f6 43 3b 04          	testb  $0x4,0x3b(%ebx)
   1673c:	74 29                	je     16767 <net_conn_input+0x170>
   1673e:	eb 14                	jmp    16754 <net_conn_input+0x15d>
				if (!check_addr(pkt, ip_hdr,
   16740:	89 d9                	mov    %ebx,%ecx
   16742:	89 fa                	mov    %edi,%edx
   16744:	89 f0                	mov    %esi,%eax
   16746:	6a 01                	push   $0x1
   16748:	e8 76 fa ff ff       	call   161c3 <check_addr>
   1674d:	59                   	pop    %ecx
   1674e:	84 c0                	test   %al,%al
   16750:	75 e6                	jne    16738 <net_conn_input+0x141>
   16752:	eb 42                	jmp    16796 <net_conn_input+0x19f>
				if (!check_addr(pkt, ip_hdr,
   16754:	89 fa                	mov    %edi,%edx
   16756:	8d 4b 18             	lea    0x18(%ebx),%ecx
   16759:	89 f0                	mov    %esi,%eax
   1675b:	6a 00                	push   $0x0
   1675d:	e8 61 fa ff ff       	call   161c3 <check_addr>
   16762:	5a                   	pop    %edx
   16763:	84 c0                	test   %al,%al
   16765:	74 2f                	je     16796 <net_conn_input+0x19f>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that should not override.
			 */
			if (best_match >= 0 &&
   16767:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
   1676b:	74 10                	je     1677d <net_conn_input+0x186>
			    net_sin(&conns[best_match].remote_addr)->sin_port) {
   1676d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16770:	c1 e0 06             	shl    $0x6,%eax
			if (best_match >= 0 &&
   16773:	66 83 b8 22 11 40 00 	cmpw   $0x0,0x401122(%eax)
   1677a:	00 
   1677b:	75 19                	jne    16796 <net_conn_input+0x19f>
				continue;
			}

			if (best_rank < conns[i].rank) {
   1677d:	0f b6 4b 3c          	movzbl 0x3c(%ebx),%ecx
   16781:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
   16785:	39 c8                	cmp    %ecx,%eax
   16787:	7d 0d                	jge    16796 <net_conn_input+0x19f>
				best_rank = conns[i].rank;
   16789:	0f b6 c1             	movzbl %cl,%eax
   1678c:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
   16790:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16793:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
   16796:	ff 45 ec             	incl   -0x14(%ebp)
   16799:	83 c3 40             	add    $0x40,%ebx
   1679c:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
   167a0:	0f 85 3b ff ff ff    	jne    166e1 <net_conn_input+0xea>
			best_rank = 0;
			best_match = i;
		}
	}

	if (best_match >= 0) {
   167a6:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
   167aa:	74 26                	je     167d2 <net_conn_input+0x1db>
			conns[best_match].cb,
			conns[best_match].user_data,
			conns[best_match].rank);
#endif /* CONFIG_NET_CONN_CACHE */

		if (conns[best_match].cb(&conns[best_match], pkt, ip_hdr,
   167ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167af:	c1 e0 06             	shl    $0x6,%eax
   167b2:	ff b0 54 11 40 00    	pushl  0x401154(%eax)
   167b8:	ff 75 14             	pushl  0x14(%ebp)
   167bb:	05 20 11 40 00       	add    $0x401120,%eax
   167c0:	57                   	push   %edi
   167c1:	56                   	push   %esi
   167c2:	50                   	push   %eax
   167c3:	ff 50 30             	call   *0x30(%eax)
   167c6:	83 c4 14             	add    $0x14,%esp
			goto drop;
		}

		net_stats_update_per_proto_recv(pkt_iface, proto);

		return NET_OK;
   167c9:	31 d2                	xor    %edx,%edx
		if (conns[best_match].cb(&conns[best_match], pkt, ip_hdr,
   167cb:	83 f8 02             	cmp    $0x2,%eax
   167ce:	75 58                	jne    16828 <net_conn_input+0x231>
   167d0:	eb 51                	jmp    16823 <net_conn_input+0x22c>
   167d2:	8a 46 3f             	mov    0x3f(%esi),%al
   167d5:	d0 e8                	shr    %al
   167d7:	83 e0 07             	and    $0x7,%eax
	cache_add_neg(cache_value);

	/* If the destination address is multicast address,
	 * we will not send an ICMP error as that makes no sense.
	 */
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
   167da:	3c 02                	cmp    $0x2,%al
   167dc:	75 0a                	jne    167e8 <net_conn_input+0x1f1>
	    net_pkt_family(pkt) == AF_INET6 &&
	    net_ipv6_is_addr_mcast(&ip_hdr->ipv6->dst)) {
   167de:	8b 07                	mov    (%edi),%eax
	    net_pkt_family(pkt) == AF_INET6 &&
   167e0:	80 78 18 ff          	cmpb   $0xff,0x18(%eax)
   167e4:	75 1f                	jne    16805 <net_conn_input+0x20e>
   167e6:	eb 3b                	jmp    16823 <net_conn_input+0x22c>
		;
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   167e8:	3c 01                	cmp    $0x1,%al
   167ea:	75 15                	jne    16801 <net_conn_input+0x20a>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   167ec:	8b 07                	mov    (%edi),%eax
   167ee:	8b 40 10             	mov    0x10(%eax),%eax
   167f1:	0f c8                	bswap  %eax
   167f3:	25 00 00 00 e0       	and    $0xe0000000,%eax
		   net_pkt_family(pkt) == AF_INET &&
   167f8:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
   167fd:	74 24                	je     16823 <net_conn_input+0x22c>
   167ff:	eb 15                	jmp    16816 <net_conn_input+0x21f>
	if (net_pkt_family(pkt) == AF_INET6) {
   16801:	3c 02                	cmp    $0x2,%al
   16803:	75 11                	jne    16816 <net_conn_input+0x21f>
		net_icmpv6_send_error(pkt, NET_ICMPV6_DST_UNREACH,
   16805:	6a 00                	push   $0x0
   16807:	6a 04                	push   $0x4
   16809:	6a 01                	push   $0x1
   1680b:	56                   	push   %esi
   1680c:	e8 43 b0 ff ff       	call   11854 <net_icmpv6_send_error>
   16811:	83 c4 10             	add    $0x10,%esp
   16814:	eb 0d                	jmp    16823 <net_conn_input+0x22c>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
   16816:	6a 03                	push   $0x3
   16818:	6a 03                	push   $0x3
   1681a:	56                   	push   %esi
   1681b:	e8 a9 a8 ff ff       	call   110c9 <net_icmpv4_send_error>
   16820:	83 c4 0c             	add    $0xc,%esp
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
   16823:	ba 02 00 00 00       	mov    $0x2,%edx
}
   16828:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1682b:	89 d0                	mov    %edx,%eax
   1682d:	5b                   	pop    %ebx
   1682e:	5e                   	pop    %esi
   1682f:	5f                   	pop    %edi
   16830:	5d                   	pop    %ebp
   16831:	c3                   	ret    

00016832 <net_conn_init>:
		for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
			conn_cache[i].idx = -1;
		}
	} while (0);
#endif /* CONFIG_NET_CONN_CACHE */
}
   16832:	c3                   	ret    

00016833 <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, u16_t src_port, u16_t dst_port)
{
   16833:	55                   	push   %ebp
   16834:	89 e5                	mov    %esp,%ebp
   16836:	57                   	push   %edi
   16837:	56                   	push   %esi
   16838:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   16839:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
   1683c:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   1683f:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   16842:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   16845:	8b 7d 10             	mov    0x10(%ebp),%edi
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   16848:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   16849:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   1684c:	ff 75 08             	pushl  0x8(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   1684f:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   16856:	e8 0c 9d ff ff       	call   10567 <net_pkt_get_data>
   1685b:	5a                   	pop    %edx
   1685c:	89 c2                	mov    %eax,%edx
   1685e:	59                   	pop    %ecx
   1685f:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!udp_hdr) {
   16864:	85 d2                	test   %edx,%edx
   16866:	74 19                	je     16881 <net_udp_create+0x4e>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
   16868:	66 89 1a             	mov    %bx,(%edx)
	udp_hdr->dst_port = dst_port;
   1686b:	66 89 7a 02          	mov    %di,0x2(%edx)
	udp_hdr->len      = 0;
   1686f:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	udp_hdr->chksum   = 0;

	return net_pkt_set_data(pkt, &udp_access);
   16876:	56                   	push   %esi
   16877:	ff 75 08             	pushl  0x8(%ebp)
   1687a:	e8 7f 9d ff ff       	call   105fe <net_pkt_set_data>
   1687f:	5a                   	pop    %edx
   16880:	59                   	pop    %ecx
}
   16881:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16884:	5b                   	pop    %ebx
   16885:	5e                   	pop    %esi
   16886:	5f                   	pop    %edi
   16887:	5d                   	pop    %ebp
   16888:	c3                   	ret    

00016889 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
   16889:	55                   	push   %ebp
   1688a:	89 e5                	mov    %esp,%ebp
   1688c:	57                   	push   %edi
   1688d:	56                   	push   %esi
   1688e:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;
	u16_t length;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   1688f:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
   16892:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   16895:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   16898:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   1689b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   1689e:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   1689f:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   168a6:	53                   	push   %ebx
   168a7:	e8 bb 9c ff ff       	call   10567 <net_pkt_get_data>
   168ac:	59                   	pop    %ecx
   168ad:	5f                   	pop    %edi
   168ae:	89 c7                	mov    %eax,%edi
	if (!udp_hdr) {
   168b0:	85 ff                	test   %edi,%edi
   168b2:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
   168b7:	74 47                	je     16900 <net_udp_finalize+0x77>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) -
   168b9:	8b 53 14             	mov    0x14(%ebx),%edx
	size_t bytes = 0;
   168bc:	31 c0                	xor    %eax,%eax
	while (buf) {
   168be:	85 d2                	test   %edx,%edx
   168c0:	74 0a                	je     168cc <net_udp_finalize+0x43>
		bytes += buf->len;
   168c2:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
   168c6:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
   168c8:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
   168ca:	eb f2                	jmp    168be <net_udp_finalize+0x35>
		net_pkt_ip_hdr_len(pkt) -
   168cc:	0f b6 53 3c          	movzbl 0x3c(%ebx),%edx
	length = net_pkt_get_len(pkt) -
   168d0:	66 03 53 42          	add    0x42(%ebx),%dx
   168d4:	29 d0                	sub    %edx,%eax
		net_pkt_ipv6_ext_len(pkt);
	udp_hdr->len = htons(length);
   168d6:	86 e0                	xchg   %ah,%al
   168d8:	66 89 47 04          	mov    %ax,0x4(%edi)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   168dc:	ff 73 24             	pushl  0x24(%ebx)
   168df:	e8 37 8f ff ff       	call   f81b <net_if_need_calc_tx_checksum>
   168e4:	5a                   	pop    %edx
   168e5:	84 c0                	test   %al,%al
   168e7:	74 0e                	je     168f7 <net_udp_finalize+0x6e>
	return net_calc_chksum(pkt, IPPROTO_UDP);
   168e9:	6a 11                	push   $0x11
   168eb:	53                   	push   %ebx
   168ec:	e8 e0 a3 ff ff       	call   10cd1 <net_calc_chksum>
   168f1:	5a                   	pop    %edx
   168f2:	59                   	pop    %ecx
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
   168f3:	66 89 47 06          	mov    %ax,0x6(%edi)
	}

	return net_pkt_set_data(pkt, &udp_access);
   168f7:	56                   	push   %esi
   168f8:	53                   	push   %ebx
   168f9:	e8 00 9d ff ff       	call   105fe <net_pkt_set_data>
   168fe:	5a                   	pop    %edx
   168ff:	59                   	pop    %ecx
}
   16900:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16903:	5b                   	pop    %ebx
   16904:	5e                   	pop    %esi
   16905:	5f                   	pop    %edi
   16906:	5d                   	pop    %ebp
   16907:	c3                   	ret    

00016908 <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
   16908:	55                   	push   %ebp
   16909:	89 e5                	mov    %esp,%ebp
   1690b:	57                   	push   %edi
   1690c:	56                   	push   %esi
   1690d:	53                   	push   %ebx
   1690e:	8b 5d 08             	mov    0x8(%ebp),%ebx
   16911:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_udp_hdr *udp_hdr;

	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   16914:	ff 73 24             	pushl  0x24(%ebx)
   16917:	e8 1f 8f ff ff       	call   f83b <net_if_need_calc_rx_checksum>
   1691c:	5a                   	pop    %edx
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
   1691d:	84 c0                	test   %al,%al
   1691f:	75 11                	jne    16932 <net_udp_input+0x2a>
	    net_calc_chksum_udp(pkt) != 0) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
   16921:	57                   	push   %edi
   16922:	53                   	push   %ebx
   16923:	e8 3f 9c ff ff       	call   10567 <net_pkt_get_data>
   16928:	59                   	pop    %ecx
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
   16929:	85 c0                	test   %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
   1692b:	5e                   	pop    %esi
   1692c:	89 c6                	mov    %eax,%esi
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
   1692e:	75 13                	jne    16943 <net_udp_input+0x3b>
   16930:	eb 1e                	jmp    16950 <net_udp_input+0x48>
   16932:	6a 11                	push   $0x11
   16934:	53                   	push   %ebx
   16935:	e8 97 a3 ff ff       	call   10cd1 <net_calc_chksum>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   1693a:	66 85 c0             	test   %ax,%ax
   1693d:	5e                   	pop    %esi
   1693e:	5a                   	pop    %edx
   1693f:	74 e0                	je     16921 <net_udp_input+0x19>
   16941:	eb 0d                	jmp    16950 <net_udp_input+0x48>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
   16943:	57                   	push   %edi
   16944:	53                   	push   %ebx
   16945:	e8 b4 9c ff ff       	call   105fe <net_pkt_set_data>
   1694a:	5a                   	pop    %edx
   1694b:	85 c0                	test   %eax,%eax
   1694d:	59                   	pop    %ecx
   1694e:	74 02                	je     16952 <net_udp_input+0x4a>
	}

	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
   16950:	31 f6                	xor    %esi,%esi
}
   16952:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16955:	89 f0                	mov    %esi,%eax
   16957:	5b                   	pop    %ebx
   16958:	5e                   	pop    %esi
   16959:	5f                   	pop    %edi
   1695a:	5d                   	pop    %ebp
   1695b:	c3                   	ret    

0001695c <sys_slist_append>:
	parent->next = child;
   1695c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_APPEND(slist, snode)
   16962:	8b 48 04             	mov    0x4(%eax),%ecx
   16965:	85 c9                	test   %ecx,%ecx
   16967:	75 06                	jne    1696f <sys_slist_append+0x13>
	list->tail = node;
   16969:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
   1696c:	89 10                	mov    %edx,(%eax)
   1696e:	c3                   	ret    
	parent->next = child;
   1696f:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
   16971:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_APPEND(slist, snode)
   16974:	c3                   	ret    

00016975 <sys_slist_remove>:
Z_GENLIST_REMOVE(slist, snode)
   16975:	55                   	push   %ebp
   16976:	85 d2                	test   %edx,%edx
   16978:	89 e5                	mov    %esp,%ebp
   1697a:	53                   	push   %ebx
   1697b:	8b 19                	mov    (%ecx),%ebx
   1697d:	75 0c                	jne    1698b <sys_slist_remove+0x16>
	list->head = node;
   1697f:	89 18                	mov    %ebx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
   16981:	3b 48 04             	cmp    0x4(%eax),%ecx
   16984:	75 0f                	jne    16995 <sys_slist_remove+0x20>
	list->tail = node;
   16986:	89 58 04             	mov    %ebx,0x4(%eax)
   16989:	eb 0a                	jmp    16995 <sys_slist_remove+0x20>
	parent->next = child;
   1698b:	89 1a                	mov    %ebx,(%edx)
Z_GENLIST_REMOVE(slist, snode)
   1698d:	3b 48 04             	cmp    0x4(%eax),%ecx
   16990:	75 03                	jne    16995 <sys_slist_remove+0x20>
	list->tail = node;
   16992:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_REMOVE(slist, snode)
   16995:	5b                   	pop    %ebx
	parent->next = child;
   16996:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
   1699c:	5d                   	pop    %ebp
   1699d:	c3                   	ret    

0001699e <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1699e:	55                   	push   %ebp
   1699f:	89 e5                	mov    %esp,%ebp
   169a1:	53                   	push   %ebx
   169a2:	8b 08                	mov    (%eax),%ecx
   169a4:	31 db                	xor    %ebx,%ebx
   169a6:	85 c9                	test   %ecx,%ecx
   169a8:	74 15                	je     169bf <sys_slist_find_and_remove+0x21>
   169aa:	39 d1                	cmp    %edx,%ecx
   169ac:	75 0b                	jne    169b9 <sys_slist_find_and_remove+0x1b>
   169ae:	89 da                	mov    %ebx,%edx
   169b0:	e8 c0 ff ff ff       	call   16975 <sys_slist_remove>
   169b5:	b0 01                	mov    $0x1,%al
   169b7:	eb 08                	jmp    169c1 <sys_slist_find_and_remove+0x23>
   169b9:	89 cb                	mov    %ecx,%ebx
   169bb:	8b 09                	mov    (%ecx),%ecx
   169bd:	eb e7                	jmp    169a6 <sys_slist_find_and_remove+0x8>
   169bf:	31 c0                	xor    %eax,%eax
   169c1:	5b                   	pop    %ebx
   169c2:	5d                   	pop    %ebp
   169c3:	c3                   	ret    

000169c4 <engine_get_s32>:
	return 0;
}

static inline size_t engine_get_s32(struct lwm2m_input_context *in,
				    s32_t *value)
{
   169c4:	55                   	push   %ebp
   169c5:	89 e5                	mov    %esp,%ebp
	return in->reader->get_s32(in, value);
   169c7:	8b 08                	mov    (%eax),%ecx
   169c9:	52                   	push   %edx
   169ca:	50                   	push   %eax
   169cb:	ff 11                	call   *(%ecx)
   169cd:	5a                   	pop    %edx
   169ce:	59                   	pop    %ecx
}
   169cf:	c9                   	leave  
   169d0:	c3                   	ret    

000169d1 <get_engine_obj>:

static struct lwm2m_engine_obj *get_engine_obj(int obj_id)
{
	struct lwm2m_engine_obj *obj;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
   169d1:	8b 15 b0 43 40 00    	mov    0x4043b0,%edx
   169d7:	85 d2                	test   %edx,%edx
   169d9:	74 0c                	je     169e7 <get_engine_obj+0x16>
		if (obj->obj_id == obj_id) {
   169db:	0f b7 4a 18          	movzwl 0x18(%edx),%ecx
   169df:	39 c1                	cmp    %eax,%ecx
   169e1:	74 04                	je     169e7 <get_engine_obj+0x16>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   169e3:	8b 12                	mov    (%edx),%edx
	return node->next;
   169e5:	eb f0                	jmp    169d7 <get_engine_obj+0x6>
			return obj;
		}
	}

	return NULL;
}
   169e7:	89 d0                	mov    %edx,%eax
   169e9:	c3                   	ret    

000169ea <get_engine_obj_inst>:
static struct lwm2m_engine_obj_inst *get_engine_obj_inst(int obj_id,
							 int obj_inst_id)
{
	struct lwm2m_engine_obj_inst *obj_inst;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
   169ea:	8b 0d a8 43 40 00    	mov    0x4043a8,%ecx
   169f0:	85 c9                	test   %ecx,%ecx
   169f2:	75 03                	jne    169f7 <get_engine_obj_inst+0xd>
			return obj_inst;
		}
	}

	return NULL;
}
   169f4:	89 c8                	mov    %ecx,%eax
   169f6:	c3                   	ret    
{
   169f7:	55                   	push   %ebp
   169f8:	89 e5                	mov    %esp,%ebp
   169fa:	53                   	push   %ebx
		if (obj_inst->obj->obj_id == obj_id &&
   169fb:	8b 59 04             	mov    0x4(%ecx),%ebx
   169fe:	0f b7 5b 18          	movzwl 0x18(%ebx),%ebx
   16a02:	39 c3                	cmp    %eax,%ebx
   16a04:	75 08                	jne    16a0e <get_engine_obj_inst+0x24>
		    obj_inst->obj_inst_id == obj_inst_id) {
   16a06:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
		if (obj_inst->obj->obj_id == obj_id &&
   16a0a:	39 d3                	cmp    %edx,%ebx
   16a0c:	74 06                	je     16a14 <get_engine_obj_inst+0x2a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   16a0e:	8b 09                	mov    (%ecx),%ecx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
   16a10:	85 c9                	test   %ecx,%ecx
   16a12:	75 e7                	jne    169fb <get_engine_obj_inst+0x11>
}
   16a14:	5b                   	pop    %ebx
   16a15:	89 c8                	mov    %ecx,%eax
   16a17:	5d                   	pop    %ebp
   16a18:	c3                   	ret    

00016a19 <next_engine_obj_inst>:
static struct lwm2m_engine_obj_inst *
next_engine_obj_inst(int obj_id, int obj_inst_id)
{
	struct lwm2m_engine_obj_inst *obj_inst, *next = NULL;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
   16a19:	8b 0d a8 43 40 00    	mov    0x4043a8,%ecx
   16a1f:	85 c9                	test   %ecx,%ecx
   16a21:	74 34                	je     16a57 <next_engine_obj_inst+0x3e>
{
   16a23:	55                   	push   %ebp
   16a24:	89 e5                	mov    %esp,%ebp
   16a26:	57                   	push   %edi
   16a27:	56                   	push   %esi
   16a28:	53                   	push   %ebx
   16a29:	31 db                	xor    %ebx,%ebx
				     node) {
		if (obj_inst->obj->obj_id == obj_id &&
   16a2b:	8b 71 04             	mov    0x4(%ecx),%esi
   16a2e:	0f b7 76 18          	movzwl 0x18(%esi),%esi
   16a32:	39 c6                	cmp    %eax,%esi
   16a34:	75 14                	jne    16a4a <next_engine_obj_inst+0x31>
		    obj_inst->obj_inst_id > obj_inst_id &&
   16a36:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		if (obj_inst->obj->obj_id == obj_id &&
   16a3a:	39 d7                	cmp    %edx,%edi
   16a3c:	7e 0c                	jle    16a4a <next_engine_obj_inst+0x31>
		    obj_inst->obj_inst_id > obj_inst_id &&
   16a3e:	85 db                	test   %ebx,%ebx
   16a40:	74 06                	je     16a48 <next_engine_obj_inst+0x2f>
		    (!next || next->obj_inst_id > obj_inst->obj_inst_id)) {
   16a42:	66 3b 7b 0c          	cmp    0xc(%ebx),%di
   16a46:	73 02                	jae    16a4a <next_engine_obj_inst+0x31>
   16a48:	89 cb                	mov    %ecx,%ebx
   16a4a:	8b 09                	mov    (%ecx),%ecx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
   16a4c:	85 c9                	test   %ecx,%ecx
   16a4e:	75 db                	jne    16a2b <next_engine_obj_inst+0x12>
			next = obj_inst;
		}
	}

	return next;
}
   16a50:	89 d8                	mov    %ebx,%eax
   16a52:	5b                   	pop    %ebx
   16a53:	5e                   	pop    %esi
   16a54:	5f                   	pop    %edi
   16a55:	5d                   	pop    %ebp
   16a56:	c3                   	ret    
   16a57:	89 c8                	mov    %ecx,%eax
   16a59:	c3                   	ret    

00016a5a <update_attrs>:
{
   16a5a:	55                   	push   %ebp
   16a5b:	89 e5                	mov    %esp,%ebp
   16a5d:	57                   	push   %edi
   16a5e:	56                   	push   %esi
   16a5f:	53                   	push   %ebx
   16a60:	bb 00 28 40 00       	mov    $0x402800,%ebx
		if (ref != write_attr_pool[i].ref) {
   16a65:	39 03                	cmp    %eax,(%ebx)
   16a67:	0f 85 8b 00 00 00    	jne    16af8 <update_attrs+0x9e>
		switch (write_attr_pool[i].type) {
   16a6d:	0f b6 4b 0c          	movzbl 0xc(%ebx),%ecx
   16a71:	80 f9 04             	cmp    $0x4,%cl
   16a74:	77 43                	ja     16ab9 <update_attrs+0x5f>
   16a76:	0f b6 f9             	movzbl %cl,%edi
   16a79:	ff 24 bd 08 61 02 00 	jmp    *0x26108(,%edi,4)
			out->pmin = write_attr_pool[i].int_val;
   16a80:	8b 7b 04             	mov    0x4(%ebx),%edi
   16a83:	89 7a 18             	mov    %edi,0x18(%edx)
			break;
   16a86:	eb 64                	jmp    16aec <update_attrs+0x92>
			out->pmax = write_attr_pool[i].int_val;
   16a88:	8b 73 04             	mov    0x4(%ebx),%esi
   16a8b:	89 72 1c             	mov    %esi,0x1c(%edx)
			break;
   16a8e:	eb 5c                	jmp    16aec <update_attrs+0x92>
			out->lt = write_attr_pool[i].float_val;
   16a90:	8b 73 04             	mov    0x4(%ebx),%esi
   16a93:	8b 7b 08             	mov    0x8(%ebx),%edi
   16a96:	89 7a 0c             	mov    %edi,0xc(%edx)
   16a99:	89 72 08             	mov    %esi,0x8(%edx)
			break;
   16a9c:	eb 4e                	jmp    16aec <update_attrs+0x92>
			out->gt = write_attr_pool[i].float_val;
   16a9e:	8b 73 04             	mov    0x4(%ebx),%esi
   16aa1:	8b 7b 08             	mov    0x8(%ebx),%edi
   16aa4:	89 7a 04             	mov    %edi,0x4(%edx)
   16aa7:	89 32                	mov    %esi,(%edx)
			break;
   16aa9:	eb 41                	jmp    16aec <update_attrs+0x92>
			out->st = write_attr_pool[i].float_val;
   16aab:	8b 73 04             	mov    0x4(%ebx),%esi
   16aae:	8b 7b 08             	mov    0x8(%ebx),%edi
   16ab1:	89 7a 14             	mov    %edi,0x14(%edx)
   16ab4:	89 72 10             	mov    %esi,0x10(%edx)
			break;
   16ab7:	eb 33                	jmp    16aec <update_attrs+0x92>
			return -EINVAL;
   16ab9:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
			LOG_ERR("Unrecognize attr: %d",
   16abe:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   16ac5:	74 42                	je     16b09 <update_attrs+0xaf>
   16ac7:	ba cc 51 02 00       	mov    $0x251cc,%edx
   16acc:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   16ad2:	c1 ea 03             	shr    $0x3,%edx
   16ad5:	c1 e2 06             	shl    $0x6,%edx
   16ad8:	83 ca 01             	or     $0x1,%edx
   16adb:	52                   	push   %edx
   16adc:	51                   	push   %ecx
   16add:	68 bb 91 02 00       	push   $0x291bb
   16ae2:	e8 c8 c9 fe ff       	call   34af <log_1>
   16ae7:	83 c4 0c             	add    $0xc,%esp
   16aea:	eb 1d                	jmp    16b09 <update_attrs+0xaf>
		out->flags |= BIT(write_attr_pool[i].type);
   16aec:	be 01 00 00 00       	mov    $0x1,%esi
   16af1:	d3 e6                	shl    %cl,%esi
   16af3:	89 f1                	mov    %esi,%ecx
   16af5:	08 4a 20             	or     %cl,0x20(%edx)
   16af8:	83 c3 10             	add    $0x10,%ebx
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   16afb:	81 fb 40 29 40 00    	cmp    $0x402940,%ebx
   16b01:	0f 85 5e ff ff ff    	jne    16a65 <update_attrs+0xb>
	return 0;
   16b07:	31 db                	xor    %ebx,%ebx
}
   16b09:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16b0c:	89 d8                	mov    %ebx,%eax
   16b0e:	5b                   	pop    %ebx
   16b0f:	5e                   	pop    %esi
   16b10:	5f                   	pop    %edi
   16b11:	5d                   	pop    %ebp
   16b12:	c3                   	ret    

00016b13 <engine_remove_observer_by_id>:
{
   16b13:	55                   	push   %ebp
   16b14:	89 e5                	mov    %esp,%ebp
   16b16:	57                   	push   %edi
   16b17:	56                   	push   %esi
   16b18:	53                   	push   %ebx
   16b19:	83 ec 08             	sub    $0x8,%esp
   16b1c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(
   16b20:	a1 a0 43 40 00       	mov    0x4043a0,%eax
   16b25:	85 c0                	test   %eax,%eax
   16b27:	74 45                	je     16b6e <engine_remove_observer_by_id+0x5b>
   16b29:	89 55 ec             	mov    %edx,-0x14(%ebp)
   16b2c:	8b 18                	mov    (%eax),%ebx
   16b2e:	31 ff                	xor    %edi,%edi
		if (!(obj_id == obs->path.obj_id &&
   16b30:	66 8b 4d f2          	mov    -0xe(%ebp),%cx
   16b34:	89 c6                	mov    %eax,%esi
   16b36:	66 39 48 08          	cmp    %cx,0x8(%eax)
   16b3a:	75 26                	jne    16b62 <engine_remove_observer_by_id+0x4f>
		      obj_inst_id == obs->path.obj_inst_id)) {
   16b3c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
		if (!(obj_id == obs->path.obj_id &&
   16b40:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   16b43:	75 1d                	jne    16b62 <engine_remove_observer_by_id+0x4f>
		sys_slist_remove(&engine_observer_list, prev_node, &obs->node);
   16b45:	89 f1                	mov    %esi,%ecx
   16b47:	89 fa                	mov    %edi,%edx
   16b49:	b8 a0 43 40 00       	mov    $0x4043a0,%eax
   16b4e:	e8 22 fe ff ff       	call   16975 <sys_slist_remove>
		(void)memset(obs, 0, sizeof(*obs));
   16b53:	6a 3c                	push   $0x3c
   16b55:	6a 00                	push   $0x0
   16b57:	56                   	push   %esi
   16b58:	89 fe                	mov    %edi,%esi
   16b5a:	e8 41 3e ff ff       	call   a9a0 <memset>
   16b5f:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(
   16b62:	85 db                	test   %ebx,%ebx
   16b64:	74 08                	je     16b6e <engine_remove_observer_by_id+0x5b>
   16b66:	89 d8                	mov    %ebx,%eax
   16b68:	89 f7                	mov    %esi,%edi
   16b6a:	8b 1b                	mov    (%ebx),%ebx
   16b6c:	eb c2                	jmp    16b30 <engine_remove_observer_by_id+0x1d>
}
   16b6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16b71:	5b                   	pop    %ebx
   16b72:	5e                   	pop    %esi
   16b73:	5f                   	pop    %edi
   16b74:	5d                   	pop    %ebp
   16b75:	c3                   	ret    

00016b76 <clear_attrs>:
{
   16b76:	55                   	push   %ebp
   16b77:	89 e5                	mov    %esp,%ebp
   16b79:	56                   	push   %esi
   16b7a:	53                   	push   %ebx
   16b7b:	89 c6                	mov    %eax,%esi
   16b7d:	31 db                	xor    %ebx,%ebx
		if (ref == write_attr_pool[i].ref) {
   16b7f:	39 b3 00 28 40 00    	cmp    %esi,0x402800(%ebx)
   16b85:	75 13                	jne    16b9a <clear_attrs+0x24>
			(void)memset(&write_attr_pool[i], 0,
   16b87:	6a 10                	push   $0x10
   16b89:	8d 83 00 28 40 00    	lea    0x402800(%ebx),%eax
   16b8f:	6a 00                	push   $0x0
   16b91:	50                   	push   %eax
   16b92:	e8 09 3e ff ff       	call   a9a0 <memset>
   16b97:	83 c4 0c             	add    $0xc,%esp
   16b9a:	83 c3 10             	add    $0x10,%ebx
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   16b9d:	81 fb 40 01 00 00    	cmp    $0x140,%ebx
   16ba3:	75 da                	jne    16b7f <clear_attrs+0x9>
}
   16ba5:	8d 65 f8             	lea    -0x8(%ebp),%esp
   16ba8:	5b                   	pop    %ebx
   16ba9:	5e                   	pop    %esi
   16baa:	5d                   	pop    %ebp
   16bab:	c3                   	ret    

00016bac <buf_append>:
#endif

/* append */
static inline int buf_append(u8_t *dst, u16_t *dst_len, u16_t dst_size,
			     u8_t *src, u16_t src_len)
{
   16bac:	55                   	push   %ebp
   16bad:	89 e5                	mov    %esp,%ebp
   16baf:	57                   	push   %edi
   16bb0:	56                   	push   %esi
   16bb1:	53                   	push   %ebx
   16bb2:	89 c3                	mov    %eax,%ebx
   16bb4:	83 ec 08             	sub    $0x8,%esp
	if (!dst || !src) {
   16bb7:	85 db                	test   %ebx,%ebx
{
   16bb9:	8b 45 0c             	mov    0xc(%ebp),%eax
   16bbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		return -EINVAL;
   16bbf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!dst || !src) {
   16bc4:	74 37                	je     16bfd <buf_append+0x51>
	}

	if (*dst_len + src_len > dst_size) {
   16bc6:	0f b7 32             	movzwl (%edx),%esi
   16bc9:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
   16bcd:	0f b7 c9             	movzwl %cx,%ecx
   16bd0:	8d 04 3e             	lea    (%esi,%edi,1),%eax
   16bd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
   16bd6:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (*dst_len + src_len > dst_size) {
   16bdb:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
   16bde:	7f 1d                	jg     16bfd <buf_append+0x51>
	}

	memcpy(dst + *dst_len, src, src_len);
   16be0:	57                   	push   %edi
   16be1:	01 de                	add    %ebx,%esi
   16be3:	ff 75 08             	pushl  0x8(%ebp)
   16be6:	89 55 ec             	mov    %edx,-0x14(%ebp)
   16be9:	56                   	push   %esi
   16bea:	e8 42 3d ff ff       	call   a931 <memcpy>
	*dst_len += src_len;
   16bef:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16bf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memcpy(dst + *dst_len, src, src_len);
   16bf5:	83 c4 0c             	add    $0xc,%esp
	*dst_len += src_len;
   16bf8:	66 01 02             	add    %ax,(%edx)
	return 0;
   16bfb:	31 c0                	xor    %eax,%eax
}
   16bfd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16c00:	5b                   	pop    %ebx
   16c01:	5e                   	pop    %esi
   16c02:	5f                   	pop    %edi
   16c03:	5d                   	pop    %ebp
   16c04:	c3                   	ret    

00016c05 <get_option_int>:
}

/* utility functions */

static int get_option_int(const struct coap_packet *cpkt, u8_t opt)
{
   16c05:	55                   	push   %ebp
	struct coap_option option = {};
   16c06:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   16c0b:	89 e5                	mov    %esp,%ebp
   16c0d:	57                   	push   %edi
   16c0e:	53                   	push   %ebx
   16c0f:	89 c3                	mov    %eax,%ebx
   16c11:	83 ec 10             	sub    $0x10,%esp
	struct coap_option option = {};
   16c14:	31 c0                	xor    %eax,%eax
   16c16:	8d 7d e8             	lea    -0x18(%ebp),%edi
   16c19:	f3 ab                	rep stos %eax,%es:(%edi)
	u16_t count = 1U;
	int r;

	r = coap_find_options(cpkt, opt, &option, count);
   16c1b:	6a 01                	push   $0x1
   16c1d:	8d 7d e8             	lea    -0x18(%ebp),%edi
   16c20:	57                   	push   %edi
   16c21:	0f b6 d2             	movzbl %dl,%edx
   16c24:	52                   	push   %edx
   16c25:	53                   	push   %ebx
   16c26:	e8 65 17 ff ff       	call   8390 <coap_find_options>
   16c2b:	83 c4 10             	add    $0x10,%esp
	if (r <= 0) {
   16c2e:	85 c0                	test   %eax,%eax
   16c30:	7e 09                	jle    16c3b <get_option_int+0x36>
		return -ENOENT;
	}

	return coap_option_value_to_int(&option);
   16c32:	57                   	push   %edi
   16c33:	e8 dc 15 ff ff       	call   8214 <coap_option_value_to_int>
   16c38:	5a                   	pop    %edx
   16c39:	eb 05                	jmp    16c40 <get_option_int+0x3b>
		return -ENOENT;
   16c3b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
}
   16c40:	8d 65 f8             	lea    -0x8(%ebp),%esp
   16c43:	5b                   	pop    %ebx
   16c44:	5f                   	pop    %edi
   16c45:	5d                   	pop    %ebp
   16c46:	c3                   	ret    

00016c47 <find_msg>:
static struct lwm2m_message *find_msg(struct coap_pending *pending,
				      struct coap_reply *reply)
{
	size_t i;

	if (!pending && !reply) {
   16c47:	89 c1                	mov    %eax,%ecx
   16c49:	09 d1                	or     %edx,%ecx
   16c4b:	74 3a                	je     16c87 <find_msg+0x40>
{
   16c4d:	55                   	push   %ebp
   16c4e:	89 e5                	mov    %esp,%ebp
   16c50:	53                   	push   %ebx
		return NULL;
	}

	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
   16c51:	31 db                	xor    %ebx,%ebx
		if (messages[i].ctx && messages[i].pending == pending) {
   16c53:	69 cb 88 01 00 00    	imul   $0x188,%ebx,%ecx
   16c59:	83 b9 80 18 40 00 00 	cmpl   $0x0,0x401880(%ecx)
   16c60:	74 18                	je     16c7a <find_msg+0x33>
   16c62:	3b 81 ec 19 40 00    	cmp    0x4019ec(%ecx),%eax
   16c68:	74 08                	je     16c72 <find_msg+0x2b>
			return &messages[i];
		}

		if (messages[i].ctx && messages[i].reply == reply) {
   16c6a:	3b 91 f0 19 40 00    	cmp    0x4019f0(%ecx),%edx
   16c70:	75 08                	jne    16c7a <find_msg+0x33>
			return &messages[i];
   16c72:	81 c1 80 18 40 00    	add    $0x401880,%ecx
   16c78:	eb 08                	jmp    16c82 <find_msg+0x3b>
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
   16c7a:	43                   	inc    %ebx
   16c7b:	83 fb 0a             	cmp    $0xa,%ebx
   16c7e:	75 d3                	jne    16c53 <find_msg+0xc>
		return NULL;
   16c80:	31 c9                	xor    %ecx,%ecx
		}
	}

	return NULL;
}
   16c82:	5b                   	pop    %ebx
   16c83:	89 c8                	mov    %ecx,%eax
   16c85:	5d                   	pop    %ebp
   16c86:	c3                   	ret    
   16c87:	89 c8                	mov    %ecx,%eax
   16c89:	c3                   	ret    

00016c8a <select_writer>:

/* input / output selection */

static int select_writer(struct lwm2m_output_context *out, u16_t accept)
{
	switch (accept) {
   16c8a:	66 81 fa 06 06       	cmp    $0x606,%dx
{
   16c8f:	55                   	push   %ebp
   16c90:	89 e5                	mov    %esp,%ebp
   16c92:	53                   	push   %ebx
	switch (accept) {
   16c93:	74 37                	je     16ccc <select_writer+0x42>
   16c95:	77 16                	ja     16cad <select_writer+0x23>
		LOG_WRN("Unknown content type %u", accept);
		return -ENOMSG;

	}

	return 0;
   16c97:	31 db                	xor    %ebx,%ebx
	switch (accept) {
   16c99:	66 83 fa 28          	cmp    $0x28,%dx
   16c9d:	74 73                	je     16d12 <select_writer+0x88>
   16c9f:	66 81 fa 05 06       	cmp    $0x605,%dx
   16ca4:	74 1e                	je     16cc4 <select_writer+0x3a>
   16ca6:	66 85 d2             	test   %dx,%dx
   16ca9:	75 33                	jne    16cde <select_writer+0x54>
   16cab:	eb 17                	jmp    16cc4 <select_writer+0x3a>
   16cad:	66 81 fa 16 2d       	cmp    $0x2d16,%dx
   16cb2:	74 18                	je     16ccc <select_writer+0x42>
   16cb4:	66 81 fa 17 2d       	cmp    $0x2d17,%dx
   16cb9:	74 1b                	je     16cd6 <select_writer+0x4c>
   16cbb:	66 81 fa 07 06       	cmp    $0x607,%dx
   16cc0:	75 1c                	jne    16cde <select_writer+0x54>
   16cc2:	eb 12                	jmp    16cd6 <select_writer+0x4c>
		out->writer = &plain_text_writer;
   16cc4:	c7 00 40 5a 02 00    	movl   $0x25a40,(%eax)
		break;
   16cca:	eb 06                	jmp    16cd2 <select_writer+0x48>
		out->writer = &oma_tlv_writer;
   16ccc:	c7 00 a0 5a 02 00    	movl   $0x25aa0,(%eax)
	return 0;
   16cd2:	31 db                	xor    %ebx,%ebx
		break;
   16cd4:	eb 3c                	jmp    16d12 <select_writer+0x88>
		out->writer = &json_writer;
   16cd6:	c7 00 60 5b 02 00    	movl   $0x25b60,(%eax)
		break;
   16cdc:	eb f4                	jmp    16cd2 <select_writer+0x48>
		return -ENOMSG;
   16cde:	bb b0 ff ff ff       	mov    $0xffffffb0,%ebx
		LOG_WRN("Unknown content type %u", accept);
   16ce3:	f6 05 a4 a8 40 00 06 	testb  $0x6,0x40a8a4
   16cea:	74 26                	je     16d12 <select_writer+0x88>
   16cec:	b9 cc 51 02 00       	mov    $0x251cc,%ecx
   16cf1:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   16cf7:	c1 e9 03             	shr    $0x3,%ecx
   16cfa:	c1 e1 06             	shl    $0x6,%ecx
   16cfd:	83 c9 02             	or     $0x2,%ecx
   16d00:	51                   	push   %ecx
   16d01:	0f b7 d2             	movzwl %dx,%edx
   16d04:	52                   	push   %edx
   16d05:	68 d0 91 02 00       	push   $0x291d0
   16d0a:	e8 a0 c7 fe ff       	call   34af <log_1>
   16d0f:	83 c4 0c             	add    $0xc,%esp
}
   16d12:	89 d8                	mov    %ebx,%eax
   16d14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16d17:	c9                   	leave  
   16d18:	c3                   	ret    

00016d19 <get_block_ctx>:
{
   16d19:	55                   	push   %ebp
   16d1a:	89 e5                	mov    %esp,%ebp
   16d1c:	57                   	push   %edi
   16d1d:	56                   	push   %esi
   16d1e:	89 cf                	mov    %ecx,%edi
   16d20:	53                   	push   %ebx
	*ctx = NULL;
   16d21:	be 40 29 40 00       	mov    $0x402940,%esi
{
   16d26:	83 ec 0c             	sub    $0xc,%esp
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
   16d29:	31 db                	xor    %ebx,%ebx
{
   16d2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	*ctx = NULL;
   16d2e:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		if (block1_contexts[i].tkl == tkl &&
   16d34:	38 56 1c             	cmp    %dl,0x1c(%esi)
   16d37:	75 47                	jne    16d80 <get_block_ctx+0x67>
   16d39:	89 f0                	mov    %esi,%eax
		    memcmp(token, block1_contexts[i].token, tkl) == 0) {
   16d3b:	88 55 eb             	mov    %dl,-0x15(%ebp)
   16d3e:	2d 40 29 40 00       	sub    $0x402940,%eax
   16d43:	89 45 f0             	mov    %eax,-0x10(%ebp)
   16d46:	0f b6 c2             	movzbl %dl,%eax
   16d49:	50                   	push   %eax
   16d4a:	8d 46 14             	lea    0x14(%esi),%eax
   16d4d:	50                   	push   %eax
   16d4e:	ff 75 ec             	pushl  -0x14(%ebp)
   16d51:	e8 70 3b ff ff       	call   a8c6 <memcmp>
   16d56:	83 c4 0c             	add    $0xc,%esp
		if (block1_contexts[i].tkl == tkl &&
   16d59:	8a 55 eb             	mov    -0x15(%ebp),%dl
   16d5c:	85 c0                	test   %eax,%eax
   16d5e:	75 20                	jne    16d80 <get_block_ctx+0x67>
			(*ctx)->timestamp = k_uptime_get();
   16d60:	c1 e3 05             	shl    $0x5,%ebx
			*ctx = &block1_contexts[i];
   16d63:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16d66:	05 40 29 40 00       	add    $0x402940,%eax
   16d6b:	89 07                	mov    %eax,(%edi)
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   16d6d:	e8 9f db 00 00       	call   24911 <z_impl_k_uptime_get>
			(*ctx)->timestamp = k_uptime_get();
   16d72:	89 83 4c 29 40 00    	mov    %eax,0x40294c(%ebx)
   16d78:	89 93 50 29 40 00    	mov    %edx,0x402950(%ebx)
			break;
   16d7e:	eb 09                	jmp    16d89 <get_block_ctx+0x70>
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
   16d80:	43                   	inc    %ebx
   16d81:	83 c6 20             	add    $0x20,%esi
   16d84:	83 fb 03             	cmp    $0x3,%ebx
   16d87:	75 ab                	jne    16d34 <get_block_ctx+0x1b>
	return 0;
   16d89:	31 db                	xor    %ebx,%ebx
	if (*ctx == NULL) {
   16d8b:	83 3f 00             	cmpl   $0x0,(%edi)
   16d8e:	75 2f                	jne    16dbf <get_block_ctx+0xa6>
		LOG_ERR("Cannot find block context");
   16d90:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
   16d95:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   16d9c:	74 21                	je     16dbf <get_block_ctx+0xa6>
   16d9e:	ba cc 51 02 00       	mov    $0x251cc,%edx
   16da3:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   16da9:	c1 ea 03             	shr    $0x3,%edx
   16dac:	c1 e2 06             	shl    $0x6,%edx
   16daf:	83 ca 01             	or     $0x1,%edx
   16db2:	52                   	push   %edx
   16db3:	68 e8 91 02 00       	push   $0x291e8
   16db8:	e8 cd c6 fe ff       	call   348a <log_0>
   16dbd:	58                   	pop    %eax
   16dbe:	5a                   	pop    %edx
}
   16dbf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16dc2:	89 d8                	mov    %ebx,%eax
   16dc4:	5b                   	pop    %ebx
   16dc5:	5e                   	pop    %esi
   16dc6:	5f                   	pop    %edi
   16dc7:	5d                   	pop    %ebp
   16dc8:	c3                   	ret    

00016dc9 <do_read_op>:
}

static int do_read_op(struct lwm2m_engine_obj *obj,
		      struct lwm2m_message *msg, u16_t content_format)
{
	switch (content_format) {
   16dc9:	66 81 f9 06 06       	cmp    $0x606,%cx
{
   16dce:	55                   	push   %ebp
   16dcf:	89 e5                	mov    %esp,%ebp
   16dd1:	53                   	push   %ebx
   16dd2:	53                   	push   %ebx
	switch (content_format) {
   16dd3:	0f b7 d9             	movzwl %cx,%ebx
   16dd6:	74 37                	je     16e0f <do_read_op+0x46>
   16dd8:	77 14                	ja     16dee <do_read_op+0x25>
   16dda:	66 83 f9 2a          	cmp    $0x2a,%cx
   16dde:	74 25                	je     16e05 <do_read_op+0x3c>
   16de0:	66 81 f9 05 06       	cmp    $0x605,%cx
   16de5:	74 1e                	je     16e05 <do_read_op+0x3c>
   16de7:	66 85 c9             	test   %cx,%cx
   16dea:	75 3a                	jne    16e26 <do_read_op+0x5d>
   16dec:	eb 17                	jmp    16e05 <do_read_op+0x3c>
   16dee:	66 81 f9 16 2d       	cmp    $0x2d16,%cx
   16df3:	74 1a                	je     16e0f <do_read_op+0x46>
   16df5:	66 81 f9 17 2d       	cmp    $0x2d17,%cx
   16dfa:	74 20                	je     16e1c <do_read_op+0x53>
   16dfc:	66 81 f9 07 06       	cmp    $0x607,%cx
   16e01:	75 23                	jne    16e26 <do_read_op+0x5d>
   16e03:	eb 17                	jmp    16e1c <do_read_op+0x53>

	case LWM2M_FORMAT_APP_OCTET_STREAM:
	case LWM2M_FORMAT_PLAIN_TEXT:
	case LWM2M_FORMAT_OMA_PLAIN_TEXT:
		return do_read_op_plain_text(obj, msg, content_format);
   16e05:	53                   	push   %ebx
   16e06:	52                   	push   %edx
   16e07:	50                   	push   %eax
   16e08:	e8 dc 61 00 00       	call   1cfe9 <do_read_op_plain_text>
   16e0d:	eb 08                	jmp    16e17 <do_read_op+0x4e>

	case LWM2M_FORMAT_OMA_TLV:
	case LWM2M_FORMAT_OMA_OLD_TLV:
		return do_read_op_tlv(obj, msg, content_format);
   16e0f:	53                   	push   %ebx
   16e10:	52                   	push   %edx
   16e11:	50                   	push   %eax
   16e12:	e8 0e 6f 00 00       	call   1dd25 <do_read_op_tlv>
   16e17:	83 c4 0c             	add    $0xc,%esp
   16e1a:	eb 41                	jmp    16e5d <do_read_op+0x94>

#if defined(CONFIG_LWM2M_RW_JSON_SUPPORT)
	case LWM2M_FORMAT_OMA_JSON:
	case LWM2M_FORMAT_OMA_OLD_JSON:
		return do_read_op_json(obj, msg, content_format);
   16e1c:	53                   	push   %ebx
   16e1d:	52                   	push   %edx
   16e1e:	50                   	push   %eax
   16e1f:	e8 2f 9b 00 00       	call   20953 <do_read_op_json>
   16e24:	eb f1                	jmp    16e17 <do_read_op+0x4e>
#endif

	default:
		LOG_ERR("Unsupported content-format: %u", content_format);
   16e26:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
   16e2b:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   16e32:	74 29                	je     16e5d <do_read_op+0x94>
   16e34:	ba cc 51 02 00       	mov    $0x251cc,%edx
   16e39:	89 45 f8             	mov    %eax,-0x8(%ebp)
   16e3c:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   16e42:	c1 ea 03             	shr    $0x3,%edx
   16e45:	c1 e2 06             	shl    $0x6,%edx
   16e48:	83 ca 01             	or     $0x1,%edx
   16e4b:	52                   	push   %edx
   16e4c:	53                   	push   %ebx
   16e4d:	68 02 92 02 00       	push   $0x29202
   16e52:	e8 58 c6 fe ff       	call   34af <log_1>
   16e57:	83 c4 0c             	add    $0xc,%esp
   16e5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
		return -ENOMSG;

	}
}
   16e5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16e60:	c9                   	leave  
   16e61:	c3                   	ret    

00016e62 <print_attr.constprop.17>:
	}

	return ret;
}

static int print_attr(struct lwm2m_output_context *out,
   16e62:	55                   	push   %ebp
   16e63:	89 e5                	mov    %esp,%ebp
   16e65:	57                   	push   %edi
   16e66:	56                   	push   %esi
   16e67:	53                   	push   %ebx
   16e68:	bb 00 28 40 00       	mov    $0x402800,%ebx
   16e6d:	83 ec 08             	sub    $0x8,%esp
   16e70:	89 45 f0             	mov    %eax,-0x10(%ebp)
   16e73:	89 55 ec             	mov    %edx,-0x14(%ebp)
	int i, used, base, ret;
	u8_t digit;
	s32_t fraction;

	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
		if (ref != write_attr_pool[i].ref) {
   16e76:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16e79:	39 03                	cmp    %eax,(%ebx)
   16e7b:	74 13                	je     16e90 <print_attr.constprop.17+0x2e>
   16e7d:	83 c3 10             	add    $0x10,%ebx
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   16e80:	b8 40 29 40 00       	mov    $0x402940,%eax
   16e85:	39 d8                	cmp    %ebx,%eax
   16e87:	75 ed                	jne    16e76 <print_attr.constprop.17+0x14>
		if (ret < 0) {
			return ret;
		}
	}

	return 0;
   16e89:	31 c0                	xor    %eax,%eax
   16e8b:	e9 bb 00 00 00       	jmp    16f4b <print_attr.constprop.17+0xe9>
				attr->float_val.val2 != 0 ? "." : "");
   16e90:	8b 73 08             	mov    0x8(%ebx),%esi
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16e93:	b9 c4 96 02 00       	mov    $0x296c4,%ecx
   16e98:	85 f6                	test   %esi,%esi
   16e9a:	75 05                	jne    16ea1 <print_attr.constprop.17+0x3f>
   16e9c:	b9 7b 85 02 00       	mov    $0x2857b,%ecx
   16ea1:	8b 53 04             	mov    0x4(%ebx),%edx
				attr->float_val.val1 == 0 &&
   16ea4:	85 d2                	test   %edx,%edx
   16ea6:	75 09                	jne    16eb1 <print_attr.constprop.17+0x4f>
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16ea8:	b8 21 92 02 00       	mov    $0x29221,%eax
				attr->float_val.val1 == 0 &&
   16ead:	85 f6                	test   %esi,%esi
   16eaf:	78 05                	js     16eb6 <print_attr.constprop.17+0x54>
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16eb1:	b8 7b 85 02 00       	mov    $0x2857b,%eax
   16eb6:	51                   	push   %ecx
		base = 100000;
   16eb7:	bf a0 86 01 00       	mov    $0x186a0,%edi
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16ebc:	52                   	push   %edx
   16ebd:	50                   	push   %eax
				LWM2M_ATTR_STR[attr->type],
   16ebe:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16ec2:	ff 34 85 50 63 02 00 	pushl  0x26350(,%eax,4)
   16ec9:	68 23 92 02 00       	push   $0x29223
   16ece:	6a 18                	push   $0x18
   16ed0:	68 40 43 40 00       	push   $0x404340
   16ed5:	e8 03 bd fe ff       	call   2bdd <snprintk>
   16eda:	89 c6                	mov    %eax,%esi
		fraction = attr->float_val.val2 < 0 ?
   16edc:	8b 43 08             	mov    0x8(%ebx),%eax
   16edf:	c1 f8 1f             	sar    $0x1f,%eax
   16ee2:	8b 4b 08             	mov    0x8(%ebx),%ecx
   16ee5:	31 c1                	xor    %eax,%ecx
		used = snprintk(buf, buflen, ";%s=%s%d%s",
   16ee7:	83 c4 1c             	add    $0x1c,%esp
		fraction = attr->float_val.val2 < 0 ?
   16eea:	29 c1                	sub    %eax,%ecx
		while (fraction && used < buflen && base > 0) {
   16eec:	85 c9                	test   %ecx,%ecx
   16eee:	0f 95 c2             	setne  %dl
   16ef1:	83 fe 17             	cmp    $0x17,%esi
   16ef4:	0f 9e c0             	setle  %al
   16ef7:	84 c2                	test   %al,%dl
   16ef9:	74 29                	je     16f24 <print_attr.constprop.17+0xc2>
   16efb:	85 ff                	test   %edi,%edi
   16efd:	7e 25                	jle    16f24 <print_attr.constprop.17+0xc2>
			digit = fraction / base;
   16eff:	89 c8                	mov    %ecx,%eax
			buf[used++] = '0' + digit;
   16f01:	46                   	inc    %esi
			digit = fraction / base;
   16f02:	99                   	cltd   
   16f03:	f7 ff                	idiv   %edi
			buf[used++] = '0' + digit;
   16f05:	8d 50 30             	lea    0x30(%eax),%edx
			fraction -= digit * base;
   16f08:	0f b6 c0             	movzbl %al,%eax
   16f0b:	0f af c7             	imul   %edi,%eax
   16f0e:	29 c1                	sub    %eax,%ecx
			base /= 10;
   16f10:	89 f8                	mov    %edi,%eax
			buf[used++] = '0' + digit;
   16f12:	88 96 3f 43 40 00    	mov    %dl,0x40433f(%esi)
			base /= 10;
   16f18:	bf 0a 00 00 00       	mov    $0xa,%edi
   16f1d:	99                   	cltd   
   16f1e:	f7 ff                	idiv   %edi
   16f20:	89 c7                	mov    %eax,%edi
   16f22:	eb c8                	jmp    16eec <print_attr.constprop.17+0x8a>
		ret = buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, used);
   16f24:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16f27:	0f b7 f6             	movzwl %si,%esi
   16f2a:	8b 40 04             	mov    0x4(%eax),%eax
   16f2d:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   16f31:	8d 50 04             	lea    0x4(%eax),%edx
   16f34:	56                   	push   %esi
   16f35:	8b 00                	mov    (%eax),%eax
   16f37:	68 40 43 40 00       	push   $0x404340
   16f3c:	e8 6b fc ff ff       	call   16bac <buf_append>
   16f41:	5a                   	pop    %edx
   16f42:	59                   	pop    %ecx
		if (ret < 0) {
   16f43:	85 c0                	test   %eax,%eax
   16f45:	0f 89 32 ff ff ff    	jns    16e7d <print_attr.constprop.17+0x1b>
}
   16f4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16f4e:	5b                   	pop    %ebx
   16f4f:	5e                   	pop    %esi
   16f50:	5f                   	pop    %edi
   16f51:	5d                   	pop    %ebp
   16f52:	c3                   	ret    

00016f53 <string_to_path.constprop.18>:
static int string_to_path(char *pathstr, struct lwm2m_obj_path *path,
   16f53:	55                   	push   %ebp
   16f54:	89 e5                	mov    %esp,%ebp
   16f56:	57                   	push   %edi
   16f57:	56                   	push   %esi
	for (i = 0; i <= end_index; i++) {
   16f58:	31 ff                	xor    %edi,%edi
static int string_to_path(char *pathstr, struct lwm2m_obj_path *path,
   16f5a:	53                   	push   %ebx
   16f5b:	89 d3                	mov    %edx,%ebx
   16f5d:	83 ec 0c             	sub    $0xc,%esp
   16f60:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int end_index = strlen(pathstr) - 1;
   16f63:	50                   	push   %eax
   16f64:	e8 fa 38 ff ff       	call   a863 <strlen>
	(void)memset(path, 0, sizeof(*path));
   16f69:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
   16f70:	6a 00                	push   $0x0
	int end_index = strlen(pathstr) - 1;
   16f72:	48                   	dec    %eax
	(void)memset(path, 0, sizeof(*path));
   16f73:	53                   	push   %ebx
	int end_index = strlen(pathstr) - 1;
   16f74:	89 45 ec             	mov    %eax,-0x14(%ebp)
	(void)memset(path, 0, sizeof(*path));
   16f77:	e8 24 3a ff ff       	call   a9a0 <memset>
   16f7c:	83 c4 0c             	add    $0xc,%esp
	int i, tokstart = -1, toklen;
   16f7f:	83 c9 ff             	or     $0xffffffff,%ecx
	for (i = 0; i <= end_index; i++) {
   16f82:	39 7d ec             	cmp    %edi,-0x14(%ebp)
   16f85:	0f 8c d3 00 00 00    	jl     1705e <string_to_path.constprop.18+0x10b>
		if (tokstart == -1) {
   16f8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16f8e:	83 f9 ff             	cmp    $0xffffffff,%ecx
   16f91:	8a 04 38             	mov    (%eax,%edi,1),%al
   16f94:	75 11                	jne    16fa7 <string_to_path.constprop.18+0x54>
   16f96:	0f b6 d0             	movzbl %al,%edx
   16f99:	83 ea 30             	sub    $0x30,%edx
			if (!isdigit((unsigned char)pathstr[i])) {
   16f9c:	83 fa 09             	cmp    $0x9,%edx
   16f9f:	0f 87 b3 00 00 00    	ja     17058 <string_to_path.constprop.18+0x105>
   16fa5:	89 f9                	mov    %edi,%ecx
		if (pathstr[i] == delim || i == end_index) {
   16fa7:	3c 2f                	cmp    $0x2f,%al
   16fa9:	74 09                	je     16fb4 <string_to_path.constprop.18+0x61>
   16fab:	39 7d ec             	cmp    %edi,-0x14(%ebp)
   16fae:	0f 85 a4 00 00 00    	jne    17058 <string_to_path.constprop.18+0x105>
			toklen = i - tokstart + 1;
   16fb4:	89 fa                	mov    %edi,%edx
   16fb6:	29 ca                	sub    %ecx,%edx
			if (pathstr[i] == delim) {
   16fb8:	3c 2f                	cmp    $0x2f,%al
   16fba:	74 01                	je     16fbd <string_to_path.constprop.18+0x6a>
			toklen = i - tokstart + 1;
   16fbc:	42                   	inc    %edx
			if (toklen <= 0) {
   16fbd:	85 d2                	test   %edx,%edx
   16fbf:	0f 8e 93 00 00 00    	jle    17058 <string_to_path.constprop.18+0x105>
	while (pos < buflen && isdigit(buf[pos])) {
   16fc5:	03 4d f0             	add    -0x10(%ebp),%ecx
   16fc8:	0f b7 d2             	movzwl %dx,%edx
   16fcb:	8d 04 11             	lea    (%ecx,%edx,1),%eax
   16fce:	89 45 e8             	mov    %eax,-0x18(%ebp)
	u16_t val = 0U;
   16fd1:	31 c0                	xor    %eax,%eax
	while (pos < buflen && isdigit(buf[pos])) {
   16fd3:	3b 4d e8             	cmp    -0x18(%ebp),%ecx
   16fd6:	74 18                	je     16ff0 <string_to_path.constprop.18+0x9d>
   16fd8:	0f b6 11             	movzbl (%ecx),%edx
   16fdb:	0f b6 f2             	movzbl %dl,%esi
   16fde:	83 ee 30             	sub    $0x30,%esi
   16fe1:	41                   	inc    %ecx
   16fe2:	83 fe 09             	cmp    $0x9,%esi
   16fe5:	77 09                	ja     16ff0 <string_to_path.constprop.18+0x9d>
		val = val * 10 + (buf[pos] - '0');
   16fe7:	6b c0 0a             	imul   $0xa,%eax,%eax
   16fea:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
		pos++;
   16fee:	eb e3                	jmp    16fd3 <string_to_path.constprop.18+0x80>
			switch (path->level) {
   16ff0:	0f b6 4b 08          	movzbl 0x8(%ebx),%ecx
   16ff4:	80 f9 01             	cmp    $0x1,%cl
   16ff7:	74 19                	je     17012 <string_to_path.constprop.18+0xbf>
   16ff9:	84 c9                	test   %cl,%cl
   16ffb:	74 10                	je     1700d <string_to_path.constprop.18+0xba>
   16ffd:	80 f9 02             	cmp    $0x2,%cl
   17000:	74 16                	je     17018 <string_to_path.constprop.18+0xc5>
   17002:	80 f9 03             	cmp    $0x3,%cl
   17005:	75 17                	jne    1701e <string_to_path.constprop.18+0xcb>
				path->res_inst_id = value;
   17007:	66 89 43 06          	mov    %ax,0x6(%ebx)
				break;
   1700b:	eb 44                	jmp    17051 <string_to_path.constprop.18+0xfe>
				path->obj_id = value;
   1700d:	66 89 03             	mov    %ax,(%ebx)
				break;
   17010:	eb 3f                	jmp    17051 <string_to_path.constprop.18+0xfe>
				path->obj_inst_id = value;
   17012:	66 89 43 02          	mov    %ax,0x2(%ebx)
				break;
   17016:	eb 39                	jmp    17051 <string_to_path.constprop.18+0xfe>
				path->res_id = value;
   17018:	66 89 43 04          	mov    %ax,0x4(%ebx)
				break;
   1701c:	eb 33                	jmp    17051 <string_to_path.constprop.18+0xfe>
				return -EINVAL;
   1701e:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
				LOG_ERR("invalid level (%d)", path->level);
   17023:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1702a:	74 34                	je     17060 <string_to_path.constprop.18+0x10d>
   1702c:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17031:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   17037:	c1 ea 03             	shr    $0x3,%edx
   1703a:	c1 e2 06             	shl    $0x6,%edx
   1703d:	83 ca 01             	or     $0x1,%edx
   17040:	52                   	push   %edx
   17041:	51                   	push   %ecx
   17042:	68 2e 92 02 00       	push   $0x2922e
   17047:	e8 63 c4 fe ff       	call   34af <log_1>
   1704c:	83 c4 0c             	add    $0xc,%esp
   1704f:	eb 0f                	jmp    17060 <string_to_path.constprop.18+0x10d>
			path->level++;
   17051:	41                   	inc    %ecx
   17052:	88 4b 08             	mov    %cl,0x8(%ebx)
			tokstart = -1;
   17055:	83 c9 ff             	or     $0xffffffff,%ecx
	for (i = 0; i <= end_index; i++) {
   17058:	47                   	inc    %edi
   17059:	e9 24 ff ff ff       	jmp    16f82 <string_to_path.constprop.18+0x2f>
	return 0;
   1705e:	31 db                	xor    %ebx,%ebx
}
   17060:	8d 65 f4             	lea    -0xc(%ebp),%esp
   17063:	89 d8                	mov    %ebx,%eax
   17065:	5b                   	pop    %ebx
   17066:	5e                   	pop    %esi
   17067:	5f                   	pop    %edi
   17068:	5d                   	pop    %ebp
   17069:	c3                   	ret    

0001706a <sprint_token>:
{
   1706a:	55                   	push   %ebp
	if (token && tkl != LWM2M_MSG_TOKEN_LEN_SKIP) {
   1706b:	80 fa ff             	cmp    $0xff,%dl
{
   1706e:	89 e5                	mov    %esp,%ebp
   17070:	56                   	push   %esi
   17071:	53                   	push   %ebx
	if (token && tkl != LWM2M_MSG_TOKEN_LEN_SKIP) {
   17072:	74 54                	je     170c8 <sprint_token+0x5e>
		tkl = MIN(tkl, sizeof(buf) / 2 - 1);
   17074:	0f b6 ca             	movzbl %dl,%ecx
   17077:	80 fa 0f             	cmp    $0xf,%dl
   1707a:	76 05                	jbe    17081 <sprint_token+0x17>
   1707c:	b9 0f 00 00 00       	mov    $0xf,%ecx
		for (i = 0; i < tkl; i++) {
   17081:	31 d2                	xor    %edx,%edx
   17083:	39 d1                	cmp    %edx,%ecx
   17085:	7e 37                	jle    170be <sprint_token+0x54>
			*ptr++ = to_hex_digit(token[i] >> 4);
   17087:	8a 1c 10             	mov    (%eax,%edx,1),%bl
   1708a:	c0 eb 04             	shr    $0x4,%bl
	if (digit >= 10) {
   1708d:	80 fb 09             	cmp    $0x9,%bl
	return digit + '0';
   17090:	8d 73 30             	lea    0x30(%ebx),%esi
	if (digit >= 10) {
   17093:	76 03                	jbe    17098 <sprint_token+0x2e>
		return digit - 10 + 'a';
   17095:	8d 73 57             	lea    0x57(%ebx),%esi
			*ptr++ = to_hex_digit(token[i] >> 4);
   17098:	89 f3                	mov    %esi,%ebx
   1709a:	88 9c 12 20 18 40 00 	mov    %bl,0x401820(%edx,%edx,1)
			*ptr++ = to_hex_digit(token[i] & 0x0F);
   170a1:	8a 1c 10             	mov    (%eax,%edx,1),%bl
   170a4:	83 e3 0f             	and    $0xf,%ebx
	if (digit >= 10) {
   170a7:	80 fb 09             	cmp    $0x9,%bl
	return digit + '0';
   170aa:	8d 73 30             	lea    0x30(%ebx),%esi
	if (digit >= 10) {
   170ad:	76 03                	jbe    170b2 <sprint_token+0x48>
		return digit - 10 + 'a';
   170af:	8d 73 57             	lea    0x57(%ebx),%esi
			*ptr++ = to_hex_digit(token[i] & 0x0F);
   170b2:	89 f3                	mov    %esi,%ebx
   170b4:	88 9c 12 21 18 40 00 	mov    %bl,0x401821(%edx,%edx,1)
		for (i = 0; i < tkl; i++) {
   170bb:	42                   	inc    %edx
   170bc:	eb c5                	jmp    17083 <sprint_token+0x19>
		*ptr = '\0';
   170be:	c6 84 09 20 18 40 00 	movb   $0x0,0x401820(%ecx,%ecx,1)
   170c5:	00 
   170c6:	eb 11                	jmp    170d9 <sprint_token+0x6f>
		strcpy(buf, "[skip-token]");
   170c8:	68 41 92 02 00       	push   $0x29241
   170cd:	68 20 18 40 00       	push   $0x401820
   170d2:	e8 f4 36 ff ff       	call   a7cb <strcpy>
   170d7:	58                   	pop    %eax
   170d8:	5a                   	pop    %edx
}
   170d9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   170dc:	b8 20 18 40 00       	mov    $0x401820,%eax
   170e1:	5b                   	pop    %ebx
   170e2:	5e                   	pop    %esi
   170e3:	5d                   	pop    %ebp
   170e4:	c3                   	ret    

000170e5 <engine_remove_observer>:
{
   170e5:	55                   	push   %ebp
   170e6:	89 e5                	mov    %esp,%ebp
   170e8:	57                   	push   %edi
   170e9:	56                   	push   %esi
   170ea:	89 c7                	mov    %eax,%edi
   170ec:	53                   	push   %ebx
	if (!token || (tkl == 0 || tkl > MAX_TOKEN_LEN)) {
   170ed:	8d 42 ff             	lea    -0x1(%edx),%eax
{
   170f0:	83 ec 0c             	sub    $0xc,%esp
   170f3:	88 55 ef             	mov    %dl,-0x11(%ebp)
	if (!token || (tkl == 0 || tkl > MAX_TOKEN_LEN)) {
   170f6:	3c 07                	cmp    $0x7,%al
   170f8:	76 35                	jbe    1712f <engine_remove_observer+0x4a>
		return -EINVAL;
   170fa:	be ea ff ff ff       	mov    $0xffffffea,%esi
		LOG_ERR("token(%p) and token length(%u) must be valid.",
   170ff:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17106:	0f 84 b3 00 00 00    	je     171bf <engine_remove_observer+0xda>
   1710c:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17111:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17116:	c1 e8 03             	shr    $0x3,%eax
   17119:	c1 e0 06             	shl    $0x6,%eax
   1711c:	83 c8 01             	or     $0x1,%eax
   1711f:	50                   	push   %eax
   17120:	0f b6 d2             	movzbl %dl,%edx
   17123:	52                   	push   %edx
   17124:	57                   	push   %edi
   17125:	68 4e 92 02 00       	push   $0x2924e
   1712a:	e9 88 00 00 00       	jmp    171b7 <engine_remove_observer+0xd2>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   1712f:	8b 1d a0 43 40 00    	mov    0x4043a0,%ebx
	return list->head;
   17135:	31 d2                	xor    %edx,%edx
   17137:	85 db                	test   %ebx,%ebx
   17139:	75 07                	jne    17142 <engine_remove_observer+0x5d>
		return -ENOENT;
   1713b:	be fe ff ff ff       	mov    $0xfffffffe,%esi
   17140:	eb 7d                	jmp    171bf <engine_remove_observer+0xda>
		if (memcmp(obs->token, token, tkl) == 0) {
   17142:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   17146:	50                   	push   %eax
   17147:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1714a:	57                   	push   %edi
   1714b:	8d 43 12             	lea    0x12(%ebx),%eax
   1714e:	89 55 e8             	mov    %edx,-0x18(%ebp)
   17151:	50                   	push   %eax
   17152:	e8 6f 37 ff ff       	call   a8c6 <memcmp>
   17157:	83 c4 0c             	add    $0xc,%esp
   1715a:	89 c6                	mov    %eax,%esi
   1715c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1715f:	89 d8                	mov    %ebx,%eax
   17161:	85 f6                	test   %esi,%esi
   17163:	74 06                	je     1716b <engine_remove_observer+0x86>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   17165:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
   17167:	89 c2                	mov    %eax,%edx
   17169:	eb cc                	jmp    17137 <engine_remove_observer+0x52>
	sys_slist_remove(&engine_observer_list, prev_node, &found_obj->node);
   1716b:	89 d9                	mov    %ebx,%ecx
   1716d:	b8 a0 43 40 00       	mov    $0x4043a0,%eax
   17172:	e8 fe f7 ff ff       	call   16975 <sys_slist_remove>
	(void)memset(found_obj, 0, sizeof(*found_obj));
   17177:	6a 3c                	push   $0x3c
   17179:	6a 00                	push   $0x0
   1717b:	53                   	push   %ebx
   1717c:	e8 1f 38 ff ff       	call   a9a0 <memset>
   17181:	83 c4 0c             	add    $0xc,%esp
	LOG_DBG("observer '%s' removed", sprint_token(token, tkl));
   17184:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1718b:	74 32                	je     171bf <engine_remove_observer+0xda>
   1718d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   17190:	89 f8                	mov    %edi,%eax
   17192:	e8 d3 fe ff ff       	call   1706a <sprint_token>
   17197:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   1719c:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   171a2:	c1 eb 03             	shr    $0x3,%ebx
   171a5:	c1 e3 06             	shl    $0x6,%ebx
   171a8:	83 cb 04             	or     $0x4,%ebx
   171ab:	53                   	push   %ebx
   171ac:	50                   	push   %eax
   171ad:	68 78 62 02 00       	push   $0x26278
   171b2:	68 7c 92 02 00       	push   $0x2927c
   171b7:	e8 2d c3 fe ff       	call   34e9 <log_2>
   171bc:	83 c4 10             	add    $0x10,%esp
}
   171bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   171c2:	89 f0                	mov    %esi,%eax
   171c4:	5b                   	pop    %ebx
   171c5:	5e                   	pop    %esi
   171c6:	5f                   	pop    %edi
   171c7:	5d                   	pop    %ebp
   171c8:	c3                   	ret    

000171c9 <notify_message_reply_cb>:
}

static int notify_message_reply_cb(const struct coap_packet *response,
				   struct coap_reply *reply,
				   const struct sockaddr *from)
{
   171c9:	55                   	push   %ebp
   171ca:	89 e5                	mov    %esp,%ebp
   171cc:	57                   	push   %edi
   171cd:	56                   	push   %esi
   171ce:	53                   	push   %ebx
   171cf:	83 ec 14             	sub    $0x14,%esp
   171d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
   171d5:	8b 75 0c             	mov    0xc(%ebp),%esi
	int ret = 0;
	u8_t type, code;

	type = coap_header_get_type(response);
   171d8:	53                   	push   %ebx
   171d9:	e8 a9 12 ff ff       	call   8487 <coap_header_get_type>
	code = coap_header_get_code(response);
   171de:	89 1c 24             	mov    %ebx,(%esp)
	type = coap_header_get_type(response);
   171e1:	89 c7                	mov    %eax,%edi
	code = coap_header_get_code(response);
   171e3:	e8 f0 12 ff ff       	call   84d8 <coap_header_get_code>
   171e8:	59                   	pop    %ecx

	LOG_DBG("NOTIFY ACK type:%u code:%d.%d reply_token:'%s'",
   171e9:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   171f0:	74 57                	je     17249 <notify_message_reply_cb+0x80>
   171f2:	89 f9                	mov    %edi,%ecx
   171f4:	c7 45 e0 90 62 02 00 	movl   $0x26290,-0x20(%ebp)
   171fb:	0f b6 d1             	movzbl %cl,%edx
   171fe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   17201:	88 c2                	mov    %al,%dl
   17203:	c0 ea 05             	shr    $0x5,%dl
   17206:	83 e0 1f             	and    $0x1f,%eax
   17209:	0f b6 d2             	movzbl %dl,%edx
   1720c:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1720f:	89 45 ec             	mov    %eax,-0x14(%ebp)
   17212:	0f b6 56 16          	movzbl 0x16(%esi),%edx
   17216:	8d 46 0e             	lea    0xe(%esi),%eax
   17219:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   1721e:	e8 47 fe ff ff       	call   1706a <sprint_token>
   17223:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   17229:	c1 eb 03             	shr    $0x3,%ebx
   1722c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1722f:	c1 e3 06             	shl    $0x6,%ebx
   17232:	8d 45 e0             	lea    -0x20(%ebp),%eax
   17235:	83 cb 04             	or     $0x4,%ebx
   17238:	53                   	push   %ebx
   17239:	6a 05                	push   $0x5
   1723b:	50                   	push   %eax
   1723c:	68 96 92 02 00       	push   $0x29296
   17241:	e8 43 c3 fe ff       	call   3589 <log_n>
   17246:	83 c4 10             	add    $0x10,%esp
		COAP_RESPONSE_CODE_CLASS(code),
		COAP_RESPONSE_CODE_DETAIL(code),
		sprint_token(reply->token, reply->tkl));

	/* remove observer on COAP_TYPE_RESET */
	if (type == COAP_TYPE_RESET) {
   17249:	89 f8                	mov    %edi,%eax
   1724b:	3c 03                	cmp    $0x3,%al
   1724d:	75 6b                	jne    172ba <notify_message_reply_cb+0xf1>
		if (reply->tkl > 0) {
   1724f:	0f b6 56 16          	movzbl 0x16(%esi),%edx
   17253:	84 d2                	test   %dl,%dl
   17255:	74 3a                	je     17291 <notify_message_reply_cb+0xc8>
			ret = engine_remove_observer(reply->token, reply->tkl);
   17257:	8d 46 0e             	lea    0xe(%esi),%eax
   1725a:	e8 86 fe ff ff       	call   170e5 <engine_remove_observer>
			if (ret) {
   1725f:	85 c0                	test   %eax,%eax
   17261:	74 57                	je     172ba <notify_message_reply_cb+0xf1>
				LOG_ERR("remove observe error: %d", ret);
   17263:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1726a:	74 4e                	je     172ba <notify_message_reply_cb+0xf1>
   1726c:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17271:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   17277:	c1 ea 03             	shr    $0x3,%edx
   1727a:	c1 e2 06             	shl    $0x6,%edx
   1727d:	83 ca 01             	or     $0x1,%edx
   17280:	52                   	push   %edx
   17281:	50                   	push   %eax
   17282:	68 c9 92 02 00       	push   $0x292c9
   17287:	e8 23 c2 fe ff       	call   34af <log_1>
   1728c:	83 c4 0c             	add    $0xc,%esp
   1728f:	eb 29                	jmp    172ba <notify_message_reply_cb+0xf1>
			}
		} else {
			LOG_ERR("notify reply missing token -- ignored.");
   17291:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17298:	74 20                	je     172ba <notify_message_reply_cb+0xf1>
   1729a:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1729f:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   172a4:	c1 e8 03             	shr    $0x3,%eax
   172a7:	c1 e0 06             	shl    $0x6,%eax
   172aa:	83 c8 01             	or     $0x1,%eax
   172ad:	50                   	push   %eax
   172ae:	68 e2 92 02 00       	push   $0x292e2
   172b3:	e8 d2 c1 fe ff       	call   348a <log_0>
   172b8:	58                   	pop    %eax
   172b9:	5a                   	pop    %edx
		}
	}

	return 0;
}
   172ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
   172bd:	31 c0                	xor    %eax,%eax
   172bf:	5b                   	pop    %ebx
   172c0:	5e                   	pop    %esi
   172c1:	5f                   	pop    %edi
   172c2:	5d                   	pop    %ebp
   172c3:	c3                   	ret    

000172c4 <lwm2m_engine_init>:
	lwm2m_engine_context_init(client_ctx);
	return lwm2m_socket_start(client_ctx);
}

static int lwm2m_engine_init(struct device *dev)
{
   172c4:	55                   	push   %ebp
   172c5:	89 e5                	mov    %esp,%ebp
   172c7:	53                   	push   %ebx
	int ret;

	(void)memset(block1_contexts, 0,
   172c8:	6a 60                	push   $0x60
   172ca:	6a 00                	push   $0x0
   172cc:	68 40 29 40 00       	push   $0x402940
   172d1:	e8 ca 36 ff ff       	call   a9a0 <memset>
   172d6:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
   172d9:	6a 00                	push   $0x0
   172db:	6a 00                	push   $0x0
   172dd:	6a ff                	push   $0xffffffff
   172df:	6a 00                	push   $0x0
   172e1:	6a 00                	push   $0x0
   172e3:	6a 00                	push   $0x0
   172e5:	68 79 a2 01 00       	push   $0x1a279
   172ea:	68 00 0a 00 00       	push   $0xa00
   172ef:	68 10 7b 40 00       	push   $0x407b10
   172f4:	68 a0 29 40 00       	push   $0x4029a0
   172f9:	e8 1e cf 00 00       	call   2421c <z_impl_k_thread_create>
   172fe:	83 c4 28             	add    $0x28,%esp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   17301:	68 09 93 02 00       	push   $0x29309
   17306:	68 a0 29 40 00       	push   $0x4029a0
   1730b:	e8 8f ce 00 00       	call   2419f <z_impl_k_thread_name_set>
   17310:	59                   	pop    %ecx
			NULL, NULL, NULL,
			/* Lowest priority cooperative thread */
			K_PRIO_COOP(CONFIG_NUM_COOP_PRIORITIES - 1),
			0, K_NO_WAIT);
	k_thread_name_set(&engine_thread_data, "lwm2m-sock-recv");
	LOG_DBG("LWM2M engine socket receive thread started");
   17311:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   17318:	5b                   	pop    %ebx
   17319:	74 26                	je     17341 <lwm2m_engine_init+0x7d>
   1731b:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17320:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17325:	c1 e8 03             	shr    $0x3,%eax
   17328:	c1 e0 06             	shl    $0x6,%eax
   1732b:	83 c8 04             	or     $0x4,%eax
   1732e:	50                   	push   %eax
   1732f:	68 c0 62 02 00       	push   $0x262c0
   17334:	68 19 93 02 00       	push   $0x29319
   17339:	e8 71 c1 fe ff       	call   34af <log_1>
   1733e:	83 c4 0c             	add    $0xc,%esp

	k_delayed_work_init(&periodic_work, lwm2m_engine_service);
   17341:	68 fd b3 01 00       	push   $0x1b3fd
   17346:	68 e0 27 40 00       	push   $0x4027e0
   1734b:	e8 55 d1 00 00       	call   244a5 <k_delayed_work_init>
   17350:	58                   	pop    %eax
   17351:	5a                   	pop    %edx
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   17352:	68 d0 07 00 00       	push   $0x7d0
   17357:	68 e0 27 40 00       	push   $0x4027e0
   1735c:	68 60 41 40 00       	push   $0x404160
   17361:	e8 6f d1 00 00       	call   244d5 <k_delayed_work_submit_to_queue>
   17366:	83 c4 0c             	add    $0xc,%esp
   17369:	89 c3                	mov    %eax,%ebx
	ret = k_delayed_work_submit(&periodic_work, K_MSEC(2000));
	if (ret < 0) {
   1736b:	85 c0                	test   %eax,%eax
   1736d:	a1 a4 a8 40 00       	mov    0x40a8a4,%eax
   17372:	79 20                	jns    17394 <lwm2m_engine_init+0xd0>
		LOG_ERR("Error starting periodic work: %d", ret);
   17374:	a8 07                	test   $0x7,%al
   17376:	74 49                	je     173c1 <lwm2m_engine_init+0xfd>
   17378:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1737d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17382:	c1 e8 03             	shr    $0x3,%eax
   17385:	c1 e0 06             	shl    $0x6,%eax
   17388:	83 c8 01             	or     $0x1,%eax
   1738b:	50                   	push   %eax
   1738c:	53                   	push   %ebx
   1738d:	68 48 93 02 00       	push   $0x29348
   17392:	eb 25                	jmp    173b9 <lwm2m_engine_init+0xf5>
		return ret;
	}

	LOG_DBG("LWM2M engine periodic work started");
	return 0;
   17394:	31 db                	xor    %ebx,%ebx
	LOG_DBG("LWM2M engine periodic work started");
   17396:	a8 04                	test   $0x4,%al
   17398:	74 27                	je     173c1 <lwm2m_engine_init+0xfd>
   1739a:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1739f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   173a5:	c1 ea 03             	shr    $0x3,%edx
   173a8:	c1 e2 06             	shl    $0x6,%edx
   173ab:	83 ca 04             	or     $0x4,%edx
   173ae:	52                   	push   %edx
   173af:	68 c0 62 02 00       	push   $0x262c0
   173b4:	68 69 93 02 00       	push   $0x29369
   173b9:	e8 f1 c0 fe ff       	call   34af <log_1>
   173be:	83 c4 0c             	add    $0xc,%esp
}
   173c1:	89 d8                	mov    %ebx,%eax
   173c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   173c6:	c9                   	leave  
   173c7:	c3                   	ret    

000173c8 <lwm2m_sprint_ip_addr>:
{
   173c8:	55                   	push   %ebp
   173c9:	89 e5                	mov    %esp,%ebp
   173cb:	50                   	push   %eax
   173cc:	8b 45 08             	mov    0x8(%ebp),%eax
	if (addr->sa_family == AF_INET6) {
   173cf:	0f b7 08             	movzwl (%eax),%ecx
   173d2:	66 83 f9 02          	cmp    $0x2,%cx
   173d6:	75 0f                	jne    173e7 <lwm2m_sprint_ip_addr+0x1f>
		return net_addr_ntop(AF_INET6, &net_sin6(addr)->sin6_addr,
   173d8:	6a 28                	push   $0x28
   173da:	83 c0 04             	add    $0x4,%eax
   173dd:	68 40 18 40 00       	push   $0x401840
   173e2:	50                   	push   %eax
   173e3:	6a 02                	push   $0x2
   173e5:	eb 13                	jmp    173fa <lwm2m_sprint_ip_addr+0x32>
	if (addr->sa_family == AF_INET) {
   173e7:	66 83 f9 01          	cmp    $0x1,%cx
   173eb:	75 17                	jne    17404 <lwm2m_sprint_ip_addr+0x3c>
		return net_addr_ntop(AF_INET, &net_sin(addr)->sin_addr,
   173ed:	6a 28                	push   $0x28
   173ef:	83 c0 04             	add    $0x4,%eax
   173f2:	68 40 18 40 00       	push   $0x401840
   173f7:	50                   	push   %eax
   173f8:	6a 01                	push   $0x1
   173fa:	e8 5c 94 ff ff       	call   1085b <net_addr_ntop>
   173ff:	83 c4 10             	add    $0x10,%esp
   17402:	eb 34                	jmp    17438 <lwm2m_sprint_ip_addr+0x70>
	return NULL;
   17404:	31 c0                	xor    %eax,%eax
	LOG_ERR("Unknown IP address family:%d", addr->sa_family);
   17406:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1740d:	74 29                	je     17438 <lwm2m_sprint_ip_addr+0x70>
   1740f:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17414:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17417:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1741d:	c1 ea 03             	shr    $0x3,%edx
   17420:	c1 e2 06             	shl    $0x6,%edx
   17423:	83 ca 01             	or     $0x1,%edx
   17426:	52                   	push   %edx
   17427:	51                   	push   %ecx
   17428:	68 90 93 02 00       	push   $0x29390
   1742d:	e8 7d c0 fe ff       	call   34af <log_1>
   17432:	83 c4 0c             	add    $0xc,%esp
   17435:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   17438:	c9                   	leave  
   17439:	c3                   	ret    

0001743a <lwm2m_default_block_size>:
}
   1743a:	b8 04 00 00 00       	mov    $0x4,%eax
   1743f:	c3                   	ret    

00017440 <lwm2m_notify_observer>:
{
   17440:	55                   	push   %ebp
   17441:	89 e5                	mov    %esp,%ebp
   17443:	57                   	push   %edi
   17444:	56                   	push   %esi
   17445:	53                   	push   %ebx
   17446:	31 db                	xor    %ebx,%ebx
   17448:	83 ec 18             	sub    $0x18,%esp
   1744b:	8b 45 08             	mov    0x8(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   1744e:	8b 35 a0 43 40 00    	mov    0x4043a0,%esi
{
   17454:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
   17458:	8b 45 0c             	mov    0xc(%ebp),%eax
   1745b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
   1745f:	8b 7d 10             	mov    0x10(%ebp),%edi
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   17462:	85 f6                	test   %esi,%esi
   17464:	0f 84 84 00 00 00    	je     174ee <lwm2m_notify_observer+0xae>
   1746a:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1746f:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17474:	c1 e8 03             	shr    $0x3,%eax
			LOG_DBG("NOTIFY EVENT %u/%u/%u",
   17477:	c1 e0 06             	shl    $0x6,%eax
   1747a:	66 89 45 de          	mov    %ax,-0x22(%ebp)
		if (obs->path.obj_id == obj_id &&
   1747e:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
   17482:	66 39 46 08          	cmp    %ax,0x8(%esi)
   17486:	75 60                	jne    174e8 <lwm2m_notify_observer+0xa8>
   17488:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1748b:	66 39 46 0a          	cmp    %ax,0xa(%esi)
   1748f:	75 57                	jne    174e8 <lwm2m_notify_observer+0xa8>
		    obs->path.obj_inst_id == obj_inst_id &&
   17491:	80 7e 10 02          	cmpb   $0x2,0x10(%esi)
   17495:	76 06                	jbe    1749d <lwm2m_notify_observer+0x5d>
		    (obs->path.level < 3 ||
   17497:	66 39 7e 0c          	cmp    %di,0xc(%esi)
   1749b:	75 4b                	jne    174e8 <lwm2m_notify_observer+0xa8>
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   1749d:	e8 6f d4 00 00       	call   24911 <z_impl_k_uptime_get>
			LOG_DBG("NOTIFY EVENT %u/%u/%u",
   174a2:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
			obs->event_timestamp = k_uptime_get();
   174a9:	89 46 1c             	mov    %eax,0x1c(%esi)
   174ac:	89 56 20             	mov    %edx,0x20(%esi)
			LOG_DBG("NOTIFY EVENT %u/%u/%u",
   174af:	74 36                	je     174e7 <lwm2m_notify_observer+0xa7>
   174b1:	66 8b 45 de          	mov    -0x22(%ebp),%ax
   174b5:	c7 45 e4 30 63 02 00 	movl   $0x26330,-0x1c(%ebp)
   174bc:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
   174c0:	83 c8 04             	or     $0x4,%eax
   174c3:	89 55 e8             	mov    %edx,-0x18(%ebp)
   174c6:	50                   	push   %eax
   174c7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   174ca:	6a 04                	push   $0x4
   174cc:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   174d0:	50                   	push   %eax
   174d1:	89 55 ec             	mov    %edx,-0x14(%ebp)
   174d4:	68 ad 93 02 00       	push   $0x293ad
   174d9:	0f b7 d7             	movzwl %di,%edx
   174dc:	89 55 f0             	mov    %edx,-0x10(%ebp)
   174df:	e8 a5 c0 fe ff       	call   3589 <log_n>
   174e4:	83 c4 10             	add    $0x10,%esp
			ret++;
   174e7:	43                   	inc    %ebx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   174e8:	8b 36                	mov    (%esi),%esi
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   174ea:	85 f6                	test   %esi,%esi
   174ec:	75 90                	jne    1747e <lwm2m_notify_observer+0x3e>
}
   174ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
   174f1:	89 d8                	mov    %ebx,%eax
   174f3:	5b                   	pop    %ebx
   174f4:	5e                   	pop    %esi
   174f5:	5f                   	pop    %edi
   174f6:	5d                   	pop    %ebp
   174f7:	c3                   	ret    

000174f8 <lwm2m_notify_observer_path>:
{
   174f8:	55                   	push   %ebp
   174f9:	89 e5                	mov    %esp,%ebp
   174fb:	8b 45 08             	mov    0x8(%ebp),%eax
	return lwm2m_notify_observer(path->obj_id, path->obj_inst_id,
   174fe:	0f b7 50 04          	movzwl 0x4(%eax),%edx
   17502:	52                   	push   %edx
   17503:	0f b7 50 02          	movzwl 0x2(%eax),%edx
   17507:	52                   	push   %edx
   17508:	0f b7 00             	movzwl (%eax),%eax
   1750b:	50                   	push   %eax
   1750c:	e8 2f ff ff ff       	call   17440 <lwm2m_notify_observer>
   17511:	83 c4 0c             	add    $0xc,%esp
}
   17514:	c9                   	leave  
   17515:	c3                   	ret    

00017516 <lwm2m_register_obj>:
{
   17516:	55                   	push   %ebp
	sys_slist_append(&engine_obj_list, &obj->node);
   17517:	b8 b0 43 40 00       	mov    $0x4043b0,%eax
{
   1751c:	89 e5                	mov    %esp,%ebp
	sys_slist_append(&engine_obj_list, &obj->node);
   1751e:	8b 55 08             	mov    0x8(%ebp),%edx
}
   17521:	5d                   	pop    %ebp
	sys_slist_append(&engine_obj_list, &obj->node);
   17522:	e9 35 f4 ff ff       	jmp    1695c <sys_slist_append>

00017527 <lwm2m_get_engine_obj_field>:
{
   17527:	55                   	push   %ebp
	return NULL;
   17528:	31 c0                	xor    %eax,%eax
{
   1752a:	89 e5                	mov    %esp,%ebp
   1752c:	53                   	push   %ebx
   1752d:	8b 55 08             	mov    0x8(%ebp),%edx
	if (obj && obj->fields && obj->field_count > 0) {
   17530:	85 d2                	test   %edx,%edx
   17532:	74 24                	je     17558 <lwm2m_get_engine_obj_field+0x31>
   17534:	8b 42 04             	mov    0x4(%edx),%eax
   17537:	85 c0                	test   %eax,%eax
   17539:	74 1d                	je     17558 <lwm2m_get_engine_obj_field+0x31>
   1753b:	0f b7 52 1a          	movzwl 0x1a(%edx),%edx
   1753f:	66 85 d2             	test   %dx,%dx
   17542:	74 12                	je     17556 <lwm2m_get_engine_obj_field+0x2f>
		for (i = 0; i < obj->field_count; i++) {
   17544:	31 c9                	xor    %ecx,%ecx
			if (obj->fields[i].res_id == res_id) {
   17546:	0f b7 18             	movzwl (%eax),%ebx
   17549:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
   1754c:	74 0a                	je     17558 <lwm2m_get_engine_obj_field+0x31>
		for (i = 0; i < obj->field_count; i++) {
   1754e:	41                   	inc    %ecx
   1754f:	83 c0 06             	add    $0x6,%eax
   17552:	39 ca                	cmp    %ecx,%edx
   17554:	7f f0                	jg     17546 <lwm2m_get_engine_obj_field+0x1f>
	return NULL;
   17556:	31 c0                	xor    %eax,%eax
}
   17558:	5b                   	pop    %ebx
   17559:	5d                   	pop    %ebp
   1755a:	c3                   	ret    

0001755b <path_to_objs>:
{
   1755b:	55                   	push   %ebp
   1755c:	89 e5                	mov    %esp,%ebp
   1755e:	57                   	push   %edi
   1755f:	56                   	push   %esi
   17560:	89 c7                	mov    %eax,%edi
   17562:	53                   	push   %ebx
   17563:	83 ec 10             	sub    $0x10,%esp
   17566:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	oi = get_engine_obj_inst(path->obj_id, path->obj_inst_id);
   17569:	0f b7 18             	movzwl (%eax),%ebx
   1756c:	0f b7 48 02          	movzwl 0x2(%eax),%ecx
{
   17570:	89 55 ec             	mov    %edx,-0x14(%ebp)
	oi = get_engine_obj_inst(path->obj_id, path->obj_inst_id);
   17573:	89 d8                	mov    %ebx,%eax
   17575:	89 ca                	mov    %ecx,%edx
   17577:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1757a:	e8 6b f4 ff ff       	call   169ea <get_engine_obj_inst>
	if (!oi) {
   1757f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   17582:	85 c0                	test   %eax,%eax
   17584:	75 3a                	jne    175c0 <path_to_objs+0x65>
		return -ENOENT;
   17586:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		LOG_ERR("obj instance %d/%d not found",
   1758b:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17592:	0f 84 35 01 00 00    	je     176cd <path_to_objs+0x172>
   17598:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1759d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   175a2:	c1 e8 03             	shr    $0x3,%eax
   175a5:	c1 e0 06             	shl    $0x6,%eax
   175a8:	83 c8 01             	or     $0x1,%eax
   175ab:	50                   	push   %eax
   175ac:	51                   	push   %ecx
   175ad:	53                   	push   %ebx
   175ae:	68 c7 93 02 00       	push   $0x293c7
   175b3:	e8 31 bf fe ff       	call   34e9 <log_2>
   175b8:	83 c4 10             	add    $0x10,%esp
   175bb:	e9 0d 01 00 00       	jmp    176cd <path_to_objs+0x172>
	if (!oi->resources || oi->resource_count == 0) {
   175c0:	8b 58 08             	mov    0x8(%eax),%ebx
   175c3:	89 c6                	mov    %eax,%esi
   175c5:	85 db                	test   %ebx,%ebx
   175c7:	74 09                	je     175d2 <path_to_objs+0x77>
   175c9:	66 8b 48 0e          	mov    0xe(%eax),%cx
   175cd:	66 85 c9             	test   %cx,%cx
   175d0:	75 37                	jne    17609 <path_to_objs+0xae>
		return -EINVAL;
   175d2:	be ea ff ff ff       	mov    $0xffffffea,%esi
		LOG_ERR("obj instance has no resources");
   175d7:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   175de:	0f 84 e9 00 00 00    	je     176cd <path_to_objs+0x172>
   175e4:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   175e9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   175ee:	c1 e8 03             	shr    $0x3,%eax
   175f1:	c1 e0 06             	shl    $0x6,%eax
   175f4:	83 c8 01             	or     $0x1,%eax
   175f7:	50                   	push   %eax
   175f8:	68 e4 93 02 00       	push   $0x293e4
   175fd:	e8 88 be fe ff       	call   348a <log_0>
   17602:	5b                   	pop    %ebx
   17603:	5f                   	pop    %edi
   17604:	e9 c4 00 00 00       	jmp    176cd <path_to_objs+0x172>
	of = lwm2m_get_engine_obj_field(oi->obj, path->res_id);
   17609:	0f b7 7f 04          	movzwl 0x4(%edi),%edi
   1760d:	57                   	push   %edi
   1760e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
   17611:	ff 76 04             	pushl  0x4(%esi)
   17614:	66 89 7d f0          	mov    %di,-0x10(%ebp)
   17618:	e8 0a ff ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   1761d:	5a                   	pop    %edx
   1761e:	89 da                	mov    %ebx,%edx
   17620:	59                   	pop    %ecx
	for (i = 0; i < oi->resource_count; i++) {
   17621:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   17624:	31 db                	xor    %ebx,%ebx
	if (!of) {
   17626:	85 c0                	test   %eax,%eax
	for (i = 0; i < oi->resource_count; i++) {
   17628:	0f b7 c9             	movzwl %cx,%ecx
	if (!of) {
   1762b:	75 3e                	jne    1766b <path_to_objs+0x110>
		return -ENOENT;
   1762d:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		LOG_ERR("obj field %d not found", path->res_id);
   17632:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17639:	0f 84 8e 00 00 00    	je     176cd <path_to_objs+0x172>
   1763f:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17644:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17649:	c1 e8 03             	shr    $0x3,%eax
   1764c:	c1 e0 06             	shl    $0x6,%eax
   1764f:	83 c8 01             	or     $0x1,%eax
   17652:	50                   	push   %eax
   17653:	57                   	push   %edi
   17654:	68 02 94 02 00       	push   $0x29402
   17659:	e8 51 be fe ff       	call   34af <log_1>
   1765e:	83 c4 0c             	add    $0xc,%esp
   17661:	eb 6a                	jmp    176cd <path_to_objs+0x172>
	for (i = 0; i < oi->resource_count; i++) {
   17663:	43                   	inc    %ebx
   17664:	83 c2 20             	add    $0x20,%edx
   17667:	39 cb                	cmp    %ecx,%ebx
   17669:	7d 2e                	jge    17699 <path_to_objs+0x13e>
		if (oi->resources[i].res_id == path->res_id) {
   1766b:	8b 7d f0             	mov    -0x10(%ebp),%edi
   1766e:	66 3b 7a 1a          	cmp    0x1a(%edx),%di
   17672:	75 ef                	jne    17663 <path_to_objs+0x108>
	if (obj_inst) {
   17674:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17678:	74 05                	je     1767f <path_to_objs+0x124>
		*obj_inst = oi;
   1767a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   1767d:	89 33                	mov    %esi,(%ebx)
	if (obj_field) {
   1767f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   17683:	74 05                	je     1768a <path_to_objs+0x12f>
		*obj_field = of;
   17685:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   17688:	89 03                	mov    %eax,(%ebx)
	return 0;
   1768a:	31 f6                	xor    %esi,%esi
	if (res) {
   1768c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17690:	74 3b                	je     176cd <path_to_objs+0x172>
		*res = r;
   17692:	8b 45 08             	mov    0x8(%ebp),%eax
   17695:	89 10                	mov    %edx,(%eax)
   17697:	eb 34                	jmp    176cd <path_to_objs+0x172>
		LOG_ERR("res instance %d not found", path->res_id);
   17699:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   176a0:	74 26                	je     176c8 <path_to_objs+0x16d>
   176a2:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   176a7:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   176ac:	c1 e8 03             	shr    $0x3,%eax
   176af:	c1 e0 06             	shl    $0x6,%eax
   176b2:	83 c8 01             	or     $0x1,%eax
   176b5:	50                   	push   %eax
   176b6:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
   176ba:	50                   	push   %eax
   176bb:	68 19 94 02 00       	push   $0x29419
   176c0:	e8 ea bd fe ff       	call   34af <log_1>
   176c5:	83 c4 0c             	add    $0xc,%esp
		return -ENOENT;
   176c8:	be fe ff ff ff       	mov    $0xfffffffe,%esi
}
   176cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   176d0:	89 f0                	mov    %esi,%eax
   176d2:	5b                   	pop    %ebx
   176d3:	5e                   	pop    %esi
   176d4:	5f                   	pop    %edi
   176d5:	5d                   	pop    %ebp
   176d6:	c3                   	ret    

000176d7 <lwm2m_engine_set>:
{
   176d7:	55                   	push   %ebp
   176d8:	89 e5                	mov    %esp,%ebp
   176da:	57                   	push   %edi
   176db:	56                   	push   %esi
   176dc:	53                   	push   %ebx
   176dd:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   176e0:	83 ec 28             	sub    $0x28,%esp
   176e3:	89 d3                	mov    %edx,%ebx
   176e5:	89 4d d0             	mov    %ecx,-0x30(%ebp)
	struct lwm2m_engine_res_inst *res = NULL;
   176e8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	size_t data_len = 0;
   176ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	LOG_DBG("path:%s, value:%p, len:%d", pathstr, value, len);
   176f6:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   176fd:	74 3f                	je     1773e <lwm2m_engine_set+0x67>
   176ff:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17704:	89 45 e8             	mov    %eax,-0x18(%ebp)
   17707:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1770d:	89 45 cc             	mov    %eax,-0x34(%ebp)
   17710:	c1 ea 03             	shr    $0x3,%edx
   17713:	c7 45 e4 fc 62 02 00 	movl   $0x262fc,-0x1c(%ebp)
   1771a:	c1 e2 06             	shl    $0x6,%edx
   1771d:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   17720:	83 ca 04             	or     $0x4,%edx
   17723:	52                   	push   %edx
   17724:	6a 04                	push   $0x4
   17726:	57                   	push   %edi
   17727:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
   1772b:	68 33 94 02 00       	push   $0x29433
   17730:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   17733:	e8 51 be fe ff       	call   3589 <log_n>
   17738:	83 c4 10             	add    $0x10,%esp
   1773b:	8b 45 cc             	mov    -0x34(%ebp),%eax
	ret = string_to_path(pathstr, &path, '/');
   1773e:	89 fa                	mov    %edi,%edx
   17740:	e8 0e f8 ff ff       	call   16f53 <string_to_path.constprop.18>
   17745:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   17747:	85 c0                	test   %eax,%eax
   17749:	0f 88 86 02 00 00    	js     179d5 <lwm2m_engine_set+0x2fe>
	if (path.level < 3) {
   1774f:	80 7d ec 02          	cmpb   $0x2,-0x14(%ebp)
   17753:	77 33                	ja     17788 <lwm2m_engine_set+0xb1>
		LOG_ERR("path must have 3 parts");
   17755:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1775c:	74 20                	je     1777e <lwm2m_engine_set+0xa7>
   1775e:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17763:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17768:	c1 e8 03             	shr    $0x3,%eax
   1776b:	c1 e0 06             	shl    $0x6,%eax
   1776e:	83 c8 01             	or     $0x1,%eax
   17771:	50                   	push   %eax
   17772:	68 51 94 02 00       	push   $0x29451
   17777:	e8 0e bd fe ff       	call   348a <log_0>
   1777c:	59                   	pop    %ecx
   1777d:	5b                   	pop    %ebx
		return -EINVAL;
   1777e:	be ea ff ff ff       	mov    $0xffffffea,%esi
   17783:	e9 4d 02 00 00       	jmp    179d5 <lwm2m_engine_set+0x2fe>
	ret = path_to_objs(&path, &obj_inst, &obj_field, &res);
   17788:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1778b:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   1778e:	50                   	push   %eax
   1778f:	8d 4d d8             	lea    -0x28(%ebp),%ecx
   17792:	89 f8                	mov    %edi,%eax
   17794:	e8 c2 fd ff ff       	call   1755b <path_to_objs>
   17799:	5a                   	pop    %edx
   1779a:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1779c:	85 c0                	test   %eax,%eax
   1779e:	0f 88 31 02 00 00    	js     179d5 <lwm2m_engine_set+0x2fe>
	if (!res) {
   177a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   177a7:	85 c0                	test   %eax,%eax
   177a9:	75 3d                	jne    177e8 <lwm2m_engine_set+0x111>
		return -ENOENT;
   177ab:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		LOG_ERR("res instance %d not found", path.res_id);
   177b0:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   177b7:	0f 84 18 02 00 00    	je     179d5 <lwm2m_engine_set+0x2fe>
   177bd:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   177c2:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   177c7:	c1 e8 03             	shr    $0x3,%eax
   177ca:	c1 e0 06             	shl    $0x6,%eax
   177cd:	83 c8 01             	or     $0x1,%eax
   177d0:	50                   	push   %eax
   177d1:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   177d5:	50                   	push   %eax
   177d6:	68 19 94 02 00       	push   $0x29419
   177db:	e8 cf bc fe ff       	call   34af <log_1>
   177e0:	83 c4 0c             	add    $0xc,%esp
   177e3:	e9 ed 01 00 00       	jmp    179d5 <lwm2m_engine_set+0x2fe>
	if (LWM2M_HAS_RES_FLAG(res, LWM2M_RES_DATA_FLAG_RO)) {
   177e8:	f6 40 1c 01          	testb  $0x1,0x1c(%eax)
   177ec:	74 37                	je     17825 <lwm2m_engine_set+0x14e>
		return -EACCES;
   177ee:	be f3 ff ff ff       	mov    $0xfffffff3,%esi
		LOG_ERR("res data pointer is read-only");
   177f3:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   177fa:	0f 84 d5 01 00 00    	je     179d5 <lwm2m_engine_set+0x2fe>
   17800:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17805:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1780a:	c1 e8 03             	shr    $0x3,%eax
   1780d:	c1 e0 06             	shl    $0x6,%eax
   17810:	83 c8 01             	or     $0x1,%eax
   17813:	50                   	push   %eax
   17814:	68 68 94 02 00       	push   $0x29468
   17819:	e8 6c bc fe ff       	call   348a <log_0>
   1781e:	5b                   	pop    %ebx
   1781f:	5f                   	pop    %edi
   17820:	e9 b0 01 00 00       	jmp    179d5 <lwm2m_engine_set+0x2fe>
	data_len = res->data_len;
   17825:	0f b7 50 18          	movzwl 0x18(%eax),%edx
	data_ptr = res->data_ptr;
   17829:	8b 78 14             	mov    0x14(%eax),%edi
	if (res->pre_write_cb) {
   1782c:	8b 40 04             	mov    0x4(%eax),%eax
	data_len = res->data_len;
   1782f:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (res->pre_write_cb) {
   17832:	85 c0                	test   %eax,%eax
   17834:	74 12                	je     17848 <lwm2m_engine_set+0x171>
		data_ptr = res->pre_write_cb(obj_inst->obj_inst_id, &data_len);
   17836:	8d 55 e0             	lea    -0x20(%ebp),%edx
   17839:	52                   	push   %edx
   1783a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1783d:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
   17841:	52                   	push   %edx
   17842:	ff d0                	call   *%eax
   17844:	5a                   	pop    %edx
   17845:	89 c7                	mov    %eax,%edi
   17847:	59                   	pop    %ecx
	if (!data_ptr) {
   17848:	85 ff                	test   %edi,%edi
   1784a:	75 2b                	jne    17877 <lwm2m_engine_set+0x1a0>
		LOG_ERR("res data pointer is NULL");
   1784c:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17853:	0f 84 25 ff ff ff    	je     1777e <lwm2m_engine_set+0xa7>
   17859:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1785e:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17863:	c1 e8 03             	shr    $0x3,%eax
   17866:	c1 e0 06             	shl    $0x6,%eax
   17869:	83 c8 01             	or     $0x1,%eax
   1786c:	50                   	push   %eax
   1786d:	68 86 94 02 00       	push   $0x29486
   17872:	e9 00 ff ff ff       	jmp    17777 <lwm2m_engine_set+0xa0>
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
   17877:	8b 55 d8             	mov    -0x28(%ebp),%edx
	if (len > res->data_len -
   1787a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1787d:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
   17881:	80 7a 03 02          	cmpb   $0x2,0x3(%edx)
	if (len > res->data_len -
   17885:	0f b7 40 18          	movzwl 0x18(%eax),%eax
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
   17889:	0f 94 c2             	sete   %dl
   1788c:	0f b6 d2             	movzbl %dl,%edx
	if (len > res->data_len -
   1788f:	29 d0                	sub    %edx,%eax
   17891:	39 c1                	cmp    %eax,%ecx
   17893:	7e 3e                	jle    178d3 <lwm2m_engine_set+0x1fc>
		return -ENOMEM;
   17895:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
		LOG_ERR("length %u is too long for resource %d data",
   1789a:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   178a1:	0f 84 2e 01 00 00    	je     179d5 <lwm2m_engine_set+0x2fe>
   178a7:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   178ac:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   178b1:	c1 e8 03             	shr    $0x3,%eax
   178b4:	c1 e0 06             	shl    $0x6,%eax
   178b7:	83 c8 01             	or     $0x1,%eax
   178ba:	50                   	push   %eax
   178bb:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   178bf:	50                   	push   %eax
   178c0:	51                   	push   %ecx
   178c1:	68 9f 94 02 00       	push   $0x2949f
   178c6:	e8 1e bc fe ff       	call   34e9 <log_2>
   178cb:	83 c4 10             	add    $0x10,%esp
   178ce:	e9 02 01 00 00       	jmp    179d5 <lwm2m_engine_set+0x2fe>
	if (memcmp(data_ptr, value, len) !=  0) {
   178d3:	51                   	push   %ecx
   178d4:	89 4d cc             	mov    %ecx,-0x34(%ebp)
   178d7:	53                   	push   %ebx
   178d8:	57                   	push   %edi
   178d9:	e8 e8 2f ff ff       	call   a8c6 <memcmp>
   178de:	89 45 d0             	mov    %eax,-0x30(%ebp)
	switch (obj_field->data_type) {
   178e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
	if (memcmp(data_ptr, value, len) !=  0) {
   178e4:	83 c4 0c             	add    $0xc,%esp
	switch (obj_field->data_type) {
   178e7:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   178eb:	8d 50 ff             	lea    -0x1(%eax),%edx
   178ee:	80 fa 0d             	cmp    $0xd,%dl
   178f1:	77 7e                	ja     17971 <lwm2m_engine_set+0x29a>
   178f3:	0f b6 d2             	movzbl %dl,%edx
   178f6:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   178f9:	ff 24 95 1c 61 02 00 	jmp    *0x2611c(,%edx,4)
		memcpy((u8_t *)data_ptr, value, len);
   17900:	51                   	push   %ecx
   17901:	89 4d cc             	mov    %ecx,-0x34(%ebp)
   17904:	53                   	push   %ebx
   17905:	57                   	push   %edi
   17906:	e8 26 30 ff ff       	call   a931 <memcpy>
   1790b:	83 c4 0c             	add    $0xc,%esp
		break;
   1790e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   17911:	e9 90 00 00 00       	jmp    179a6 <lwm2m_engine_set+0x2cf>
		memcpy((u8_t *)data_ptr, value, len);
   17916:	51                   	push   %ecx
   17917:	89 4d cc             	mov    %ecx,-0x34(%ebp)
   1791a:	53                   	push   %ebx
   1791b:	57                   	push   %edi
   1791c:	e8 10 30 ff ff       	call   a931 <memcpy>
		((u8_t *)data_ptr)[len] = '\0';
   17921:	8b 4d cc             	mov    -0x34(%ebp),%ecx
		memcpy((u8_t *)data_ptr, value, len);
   17924:	83 c4 0c             	add    $0xc,%esp
		((u8_t *)data_ptr)[len] = '\0';
   17927:	c6 04 0f 00          	movb   $0x0,(%edi,%ecx,1)
		break;
   1792b:	eb 79                	jmp    179a6 <lwm2m_engine_set+0x2cf>
		*((s64_t *)data_ptr) = *(s64_t *)value;
   1792d:	8b 03                	mov    (%ebx),%eax
   1792f:	8b 53 04             	mov    0x4(%ebx),%edx
   17932:	89 57 04             	mov    %edx,0x4(%edi)
   17935:	89 07                	mov    %eax,(%edi)
		break;
   17937:	eb 6d                	jmp    179a6 <lwm2m_engine_set+0x2cf>
		*((s32_t *)data_ptr) = *(s32_t *)value;
   17939:	8b 03                	mov    (%ebx),%eax
   1793b:	89 07                	mov    %eax,(%edi)
		break;
   1793d:	eb 67                	jmp    179a6 <lwm2m_engine_set+0x2cf>
		*((s16_t *)data_ptr) = *(s16_t *)value;
   1793f:	66 8b 03             	mov    (%ebx),%ax
   17942:	66 89 07             	mov    %ax,(%edi)
		break;
   17945:	eb 5f                	jmp    179a6 <lwm2m_engine_set+0x2cf>
		*((bool *)data_ptr) = *(bool *)value;
   17947:	8a 03                	mov    (%ebx),%al
   17949:	88 07                	mov    %al,(%edi)
		break;
   1794b:	eb 59                	jmp    179a6 <lwm2m_engine_set+0x2cf>
				((float32_value_t *)value)->val1;
   1794d:	8b 03                	mov    (%ebx),%eax
		((float32_value_t *)data_ptr)->val1 =
   1794f:	89 07                	mov    %eax,(%edi)
				((float32_value_t *)value)->val2;
   17951:	8b 43 04             	mov    0x4(%ebx),%eax
		((float32_value_t *)data_ptr)->val2 =
   17954:	89 47 04             	mov    %eax,0x4(%edi)
		break;
   17957:	eb 4d                	jmp    179a6 <lwm2m_engine_set+0x2cf>
				((float64_value_t *)value)->val1;
   17959:	8b 53 04             	mov    0x4(%ebx),%edx
   1795c:	8b 03                	mov    (%ebx),%eax
		((float64_value_t *)data_ptr)->val1 =
   1795e:	89 57 04             	mov    %edx,0x4(%edi)
   17961:	89 07                	mov    %eax,(%edi)
				((float64_value_t *)value)->val2;
   17963:	8b 53 0c             	mov    0xc(%ebx),%edx
   17966:	8b 43 08             	mov    0x8(%ebx),%eax
		((float64_value_t *)data_ptr)->val2 =
   17969:	89 47 08             	mov    %eax,0x8(%edi)
   1796c:	89 57 0c             	mov    %edx,0xc(%edi)
		break;
   1796f:	eb 35                	jmp    179a6 <lwm2m_engine_set+0x2cf>
		LOG_ERR("unknown obj data_type %d", obj_field->data_type);
   17971:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17978:	0f 84 00 fe ff ff    	je     1777e <lwm2m_engine_set+0xa7>
   1797e:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17983:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   17989:	c1 ea 03             	shr    $0x3,%edx
   1798c:	c1 e2 06             	shl    $0x6,%edx
   1798f:	83 ca 01             	or     $0x1,%edx
   17992:	52                   	push   %edx
   17993:	50                   	push   %eax
   17994:	68 ca 94 02 00       	push   $0x294ca
   17999:	e8 11 bb fe ff       	call   34af <log_1>
   1799e:	83 c4 0c             	add    $0xc,%esp
   179a1:	e9 d8 fd ff ff       	jmp    1777e <lwm2m_engine_set+0xa7>
	if (res->post_write_cb) {
   179a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   179a9:	8b 40 08             	mov    0x8(%eax),%eax
   179ac:	85 c0                	test   %eax,%eax
   179ae:	74 15                	je     179c5 <lwm2m_engine_set+0x2ee>
		ret = res->post_write_cb(obj_inst->obj_inst_id, data_ptr, len,
   179b0:	6a 00                	push   $0x0
   179b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   179b5:	6a 00                	push   $0x0
   179b7:	51                   	push   %ecx
   179b8:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
   179bc:	57                   	push   %edi
   179bd:	52                   	push   %edx
   179be:	ff d0                	call   *%eax
   179c0:	83 c4 14             	add    $0x14,%esp
   179c3:	89 c6                	mov    %eax,%esi
	if (changed) {
   179c5:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   179c9:	74 0a                	je     179d5 <lwm2m_engine_set+0x2fe>
		NOTIFY_OBSERVER_PATH(&path);
   179cb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   179ce:	50                   	push   %eax
   179cf:	e8 24 fb ff ff       	call   174f8 <lwm2m_notify_observer_path>
   179d4:	58                   	pop    %eax
}
   179d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
   179d8:	89 f0                	mov    %esi,%eax
   179da:	5b                   	pop    %ebx
   179db:	5e                   	pop    %esi
   179dc:	5f                   	pop    %edi
   179dd:	5d                   	pop    %ebp
   179de:	c3                   	ret    

000179df <lwm2m_engine_get>:
{
   179df:	55                   	push   %ebp
   179e0:	89 e5                	mov    %esp,%ebp
   179e2:	57                   	push   %edi
   179e3:	56                   	push   %esi
   179e4:	89 ce                	mov    %ecx,%esi
   179e6:	53                   	push   %ebx
   179e7:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   179ea:	83 ec 24             	sub    $0x24,%esp
   179ed:	89 d3                	mov    %edx,%ebx
	struct lwm2m_engine_res_inst *res = NULL;
   179ef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	size_t data_len = 0;
   179f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	LOG_DBG("path:%s, buf:%p, buflen:%d", pathstr, buf, buflen);
   179fd:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   17a04:	74 3e                	je     17a44 <lwm2m_engine_get+0x65>
   17a06:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17a0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   17a0e:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   17a14:	89 45 d0             	mov    %eax,-0x30(%ebp)
   17a17:	c1 ea 03             	shr    $0x3,%edx
   17a1a:	c7 45 e4 e8 62 02 00 	movl   $0x262e8,-0x1c(%ebp)
   17a21:	c1 e2 06             	shl    $0x6,%edx
   17a24:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   17a27:	83 ca 04             	or     $0x4,%edx
   17a2a:	52                   	push   %edx
   17a2b:	6a 04                	push   $0x4
   17a2d:	57                   	push   %edi
   17a2e:	0f b7 c9             	movzwl %cx,%ecx
   17a31:	68 e3 94 02 00       	push   $0x294e3
   17a36:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   17a39:	e8 4b bb fe ff       	call   3589 <log_n>
   17a3e:	83 c4 10             	add    $0x10,%esp
   17a41:	8b 45 d0             	mov    -0x30(%ebp),%eax
	ret = string_to_path(pathstr, &path, '/');
   17a44:	89 fa                	mov    %edi,%edx
   17a46:	e8 08 f5 ff ff       	call   16f53 <string_to_path.constprop.18>
	if (ret < 0) {
   17a4b:	85 c0                	test   %eax,%eax
   17a4d:	0f 88 8c 01 00 00    	js     17bdf <lwm2m_engine_get+0x200>
	if (path.level < 3) {
   17a53:	80 7d ec 02          	cmpb   $0x2,-0x14(%ebp)
   17a57:	77 32                	ja     17a8b <lwm2m_engine_get+0xac>
		LOG_ERR("path must have 3 parts");
   17a59:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17a60:	0f 84 74 01 00 00    	je     17bda <lwm2m_engine_get+0x1fb>
   17a66:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17a6b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17a70:	c1 e8 03             	shr    $0x3,%eax
   17a73:	c1 e0 06             	shl    $0x6,%eax
   17a76:	83 c8 01             	or     $0x1,%eax
   17a79:	50                   	push   %eax
   17a7a:	68 51 94 02 00       	push   $0x29451
   17a7f:	e8 06 ba fe ff       	call   348a <log_0>
   17a84:	58                   	pop    %eax
   17a85:	5a                   	pop    %edx
   17a86:	e9 4f 01 00 00       	jmp    17bda <lwm2m_engine_get+0x1fb>
	ret = path_to_objs(&path, &obj_inst, &obj_field, &res);
   17a8b:	8d 45 dc             	lea    -0x24(%ebp),%eax
   17a8e:	8d 4d d8             	lea    -0x28(%ebp),%ecx
   17a91:	50                   	push   %eax
   17a92:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   17a95:	89 f8                	mov    %edi,%eax
   17a97:	e8 bf fa ff ff       	call   1755b <path_to_objs>
   17a9c:	5f                   	pop    %edi
	if (ret < 0) {
   17a9d:	85 c0                	test   %eax,%eax
   17a9f:	0f 88 3a 01 00 00    	js     17bdf <lwm2m_engine_get+0x200>
	if (!res) {
   17aa5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17aa8:	85 c0                	test   %eax,%eax
   17aaa:	75 44                	jne    17af0 <lwm2m_engine_get+0x111>
		return -ENOENT;
   17aac:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		LOG_ERR("res instance %d not found", path.res_id);
   17ab1:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17ab8:	0f 84 21 01 00 00    	je     17bdf <lwm2m_engine_get+0x200>
   17abe:	ba cc 51 02 00       	mov    $0x251cc,%edx
   17ac3:	89 45 d0             	mov    %eax,-0x30(%ebp)
   17ac6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   17acc:	c1 ea 03             	shr    $0x3,%edx
   17acf:	c1 e2 06             	shl    $0x6,%edx
   17ad2:	83 ca 01             	or     $0x1,%edx
   17ad5:	52                   	push   %edx
   17ad6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   17ada:	52                   	push   %edx
   17adb:	68 19 94 02 00       	push   $0x29419
   17ae0:	e8 ca b9 fe ff       	call   34af <log_1>
   17ae5:	83 c4 0c             	add    $0xc,%esp
   17ae8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   17aeb:	e9 ef 00 00 00       	jmp    17bdf <lwm2m_engine_get+0x200>
	data_len = res->data_len;
   17af0:	0f b7 48 18          	movzwl 0x18(%eax),%ecx
	data_ptr = res->data_ptr;
   17af4:	8b 50 14             	mov    0x14(%eax),%edx
	if (res->read_cb) {
   17af7:	8b 00                	mov    (%eax),%eax
	data_len = res->data_len;
   17af9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	if (res->read_cb) {
   17afc:	85 c0                	test   %eax,%eax
   17afe:	74 12                	je     17b12 <lwm2m_engine_get+0x133>
		data_ptr = res->read_cb(obj_inst->obj_inst_id, &data_len);
   17b00:	8d 55 e0             	lea    -0x20(%ebp),%edx
   17b03:	52                   	push   %edx
   17b04:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   17b07:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
   17b0b:	52                   	push   %edx
   17b0c:	ff d0                	call   *%eax
   17b0e:	5a                   	pop    %edx
   17b0f:	89 c2                	mov    %eax,%edx
   17b11:	59                   	pop    %ecx
	return 0;
   17b12:	31 c0                	xor    %eax,%eax
	if (data_ptr && data_len > 0) {
   17b14:	85 d2                	test   %edx,%edx
   17b16:	0f 84 c3 00 00 00    	je     17bdf <lwm2m_engine_get+0x200>
   17b1c:	8b 7d e0             	mov    -0x20(%ebp),%edi
   17b1f:	85 ff                	test   %edi,%edi
   17b21:	0f 84 b8 00 00 00    	je     17bdf <lwm2m_engine_get+0x200>
		switch (obj_field->data_type) {
   17b27:	8b 45 d8             	mov    -0x28(%ebp),%eax
   17b2a:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
   17b2e:	8d 41 ff             	lea    -0x1(%ecx),%eax
   17b31:	3c 0d                	cmp    $0xd,%al
   17b33:	77 7a                	ja     17baf <lwm2m_engine_get+0x1d0>
   17b35:	0f b6 c0             	movzbl %al,%eax
   17b38:	ff 24 85 54 61 02 00 	jmp    *0x26154(,%eax,4)
			if (data_len > buflen) {
   17b3f:	0f b7 f6             	movzwl %si,%esi
				return -ENOMEM;
   17b42:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			if (data_len > buflen) {
   17b47:	39 f7                	cmp    %esi,%edi
   17b49:	0f 87 90 00 00 00    	ja     17bdf <lwm2m_engine_get+0x200>
			memcpy(buf, data_ptr, data_len);
   17b4f:	57                   	push   %edi
   17b50:	52                   	push   %edx
   17b51:	53                   	push   %ebx
   17b52:	e8 da 2d ff ff       	call   a931 <memcpy>
   17b57:	eb 0b                	jmp    17b64 <lwm2m_engine_get+0x185>
			strncpy((u8_t *)buf, (u8_t *)data_ptr, buflen);
   17b59:	0f b7 f6             	movzwl %si,%esi
   17b5c:	56                   	push   %esi
   17b5d:	52                   	push   %edx
   17b5e:	53                   	push   %ebx
   17b5f:	e8 89 2c ff ff       	call   a7ed <strncpy>
   17b64:	83 c4 0c             	add    $0xc,%esp
			break;
   17b67:	eb 42                	jmp    17bab <lwm2m_engine_get+0x1cc>
			*(s64_t *)buf = *(s64_t *)data_ptr;
   17b69:	8b 02                	mov    (%edx),%eax
   17b6b:	8b 52 04             	mov    0x4(%edx),%edx
   17b6e:	89 53 04             	mov    %edx,0x4(%ebx)
   17b71:	89 03                	mov    %eax,(%ebx)
   17b73:	eb 36                	jmp    17bab <lwm2m_engine_get+0x1cc>
			*(s32_t *)buf = *(s32_t *)data_ptr;
   17b75:	8b 02                	mov    (%edx),%eax
   17b77:	89 03                	mov    %eax,(%ebx)
			break;
   17b79:	eb 30                	jmp    17bab <lwm2m_engine_get+0x1cc>
			*(s16_t *)buf = *(s16_t *)data_ptr;
   17b7b:	66 8b 02             	mov    (%edx),%ax
   17b7e:	66 89 03             	mov    %ax,(%ebx)
			break;
   17b81:	eb 28                	jmp    17bab <lwm2m_engine_get+0x1cc>
			*(bool *)buf = *(bool *)data_ptr;
   17b83:	8a 02                	mov    (%edx),%al
   17b85:	88 03                	mov    %al,(%ebx)
			break;
   17b87:	eb 22                	jmp    17bab <lwm2m_engine_get+0x1cc>
				((float32_value_t *)data_ptr)->val1;
   17b89:	8b 02                	mov    (%edx),%eax
			((float32_value_t *)buf)->val1 =
   17b8b:	89 03                	mov    %eax,(%ebx)
				((float32_value_t *)data_ptr)->val2;
   17b8d:	8b 42 04             	mov    0x4(%edx),%eax
			((float32_value_t *)buf)->val2 =
   17b90:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
   17b93:	eb 16                	jmp    17bab <lwm2m_engine_get+0x1cc>
				((float64_value_t *)data_ptr)->val1;
   17b95:	8b 7a 04             	mov    0x4(%edx),%edi
   17b98:	8b 32                	mov    (%edx),%esi
			((float64_value_t *)buf)->val1 =
   17b9a:	89 7b 04             	mov    %edi,0x4(%ebx)
   17b9d:	89 33                	mov    %esi,(%ebx)
				((float64_value_t *)data_ptr)->val2;
   17b9f:	8b 42 08             	mov    0x8(%edx),%eax
   17ba2:	8b 52 0c             	mov    0xc(%edx),%edx
			((float64_value_t *)buf)->val2 =
   17ba5:	89 53 0c             	mov    %edx,0xc(%ebx)
   17ba8:	89 43 08             	mov    %eax,0x8(%ebx)
	return 0;
   17bab:	31 c0                	xor    %eax,%eax
			break;
   17bad:	eb 30                	jmp    17bdf <lwm2m_engine_get+0x200>
			LOG_ERR("unknown obj data_type %d",
   17baf:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17bb6:	74 22                	je     17bda <lwm2m_engine_get+0x1fb>
   17bb8:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17bbd:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17bc2:	c1 e8 03             	shr    $0x3,%eax
   17bc5:	c1 e0 06             	shl    $0x6,%eax
   17bc8:	83 c8 01             	or     $0x1,%eax
   17bcb:	50                   	push   %eax
   17bcc:	51                   	push   %ecx
   17bcd:	68 ca 94 02 00       	push   $0x294ca
   17bd2:	e8 d8 b8 fe ff       	call   34af <log_1>
   17bd7:	83 c4 0c             	add    $0xc,%esp
			return -EINVAL;
   17bda:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   17bdf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   17be2:	5b                   	pop    %ebx
   17be3:	5e                   	pop    %esi
   17be4:	5f                   	pop    %edi
   17be5:	5d                   	pop    %ebp
   17be6:	c3                   	ret    

00017be7 <lwm2m_delete_obj_inst>:
{
   17be7:	55                   	push   %ebp
   17be8:	89 e5                	mov    %esp,%ebp
   17bea:	57                   	push   %edi
   17beb:	56                   	push   %esi
		return -ENOENT;
   17bec:	be fe ff ff ff       	mov    $0xfffffffe,%esi
{
   17bf1:	53                   	push   %ebx
   17bf2:	83 ec 08             	sub    $0x8,%esp
	obj = get_engine_obj(obj_id);
   17bf5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   17bf9:	89 45 ec             	mov    %eax,-0x14(%ebp)
   17bfc:	e8 d0 ed ff ff       	call   169d1 <get_engine_obj>
{
   17c01:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!obj) {
   17c04:	85 c0                	test   %eax,%eax
   17c06:	0f 84 d7 00 00 00    	je     17ce3 <lwm2m_delete_obj_inst+0xfc>
   17c0c:	89 c7                	mov    %eax,%edi
	obj_inst = get_engine_obj_inst(obj_id, obj_inst_id);
   17c0e:	0f b7 c3             	movzwl %bx,%eax
   17c11:	89 45 f0             	mov    %eax,-0x10(%ebp)
   17c14:	89 c2                	mov    %eax,%edx
   17c16:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17c19:	e8 cc ed ff ff       	call   169ea <get_engine_obj_inst>
   17c1e:	89 c3                	mov    %eax,%ebx
	if (!obj_inst) {
   17c20:	85 c0                	test   %eax,%eax
   17c22:	0f 84 bb 00 00 00    	je     17ce3 <lwm2m_delete_obj_inst+0xfc>
	if (obj->user_delete_cb) {
   17c28:	8b 47 14             	mov    0x14(%edi),%eax
	int i, ret = 0;
   17c2b:	31 f6                	xor    %esi,%esi
	if (obj->user_delete_cb) {
   17c2d:	85 c0                	test   %eax,%eax
   17c2f:	74 3d                	je     17c6e <lwm2m_delete_obj_inst+0x87>
		ret = obj->user_delete_cb(obj_inst_id);
   17c31:	ff 75 f0             	pushl  -0x10(%ebp)
   17c34:	ff d0                	call   *%eax
   17c36:	59                   	pop    %ecx
   17c37:	89 c6                	mov    %eax,%esi
		if (ret < 0) {
   17c39:	85 c0                	test   %eax,%eax
   17c3b:	79 31                	jns    17c6e <lwm2m_delete_obj_inst+0x87>
			LOG_ERR("Error in user obj delete %u/%u: %d",
   17c3d:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17c44:	74 28                	je     17c6e <lwm2m_delete_obj_inst+0x87>
   17c46:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17c4b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17c50:	c1 e8 03             	shr    $0x3,%eax
   17c53:	c1 e0 06             	shl    $0x6,%eax
   17c56:	83 c8 01             	or     $0x1,%eax
   17c59:	50                   	push   %eax
   17c5a:	56                   	push   %esi
   17c5b:	ff 75 f0             	pushl  -0x10(%ebp)
   17c5e:	ff 75 ec             	pushl  -0x14(%ebp)
   17c61:	68 02 95 02 00       	push   $0x29502
   17c66:	e8 c5 b8 fe ff       	call   3530 <log_3>
   17c6b:	83 c4 14             	add    $0x14,%esp
			obj_inst->obj->obj_id, obj_inst->obj_inst_id);
   17c6e:	8b 43 04             	mov    0x4(%ebx),%eax
	engine_remove_observer_by_id(
   17c71:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
   17c75:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   17c79:	e8 95 ee ff ff       	call   16b13 <engine_remove_observer_by_id>
	sys_slist_find_and_remove(&engine_obj_inst_list, &obj_inst->node);
   17c7e:	89 da                	mov    %ebx,%edx
   17c80:	b8 a8 43 40 00       	mov    $0x4043a8,%eax
   17c85:	e8 14 ed ff ff       	call   1699e <sys_slist_find_and_remove>
	if (obj->delete_cb) {
   17c8a:	8b 47 0c             	mov    0xc(%edi),%eax
	obj->instance_count--;
   17c8d:	66 ff 4f 1c          	decw   0x1c(%edi)
	if (obj->delete_cb) {
   17c91:	85 c0                	test   %eax,%eax
   17c93:	74 08                	je     17c9d <lwm2m_delete_obj_inst+0xb6>
		ret = obj->delete_cb(obj_inst_id);
   17c95:	ff 75 f0             	pushl  -0x10(%ebp)
   17c98:	ff d0                	call   *%eax
   17c9a:	5a                   	pop    %edx
   17c9b:	89 c6                	mov    %eax,%esi
	for (i = 0; i < obj_inst->resource_count; i++) {
   17c9d:	31 ff                	xor    %edi,%edi
   17c9f:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
   17ca3:	39 c7                	cmp    %eax,%edi
   17ca5:	7d 28                	jge    17ccf <lwm2m_delete_obj_inst+0xe8>
		clear_attrs(&obj_inst->resources[i]);
   17ca7:	89 fa                	mov    %edi,%edx
	for (i = 0; i < obj_inst->resource_count; i++) {
   17ca9:	47                   	inc    %edi
   17caa:	c1 e2 05             	shl    $0x5,%edx
		clear_attrs(&obj_inst->resources[i]);
   17cad:	89 d0                	mov    %edx,%eax
   17caf:	89 55 f0             	mov    %edx,-0x10(%ebp)
   17cb2:	03 43 08             	add    0x8(%ebx),%eax
   17cb5:	e8 bc ee ff ff       	call   16b76 <clear_attrs>
		(void)memset(obj_inst->resources + i, 0,
   17cba:	8b 55 f0             	mov    -0x10(%ebp),%edx
   17cbd:	6a 20                	push   $0x20
   17cbf:	03 53 08             	add    0x8(%ebx),%edx
   17cc2:	6a 00                	push   $0x0
   17cc4:	52                   	push   %edx
   17cc5:	e8 d6 2c ff ff       	call   a9a0 <memset>
   17cca:	83 c4 0c             	add    $0xc,%esp
   17ccd:	eb d0                	jmp    17c9f <lwm2m_delete_obj_inst+0xb8>
	clear_attrs(obj_inst);
   17ccf:	89 d8                	mov    %ebx,%eax
   17cd1:	e8 a0 ee ff ff       	call   16b76 <clear_attrs>
	(void)memset(obj_inst, 0, sizeof(struct lwm2m_engine_obj_inst));
   17cd6:	6a 10                	push   $0x10
   17cd8:	6a 00                	push   $0x0
   17cda:	53                   	push   %ebx
   17cdb:	e8 c0 2c ff ff       	call   a9a0 <memset>
   17ce0:	83 c4 0c             	add    $0xc,%esp
}
   17ce3:	8d 65 f4             	lea    -0xc(%ebp),%esp
   17ce6:	89 f0                	mov    %esi,%eax
   17ce8:	5b                   	pop    %ebx
   17ce9:	5e                   	pop    %esi
   17cea:	5f                   	pop    %edi
   17ceb:	5d                   	pop    %ebp
   17cec:	c3                   	ret    

00017ced <lwm2m_create_obj_inst>:
{
   17ced:	55                   	push   %ebp
   17cee:	89 e5                	mov    %esp,%ebp
   17cf0:	57                   	push   %edi
   17cf1:	56                   	push   %esi
   17cf2:	53                   	push   %ebx
   17cf3:	51                   	push   %ecx
   17cf4:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*obj_inst = NULL;
   17cfa:	8b 45 10             	mov    0x10(%ebp),%eax
	obj = get_engine_obj(obj_id);
   17cfd:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
	*obj_inst = NULL;
   17d01:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	obj = get_engine_obj(obj_id);
   17d07:	89 d8                	mov    %ebx,%eax
   17d09:	e8 c3 ec ff ff       	call   169d1 <get_engine_obj>
	if (!obj) {
   17d0e:	85 c0                	test   %eax,%eax
   17d10:	75 2e                	jne    17d40 <lwm2m_create_obj_inst+0x53>
		return -ENOENT;
   17d12:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
		LOG_ERR("unable to find obj: %u", obj_id);
   17d17:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17d1e:	0f 84 46 01 00 00    	je     17e6a <lwm2m_create_obj_inst+0x17d>
   17d24:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17d29:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17d2e:	c1 e8 03             	shr    $0x3,%eax
   17d31:	c1 e0 06             	shl    $0x6,%eax
   17d34:	83 c8 01             	or     $0x1,%eax
   17d37:	50                   	push   %eax
   17d38:	53                   	push   %ebx
   17d39:	68 25 95 02 00       	push   $0x29525
   17d3e:	eb 35                	jmp    17d75 <lwm2m_create_obj_inst+0x88>
	if (!obj->create_cb) {
   17d40:	8b 50 08             	mov    0x8(%eax),%edx
   17d43:	89 c7                	mov    %eax,%edi
   17d45:	85 d2                	test   %edx,%edx
   17d47:	75 39                	jne    17d82 <lwm2m_create_obj_inst+0x95>
		return -EINVAL;
   17d49:	bf ea ff ff ff       	mov    $0xffffffea,%edi
		LOG_ERR("obj %u has no create_cb", obj_id);
   17d4e:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17d55:	0f 84 0f 01 00 00    	je     17e6a <lwm2m_create_obj_inst+0x17d>
   17d5b:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17d60:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17d65:	c1 e8 03             	shr    $0x3,%eax
   17d68:	c1 e0 06             	shl    $0x6,%eax
   17d6b:	83 c8 01             	or     $0x1,%eax
   17d6e:	50                   	push   %eax
   17d6f:	53                   	push   %ebx
   17d70:	68 3c 95 02 00       	push   $0x2953c
   17d75:	e8 35 b7 fe ff       	call   34af <log_1>
   17d7a:	83 c4 0c             	add    $0xc,%esp
   17d7d:	e9 e8 00 00 00       	jmp    17e6a <lwm2m_create_obj_inst+0x17d>
	if (obj->instance_count + 1 > obj->max_instance_count) {
   17d82:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   17d86:	0f b7 77 1e          	movzwl 0x1e(%edi),%esi
   17d8a:	40                   	inc    %eax
   17d8b:	39 f0                	cmp    %esi,%eax
   17d8d:	7e 2e                	jle    17dbd <lwm2m_create_obj_inst+0xd0>
		return -ENOMEM;
   17d8f:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("no more instances available for obj %u", obj_id);
   17d94:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17d9b:	0f 84 c9 00 00 00    	je     17e6a <lwm2m_create_obj_inst+0x17d>
   17da1:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17da6:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17dab:	c1 e8 03             	shr    $0x3,%eax
   17dae:	c1 e0 06             	shl    $0x6,%eax
   17db1:	83 c8 01             	or     $0x1,%eax
   17db4:	50                   	push   %eax
   17db5:	53                   	push   %ebx
   17db6:	68 54 95 02 00       	push   $0x29554
   17dbb:	eb b8                	jmp    17d75 <lwm2m_create_obj_inst+0x88>
	*obj_inst = obj->create_cb(obj_inst_id);
   17dbd:	0f b7 75 f0          	movzwl -0x10(%ebp),%esi
   17dc1:	56                   	push   %esi
   17dc2:	ff d2                	call   *%edx
   17dc4:	8b 4d 10             	mov    0x10(%ebp),%ecx
   17dc7:	5a                   	pop    %edx
	if (!*obj_inst) {
   17dc8:	85 c0                	test   %eax,%eax
	*obj_inst = obj->create_cb(obj_inst_id);
   17dca:	89 01                	mov    %eax,(%ecx)
	if (!*obj_inst) {
   17dcc:	75 37                	jne    17e05 <lwm2m_create_obj_inst+0x118>
		return -EEXIST;
   17dce:	bf ef ff ff ff       	mov    $0xffffffef,%edi
		LOG_ERR("unable to create obj %u instance %u",
   17dd3:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17dda:	0f 84 8a 00 00 00    	je     17e6a <lwm2m_create_obj_inst+0x17d>
   17de0:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17de5:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17dea:	c1 e8 03             	shr    $0x3,%eax
   17ded:	c1 e0 06             	shl    $0x6,%eax
   17df0:	83 c8 01             	or     $0x1,%eax
   17df3:	50                   	push   %eax
   17df4:	56                   	push   %esi
   17df5:	53                   	push   %ebx
   17df6:	68 7b 95 02 00       	push   $0x2957b
   17dfb:	e8 e9 b6 fe ff       	call   34e9 <log_2>
   17e00:	83 c4 10             	add    $0x10,%esp
   17e03:	eb 65                	jmp    17e6a <lwm2m_create_obj_inst+0x17d>
	obj->instance_count++;
   17e05:	66 ff 47 1c          	incw   0x1c(%edi)
	(*obj_inst)->obj_inst_id = obj_inst_id;
   17e09:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	(*obj_inst)->obj = obj;
   17e0c:	89 78 04             	mov    %edi,0x4(%eax)
	(*obj_inst)->obj_inst_id = obj_inst_id;
   17e0f:	66 89 48 0c          	mov    %cx,0xc(%eax)
	sys_slist_append(&engine_obj_inst_list, &obj_inst->node);
   17e13:	89 c2                	mov    %eax,%edx
   17e15:	b8 a8 43 40 00       	mov    $0x4043a8,%eax
   17e1a:	e8 3d eb ff ff       	call   1695c <sys_slist_append>
	if (obj->user_create_cb) {
   17e1f:	8b 47 10             	mov    0x10(%edi),%eax
   17e22:	85 c0                	test   %eax,%eax
   17e24:	75 04                	jne    17e2a <lwm2m_create_obj_inst+0x13d>
	return 0;
   17e26:	31 ff                	xor    %edi,%edi
   17e28:	eb 40                	jmp    17e6a <lwm2m_create_obj_inst+0x17d>
		ret = obj->user_create_cb(obj_inst_id);
   17e2a:	56                   	push   %esi
   17e2b:	ff d0                	call   *%eax
   17e2d:	59                   	pop    %ecx
   17e2e:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
   17e30:	85 c0                	test   %eax,%eax
   17e32:	79 f2                	jns    17e26 <lwm2m_create_obj_inst+0x139>
			LOG_ERR("Error in user obj create %u/%u: %d",
   17e34:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17e3b:	74 24                	je     17e61 <lwm2m_create_obj_inst+0x174>
   17e3d:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17e42:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17e47:	c1 e8 03             	shr    $0x3,%eax
   17e4a:	c1 e0 06             	shl    $0x6,%eax
   17e4d:	83 c8 01             	or     $0x1,%eax
   17e50:	50                   	push   %eax
   17e51:	57                   	push   %edi
   17e52:	56                   	push   %esi
   17e53:	53                   	push   %ebx
   17e54:	68 9f 95 02 00       	push   $0x2959f
   17e59:	e8 d2 b6 fe ff       	call   3530 <log_3>
   17e5e:	83 c4 14             	add    $0x14,%esp
			lwm2m_delete_obj_inst(obj_id, obj_inst_id);
   17e61:	56                   	push   %esi
   17e62:	53                   	push   %ebx
   17e63:	e8 7f fd ff ff       	call   17be7 <lwm2m_delete_obj_inst>
   17e68:	58                   	pop    %eax
   17e69:	5a                   	pop    %edx
}
   17e6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   17e6d:	89 f8                	mov    %edi,%eax
   17e6f:	5b                   	pop    %ebx
   17e70:	5e                   	pop    %esi
   17e71:	5f                   	pop    %edi
   17e72:	5d                   	pop    %ebp
   17e73:	c3                   	ret    

00017e74 <lwm2m_get_message>:
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
   17e74:	31 c0                	xor    %eax,%eax
		if (!messages[i].ctx) {
   17e76:	69 d0 88 01 00 00    	imul   $0x188,%eax,%edx
   17e7c:	83 ba 80 18 40 00 00 	cmpl   $0x0,0x401880(%edx)
   17e83:	75 14                	jne    17e99 <lwm2m_get_message+0x25>
{
   17e85:	55                   	push   %ebp
   17e86:	89 e5                	mov    %esp,%ebp
			messages[i].ctx = client_ctx;
   17e88:	8b 45 08             	mov    0x8(%ebp),%eax
}
   17e8b:	5d                   	pop    %ebp
			messages[i].ctx = client_ctx;
   17e8c:	89 82 80 18 40 00    	mov    %eax,0x401880(%edx)
			return &messages[i];
   17e92:	8d 82 80 18 40 00    	lea    0x401880(%edx),%eax
}
   17e98:	c3                   	ret    
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
   17e99:	40                   	inc    %eax
   17e9a:	83 f8 0a             	cmp    $0xa,%eax
   17e9d:	75 d7                	jne    17e76 <lwm2m_get_message+0x2>
	return NULL;
   17e9f:	31 c0                	xor    %eax,%eax
}
   17ea1:	c3                   	ret    

00017ea2 <lwm2m_reset_message>:
{
   17ea2:	55                   	push   %ebp
   17ea3:	89 e5                	mov    %esp,%ebp
   17ea5:	56                   	push   %esi
   17ea6:	53                   	push   %ebx
   17ea7:	8b 5d 08             	mov    0x8(%ebp),%ebx
   17eaa:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!msg) {
   17ead:	85 db                	test   %ebx,%ebx
   17eaf:	74 4b                	je     17efc <lwm2m_reset_message+0x5a>
	if (msg->pending) {
   17eb1:	8b 83 6c 01 00 00    	mov    0x16c(%ebx),%eax
   17eb7:	85 c0                	test   %eax,%eax
   17eb9:	74 07                	je     17ec2 <lwm2m_reset_message+0x20>
		coap_pending_clear(msg->pending);
   17ebb:	50                   	push   %eax
   17ebc:	e8 1d 0a ff ff       	call   88de <coap_pending_clear>
   17ec1:	5a                   	pop    %edx
	if (msg->reply) {
   17ec2:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
   17ec8:	85 c0                	test   %eax,%eax
   17eca:	74 07                	je     17ed3 <lwm2m_reset_message+0x31>
		coap_reply_clear(msg->reply);
   17ecc:	50                   	push   %eax
   17ecd:	e8 27 0b ff ff       	call   89f9 <coap_reply_clear>
   17ed2:	58                   	pop    %eax
	if (release) {
   17ed3:	89 f0                	mov    %esi,%eax
   17ed5:	84 c0                	test   %al,%al
   17ed7:	74 09                	je     17ee2 <lwm2m_reset_message+0x40>
		(void)memset(msg, 0, sizeof(*msg));
   17ed9:	68 88 01 00 00       	push   $0x188
   17ede:	6a 00                	push   $0x0
   17ee0:	eb 11                	jmp    17ef3 <lwm2m_reset_message+0x51>
		msg->message_timeout_cb = NULL;
   17ee2:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
   17ee9:	00 00 00 
		(void)memset(&msg->cpkt, 0, sizeof(msg->cpkt));
   17eec:	6a 10                	push   $0x10
   17eee:	6a 00                	push   $0x0
   17ef0:	83 c3 2c             	add    $0x2c,%ebx
   17ef3:	53                   	push   %ebx
   17ef4:	e8 a7 2a ff ff       	call   a9a0 <memset>
   17ef9:	83 c4 0c             	add    $0xc,%esp
}
   17efc:	8d 65 f8             	lea    -0x8(%ebp),%esp
   17eff:	5b                   	pop    %ebx
   17f00:	5e                   	pop    %esi
   17f01:	5d                   	pop    %ebp
   17f02:	c3                   	ret    

00017f03 <retransmit_request>:
{
   17f03:	55                   	push   %ebp
   17f04:	89 e5                	mov    %esp,%ebp
   17f06:	57                   	push   %edi
   17f07:	56                   	push   %esi
   17f08:	8b 7d 08             	mov    0x8(%ebp),%edi
   17f0b:	53                   	push   %ebx
	pending = coap_pending_next_to_expire(client_ctx->pendings,
   17f0c:	6a 05                	push   $0x5
   17f0e:	8d 87 c0 fe ff ff    	lea    -0x140(%edi),%eax
   17f14:	50                   	push   %eax
   17f15:	e8 4a 09 ff ff       	call   8864 <coap_pending_next_to_expire>
   17f1a:	59                   	pop    %ecx
	if (!pending) {
   17f1b:	85 c0                	test   %eax,%eax
	pending = coap_pending_next_to_expire(client_ctx->pendings,
   17f1d:	5b                   	pop    %ebx
	if (!pending) {
   17f1e:	0f 84 01 01 00 00    	je     18025 <retransmit_request+0x122>
	msg = find_msg(pending, NULL);
   17f24:	31 d2                	xor    %edx,%edx
   17f26:	89 c6                	mov    %eax,%esi
   17f28:	e8 1a ed ff ff       	call   16c47 <find_msg>
   17f2d:	89 c3                	mov    %eax,%ebx
	if (!msg) {
   17f2f:	85 c0                	test   %eax,%eax
   17f31:	75 2d                	jne    17f60 <retransmit_request+0x5d>
		LOG_ERR("pending has no valid LwM2M message!");
   17f33:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17f3a:	0f 84 e5 00 00 00    	je     18025 <retransmit_request+0x122>
   17f40:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17f45:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17f4a:	c1 e8 03             	shr    $0x3,%eax
   17f4d:	c1 e0 06             	shl    $0x6,%eax
   17f50:	83 c8 01             	or     $0x1,%eax
   17f53:	50                   	push   %eax
   17f54:	68 c2 95 02 00       	push   $0x295c2
   17f59:	e8 2c b5 fe ff       	call   348a <log_0>
   17f5e:	eb 21                	jmp    17f81 <retransmit_request+0x7e>
	if (!coap_pending_cycle(pending)) {
   17f60:	56                   	push   %esi
   17f61:	e8 29 09 ff ff       	call   888f <coap_pending_cycle>
   17f66:	5a                   	pop    %edx
   17f67:	84 c0                	test   %al,%al
   17f69:	75 1d                	jne    17f88 <retransmit_request+0x85>
		if (msg->message_timeout_cb) {
   17f6b:	8b 83 7c 01 00 00    	mov    0x17c(%ebx),%eax
   17f71:	85 c0                	test   %eax,%eax
   17f73:	74 04                	je     17f79 <retransmit_request+0x76>
			msg->message_timeout_cb(msg);
   17f75:	53                   	push   %ebx
   17f76:	ff d0                	call   *%eax
   17f78:	59                   	pop    %ecx
		lwm2m_reset_message(msg, true);
   17f79:	6a 01                	push   $0x1
   17f7b:	53                   	push   %ebx
   17f7c:	e8 21 ff ff ff       	call   17ea2 <lwm2m_reset_message>
   17f81:	58                   	pop    %eax
   17f82:	5a                   	pop    %edx
		return;
   17f83:	e9 9d 00 00 00       	jmp    18025 <retransmit_request+0x122>
	LOG_INF("Resending message: %p", msg);
   17f88:	a1 a4 a8 40 00       	mov    0x40a8a4,%eax
   17f8d:	83 e0 07             	and    $0x7,%eax
   17f90:	83 f8 02             	cmp    $0x2,%eax
   17f93:	76 22                	jbe    17fb7 <retransmit_request+0xb4>
   17f95:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   17f9a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   17f9f:	c1 e8 03             	shr    $0x3,%eax
   17fa2:	c1 e0 06             	shl    $0x6,%eax
   17fa5:	83 c8 03             	or     $0x3,%eax
   17fa8:	50                   	push   %eax
   17fa9:	53                   	push   %ebx
   17faa:	68 e6 95 02 00       	push   $0x295e6
   17faf:	e8 fb b4 fe ff       	call   34af <log_1>
   17fb4:	83 c4 0c             	add    $0xc,%esp
	msg->send_attempts++;
   17fb7:	fe 83 86 01 00 00    	incb   0x186(%ebx)

K_SYSCALL_DECLARE2(K_SYSCALL_ZSOCK_LISTEN, zsock_listen, int, int, sock, int, backlog)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_ACCEPT, zsock_accept, int, int, sock, struct sockaddr *, addr, socklen_t *, addrlen)

K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_SENDTO, zsock_sendto, ssize_t, int, sock, const void *, buf, size_t, len, int, flags, const struct sockaddr *, dest_addr, socklen_t, addrlen)
   17fbd:	6a 00                	push   $0x0
   17fbf:	6a 00                	push   $0x0
   17fc1:	6a 00                	push   $0x0
	if (send(msg->ctx->sock_fd, msg->cpkt.data, msg->cpkt.offset, 0) < 0) {
   17fc3:	0f b7 43 30          	movzwl 0x30(%ebx),%eax
   17fc7:	50                   	push   %eax
   17fc8:	ff 73 2c             	pushl  0x2c(%ebx)
   17fcb:	8b 03                	mov    (%ebx),%eax
   17fcd:	ff b0 84 01 00 00    	pushl  0x184(%eax)
   17fd3:	e8 28 10 ff ff       	call   9000 <z_impl_zsock_sendto>
   17fd8:	83 c4 18             	add    $0x18,%esp
   17fdb:	85 c0                	test   %eax,%eax
   17fdd:	79 35                	jns    18014 <retransmit_request+0x111>
		LOG_ERR("Error sending lwm2m message: %d", -errno);
   17fdf:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   17fe6:	74 2c                	je     18014 <retransmit_request+0x111>
   17fe8:	e8 fb ac 00 00       	call   22ce8 <z_impl_z_errno>
   17fed:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   17ff2:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   17ff8:	c1 eb 03             	shr    $0x3,%ebx
   17ffb:	c1 e3 06             	shl    $0x6,%ebx
   17ffe:	83 cb 01             	or     $0x1,%ebx
   18001:	53                   	push   %ebx
   18002:	8b 00                	mov    (%eax),%eax
   18004:	f7 d8                	neg    %eax
   18006:	50                   	push   %eax
   18007:	68 fc 95 02 00       	push   $0x295fc
   1800c:	e8 9e b4 fe ff       	call   34af <log_1>
   18011:	83 c4 0c             	add    $0xc,%esp
   18014:	ff 76 18             	pushl  0x18(%esi)
   18017:	57                   	push   %edi
   18018:	68 60 41 40 00       	push   $0x404160
   1801d:	e8 b3 c4 00 00       	call   244d5 <k_delayed_work_submit_to_queue>
   18022:	83 c4 0c             	add    $0xc,%esp
}
   18025:	8d 65 f4             	lea    -0xc(%ebp),%esp
   18028:	5b                   	pop    %ebx
   18029:	5e                   	pop    %esi
   1802a:	5f                   	pop    %edi
   1802b:	5d                   	pop    %ebp
   1802c:	c3                   	ret    

0001802d <lwm2m_init_message>:
{
   1802d:	55                   	push   %ebp
   1802e:	89 e5                	mov    %esp,%ebp
   18030:	57                   	push   %edi
   18031:	56                   	push   %esi
   18032:	53                   	push   %ebx
   18033:	53                   	push   %ebx
   18034:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!msg || !msg->ctx) {
   18037:	85 db                	test   %ebx,%ebx
   18039:	74 05                	je     18040 <lwm2m_init_message+0x13>
   1803b:	83 3b 00             	cmpl   $0x0,(%ebx)
   1803e:	75 35                	jne    18075 <lwm2m_init_message+0x48>
		return -EINVAL;
   18040:	be ea ff ff ff       	mov    $0xffffffea,%esi
		LOG_ERR("LwM2M message is invalid.");
   18045:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1804c:	0f 84 e4 01 00 00    	je     18236 <lwm2m_init_message+0x209>
   18052:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18057:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1805c:	c1 e8 03             	shr    $0x3,%eax
   1805f:	c1 e0 06             	shl    $0x6,%eax
   18062:	83 c8 01             	or     $0x1,%eax
   18065:	50                   	push   %eax
   18066:	68 1c 96 02 00       	push   $0x2961c
   1806b:	e8 1a b4 fe ff       	call   348a <log_0>
   18070:	e9 bf 01 00 00       	jmp    18234 <lwm2m_init_message+0x207>
	if (msg->tkl == 0) {
   18075:	0f b6 8b 84 01 00 00 	movzbl 0x184(%ebx),%ecx
   1807c:	84 c9                	test   %cl,%cl
   1807e:	75 0e                	jne    1808e <lwm2m_init_message+0x61>
   18080:	88 4d f3             	mov    %cl,-0xd(%ebp)
		token = coap_next_token();
   18083:	e8 f6 01 ff ff       	call   827e <coap_next_token>
   18088:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
   1808c:	eb 13                	jmp    180a1 <lwm2m_init_message+0x74>
	} else if (msg->token && msg->tkl != LWM2M_MSG_TOKEN_LEN_SKIP) {
   1808e:	8b 83 74 01 00 00    	mov    0x174(%ebx),%eax
   18094:	85 c0                	test   %eax,%eax
   18096:	74 05                	je     1809d <lwm2m_init_message+0x70>
   18098:	80 f9 ff             	cmp    $0xff,%cl
   1809b:	75 04                	jne    180a1 <lwm2m_init_message+0x74>
	u8_t *token = NULL;
   1809d:	31 c0                	xor    %eax,%eax
	u8_t tokenlen = 0U;
   1809f:	31 c9                	xor    %ecx,%ecx
			     (msg->mid > 0 ? msg->mid : coap_next_id()));
   180a1:	0f b7 93 80 01 00 00 	movzwl 0x180(%ebx),%edx
	r = coap_packet_init(&msg->cpkt, msg->msg_data, sizeof(msg->msg_data),
   180a8:	66 85 d2             	test   %dx,%dx
   180ab:	75 14                	jne    180c1 <lwm2m_init_message+0x94>
	return ++message_id;
   180ad:	66 8b 3d 50 45 40 00 	mov    0x404550,%di
   180b4:	8d 57 01             	lea    0x1(%edi),%edx
   180b7:	66 89 15 50 45 40 00 	mov    %dx,0x404550
   180be:	0f b7 d2             	movzwl %dx,%edx
   180c1:	52                   	push   %edx
   180c2:	8d 7b 2c             	lea    0x2c(%ebx),%edi
   180c5:	0f b6 93 83 01 00 00 	movzbl 0x183(%ebx),%edx
   180cc:	52                   	push   %edx
   180cd:	50                   	push   %eax
   180ce:	51                   	push   %ecx
   180cf:	0f b6 83 82 01 00 00 	movzbl 0x182(%ebx),%eax
   180d6:	50                   	push   %eax
   180d7:	8d 43 3c             	lea    0x3c(%ebx),%eax
   180da:	6a 01                	push   $0x1
   180dc:	68 30 01 00 00       	push   $0x130
   180e1:	50                   	push   %eax
   180e2:	57                   	push   %edi
   180e3:	e8 3b fe fe ff       	call   7f23 <coap_packet_init>
   180e8:	83 c4 24             	add    $0x24,%esp
   180eb:	89 c6                	mov    %eax,%esi
	if (r < 0) {
   180ed:	85 c0                	test   %eax,%eax
   180ef:	79 2c                	jns    1811d <lwm2m_init_message+0xf0>
		LOG_ERR("coap packet init error (err:%d)", r);
   180f1:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   180f8:	0f 84 2e 01 00 00    	je     1822c <lwm2m_init_message+0x1ff>
   180fe:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18103:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18108:	c1 e8 03             	shr    $0x3,%eax
   1810b:	c1 e0 06             	shl    $0x6,%eax
   1810e:	83 c8 01             	or     $0x1,%eax
   18111:	50                   	push   %eax
   18112:	56                   	push   %esi
   18113:	68 36 96 02 00       	push   $0x29636
   18118:	e9 92 00 00 00       	jmp    181af <lwm2m_init_message+0x182>
	if (msg->type != COAP_TYPE_CON) {
   1811d:	80 bb 82 01 00 00 00 	cmpb   $0x0,0x182(%ebx)
   18124:	0f 85 fe 00 00 00    	jne    18228 <lwm2m_init_message+0x1fb>
				msg->ctx->pendings,
   1812a:	8b 03                	mov    (%ebx),%eax
	msg->pending = coap_pending_next_unused(
   1812c:	6a 05                	push   $0x5
				msg->ctx->pendings,
   1812e:	83 c0 18             	add    $0x18,%eax
	msg->pending = coap_pending_next_unused(
   18131:	50                   	push   %eax
   18132:	e8 c6 06 ff ff       	call   87fd <coap_pending_next_unused>
   18137:	5a                   	pop    %edx
	if (!msg->pending) {
   18138:	85 c0                	test   %eax,%eax
	msg->pending = coap_pending_next_unused(
   1813a:	59                   	pop    %ecx
   1813b:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	if (!msg->pending) {
   18141:	75 33                	jne    18176 <lwm2m_init_message+0x149>
		LOG_ERR("Unable to find a free pending to track "
   18143:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1814a:	74 20                	je     1816c <lwm2m_init_message+0x13f>
   1814c:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18151:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18156:	c1 e8 03             	shr    $0x3,%eax
   18159:	c1 e0 06             	shl    $0x6,%eax
   1815c:	83 c8 01             	or     $0x1,%eax
   1815f:	50                   	push   %eax
   18160:	68 56 96 02 00       	push   $0x29656
   18165:	e8 20 b3 fe ff       	call   348a <log_0>
   1816a:	5e                   	pop    %esi
   1816b:	5f                   	pop    %edi
		r = -ENOMEM;
   1816c:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
   18171:	e9 b6 00 00 00       	jmp    1822c <lwm2m_init_message+0x1ff>
	r = coap_pending_init(msg->pending, &msg->cpkt, &msg->ctx->remote_addr);
   18176:	ff 33                	pushl  (%ebx)
   18178:	57                   	push   %edi
   18179:	50                   	push   %eax
   1817a:	e8 34 06 ff ff       	call   87b3 <coap_pending_init>
   1817f:	83 c4 0c             	add    $0xc,%esp
   18182:	89 c6                	mov    %eax,%esi
	if (r < 0) {
   18184:	85 c0                	test   %eax,%eax
   18186:	79 31                	jns    181b9 <lwm2m_init_message+0x18c>
		LOG_ERR("Unable to initialize a pending "
   18188:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1818f:	0f 84 97 00 00 00    	je     1822c <lwm2m_init_message+0x1ff>
   18195:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1819a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1819f:	c1 e8 03             	shr    $0x3,%eax
   181a2:	c1 e0 06             	shl    $0x6,%eax
   181a5:	83 c8 01             	or     $0x1,%eax
   181a8:	50                   	push   %eax
   181a9:	56                   	push   %esi
   181aa:	68 8e 96 02 00       	push   $0x2968e
   181af:	e8 fb b2 fe ff       	call   34af <log_1>
   181b4:	83 c4 0c             	add    $0xc,%esp
   181b7:	eb 73                	jmp    1822c <lwm2m_init_message+0x1ff>
	if (msg->reply_cb) {
   181b9:	83 bb 78 01 00 00 00 	cmpl   $0x0,0x178(%ebx)
   181c0:	74 66                	je     18228 <lwm2m_init_message+0x1fb>
				msg->ctx->replies,
   181c2:	8b 03                	mov    (%ebx),%eax
		msg->reply = coap_reply_next_unused(
   181c4:	6a 05                	push   $0x5
				msg->ctx->replies,
   181c6:	05 e0 00 00 00       	add    $0xe0,%eax
		msg->reply = coap_reply_next_unused(
   181cb:	50                   	push   %eax
   181cc:	e8 49 06 ff ff       	call   881a <coap_reply_next_unused>
   181d1:	5a                   	pop    %edx
		if (!msg->reply) {
   181d2:	85 c0                	test   %eax,%eax
		msg->reply = coap_reply_next_unused(
   181d4:	59                   	pop    %ecx
   181d5:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
		if (!msg->reply) {
   181db:	75 27                	jne    18204 <lwm2m_init_message+0x1d7>
			LOG_ERR("No resources for waiting for replies.");
   181dd:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   181e4:	74 86                	je     1816c <lwm2m_init_message+0x13f>
   181e6:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   181eb:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   181f0:	c1 e8 03             	shr    $0x3,%eax
   181f3:	c1 e0 06             	shl    $0x6,%eax
   181f6:	83 c8 01             	or     $0x1,%eax
   181f9:	50                   	push   %eax
   181fa:	68 c6 96 02 00       	push   $0x296c6
   181ff:	e9 61 ff ff ff       	jmp    18165 <lwm2m_init_message+0x138>
		coap_reply_clear(msg->reply);
   18204:	50                   	push   %eax
   18205:	e8 ef 07 ff ff       	call   89f9 <coap_reply_clear>
		coap_reply_init(msg->reply, &msg->cpkt);
   1820a:	89 3c 24             	mov    %edi,(%esp)
   1820d:	ff b3 70 01 00 00    	pushl  0x170(%ebx)
   18213:	e8 80 07 ff ff       	call   8998 <coap_reply_init>
		msg->reply->reply = msg->reply_cb;
   18218:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
		coap_reply_init(msg->reply, &msg->cpkt);
   1821e:	59                   	pop    %ecx
		msg->reply->reply = msg->reply_cb;
   1821f:	8b 93 78 01 00 00    	mov    0x178(%ebx),%edx
		coap_reply_init(msg->reply, &msg->cpkt);
   18225:	5e                   	pop    %esi
		msg->reply->reply = msg->reply_cb;
   18226:	89 10                	mov    %edx,(%eax)
	return 0;
   18228:	31 f6                	xor    %esi,%esi
   1822a:	eb 0a                	jmp    18236 <lwm2m_init_message+0x209>
	lwm2m_reset_message(msg, true);
   1822c:	6a 01                	push   $0x1
   1822e:	53                   	push   %ebx
   1822f:	e8 6e fc ff ff       	call   17ea2 <lwm2m_reset_message>
   18234:	58                   	pop    %eax
   18235:	5a                   	pop    %edx
}
   18236:	8d 65 f4             	lea    -0xc(%ebp),%esp
   18239:	89 f0                	mov    %esi,%eax
   1823b:	5b                   	pop    %ebx
   1823c:	5e                   	pop    %esi
   1823d:	5f                   	pop    %edi
   1823e:	5d                   	pop    %ebp
   1823f:	c3                   	ret    

00018240 <handle_request>:
{
   18240:	55                   	push   %ebp
   18241:	89 e5                	mov    %esp,%ebp
   18243:	57                   	push   %edi
   18244:	56                   	push   %esi
   18245:	53                   	push   %ebx
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
   18246:	8d 9d f3 fe ff ff    	lea    -0x10d(%ebp),%ebx
{
   1824c:	81 ec 48 01 00 00    	sub    $0x148,%esp
	struct block_context *block_ctx = NULL;
   18252:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
   18259:	00 00 00 
{
   1825c:	8b 75 0c             	mov    0xc(%ebp),%esi
   1825f:	8b 45 08             	mov    0x8(%ebp),%eax
	u16_t payload_len = 0U;
   18262:	66 c7 85 da fe ff ff 	movw   $0x0,-0x126(%ebp)
   18269:	00 00 
	msg->out.out_cpkt = &msg->cpkt;
   1826b:	8d 56 2c             	lea    0x2c(%esi),%edx
	msg->in.in_cpkt = request;
   1826e:	89 46 08             	mov    %eax,0x8(%esi)
	msg->out.out_cpkt = &msg->cpkt;
   18271:	89 56 18             	mov    %edx,0x18(%esi)
	msg->in.reader = &plain_text_reader;
   18274:	c7 46 04 d4 63 02 00 	movl   $0x263d4,0x4(%esi)
	msg->out.writer = &plain_text_writer;
   1827b:	c7 46 14 40 5a 02 00 	movl   $0x25a40,0x14(%esi)
	code = coap_header_get_code(msg->in.in_cpkt);
   18282:	50                   	push   %eax
   18283:	e8 50 02 ff ff       	call   84d8 <coap_header_get_code>
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
   18288:	89 1c 24             	mov    %ebx,(%esp)
   1828b:	ff 76 08             	pushl  0x8(%esi)
	code = coap_header_get_code(msg->in.in_cpkt);
   1828e:	88 85 bc fe ff ff    	mov    %al,-0x144(%ebp)
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
   18294:	e8 0b 02 ff ff       	call   84a4 <coap_header_get_token>
   18299:	5f                   	pop    %edi
   1829a:	88 85 d0 fe ff ff    	mov    %al,-0x130(%ebp)
   182a0:	5a                   	pop    %edx
	if (tkl) {
   182a1:	84 c0                	test   %al,%al
   182a3:	74 0c                	je     182b1 <handle_request+0x71>
		msg->tkl = tkl;
   182a5:	88 86 84 01 00 00    	mov    %al,0x184(%esi)
		msg->token = token;
   182ab:	89 9e 74 01 00 00    	mov    %ebx,0x174(%esi)
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_URI_PATH, options,
   182b1:	6a 04                	push   $0x4
   182b3:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
   182b9:	50                   	push   %eax
   182ba:	6a 0b                	push   $0xb
   182bc:	ff 76 08             	pushl  0x8(%esi)
   182bf:	e8 cc 00 ff ff       	call   8390 <coap_find_options>
   182c4:	83 c4 10             	add    $0x10,%esp
   182c7:	89 c3                	mov    %eax,%ebx
	if (r <= 0) {
   182c9:	85 c0                	test   %eax,%eax
   182cb:	0f 8e c3 18 00 00    	jle    19b94 <handle_request+0x1954>
	if (r == 2 &&
   182d1:	83 f8 02             	cmp    $0x2,%eax
   182d4:	75 63                	jne    18339 <handle_request+0xf9>
   182d6:	80 bd 66 ff ff ff 0b 	cmpb   $0xb,-0x9a(%ebp)
   182dd:	75 5a                	jne    18339 <handle_request+0xf9>
	     strncmp(options[0].value, ".well-known", 11) == 0) &&
   182df:	6a 0b                	push   $0xb
   182e1:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
   182e7:	68 ee 96 02 00       	push   $0x296ee
   182ec:	50                   	push   %eax
   182ed:	e8 a4 25 ff ff       	call   a896 <strncmp>
   182f2:	83 c4 0c             	add    $0xc,%esp
	    (options[0].len == 11 &&
   182f5:	85 c0                	test   %eax,%eax
   182f7:	75 40                	jne    18339 <handle_request+0xf9>
	     strncmp(options[0].value, ".well-known", 11) == 0) &&
   182f9:	80 bd 76 ff ff ff 04 	cmpb   $0x4,-0x8a(%ebp)
   18300:	75 37                	jne    18339 <handle_request+0xf9>
	     strncmp(options[1].value, "core", 4) == 0)) {
   18302:	6a 04                	push   $0x4
   18304:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
   1830a:	68 45 79 02 00       	push   $0x27945
   1830f:	50                   	push   %eax
   18310:	e8 81 25 ff ff       	call   a896 <strncmp>
   18315:	83 c4 0c             	add    $0xc,%esp
	    (options[1].len == 4 &&
   18318:	85 c0                	test   %eax,%eax
   1831a:	75 1d                	jne    18339 <handle_request+0xf9>
		if ((code & COAP_REQUEST_MASK) != COAP_METHOD_GET) {
   1831c:	8a 85 bc fe ff ff    	mov    -0x144(%ebp),%al
   18322:	83 e0 07             	and    $0x7,%eax
   18325:	fe c8                	dec    %al
   18327:	0f 85 67 18 00 00    	jne    19b94 <handle_request+0x1954>
		well_known = true;
   1832d:	c6 85 cc fe ff ff 01 	movb   $0x1,-0x134(%ebp)
   18334:	e9 e8 00 00 00       	jmp    18421 <handle_request+0x1e1>
		r = coap_options_to_path(options, r, &msg->path);
   18339:	8d 46 20             	lea    0x20(%esi),%eax
	path->level = options_count;
   1833c:	88 5e 28             	mov    %bl,0x28(%esi)
		r = coap_options_to_path(options, r, &msg->path);
   1833f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	u16_t len, *id[4] = { &path->obj_id, &path->obj_inst_id,
   18342:	8d 46 22             	lea    0x22(%esi),%eax
   18345:	89 45 a8             	mov    %eax,-0x58(%ebp)
			      &path->res_id, &path->res_inst_id };
   18348:	8d 46 24             	lea    0x24(%esi),%eax
   1834b:	89 45 ac             	mov    %eax,-0x54(%ebp)
   1834e:	8d 46 26             	lea    0x26(%esi),%eax
   18351:	89 45 b0             	mov    %eax,-0x50(%ebp)
	for (int i = 0; i < options_count; i++) {
   18354:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
   1835a:	31 c0                	xor    %eax,%eax
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
   1835c:	8b 4c 85 a4          	mov    -0x5c(%ebp,%eax,4),%ecx
   18360:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%ebp)
   18367:	00 00 00 
   1836a:	89 8d b8 fe ff ff    	mov    %ecx,-0x148(%ebp)
	u16_t val = 0U;
   18370:	66 c7 85 cc fe ff ff 	movw   $0x0,-0x134(%ebp)
   18377:	00 00 
   18379:	0f b6 4f 02          	movzbl 0x2(%edi),%ecx
   1837d:	66 89 8d c8 fe ff ff 	mov    %cx,-0x138(%ebp)
	while (pos < buflen && isdigit(buf[pos])) {
   18384:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   1838a:	66 39 8d c8 fe ff ff 	cmp    %cx,-0x138(%ebp)
   18391:	66 89 8d c0 fe ff ff 	mov    %cx,-0x140(%ebp)
   18398:	76 3b                	jbe    183d5 <handle_request+0x195>
   1839a:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   183a0:	ff 85 d4 fe ff ff    	incl   -0x12c(%ebp)
   183a6:	0f b6 4c 0f 03       	movzbl 0x3(%edi,%ecx,1),%ecx
   183ab:	88 8d c4 fe ff ff    	mov    %cl,-0x13c(%ebp)
   183b1:	83 e9 30             	sub    $0x30,%ecx
   183b4:	83 f9 09             	cmp    $0x9,%ecx
   183b7:	77 1c                	ja     183d5 <handle_request+0x195>
		val = val * 10 + (buf[pos] - '0');
   183b9:	66 6b 95 cc fe ff ff 	imul   $0xa,-0x134(%ebp),%dx
   183c0:	0a 
   183c1:	0f b6 8d c4 fe ff ff 	movzbl -0x13c(%ebp),%ecx
   183c8:	8d 4c 0a d0          	lea    -0x30(%edx,%ecx,1),%ecx
   183cc:	66 89 8d cc fe ff ff 	mov    %cx,-0x134(%ebp)
		pos++;
   183d3:	eb af                	jmp    18384 <handle_request+0x144>
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
   183d5:	8b 8d b8 fe ff ff    	mov    -0x148(%ebp),%ecx
   183db:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
		if (len == 0 || opt[i].len != len) {
   183e1:	66 83 bd c0 fe ff ff 	cmpw   $0x0,-0x140(%ebp)
   183e8:	00 
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
   183e9:	66 89 11             	mov    %dx,(%ecx)
		if (len == 0 || opt[i].len != len) {
   183ec:	74 0f                	je     183fd <handle_request+0x1bd>
   183ee:	8b 95 c0 fe ff ff    	mov    -0x140(%ebp),%edx
   183f4:	66 39 95 c8 fe ff ff 	cmp    %dx,-0x138(%ebp)
   183fb:	74 05                	je     18402 <handle_request+0x1c2>
			path->level = i;
   183fd:	88 46 28             	mov    %al,0x28(%esi)
			break;
   18400:	eb 0c                	jmp    1840e <handle_request+0x1ce>
	for (int i = 0; i < options_count; i++) {
   18402:	40                   	inc    %eax
   18403:	83 c7 10             	add    $0x10,%edi
   18406:	39 c3                	cmp    %eax,%ebx
   18408:	0f 85 4e ff ff ff    	jne    1835c <handle_request+0x11c>
	return options_count == path->level ? 0 : -EINVAL;
   1840e:	0f b6 46 28          	movzbl 0x28(%esi),%eax
   18412:	39 c3                	cmp    %eax,%ebx
   18414:	0f 85 73 17 00 00    	jne    19b8d <handle_request+0x194d>
	bool well_known = false;
   1841a:	c6 85 cc fe ff ff 00 	movb   $0x0,-0x134(%ebp)
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_CONTENT_FORMAT,
   18421:	6a 01                	push   $0x1
   18423:	8d 9d 64 ff ff ff    	lea    -0x9c(%ebp),%ebx
   18429:	53                   	push   %ebx
   1842a:	6a 0c                	push   $0xc
   1842c:	ff 76 08             	pushl  0x8(%esi)
   1842f:	e8 5c ff fe ff       	call   8390 <coap_find_options>
   18434:	83 c4 10             	add    $0x10,%esp
	if (r > 0) {
   18437:	85 c0                	test   %eax,%eax
   18439:	0f 8e 90 00 00 00    	jle    184cf <handle_request+0x28f>
		format = coap_option_value_to_int(&options[0]);
   1843f:	53                   	push   %ebx
   18440:	e8 cf fd fe ff       	call   8214 <coap_option_value_to_int>
   18445:	5b                   	pop    %ebx
   18446:	89 c2                	mov    %eax,%edx
	switch (format) {
   18448:	66 3d 06 06          	cmp    $0x606,%ax
		format = coap_option_value_to_int(&options[0]);
   1844c:	89 c7                	mov    %eax,%edi
	switch (format) {
   1844e:	74 32                	je     18482 <handle_request+0x242>
   18450:	77 13                	ja     18465 <handle_request+0x225>
   18452:	66 83 f8 2a          	cmp    $0x2a,%ax
   18456:	74 21                	je     18479 <handle_request+0x239>
   18458:	66 3d 05 06          	cmp    $0x605,%ax
   1845c:	74 1b                	je     18479 <handle_request+0x239>
   1845e:	66 85 c0             	test   %ax,%ax
   18461:	75 31                	jne    18494 <handle_request+0x254>
   18463:	eb 14                	jmp    18479 <handle_request+0x239>
   18465:	66 3d 16 2d          	cmp    $0x2d16,%ax
   18469:	74 17                	je     18482 <handle_request+0x242>
   1846b:	66 3d 17 2d          	cmp    $0x2d17,%ax
   1846f:	74 1a                	je     1848b <handle_request+0x24b>
   18471:	66 3d 07 06          	cmp    $0x607,%ax
   18475:	75 1d                	jne    18494 <handle_request+0x254>
   18477:	eb 12                	jmp    1848b <handle_request+0x24b>
		in->reader = &plain_text_reader;
   18479:	c7 46 04 d4 63 02 00 	movl   $0x263d4,0x4(%esi)
		if (r < 0) {
   18480:	eb 50                	jmp    184d2 <handle_request+0x292>
		in->reader = &oma_tlv_reader;
   18482:	c7 46 04 f0 63 02 00 	movl   $0x263f0,0x4(%esi)
		if (r < 0) {
   18489:	eb 47                	jmp    184d2 <handle_request+0x292>
		in->reader = &json_reader;
   1848b:	c7 46 04 38 65 02 00 	movl   $0x26538,0x4(%esi)
		if (r < 0) {
   18492:	eb 3e                	jmp    184d2 <handle_request+0x292>
		return -ENOMSG;
   18494:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
		LOG_WRN("Unknown content type %u", format);
   18499:	f6 05 a4 a8 40 00 06 	testb  $0x6,0x40a8a4
   184a0:	0f 84 f1 16 00 00    	je     19b97 <handle_request+0x1957>
   184a6:	b9 cc 51 02 00       	mov    $0x251cc,%ecx
   184ab:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   184b1:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   184b7:	c1 e9 03             	shr    $0x3,%ecx
   184ba:	c1 e1 06             	shl    $0x6,%ecx
   184bd:	83 c9 02             	or     $0x2,%ecx
   184c0:	51                   	push   %ecx
   184c1:	0f b7 d2             	movzwl %dx,%edx
   184c4:	52                   	push   %edx
   184c5:	68 d0 91 02 00       	push   $0x291d0
   184ca:	e9 27 04 00 00       	jmp    188f6 <handle_request+0x6b6>
	u16_t format = LWM2M_FORMAT_NONE, accept;
   184cf:	83 cf ff             	or     $0xffffffff,%edi
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_ACCEPT, options, 1);
   184d2:	6a 01                	push   $0x1
   184d4:	8d 9d 64 ff ff ff    	lea    -0x9c(%ebp),%ebx
   184da:	53                   	push   %ebx
   184db:	6a 11                	push   $0x11
   184dd:	ff 76 08             	pushl  0x8(%esi)
   184e0:	e8 ab fe fe ff       	call   8390 <coap_find_options>
   184e5:	83 c4 10             	add    $0x10,%esp
	if (r > 0) {
   184e8:	85 c0                	test   %eax,%eax
   184ea:	7e 10                	jle    184fc <handle_request+0x2bc>
		accept = coap_option_value_to_int(&options[0]);
   184ec:	53                   	push   %ebx
   184ed:	e8 22 fd fe ff       	call   8214 <coap_option_value_to_int>
   184f2:	59                   	pop    %ecx
   184f3:	66 89 85 c4 fe ff ff 	mov    %ax,-0x13c(%ebp)
   184fa:	eb 38                	jmp    18534 <handle_request+0x2f4>
		accept = LWM2M_FORMAT_OMA_TLV;
   184fc:	66 c7 85 c4 fe ff ff 	movw   $0x2d16,-0x13c(%ebp)
   18503:	16 2d 
		LOG_DBG("No accept option given. Assume OMA TLV.");
   18505:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1850c:	74 26                	je     18534 <handle_request+0x2f4>
   1850e:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18513:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18518:	c1 e8 03             	shr    $0x3,%eax
   1851b:	c1 e0 06             	shl    $0x6,%eax
   1851e:	83 c8 04             	or     $0x4,%eax
   18521:	50                   	push   %eax
   18522:	68 68 62 02 00       	push   $0x26268
   18527:	68 fa 96 02 00       	push   $0x296fa
   1852c:	e8 7e af fe ff       	call   34af <log_1>
   18531:	83 c4 0c             	add    $0xc,%esp
	r = select_writer(&msg->out, accept);
   18534:	0f b7 95 c4 fe ff ff 	movzwl -0x13c(%ebp),%edx
   1853b:	8d 46 14             	lea    0x14(%esi),%eax
   1853e:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
   18544:	e8 41 e7 ff ff       	call   16c8a <select_writer>
	if (r < 0) {
   18549:	85 c0                	test   %eax,%eax
   1854b:	0f 88 46 16 00 00    	js     19b97 <handle_request+0x1957>
	struct lwm2m_engine_obj *obj = NULL;
   18551:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   18558:	00 00 00 
	if (!well_known) {
   1855b:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   18562:	75 17                	jne    1857b <handle_request+0x33b>
		obj = get_engine_obj(msg->path.obj_id);
   18564:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   18568:	e8 64 e4 ff ff       	call   169d1 <get_engine_obj>
   1856d:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
		if (!obj) {
   18573:	85 c0                	test   %eax,%eax
   18575:	0f 84 12 16 00 00    	je     19b8d <handle_request+0x194d>
	switch (code & COAP_REQUEST_MASK) {
   1857b:	8a 85 bc fe ff ff    	mov    -0x144(%ebp),%al
   18581:	83 e0 07             	and    $0x7,%eax
   18584:	3c 02                	cmp    $0x2,%al
   18586:	74 70                	je     185f8 <handle_request+0x3b8>
   18588:	77 09                	ja     18593 <handle_request+0x353>
   1858a:	fe c8                	dec    %al
   1858c:	74 28                	je     185b6 <handle_request+0x376>
   1858e:	e9 ad 00 00 00       	jmp    18640 <handle_request+0x400>
   18593:	3c 03                	cmp    $0x3,%al
   18595:	0f 84 8a 00 00 00    	je     18625 <handle_request+0x3e5>
   1859b:	3c 04                	cmp    $0x4,%al
   1859d:	0f 85 9d 00 00 00    	jne    18640 <handle_request+0x400>
		msg->operation = LWM2M_OP_DELETE;
   185a3:	c6 86 85 01 00 00 03 	movb   $0x3,0x185(%esi)
		msg->code = COAP_RESPONSE_CODE_DELETED;
   185aa:	c6 86 83 01 00 00 42 	movb   $0x42,0x183(%esi)
   185b1:	e9 8a 00 00 00       	jmp    18640 <handle_request+0x400>
		if (well_known || accept == LWM2M_FORMAT_APP_LINK_FORMAT) {
   185b6:	66 83 bd c4 fe ff ff 	cmpw   $0x28,-0x13c(%ebp)
   185bd:	28 
   185be:	74 0b                	je     185cb <handle_request+0x38b>
			msg->operation = LWM2M_OP_READ;
   185c0:	31 c0                	xor    %eax,%eax
		if (well_known || accept == LWM2M_FORMAT_APP_LINK_FORMAT) {
   185c2:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   185c9:	74 0b                	je     185d6 <handle_request+0x396>
			msg->operation = LWM2M_OP_DISCOVER;
   185cb:	b0 08                	mov    $0x8,%al
			accept = LWM2M_FORMAT_APP_LINK_FORMAT;
   185cd:	66 c7 85 c4 fe ff ff 	movw   $0x28,-0x13c(%ebp)
   185d4:	28 00 
   185d6:	88 86 85 01 00 00    	mov    %al,0x185(%esi)
		observe = get_option_int(msg->in.in_cpkt, COAP_OPTION_OBSERVE);
   185dc:	ba 06 00 00 00       	mov    $0x6,%edx
   185e1:	8b 46 08             	mov    0x8(%esi),%eax
   185e4:	e8 1c e6 ff ff       	call   16c05 <get_option_int>
		msg->code = COAP_RESPONSE_CODE_CONTENT;
   185e9:	c6 86 83 01 00 00 45 	movb   $0x45,0x183(%esi)
		observe = get_option_int(msg->in.in_cpkt, COAP_OPTION_OBSERVE);
   185f0:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
		break;
   185f6:	eb 52                	jmp    1864a <handle_request+0x40a>
		if (msg->path.level == 1) {
   185f8:	8a 46 28             	mov    0x28(%esi),%al
   185fb:	3c 01                	cmp    $0x1,%al
   185fd:	75 10                	jne    1860f <handle_request+0x3cf>
			msg->operation = LWM2M_OP_CREATE;
   185ff:	c6 86 85 01 00 00 02 	movb   $0x2,0x185(%esi)
			msg->code = COAP_RESPONSE_CODE_CREATED;
   18606:	c6 86 83 01 00 00 41 	movb   $0x41,0x183(%esi)
   1860d:	eb 31                	jmp    18640 <handle_request+0x400>
		} else if (msg->path.level == 2) {
   1860f:	3c 02                	cmp    $0x2,%al
   18611:	75 09                	jne    1861c <handle_request+0x3dc>
			msg->operation = LWM2M_OP_WRITE;
   18613:	c6 86 85 01 00 00 01 	movb   $0x1,0x185(%esi)
			msg->code = COAP_RESPONSE_CODE_CHANGED;
   1861a:	eb 1d                	jmp    18639 <handle_request+0x3f9>
			msg->operation = LWM2M_OP_EXECUTE;
   1861c:	c6 86 85 01 00 00 04 	movb   $0x4,0x185(%esi)
			msg->code = COAP_RESPONSE_CODE_CHANGED;
   18623:	eb 14                	jmp    18639 <handle_request+0x3f9>
			msg->operation = LWM2M_OP_WRITE_ATTR;
   18625:	66 83 ff ff          	cmp    $0xffff,%di
   18629:	0f 94 c0             	sete   %al
   1862c:	8d 04 c5 01 00 00 00 	lea    0x1(,%eax,8),%eax
   18633:	88 86 85 01 00 00    	mov    %al,0x185(%esi)
		msg->code = COAP_RESPONSE_CODE_CHANGED;
   18639:	c6 86 83 01 00 00 44 	movb   $0x44,0x183(%esi)
	int observe = -1; /* default to -1, 0 = ENABLE, 1 = DISABLE */
   18640:	c7 85 d4 fe ff ff ff 	movl   $0xffffffff,-0x12c(%ebp)
   18647:	ff ff ff 
	msg->in.offset = msg->in.in_cpkt->hdr_len + msg->in.in_cpkt->opt_len;
   1864a:	8b 46 08             	mov    0x8(%esi),%eax
   1864d:	0f b6 50 08          	movzbl 0x8(%eax),%edx
   18651:	66 03 50 0a          	add    0xa(%eax),%dx
   18655:	66 89 56 0c          	mov    %dx,0xc(%esi)
	coap_packet_get_payload(msg->in.in_cpkt, &payload_len);
   18659:	8d 95 da fe ff ff    	lea    -0x126(%ebp),%edx
   1865f:	52                   	push   %edx
   18660:	50                   	push   %eax
   18661:	e8 f3 fe fe ff       	call   8559 <coap_packet_get_payload>
   18666:	58                   	pop    %eax
	r = get_option_int(msg->in.in_cpkt, COAP_OPTION_BLOCK1);
   18667:	8b 46 08             	mov    0x8(%esi),%eax
	coap_packet_get_payload(msg->in.in_cpkt, &payload_len);
   1866a:	5a                   	pop    %edx
	r = get_option_int(msg->in.in_cpkt, COAP_OPTION_BLOCK1);
   1866b:	ba 1b 00 00 00       	mov    $0x1b,%edx
   18670:	e8 90 e5 ff ff       	call   16c05 <get_option_int>
	if (r > 0) {
   18675:	85 c0                	test   %eax,%eax
   18677:	0f 8e ee 01 00 00    	jle    1886b <handle_request+0x62b>
		last_block = !GET_MORE(r);
   1867d:	89 c1                	mov    %eax,%ecx
   1867f:	83 e1 08             	and    $0x8,%ecx
   18682:	89 8d b8 fe ff ff    	mov    %ecx,-0x148(%ebp)
   18688:	0f 94 85 b7 fe ff ff 	sete   -0x149(%ebp)
		if (!last_block &&
   1868f:	74 54                	je     186e5 <handle_request+0x4a5>
		block_size = GET_BLOCK_SIZE(r);
   18691:	89 c1                	mov    %eax,%ecx
	return (1 << (block_size + 4));
   18693:	ba 01 00 00 00       	mov    $0x1,%edx
   18698:	83 e1 07             	and    $0x7,%ecx
   1869b:	83 c1 04             	add    $0x4,%ecx
   1869e:	d3 e2                	shl    %cl,%edx
		if (!last_block &&
   186a0:	66 39 95 da fe ff ff 	cmp    %dx,-0x126(%ebp)
   186a7:	73 3c                	jae    186e5 <handle_request+0x4a5>
			r = -EFBIG;
   186a9:	b8 e5 ff ff ff       	mov    $0xffffffe5,%eax
			LOG_DBG("Trailing payload is discarded!");
   186ae:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   186b5:	0f 84 dc 14 00 00    	je     19b97 <handle_request+0x1957>
   186bb:	ba cc 51 02 00       	mov    $0x251cc,%edx
   186c0:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   186c6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   186cc:	c1 ea 03             	shr    $0x3,%edx
   186cf:	c1 e2 06             	shl    $0x6,%edx
   186d2:	83 ca 04             	or     $0x4,%edx
   186d5:	52                   	push   %edx
   186d6:	68 68 62 02 00       	push   $0x26268
   186db:	68 26 97 02 00       	push   $0x29726
   186e0:	e9 11 02 00 00       	jmp    188f6 <handle_request+0x6b6>
		if (GET_BLOCK_NUM(r) == 0) {
   186e5:	c1 f8 04             	sar    $0x4,%eax
   186e8:	89 c3                	mov    %eax,%ebx
   186ea:	0f 85 02 01 00 00    	jne    187f2 <handle_request+0x5b2>
	*ctx = NULL;
   186f0:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
   186f7:	00 00 00 
   186fa:	e8 12 c2 00 00       	call   24911 <z_impl_k_uptime_get>
   186ff:	c7 85 bc fe ff ff 40 	movl   $0x402940,-0x144(%ebp)
   18706:	29 40 00 
   18709:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
   1870f:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
		if (block1_contexts[i].tkl == 0) {
   18715:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
   1871b:	80 78 1c 00          	cmpb   $0x0,0x1c(%eax)
   1871f:	74 28                	je     18749 <handle_request+0x509>
		if (timestamp - block1_contexts[i].timestamp >
   18721:	8b 8d bc fe ff ff    	mov    -0x144(%ebp),%ecx
   18727:	8b 85 ac fe ff ff    	mov    -0x154(%ebp),%eax
   1872d:	8b 95 b0 fe ff ff    	mov    -0x150(%ebp),%edx
   18733:	2b 41 0c             	sub    0xc(%ecx),%eax
   18736:	1b 51 10             	sbb    0x10(%ecx),%edx
   18739:	b9 30 75 00 00       	mov    $0x7530,%ecx
   1873e:	39 c1                	cmp    %eax,%ecx
   18740:	b9 00 00 00 00       	mov    $0x0,%ecx
   18745:	19 d1                	sbb    %edx,%ecx
   18747:	7d 11                	jge    1875a <handle_request+0x51a>
			*ctx = &block1_contexts[i];
   18749:	c1 e3 05             	shl    $0x5,%ebx
   1874c:	81 c3 40 29 40 00    	add    $0x402940,%ebx
   18752:	89 9d dc fe ff ff    	mov    %ebx,-0x124(%ebp)
			break;
   18758:	eb 0d                	jmp    18767 <handle_request+0x527>
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
   1875a:	43                   	inc    %ebx
   1875b:	83 85 bc fe ff ff 20 	addl   $0x20,-0x144(%ebp)
   18762:	83 fb 03             	cmp    $0x3,%ebx
   18765:	75 ae                	jne    18715 <handle_request+0x4d5>
	if (*ctx == NULL) {
   18767:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
   1876d:	85 c0                	test   %eax,%eax
   1876f:	75 37                	jne    187a8 <handle_request+0x568>
		return -ENOMEM;
   18771:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		LOG_ERR("Cannot find free block context");
   18776:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1877d:	0f 84 14 14 00 00    	je     19b97 <handle_request+0x1957>
   18783:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18788:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   1878e:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18794:	c1 ea 03             	shr    $0x3,%edx
   18797:	c1 e2 06             	shl    $0x6,%edx
   1879a:	83 ca 01             	or     $0x1,%edx
   1879d:	52                   	push   %edx
   1879e:	68 49 97 02 00       	push   $0x29749
   187a3:	e9 39 06 00 00       	jmp    18de1 <handle_request+0xba1>
	(*ctx)->tkl = tkl;
   187a8:	0f b6 95 d0 fe ff ff 	movzbl -0x130(%ebp),%edx
   187af:	88 50 1c             	mov    %dl,0x1c(%eax)
	memcpy((*ctx)->token, token, tkl);
   187b2:	52                   	push   %edx
   187b3:	8d 95 f3 fe ff ff    	lea    -0x10d(%ebp),%edx
   187b9:	83 c0 14             	add    $0x14,%eax
   187bc:	52                   	push   %edx
   187bd:	50                   	push   %eax
   187be:	e8 6e 21 ff ff       	call   a931 <memcpy>
   187c3:	83 c4 0c             	add    $0xc,%esp
	coap_block_transfer_init(&(*ctx)->ctx, lwm2m_default_block_size(), 0);
   187c6:	6a 00                	push   $0x0
   187c8:	6a 04                	push   $0x4
   187ca:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
   187d0:	e8 c8 fd fe ff       	call   859d <coap_block_transfer_init>
	(*ctx)->timestamp = timestamp;
   187d5:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
   187db:	8b 8d ac fe ff ff    	mov    -0x154(%ebp),%ecx
   187e1:	8b 9d b0 fe ff ff    	mov    -0x150(%ebp),%ebx
	coap_block_transfer_init(&(*ctx)->ctx, lwm2m_default_block_size(), 0);
   187e7:	83 c4 0c             	add    $0xc,%esp
	(*ctx)->timestamp = timestamp;
   187ea:	89 48 0c             	mov    %ecx,0xc(%eax)
   187ed:	89 58 10             	mov    %ebx,0x10(%eax)
		if (r < 0) {
   187f0:	eb 20                	jmp    18812 <handle_request+0x5d2>
			r = get_block_ctx(token, tkl, &block_ctx);
   187f2:	0f b6 95 d0 fe ff ff 	movzbl -0x130(%ebp),%edx
   187f9:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
   187ff:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   18805:	e8 0f e5 ff ff       	call   16d19 <get_block_ctx>
		if (r < 0) {
   1880a:	85 c0                	test   %eax,%eax
   1880c:	0f 88 85 13 00 00    	js     19b97 <handle_request+0x1957>
		r = coap_update_from_block(msg->in.in_cpkt, &block_ctx->ctx);
   18812:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
   18818:	ff 76 08             	pushl  0x8(%esi)
   1881b:	e8 61 fe fe ff       	call   8681 <coap_update_from_block>
   18820:	59                   	pop    %ecx
		if (r < 0) {
   18821:	85 c0                	test   %eax,%eax
		r = coap_update_from_block(msg->in.in_cpkt, &block_ctx->ctx);
   18823:	5b                   	pop    %ebx
		if (r < 0) {
   18824:	79 33                	jns    18859 <handle_request+0x619>
			LOG_ERR("Error from block update: %d", r);
   18826:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1882d:	0f 84 64 13 00 00    	je     19b97 <handle_request+0x1957>
   18833:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18838:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   1883e:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18844:	c1 ea 03             	shr    $0x3,%edx
   18847:	c1 e2 06             	shl    $0x6,%edx
   1884a:	83 ca 01             	or     $0x1,%edx
   1884d:	52                   	push   %edx
   1884e:	50                   	push   %eax
   1884f:	68 68 97 02 00       	push   $0x29768
   18854:	e9 9d 00 00 00       	jmp    188f6 <handle_request+0x6b6>
		if (!last_block) {
   18859:	83 bd b8 fe ff ff 00 	cmpl   $0x0,-0x148(%ebp)
   18860:	74 10                	je     18872 <handle_request+0x632>
			msg->code = COAP_RESPONSE_CODE_CONTINUE;
   18862:	c6 86 83 01 00 00 5f 	movb   $0x5f,0x183(%esi)
   18869:	eb 07                	jmp    18872 <handle_request+0x632>
	bool last_block = false;
   1886b:	c6 85 b7 fe ff ff 00 	movb   $0x0,-0x149(%ebp)
	r = lwm2m_init_message(msg);
   18872:	56                   	push   %esi
   18873:	e8 b5 f7 ff ff       	call   1802d <lwm2m_init_message>
   18878:	5a                   	pop    %edx
	if (r < 0) {
   18879:	85 c0                	test   %eax,%eax
   1887b:	0f 88 16 13 00 00    	js     19b97 <handle_request+0x1957>
	switch (msg->operation) {
   18881:	0f b6 96 85 01 00 00 	movzbl 0x185(%esi),%edx
   18888:	80 fa 09             	cmp    $0x9,%dl
   1888b:	0f 87 72 12 00 00    	ja     19b03 <handle_request+0x18c3>
   18891:	0f b6 c2             	movzbl %dl,%eax
   18894:	ff 24 85 8c 61 02 00 	jmp    *0x2618c(,%eax,4)
		if (observe == 0) {
   1889b:	83 bd d4 fe ff ff 00 	cmpl   $0x0,-0x12c(%ebp)
   188a2:	0f 85 4b 05 00 00    	jne    18df3 <handle_request+0xbb3>
			if (msg->token) {
   188a8:	83 be 74 01 00 00 00 	cmpl   $0x0,0x174(%esi)
   188af:	0f 84 fa 04 00 00    	je     18daf <handle_request+0xb6f>
				r = coap_append_option_int(msg->out.out_cpkt,
   188b5:	6a 01                	push   $0x1
   188b7:	6a 06                	push   $0x6
   188b9:	ff 76 18             	pushl  0x18(%esi)
   188bc:	e8 e7 f8 fe ff       	call   81a8 <coap_append_option_int>
   188c1:	83 c4 0c             	add    $0xc,%esp
				if (r < 0) {
   188c4:	85 c0                	test   %eax,%eax
   188c6:	79 3b                	jns    18903 <handle_request+0x6c3>
					LOG_ERR("OBSERVE option error: %d", r);
   188c8:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   188cf:	0f 84 c2 12 00 00    	je     19b97 <handle_request+0x1957>
   188d5:	ba cc 51 02 00       	mov    $0x251cc,%edx
   188da:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   188e0:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   188e6:	c1 ea 03             	shr    $0x3,%edx
   188e9:	c1 e2 06             	shl    $0x6,%edx
   188ec:	83 ca 01             	or     $0x1,%edx
   188ef:	52                   	push   %edx
   188f0:	50                   	push   %eax
   188f1:	68 84 97 02 00       	push   $0x29784
   188f6:	e8 b4 ab fe ff       	call   34af <log_1>
   188fb:	83 c4 0c             	add    $0xc,%esp
   188fe:	e9 e5 04 00 00       	jmp    18de8 <handle_request+0xba8>
	struct notification_attrs attrs = {
   18903:	8d 7d a4             	lea    -0x5c(%ebp),%edi
   18906:	b9 09 00 00 00       	mov    $0x9,%ecx
   1890b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
	if (!msg || !msg->ctx) {
   18911:	83 3e 00             	cmpl   $0x0,(%esi)
	struct notification_attrs attrs = {
   18914:	f3 ab                	rep stos %eax,%es:(%edi)
   18916:	c7 45 bc 0a 00 00 00 	movl   $0xa,-0x44(%ebp)
   1891d:	c7 45 c0 3c 00 00 00 	movl   $0x3c,-0x40(%ebp)
   18924:	c6 45 c4 03          	movb   $0x3,-0x3c(%ebp)
	if (!msg || !msg->ctx) {
   18928:	75 33                	jne    1895d <handle_request+0x71d>
		LOG_ERR("valid lwm2m message is required");
   1892a:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18931:	74 20                	je     18953 <handle_request+0x713>
   18933:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18938:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1893d:	c1 e8 03             	shr    $0x3,%eax
   18940:	c1 e0 06             	shl    $0x6,%eax
   18943:	83 c8 01             	or     $0x1,%eax
   18946:	50                   	push   %eax
   18947:	68 9d 97 02 00       	push   $0x2979d
   1894c:	e8 39 ab fe ff       	call   348a <log_0>
   18951:	59                   	pop    %ecx
   18952:	5b                   	pop    %ebx
		return -EINVAL;
   18953:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   18958:	e9 1f 04 00 00       	jmp    18d7c <handle_request+0xb3c>
	if (!token || (tkl == 0 || tkl > MAX_TOKEN_LEN)) {
   1895d:	8a 85 d0 fe ff ff    	mov    -0x130(%ebp),%al
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   18963:	8b 1d a0 43 40 00    	mov    0x4043a0,%ebx
	if (!token || (tkl == 0 || tkl > MAX_TOKEN_LEN)) {
   18969:	48                   	dec    %eax
   1896a:	3c 07                	cmp    $0x7,%al
   1896c:	76 44                	jbe    189b2 <handle_request+0x772>
		LOG_ERR("token(%p) and token length(%u) must be valid.",
   1896e:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18975:	74 dc                	je     18953 <handle_request+0x713>
   18977:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1897c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18981:	c1 e8 03             	shr    $0x3,%eax
   18984:	c1 e0 06             	shl    $0x6,%eax
   18987:	83 c8 01             	or     $0x1,%eax
   1898a:	50                   	push   %eax
   1898b:	0f b6 85 d0 fe ff ff 	movzbl -0x130(%ebp),%eax
   18992:	50                   	push   %eax
   18993:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   18999:	50                   	push   %eax
   1899a:	68 4e 92 02 00       	push   $0x2924e
   1899f:	e8 45 ab fe ff       	call   34e9 <log_2>
   189a4:	83 c4 10             	add    $0x10,%esp
				if (r < 0) {
   189a7:	eb aa                	jmp    18953 <handle_request+0x713>
		if (obs->ctx == msg->ctx &&
   189a9:	8b 06                	mov    (%esi),%eax
   189ab:	39 43 04             	cmp    %eax,0x4(%ebx)
   189ae:	74 20                	je     189d0 <handle_request+0x790>
   189b0:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   189b2:	85 db                	test   %ebx,%ebx
   189b4:	75 f3                	jne    189a9 <handle_request+0x769>
	obj = get_engine_obj(msg->path.obj_id);
   189b6:	0f b7 5e 20          	movzwl 0x20(%esi),%ebx
   189ba:	89 d8                	mov    %ebx,%eax
   189bc:	e8 10 e0 ff ff       	call   169d1 <get_engine_obj>
   189c1:	89 c7                	mov    %eax,%edi
	if (!obj) {
   189c3:	85 c0                	test   %eax,%eax
   189c5:	0f 85 ea 00 00 00    	jne    18ab5 <handle_request+0x875>
   189cb:	e9 b1 00 00 00       	jmp    18a81 <handle_request+0x841>
		    memcmp(&obs->path, &msg->path, sizeof(msg->path)) == 0) {
   189d0:	6a 0a                	push   $0xa
   189d2:	8d 46 20             	lea    0x20(%esi),%eax
   189d5:	50                   	push   %eax
   189d6:	8d 43 08             	lea    0x8(%ebx),%eax
   189d9:	50                   	push   %eax
   189da:	e8 e7 1e ff ff       	call   a8c6 <memcmp>
   189df:	83 c4 0c             	add    $0xc,%esp
		if (obs->ctx == msg->ctx &&
   189e2:	85 c0                	test   %eax,%eax
   189e4:	75 ca                	jne    189b0 <handle_request+0x770>
			memcpy(obs->token, token, tkl);
   189e6:	0f b6 85 d0 fe ff ff 	movzbl -0x130(%ebp),%eax
   189ed:	50                   	push   %eax
   189ee:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   189f4:	50                   	push   %eax
   189f5:	8d 43 12             	lea    0x12(%ebx),%eax
   189f8:	50                   	push   %eax
   189f9:	e8 33 1f ff ff       	call   a931 <memcpy>
			obs->tkl = tkl;
   189fe:	8a 85 d0 fe ff ff    	mov    -0x130(%ebp),%al
			memcpy(obs->token, token, tkl);
   18a04:	83 c4 0c             	add    $0xc,%esp
			obs->tkl = tkl;
   18a07:	88 43 3a             	mov    %al,0x3a(%ebx)
			LOG_DBG("OBSERVER DUPLICATE %u/%u/%u(%u) [%s]",
   18a0a:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   18a11:	0f 84 27 04 00 00    	je     18e3e <handle_request+0xbfe>
   18a17:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   18a1b:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
   18a21:	c7 85 40 ff ff ff 54 	movl   $0x26254,-0xc0(%ebp)
   18a28:	62 02 00 
   18a2b:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   18a2f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
   18a35:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   18a3a:	0f b7 46 24          	movzwl 0x24(%esi),%eax
   18a3e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
   18a44:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   18a4a:	0f b6 46 28          	movzbl 0x28(%esi),%eax
   18a4e:	ff 36                	pushl  (%esi)
   18a50:	c1 eb 03             	shr    $0x3,%ebx
   18a53:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
   18a59:	c1 e3 06             	shl    $0x6,%ebx
   18a5c:	e8 67 e9 ff ff       	call   173c8 <lwm2m_sprint_ip_addr>
   18a61:	83 cb 04             	or     $0x4,%ebx
   18a64:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
   18a6a:	66 89 1c 24          	mov    %bx,(%esp)
   18a6e:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   18a74:	6a 06                	push   $0x6
   18a76:	50                   	push   %eax
   18a77:	68 bd 97 02 00       	push   $0x297bd
   18a7c:	e9 eb 02 00 00       	jmp    18d6c <handle_request+0xb2c>
		LOG_ERR("unable to find obj: %u", msg->path.obj_id);
   18a81:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18a88:	0f 84 6b 01 00 00    	je     18bf9 <handle_request+0x9b9>
   18a8e:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18a93:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18a98:	c1 e8 03             	shr    $0x3,%eax
   18a9b:	c1 e0 06             	shl    $0x6,%eax
   18a9e:	83 c8 01             	or     $0x1,%eax
   18aa1:	50                   	push   %eax
   18aa2:	53                   	push   %ebx
   18aa3:	68 25 95 02 00       	push   $0x29525
   18aa8:	e8 02 aa fe ff       	call   34af <log_1>
   18aad:	83 c4 0c             	add    $0xc,%esp
				if (r < 0) {
   18ab0:	e9 44 01 00 00       	jmp    18bf9 <handle_request+0x9b9>
	ret = update_attrs(obj, &attrs);
   18ab5:	8d 55 a4             	lea    -0x5c(%ebp),%edx
   18ab8:	e8 9d df ff ff       	call   16a5a <update_attrs>
	if (ret < 0) {
   18abd:	85 c0                	test   %eax,%eax
   18abf:	0f 88 b7 02 00 00    	js     18d7c <handle_request+0xb3c>
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   18ac5:	31 db                	xor    %ebx,%ebx
	if (msg->path.level >= 2) {
   18ac7:	80 7e 28 01          	cmpb   $0x1,0x28(%esi)
   18acb:	76 73                	jbe    18b40 <handle_request+0x900>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
   18acd:	0f b7 4e 20          	movzwl 0x20(%esi),%ecx
   18ad1:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   18ad5:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
   18adb:	89 c2                	mov    %eax,%edx
   18add:	89 c8                	mov    %ecx,%eax
   18adf:	89 8d c0 fe ff ff    	mov    %ecx,-0x140(%ebp)
   18ae5:	e8 00 df ff ff       	call   169ea <get_engine_obj_inst>
		if (!obj_inst) {
   18aea:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
   18af0:	89 c3                	mov    %eax,%ebx
		if (!obj_inst) {
   18af2:	85 c0                	test   %eax,%eax
   18af4:	75 3a                	jne    18b30 <handle_request+0x8f0>
			LOG_ERR("unable to find obj_inst: %u/%u",
   18af6:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18afd:	0f 84 f6 00 00 00    	je     18bf9 <handle_request+0x9b9>
   18b03:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18b08:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18b0d:	c1 e8 03             	shr    $0x3,%eax
   18b10:	c1 e0 06             	shl    $0x6,%eax
   18b13:	83 c8 01             	or     $0x1,%eax
   18b16:	50                   	push   %eax
   18b17:	ff b5 cc fe ff ff    	pushl  -0x134(%ebp)
   18b1d:	51                   	push   %ecx
   18b1e:	68 e6 97 02 00       	push   $0x297e6
   18b23:	e8 c1 a9 fe ff       	call   34e9 <log_2>
   18b28:	83 c4 10             	add    $0x10,%esp
				if (r < 0) {
   18b2b:	e9 c9 00 00 00       	jmp    18bf9 <handle_request+0x9b9>
		ret = update_attrs(obj_inst, &attrs);
   18b30:	8d 55 a4             	lea    -0x5c(%ebp),%edx
   18b33:	e8 22 df ff ff       	call   16a5a <update_attrs>
		if (ret < 0) {
   18b38:	85 c0                	test   %eax,%eax
   18b3a:	0f 88 3c 02 00 00    	js     18d7c <handle_request+0xb3c>
	if (msg->path.level >= 3) {
   18b40:	80 7e 28 02          	cmpb   $0x2,0x28(%esi)
   18b44:	0f 86 d5 00 00 00    	jbe    18c1f <handle_request+0x9df>
		for (i = 0; i < obj_inst->resource_count; i++) {
   18b4a:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
   18b4e:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
   18b54:	31 c0                	xor    %eax,%eax
   18b56:	3b 85 cc fe ff ff    	cmp    -0x134(%ebp),%eax
   18b5c:	7d 14                	jge    18b72 <handle_request+0x932>
			if (obj_inst->resources[i].res_id == msg->path.res_id) {
   18b5e:	89 c2                	mov    %eax,%edx
   18b60:	8b 4e 24             	mov    0x24(%esi),%ecx
   18b63:	c1 e2 05             	shl    $0x5,%edx
   18b66:	03 53 08             	add    0x8(%ebx),%edx
   18b69:	66 39 4a 1a          	cmp    %cx,0x1a(%edx)
   18b6d:	74 38                	je     18ba7 <handle_request+0x967>
		for (i = 0; i < obj_inst->resource_count; i++) {
   18b6f:	40                   	inc    %eax
   18b70:	eb e4                	jmp    18b56 <handle_request+0x916>
		if (i == obj_inst->resource_count) {
   18b72:	75 33                	jne    18ba7 <handle_request+0x967>
			LOG_ERR("unable to find res_id: %u/%u/%u",
   18b74:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18b7b:	74 7c                	je     18bf9 <handle_request+0x9b9>
   18b7d:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18b82:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18b87:	c1 e8 03             	shr    $0x3,%eax
   18b8a:	c1 e0 06             	shl    $0x6,%eax
   18b8d:	83 c8 01             	or     $0x1,%eax
   18b90:	50                   	push   %eax
   18b91:	0f b7 46 24          	movzwl 0x24(%esi),%eax
   18b95:	50                   	push   %eax
   18b96:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   18b9a:	50                   	push   %eax
   18b9b:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   18b9f:	50                   	push   %eax
   18ba0:	68 05 98 02 00       	push   $0x29805
   18ba5:	eb 4a                	jmp    18bf1 <handle_request+0x9b1>
				obj_inst->resources[i].res_id);
   18ba7:	c1 e0 05             	shl    $0x5,%eax
   18baa:	03 43 08             	add    0x8(%ebx),%eax
   18bad:	89 c3                	mov    %eax,%ebx
		obj_field = lwm2m_get_engine_obj_field(obj,
   18baf:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   18bb3:	50                   	push   %eax
   18bb4:	57                   	push   %edi
   18bb5:	e8 6d e9 ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   18bba:	5f                   	pop    %edi
		if (!obj_field) {
   18bbb:	85 c0                	test   %eax,%eax
		obj_field = lwm2m_get_engine_obj_field(obj,
   18bbd:	5a                   	pop    %edx
		if (!obj_field) {
   18bbe:	75 43                	jne    18c03 <handle_request+0x9c3>
			LOG_ERR("unable to find obj_field: %u/%u/%u",
   18bc0:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18bc7:	74 30                	je     18bf9 <handle_request+0x9b9>
   18bc9:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18bce:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18bd3:	c1 e8 03             	shr    $0x3,%eax
   18bd6:	c1 e0 06             	shl    $0x6,%eax
   18bd9:	83 c8 01             	or     $0x1,%eax
   18bdc:	50                   	push   %eax
   18bdd:	0f b7 46 24          	movzwl 0x24(%esi),%eax
   18be1:	50                   	push   %eax
   18be2:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   18be6:	50                   	push   %eax
   18be7:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   18beb:	50                   	push   %eax
   18bec:	68 25 98 02 00       	push   $0x29825
   18bf1:	e8 3a a9 fe ff       	call   3530 <log_3>
   18bf6:	83 c4 14             	add    $0x14,%esp
			return -ENOENT;
   18bf9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   18bfe:	e9 79 01 00 00       	jmp    18d7c <handle_request+0xb3c>
		if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_R)) {
   18c03:	f6 40 02 01          	testb  $0x1,0x2(%eax)
   18c07:	0f 84 6c 01 00 00    	je     18d79 <handle_request+0xb39>
		ret = update_attrs(&obj_inst->resources[i], &attrs);
   18c0d:	8d 55 a4             	lea    -0x5c(%ebp),%edx
   18c10:	89 d8                	mov    %ebx,%eax
   18c12:	e8 43 de ff ff       	call   16a5a <update_attrs>
		if (ret < 0) {
   18c17:	85 c0                	test   %eax,%eax
   18c19:	0f 88 5d 01 00 00    	js     18d7c <handle_request+0xb3c>
		if (!observe_node_data[i].ctx) {
   18c1f:	6b bd d4 fe ff ff 3c 	imul   $0x3c,-0x12c(%ebp),%edi
   18c26:	83 bf 04 2b 40 00 00 	cmpl   $0x0,0x402b04(%edi)
   18c2d:	74 19                	je     18c48 <handle_request+0xa08>
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_OBSERVER; i++) {
   18c2f:	ff 85 d4 fe ff ff    	incl   -0x12c(%ebp)
   18c35:	83 bd d4 fe ff ff 0a 	cmpl   $0xa,-0x12c(%ebp)
   18c3c:	75 e1                	jne    18c1f <handle_request+0x9df>
		return -ENOMEM;
   18c3e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   18c43:	e9 34 01 00 00       	jmp    18d7c <handle_request+0xb3c>
	observe_node_data[i].ctx = msg->ctx;
   18c48:	8d 9f 00 2b 40 00    	lea    0x402b00(%edi),%ebx
   18c4e:	8b 06                	mov    (%esi),%eax
   18c50:	89 43 04             	mov    %eax,0x4(%ebx)
	memcpy(&observe_node_data[i].path, &msg->path, sizeof(msg->path));
   18c53:	6a 0a                	push   $0xa
   18c55:	8d 46 20             	lea    0x20(%esi),%eax
   18c58:	50                   	push   %eax
   18c59:	8d 87 08 2b 40 00    	lea    0x402b08(%edi),%eax
   18c5f:	50                   	push   %eax
   18c60:	e8 cc 1c ff ff       	call   a931 <memcpy>
   18c65:	83 c4 0c             	add    $0xc,%esp
	memcpy(observe_node_data[i].token, token, tkl);
   18c68:	81 c7 12 2b 40 00    	add    $0x402b12,%edi
   18c6e:	0f b6 85 d0 fe ff ff 	movzbl -0x130(%ebp),%eax
   18c75:	50                   	push   %eax
   18c76:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
   18c7c:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   18c82:	50                   	push   %eax
   18c83:	57                   	push   %edi
   18c84:	e8 a8 1c ff ff       	call   a931 <memcpy>
	observe_node_data[i].tkl = tkl;
   18c89:	8a 85 d0 fe ff ff    	mov    -0x130(%ebp),%al
	memcpy(observe_node_data[i].token, token, tkl);
   18c8f:	83 c4 0c             	add    $0xc,%esp
	observe_node_data[i].tkl = tkl;
   18c92:	88 43 3a             	mov    %al,0x3a(%ebx)
   18c95:	e8 77 bc 00 00       	call   24911 <z_impl_k_uptime_get>
	observe_node_data[i].last_timestamp = k_uptime_get();
   18c9a:	89 43 24             	mov    %eax,0x24(%ebx)
   18c9d:	89 53 28             	mov    %edx,0x28(%ebx)
	observe_node_data[i].event_timestamp =
   18ca0:	89 43 1c             	mov    %eax,0x1c(%ebx)
   18ca3:	89 53 20             	mov    %edx,0x20(%ebx)
	observe_node_data[i].max_period_sec = MAX(attrs.pmax, attrs.pmin);
   18ca6:	8b 45 c0             	mov    -0x40(%ebp),%eax
	observe_node_data[i].min_period_sec = attrs.pmin;
   18ca9:	8b 55 bc             	mov    -0x44(%ebp),%edx
   18cac:	89 53 2c             	mov    %edx,0x2c(%ebx)
	observe_node_data[i].max_period_sec = MAX(attrs.pmax, attrs.pmin);
   18caf:	39 d0                	cmp    %edx,%eax
   18cb1:	7d 02                	jge    18cb5 <handle_request+0xa75>
   18cb3:	89 d0                	mov    %edx,%eax
   18cb5:	89 43 30             	mov    %eax,0x30(%ebx)
	observe_node_data[i].format = format;
   18cb8:	8b bd c4 fe ff ff    	mov    -0x13c(%ebp),%edi
   18cbe:	6b 85 d4 fe ff ff 3c 	imul   $0x3c,-0x12c(%ebp),%eax
	sys_slist_append(&engine_observer_list,
   18cc5:	89 da                	mov    %ebx,%edx
	observe_node_data[i].format = format;
   18cc7:	66 89 b8 38 2b 40 00 	mov    %di,0x402b38(%eax)
	observe_node_data[i].counter = 1U;
   18cce:	c7 80 34 2b 40 00 01 	movl   $0x1,0x402b34(%eax)
   18cd5:	00 00 00 
	sys_slist_append(&engine_observer_list,
   18cd8:	b8 a0 43 40 00       	mov    $0x4043a0,%eax
   18cdd:	e8 7a dc ff ff       	call   1695c <sys_slist_append>
	LOG_DBG("OBSERVER ADDED %u/%u/%u(%u) token:'%s' addr:%s",
   18ce2:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   18ce9:	0f 84 4f 01 00 00    	je     18e3e <handle_request+0xbfe>
   18cef:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   18cf4:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
   18cfa:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   18cff:	c7 85 40 ff ff ff 54 	movl   $0x26254,-0xc0(%ebp)
   18d06:	62 02 00 
   18d09:	c1 e8 03             	shr    $0x3,%eax
   18d0c:	c1 e0 06             	shl    $0x6,%eax
   18d0f:	83 c8 04             	or     $0x4,%eax
   18d12:	89 c3                	mov    %eax,%ebx
   18d14:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   18d18:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
   18d1e:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   18d22:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
   18d28:	0f b7 46 24          	movzwl 0x24(%esi),%eax
   18d2c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
   18d32:	0f b6 46 28          	movzbl 0x28(%esi),%eax
   18d36:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
   18d3c:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   18d42:	e8 23 e3 ff ff       	call   1706a <sprint_token>
   18d47:	ff 36                	pushl  (%esi)
   18d49:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
   18d4f:	e8 74 e6 ff ff       	call   173c8 <lwm2m_sprint_ip_addr>
   18d54:	66 89 1c 24          	mov    %bx,(%esp)
   18d58:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
   18d5e:	6a 07                	push   $0x7
   18d60:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   18d66:	50                   	push   %eax
   18d67:	68 48 98 02 00       	push   $0x29848
   18d6c:	e8 18 a8 fe ff       	call   3589 <log_n>
   18d71:	83 c4 10             	add    $0x10,%esp
				if (r < 0) {
   18d74:	e9 c5 00 00 00       	jmp    18e3e <handle_request+0xbfe>
			return -EPERM;
   18d79:	83 c8 ff             	or     $0xffffffff,%eax
					LOG_ERR("add OBSERVE error: %d", r);
   18d7c:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18d83:	0f 84 0e 0e 00 00    	je     19b97 <handle_request+0x1957>
   18d89:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18d8e:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   18d94:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18d9a:	c1 ea 03             	shr    $0x3,%edx
   18d9d:	c1 e2 06             	shl    $0x6,%edx
   18da0:	83 ca 01             	or     $0x1,%edx
   18da3:	52                   	push   %edx
   18da4:	50                   	push   %eax
   18da5:	68 7b 98 02 00       	push   $0x2987b
   18daa:	e9 47 fb ff ff       	jmp    188f6 <handle_request+0x6b6>
				r = -EINVAL;
   18daf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
				LOG_ERR("OBSERVE request missing token");
   18db4:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18dbb:	0f 84 d6 0d 00 00    	je     19b97 <handle_request+0x1957>
   18dc1:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18dc6:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   18dcc:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18dd2:	c1 ea 03             	shr    $0x3,%edx
   18dd5:	c1 e2 06             	shl    $0x6,%edx
   18dd8:	83 ca 01             	or     $0x1,%edx
   18ddb:	52                   	push   %edx
   18ddc:	68 91 98 02 00       	push   $0x29891
   18de1:	e8 a4 a6 fe ff       	call   348a <log_0>
   18de6:	59                   	pop    %ecx
   18de7:	5b                   	pop    %ebx
   18de8:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
   18dee:	e9 a4 0d 00 00       	jmp    19b97 <handle_request+0x1957>
		} else if (observe == 1) {
   18df3:	83 bd d4 fe ff ff 01 	cmpl   $0x1,-0x12c(%ebp)
   18dfa:	75 42                	jne    18e3e <handle_request+0xbfe>
			r = engine_remove_observer(token, tkl);
   18dfc:	0f b6 95 d0 fe ff ff 	movzbl -0x130(%ebp),%edx
   18e03:	8d 85 f3 fe ff ff    	lea    -0x10d(%ebp),%eax
   18e09:	e8 d7 e2 ff ff       	call   170e5 <engine_remove_observer>
			if (r < 0) {
   18e0e:	85 c0                	test   %eax,%eax
   18e10:	79 2c                	jns    18e3e <handle_request+0xbfe>
				LOG_ERR("remove observe error: %d", r);
   18e12:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18e19:	74 23                	je     18e3e <handle_request+0xbfe>
   18e1b:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18e20:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18e26:	c1 ea 03             	shr    $0x3,%edx
   18e29:	c1 e2 06             	shl    $0x6,%edx
   18e2c:	83 ca 01             	or     $0x1,%edx
   18e2f:	52                   	push   %edx
   18e30:	50                   	push   %eax
   18e31:	68 c9 92 02 00       	push   $0x292c9
   18e36:	e8 74 a6 fe ff       	call   34af <log_1>
   18e3b:	83 c4 0c             	add    $0xc,%esp
		r = do_read_op(obj, msg, accept);
   18e3e:	0f b7 8d c4 fe ff ff 	movzwl -0x13c(%ebp),%ecx
   18e45:	89 f2                	mov    %esi,%edx
   18e47:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   18e4d:	e8 77 df ff ff       	call   16dc9 <do_read_op>
		break;
   18e52:	e9 d1 0c 00 00       	jmp    19b28 <handle_request+0x18e8>
	if (!msg->ctx->bootstrap_mode && !well_known &&
   18e57:	8b 06                	mov    (%esi),%eax
   18e59:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
   18e60:	75 1e                	jne    18e80 <handle_request+0xc40>
   18e62:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   18e69:	75 15                	jne    18e80 <handle_request+0xc40>
   18e6b:	80 7e 28 00          	cmpb   $0x0,0x28(%esi)
   18e6f:	0f 84 1f 0d 00 00    	je     19b94 <handle_request+0x1954>
	    (msg->path.level == 0 ||
   18e75:	66 83 7e 20 00       	cmpw   $0x0,0x20(%esi)
   18e7a:	0f 84 14 0d 00 00    	je     19b94 <handle_request+0x1954>
	ret = coap_append_option_int(msg->out.out_cpkt,
   18e80:	6a 28                	push   $0x28
   18e82:	6a 0c                	push   $0xc
   18e84:	ff 76 18             	pushl  0x18(%esi)
   18e87:	e8 1c f3 fe ff       	call   81a8 <coap_append_option_int>
   18e8c:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   18e8f:	85 c0                	test   %eax,%eax
   18e91:	79 33                	jns    18ec6 <handle_request+0xc86>
		LOG_ERR("Error setting response content-format: %d", ret);
   18e93:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   18e9a:	0f 84 f7 0c 00 00    	je     19b97 <handle_request+0x1957>
   18ea0:	ba cc 51 02 00       	mov    $0x251cc,%edx
   18ea5:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   18eab:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   18eb1:	c1 ea 03             	shr    $0x3,%edx
   18eb4:	c1 e2 06             	shl    $0x6,%edx
   18eb7:	83 ca 01             	or     $0x1,%edx
   18eba:	52                   	push   %edx
   18ebb:	50                   	push   %eax
   18ebc:	68 af 98 02 00       	push   $0x298af
   18ec1:	e9 30 fa ff ff       	jmp    188f6 <handle_request+0x6b6>
	ret = coap_packet_append_payload_marker(msg->out.out_cpkt);
   18ec6:	ff 76 18             	pushl  0x18(%esi)
   18ec9:	e8 97 f3 fe ff       	call   8265 <coap_packet_append_payload_marker>
   18ece:	5a                   	pop    %edx
	if (ret < 0) {
   18ecf:	85 c0                	test   %eax,%eax
   18ed1:	0f 88 c0 0c 00 00    	js     19b97 <handle_request+0x1957>
	if (well_known) {
   18ed7:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   18ede:	0f 84 8b 00 00 00    	je     18f6f <handle_request+0xd2f>
				 strlen(WELL_KNOWN_CORE_PATH));
   18ee4:	68 d9 98 02 00       	push   $0x298d9
   18ee9:	e8 75 19 ff ff       	call   a863 <strlen>
		ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
   18eee:	8b 5e 18             	mov    0x18(%esi),%ebx
   18ef1:	0f b7 c0             	movzwl %ax,%eax
   18ef4:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
   18ef8:	8d 53 04             	lea    0x4(%ebx),%edx
   18efb:	89 04 24             	mov    %eax,(%esp)
   18efe:	8b 03                	mov    (%ebx),%eax
   18f00:	68 d9 98 02 00       	push   $0x298d9
   18f05:	e8 a2 dc ff ff       	call   16bac <buf_append>
   18f0a:	5b                   	pop    %ebx
   18f0b:	5f                   	pop    %edi
		if (ret < 0) {
   18f0c:	85 c0                	test   %eax,%eax
   18f0e:	0f 88 83 0c 00 00    	js     19b97 <handle_request+0x1957>
		SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
   18f14:	8b 1d b0 43 40 00    	mov    0x4043b0,%ebx
   18f1a:	85 db                	test   %ebx,%ebx
   18f1c:	0f 84 0a 0c 00 00    	je     19b2c <handle_request+0x18ec>
			snprintk(disc_buf, sizeof(disc_buf), ",</%u>",
   18f22:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
   18f26:	50                   	push   %eax
   18f27:	68 ed 98 02 00       	push   $0x298ed
   18f2c:	6a 18                	push   $0x18
   18f2e:	68 40 43 40 00       	push   $0x404340
   18f33:	e8 a5 9c fe ff       	call   2bdd <snprintk>
   18f38:	83 c4 10             	add    $0x10,%esp
					 disc_buf, strlen(disc_buf));
   18f3b:	68 40 43 40 00       	push   $0x404340
   18f40:	e8 1e 19 ff ff       	call   a863 <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
   18f45:	8b 7e 18             	mov    0x18(%esi),%edi
   18f48:	0f b7 c0             	movzwl %ax,%eax
   18f4b:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
   18f4f:	8d 57 04             	lea    0x4(%edi),%edx
   18f52:	89 04 24             	mov    %eax,(%esp)
   18f55:	8b 07                	mov    (%edi),%eax
   18f57:	68 40 43 40 00       	push   $0x404340
   18f5c:	e8 4b dc ff ff       	call   16bac <buf_append>
   18f61:	5a                   	pop    %edx
   18f62:	59                   	pop    %ecx
			if (ret < 0) {
   18f63:	85 c0                	test   %eax,%eax
   18f65:	0f 88 2c 0c 00 00    	js     19b97 <handle_request+0x1957>
   18f6b:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
   18f6d:	eb ab                	jmp    18f1a <handle_request+0xcda>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst, node) {
   18f6f:	8b 1d a8 43 40 00    	mov    0x4043a8,%ebx
   18f75:	85 db                	test   %ebx,%ebx
   18f77:	0f 84 10 0c 00 00    	je     19b8d <handle_request+0x194d>
		if ((!msg->ctx->bootstrap_mode &&
   18f7d:	8b 43 04             	mov    0x4(%ebx),%eax
   18f80:	8b 16                	mov    (%esi),%edx
   18f82:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   18f86:	80 ba 80 01 00 00 00 	cmpb   $0x0,0x180(%edx)
   18f8d:	75 09                	jne    18f98 <handle_request+0xd58>
   18f8f:	66 85 c0             	test   %ax,%ax
   18f92:	0f 84 17 02 00 00    	je     191af <handle_request+0xf6f>
		     obj_inst->obj->obj_id == LWM2M_OBJECT_SECURITY_ID) ||
   18f98:	66 3b 46 20          	cmp    0x20(%esi),%ax
   18f9c:	0f 85 0d 02 00 00    	jne    191af <handle_request+0xf6f>
		if (msg->path.level == 1) {
   18fa2:	80 7e 28 01          	cmpb   $0x1,0x28(%esi)
   18fa6:	75 76                	jne    1901e <handle_request+0xdde>
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u>",
   18fa8:	ba ec 96 02 00       	mov    $0x296ec,%edx
   18fad:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   18fb4:	75 05                	jne    18fbb <handle_request+0xd7b>
   18fb6:	ba 7b 85 02 00       	mov    $0x2857b,%edx
   18fbb:	50                   	push   %eax
   18fbc:	52                   	push   %edx
   18fbd:	68 f4 98 02 00       	push   $0x298f4
   18fc2:	6a 18                	push   $0x18
   18fc4:	68 40 43 40 00       	push   $0x404340
   18fc9:	e8 0f 9c fe ff       	call   2bdd <snprintk>
   18fce:	83 c4 14             	add    $0x14,%esp
					 disc_buf, strlen(disc_buf));
   18fd1:	68 40 43 40 00       	push   $0x404340
   18fd6:	e8 88 18 ff ff       	call   a863 <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
   18fdb:	8b 7e 18             	mov    0x18(%esi),%edi
   18fde:	0f b7 c0             	movzwl %ax,%eax
   18fe1:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
   18fe5:	8d 57 04             	lea    0x4(%edi),%edx
   18fe8:	89 04 24             	mov    %eax,(%esp)
   18feb:	8b 07                	mov    (%edi),%eax
   18fed:	68 40 43 40 00       	push   $0x404340
   18ff2:	e8 b5 db ff ff       	call   16bac <buf_append>
   18ff7:	59                   	pop    %ecx
   18ff8:	5f                   	pop    %edi
			if (ret < 0) {
   18ff9:	85 c0                	test   %eax,%eax
   18ffb:	0f 88 96 0b 00 00    	js     19b97 <handle_request+0x1957>
			ret = print_attr(&msg->out, disc_buf, sizeof(disc_buf),
   19001:	8b 53 04             	mov    0x4(%ebx),%edx
   19004:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
   1900a:	e8 53 de ff ff       	call   16e62 <print_attr.constprop.17>
			if (ret < 0) {
   1900f:	85 c0                	test   %eax,%eax
   19011:	0f 88 80 0b 00 00    	js     19b97 <handle_request+0x1957>
			reported = true;
   19017:	c6 85 cc fe ff ff 01 	movb   $0x1,-0x134(%ebp)
		if (msg->path.level > 1 &&
   1901e:	8a 56 28             	mov    0x28(%esi),%dl
   19021:	80 fa 01             	cmp    $0x1,%dl
   19024:	0f 86 96 00 00 00    	jbe    190c0 <handle_request+0xe80>
		    msg->path.obj_inst_id != obj_inst->obj_inst_id) {
   1902a:	8b 43 0c             	mov    0xc(%ebx),%eax
		if (msg->path.level > 1 &&
   1902d:	66 39 46 22          	cmp    %ax,0x22(%esi)
   19031:	0f 85 78 01 00 00    	jne    191af <handle_request+0xf6f>
		if (msg->path.level == 2) {
   19037:	80 fa 02             	cmp    $0x2,%dl
   1903a:	0f 85 80 00 00 00    	jne    190c0 <handle_request+0xe80>
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u/%u>",
   19040:	0f b7 d0             	movzwl %ax,%edx
				 obj_inst->obj->obj_id, obj_inst->obj_inst_id);
   19043:	8b 43 04             	mov    0x4(%ebx),%eax
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u/%u>",
   19046:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   1904d:	0f b7 48 18          	movzwl 0x18(%eax),%ecx
   19051:	b8 ec 96 02 00       	mov    $0x296ec,%eax
   19056:	75 05                	jne    1905d <handle_request+0xe1d>
   19058:	b8 7b 85 02 00       	mov    $0x2857b,%eax
   1905d:	52                   	push   %edx
   1905e:	51                   	push   %ecx
   1905f:	50                   	push   %eax
   19060:	68 fc 98 02 00       	push   $0x298fc
   19065:	6a 18                	push   $0x18
   19067:	68 40 43 40 00       	push   $0x404340
   1906c:	e8 6c 9b fe ff       	call   2bdd <snprintk>
   19071:	83 c4 18             	add    $0x18,%esp
					 disc_buf, strlen(disc_buf));
   19074:	68 40 43 40 00       	push   $0x404340
   19079:	e8 e5 17 ff ff       	call   a863 <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
   1907e:	8b 7e 18             	mov    0x18(%esi),%edi
   19081:	0f b7 c0             	movzwl %ax,%eax
   19084:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
   19088:	8d 57 04             	lea    0x4(%edi),%edx
   1908b:	89 04 24             	mov    %eax,(%esp)
   1908e:	8b 07                	mov    (%edi),%eax
   19090:	68 40 43 40 00       	push   $0x404340
   19095:	e8 12 db ff ff       	call   16bac <buf_append>
   1909a:	5f                   	pop    %edi
   1909b:	5a                   	pop    %edx
			if (ret < 0) {
   1909c:	85 c0                	test   %eax,%eax
   1909e:	0f 88 f3 0a 00 00    	js     19b97 <handle_request+0x1957>
			ret = print_attr(&msg->out, disc_buf, sizeof(disc_buf),
   190a4:	89 da                	mov    %ebx,%edx
   190a6:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
   190ac:	e8 b1 dd ff ff       	call   16e62 <print_attr.constprop.17>
			if (ret < 0) {
   190b1:	85 c0                	test   %eax,%eax
   190b3:	0f 88 de 0a 00 00    	js     19b97 <handle_request+0x1957>
			reported = true;
   190b9:	c6 85 cc fe ff ff 01 	movb   $0x1,-0x134(%ebp)
		if (msg->ctx->bootstrap_mode) {
   190c0:	8b 06                	mov    (%esi),%eax
		for (int i = 0; i < obj_inst->resource_count; i++) {
   190c2:	31 ff                	xor    %edi,%edi
		if (msg->ctx->bootstrap_mode) {
   190c4:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
   190cb:	0f 85 de 00 00 00    	jne    191af <handle_request+0xf6f>
		for (int i = 0; i < obj_inst->resource_count; i++) {
   190d1:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
   190d5:	39 c7                	cmp    %eax,%edi
   190d7:	0f 8d d2 00 00 00    	jge    191af <handle_request+0xf6f>
			if (msg->path.level == 3 &&
   190dd:	89 f8                	mov    %edi,%eax
   190df:	c1 e0 05             	shl    $0x5,%eax
   190e2:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   190e8:	8b 43 08             	mov    0x8(%ebx),%eax
   190eb:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   190f1:	80 7e 28 03          	cmpb   $0x3,0x28(%esi)
   190f5:	0f b7 44 08 1a       	movzwl 0x1a(%eax,%ecx,1),%eax
   190fa:	75 0a                	jne    19106 <handle_request+0xec6>
   190fc:	66 3b 46 24          	cmp    0x24(%esi),%ax
   19100:	0f 85 a3 00 00 00    	jne    191a9 <handle_request+0xf69>
			snprintk(disc_buf, sizeof(disc_buf),
   19106:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
				 obj_inst->obj->obj_id,
   1910a:	8b 53 04             	mov    0x4(%ebx),%edx
			snprintk(disc_buf, sizeof(disc_buf),
   1910d:	89 8d d0 fe ff ff    	mov    %ecx,-0x130(%ebp)
   19113:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   1911a:	0f b7 4a 18          	movzwl 0x18(%edx),%ecx
   1911e:	ba ec 96 02 00       	mov    $0x296ec,%edx
   19123:	75 05                	jne    1912a <handle_request+0xeea>
   19125:	ba 7b 85 02 00       	mov    $0x2857b,%edx
   1912a:	50                   	push   %eax
   1912b:	ff b5 d0 fe ff ff    	pushl  -0x130(%ebp)
   19131:	51                   	push   %ecx
   19132:	52                   	push   %edx
   19133:	68 07 99 02 00       	push   $0x29907
   19138:	6a 18                	push   $0x18
   1913a:	68 40 43 40 00       	push   $0x404340
   1913f:	e8 99 9a fe ff       	call   2bdd <snprintk>
   19144:	83 c4 1c             	add    $0x1c,%esp
					 disc_buf, strlen(disc_buf));
   19147:	68 40 43 40 00       	push   $0x404340
   1914c:	e8 12 17 ff ff       	call   a863 <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
   19151:	8b 4e 18             	mov    0x18(%esi),%ecx
   19154:	8b 56 18             	mov    0x18(%esi),%edx
   19157:	0f b7 c0             	movzwl %ax,%eax
   1915a:	0f b7 49 06          	movzwl 0x6(%ecx),%ecx
   1915e:	89 04 24             	mov    %eax,(%esp)
   19161:	8b 46 18             	mov    0x18(%esi),%eax
   19164:	83 c2 04             	add    $0x4,%edx
   19167:	68 40 43 40 00       	push   $0x404340
   1916c:	8b 00                	mov    (%eax),%eax
   1916e:	e8 39 da ff ff       	call   16bac <buf_append>
   19173:	5a                   	pop    %edx
   19174:	59                   	pop    %ecx
			if (ret < 0) {
   19175:	85 c0                	test   %eax,%eax
   19177:	0f 88 1a 0a 00 00    	js     19b97 <handle_request+0x1957>
			if (msg->path.level > 1) {
   1917d:	80 7e 28 01          	cmpb   $0x1,0x28(%esi)
   19181:	77 09                	ja     1918c <handle_request+0xf4c>
			reported = true;
   19183:	c6 85 cc fe ff ff 01 	movb   $0x1,-0x134(%ebp)
   1918a:	eb 1d                	jmp    191a9 <handle_request+0xf69>
						 &obj_inst->resources[i]);
   1918c:	8b 95 d4 fe ff ff    	mov    -0x12c(%ebp),%edx
				ret = print_attr(&msg->out,
   19192:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
						 &obj_inst->resources[i]);
   19198:	03 53 08             	add    0x8(%ebx),%edx
				ret = print_attr(&msg->out,
   1919b:	e8 c2 dc ff ff       	call   16e62 <print_attr.constprop.17>
				if (ret < 0) {
   191a0:	85 c0                	test   %eax,%eax
   191a2:	79 df                	jns    19183 <handle_request+0xf43>
   191a4:	e9 ee 09 00 00       	jmp    19b97 <handle_request+0x1957>
		for (int i = 0; i < obj_inst->resource_count; i++) {
   191a9:	47                   	inc    %edi
   191aa:	e9 22 ff ff ff       	jmp    190d1 <handle_request+0xe91>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   191af:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst, node) {
   191b1:	85 db                	test   %ebx,%ebx
   191b3:	0f 85 c4 fd ff ff    	jne    18f7d <handle_request+0xd3d>
	return reported ? 0 : -ENOENT;
   191b9:	80 bd cc fe ff ff 00 	cmpb   $0x0,-0x134(%ebp)
   191c0:	0f 85 66 09 00 00    	jne    19b2c <handle_request+0x18ec>
   191c6:	e9 c2 09 00 00       	jmp    19b8d <handle_request+0x194d>
	switch (format) {
   191cb:	66 81 ff 06 06       	cmp    $0x606,%di
   191d0:	74 3b                	je     1920d <handle_request+0xfcd>
   191d2:	77 14                	ja     191e8 <handle_request+0xfa8>
   191d4:	66 83 ff 2a          	cmp    $0x2a,%di
   191d8:	74 25                	je     191ff <handle_request+0xfbf>
   191da:	66 81 ff 05 06       	cmp    $0x605,%di
   191df:	74 1e                	je     191ff <handle_request+0xfbf>
   191e1:	66 85 ff             	test   %di,%di
   191e4:	75 48                	jne    1922e <handle_request+0xfee>
   191e6:	eb 17                	jmp    191ff <handle_request+0xfbf>
   191e8:	66 81 ff 16 2d       	cmp    $0x2d16,%di
   191ed:	74 1e                	je     1920d <handle_request+0xfcd>
   191ef:	66 81 ff 17 2d       	cmp    $0x2d17,%di
   191f4:	74 25                	je     1921b <handle_request+0xfdb>
   191f6:	66 81 ff 07 06       	cmp    $0x607,%di
   191fb:	75 31                	jne    1922e <handle_request+0xfee>
   191fd:	eb 1c                	jmp    1921b <handle_request+0xfdb>
		return do_write_op_plain_text(obj, msg);
   191ff:	56                   	push   %esi
   19200:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
   19206:	e8 fe 3d 00 00       	call   1d009 <do_write_op_plain_text>
   1920b:	eb 1a                	jmp    19227 <handle_request+0xfe7>
		return do_write_op_tlv(obj, msg);
   1920d:	56                   	push   %esi
   1920e:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
   19214:	e8 49 4b 00 00       	call   1dd62 <do_write_op_tlv>
   19219:	eb 0c                	jmp    19227 <handle_request+0xfe7>
		return do_write_op_json(obj, msg);
   1921b:	56                   	push   %esi
   1921c:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
   19222:	e8 6d 77 00 00       	call   20994 <do_write_op_json>
   19227:	59                   	pop    %ecx
   19228:	5b                   	pop    %ebx
   19229:	e9 fa 08 00 00       	jmp    19b28 <handle_request+0x18e8>
		return -ENOMSG;
   1922e:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
		LOG_ERR("Unsupported format: %u", format);
   19233:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1923a:	0f 84 57 09 00 00    	je     19b97 <handle_request+0x1957>
   19240:	ba cc 51 02 00       	mov    $0x251cc,%edx
   19245:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   1924b:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   19251:	c1 ea 03             	shr    $0x3,%edx
   19254:	c1 e2 06             	shl    $0x6,%edx
   19257:	83 ca 01             	or     $0x1,%edx
   1925a:	52                   	push   %edx
   1925b:	0f b7 d7             	movzwl %di,%edx
   1925e:	52                   	push   %edx
   1925f:	68 15 99 02 00       	push   $0x29915
   19264:	e9 8d f6 ff ff       	jmp    188f6 <handle_request+0x6b6>
	struct notification_attrs nattrs = { 0 };
   19269:	31 c0                	xor    %eax,%eax
   1926b:	8d bd 1c ff ff ff    	lea    -0xe4(%ebp),%edi
   19271:	b9 09 00 00 00       	mov    $0x9,%ecx
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
   19276:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
	struct notification_attrs nattrs = { 0 };
   1927c:	f3 ab                	rep stos %eax,%es:(%edi)
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
   1927e:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
   19284:	89 95 08 ff ff ff    	mov    %edx,-0xf8(%ebp)
   1928a:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
   19290:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
   19296:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
   1929c:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
   192a2:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
	struct lwm2m_engine_res_inst *res = NULL;
   192a8:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
   192af:	00 00 00 
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
   192b2:	89 95 0c ff ff ff    	mov    %edx,-0xf4(%ebp)
   192b8:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
	if (!obj || !msg) {
   192be:	83 bd c8 fe ff ff 00 	cmpl   $0x0,-0x138(%ebp)
   192c5:	0f 84 bb 08 00 00    	je     19b86 <handle_request+0x1946>
	if (obj->obj_id == LWM2M_OBJECT_SECURITY_ID) {
   192cb:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   192d1:	66 83 78 18 00       	cmpw   $0x0,0x18(%eax)
   192d6:	0f 84 b1 08 00 00    	je     19b8d <handle_request+0x194d>
	nr_opt = coap_find_options(msg->in.in_cpkt, COAP_OPTION_URI_QUERY,
   192dc:	6a 05                	push   $0x5
   192de:	8d 45 a4             	lea    -0x5c(%ebp),%eax
   192e1:	50                   	push   %eax
   192e2:	6a 0f                	push   $0xf
   192e4:	ff 76 08             	pushl  0x8(%esi)
   192e7:	e8 a4 f0 fe ff       	call   8390 <coap_find_options>
   192ec:	83 c4 10             	add    $0x10,%esp
   192ef:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
	if (nr_opt <= 0) {
   192f5:	85 c0                	test   %eax,%eax
   192f7:	7f 32                	jg     1932b <handle_request+0x10eb>
		LOG_ERR("No attribute found!");
   192f9:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19300:	0f 84 dc 02 00 00    	je     195e2 <handle_request+0x13a2>
   19306:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1930b:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   19310:	c1 e8 03             	shr    $0x3,%eax
   19313:	c1 e0 06             	shl    $0x6,%eax
   19316:	83 c8 01             	or     $0x1,%eax
   19319:	50                   	push   %eax
   1931a:	68 2c 99 02 00       	push   $0x2992c
   1931f:	e8 66 a1 fe ff       	call   348a <log_0>
   19324:	58                   	pop    %eax
   19325:	5a                   	pop    %edx
	if (r < 0) {
   19326:	e9 b7 02 00 00       	jmp    195e2 <handle_request+0x13a2>
	if (msg->path.level == 3) {
   1932b:	8a 46 28             	mov    0x28(%esi),%al
   1932e:	3c 03                	cmp    $0x3,%al
   19330:	75 24                	jne    19356 <handle_request+0x1116>
		ret = path_to_objs(&msg->path, NULL, NULL, &res);
   19332:	8d 95 e0 fe ff ff    	lea    -0x120(%ebp),%edx
   19338:	31 c9                	xor    %ecx,%ecx
   1933a:	52                   	push   %edx
   1933b:	8d 46 20             	lea    0x20(%esi),%eax
   1933e:	31 d2                	xor    %edx,%edx
   19340:	e8 16 e2 ff ff       	call   1755b <path_to_objs>
   19345:	5f                   	pop    %edi
		if (ret < 0) {
   19346:	85 c0                	test   %eax,%eax
   19348:	0f 88 49 08 00 00    	js     19b97 <handle_request+0x1957>
		ref = res;
   1934e:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
   19354:	eb 35                	jmp    1938b <handle_request+0x114b>
	} else if (msg->path.level == 1) {
   19356:	3c 01                	cmp    $0x1,%al
   19358:	74 2b                	je     19385 <handle_request+0x1145>
	} else if (msg->path.level == 2) {
   1935a:	3c 02                	cmp    $0x2,%al
   1935c:	0f 85 80 02 00 00    	jne    195e2 <handle_request+0x13a2>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
   19362:	0f b7 56 22          	movzwl 0x22(%esi),%edx
   19366:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   1936a:	e8 7b d6 ff ff       	call   169ea <get_engine_obj_inst>
   1936f:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
		if (!obj_inst) {
   19375:	85 c0                	test   %eax,%eax
   19377:	0f 84 10 08 00 00    	je     19b8d <handle_request+0x194d>
   1937d:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
   19383:	eb 16                	jmp    1939b <handle_request+0x115b>
	} else if (msg->path.level == 1) {
   19385:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   1938b:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   19391:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%ebp)
   19398:	00 00 00 
	ret = update_attrs(ref, &nattrs);
   1939b:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
   193a1:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
   193a7:	e8 ae d6 ff ff       	call   16a5a <update_attrs>
	if (ret < 0) {
   193ac:	85 c0                	test   %eax,%eax
   193ae:	0f 88 e3 07 00 00    	js     19b97 <handle_request+0x1957>
   193b4:	8d 45 a4             	lea    -0x5c(%ebp),%eax
	for (i = 0; i < nr_opt; i++) {
   193b7:	c7 85 ac fe ff ff 00 	movl   $0x0,-0x154(%ebp)
   193be:	00 00 00 
   193c1:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
		int limit = MIN(options[i].len, 5), plen = 0, vlen;
   193c7:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
   193cd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
   193d1:	3c 05                	cmp    $0x5,%al
   193d3:	76 05                	jbe    193da <handle_request+0x119a>
   193d5:	b8 05 00 00 00       	mov    $0x5,%eax
		float32_value_t val = { 0 };
   193da:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
   193e1:	00 00 00 
   193e4:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
   193eb:	00 00 00 
		int limit = MIN(options[i].len, 5), plen = 0, vlen;
   193ee:	31 db                	xor    %ebx,%ebx
		while (plen < limit && options[i].value[plen] != '=') {
   193f0:	39 d8                	cmp    %ebx,%eax
   193f2:	7e 10                	jle    19404 <handle_request+0x11c4>
   193f4:	8b bd c4 fe ff ff    	mov    -0x13c(%ebp),%edi
   193fa:	80 7c 1f 03 3d       	cmpb   $0x3d,0x3(%edi,%ebx,1)
   193ff:	74 03                	je     19404 <handle_request+0x11c4>
			plen += 1;
   19401:	43                   	inc    %ebx
   19402:	eb ec                	jmp    193f0 <handle_request+0x11b0>
		if (plen != 2 && plen != 4) {
   19404:	8d 43 fe             	lea    -0x2(%ebx),%eax
   19407:	83 e0 fd             	and    $0xfffffffd,%eax
   1940a:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
   19410:	0f 85 a5 00 00 00    	jne    194bb <handle_request+0x127b>
   19416:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
   1941c:	8d 78 03             	lea    0x3(%eax),%edi
   1941f:	8a 85 d0 fe ff ff    	mov    -0x130(%ebp),%al
   19425:	88 85 b6 fe ff ff    	mov    %al,-0x14a(%ebp)
			if (LWM2M_ATTR_LEN[type] == plen &&
   1942b:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
   19431:	0f b6 80 48 63 02 00 	movzbl 0x26348(%eax),%eax
   19438:	39 c3                	cmp    %eax,%ebx
   1943a:	74 11                	je     1944d <handle_request+0x120d>
   1943c:	ff 85 d0 fe ff ff    	incl   -0x130(%ebp)
		for (type = 0U; type < NR_LWM2M_ATTR; type++) {
   19442:	83 bd d0 fe ff ff 05 	cmpl   $0x5,-0x130(%ebp)
   19449:	75 d4                	jne    1941f <handle_request+0x11df>
   1944b:	eb 6e                	jmp    194bb <handle_request+0x127b>
			    !memcmp(options[i].value, LWM2M_ATTR_STR[type],
   1944d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
   19453:	53                   	push   %ebx
   19454:	8b 04 85 50 63 02 00 	mov    0x26350(,%eax,4),%eax
   1945b:	50                   	push   %eax
   1945c:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
   19462:	57                   	push   %edi
   19463:	e8 5e 14 ff ff       	call   a8c6 <memcmp>
   19468:	83 c4 0c             	add    $0xc,%esp
			if (LWM2M_ATTR_LEN[type] == plen &&
   1946b:	85 c0                	test   %eax,%eax
   1946d:	75 cd                	jne    1943c <handle_request+0x11fc>
		if (options[i].len == plen) {
   1946f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
   19475:	0f b6 40 02          	movzbl 0x2(%eax),%eax
   19479:	39 c3                	cmp    %eax,%ebx
   1947b:	0f 85 e3 07 00 00    	jne    19c64 <handle_request+0x1a24>
			nattrs.flags &= ~BIT(type);
   19481:	8a 8d d0 fe ff ff    	mov    -0x130(%ebp),%cl
   19487:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1948c:	d3 c0                	rol    %cl,%eax
   1948e:	20 85 3c ff ff ff    	and    %al,-0xc4(%ebp)
			(void)memset(nattr_ptrs[type], 0,
   19494:	80 bd b6 fe ff ff 02 	cmpb   $0x2,-0x14a(%ebp)
   1949b:	19 c0                	sbb    %eax,%eax
   1949d:	83 e0 fc             	and    $0xfffffffc,%eax
   194a0:	83 c0 08             	add    $0x8,%eax
   194a3:	50                   	push   %eax
   194a4:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
   194aa:	6a 00                	push   $0x0
   194ac:	ff b4 85 08 ff ff ff 	pushl  -0xf8(%ebp,%eax,4)
   194b3:	e8 e8 14 ff ff       	call   a9a0 <memset>
   194b8:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < nr_opt; i++) {
   194bb:	ff 85 ac fe ff ff    	incl   -0x154(%ebp)
   194c1:	8b bd ac fe ff ff    	mov    -0x154(%ebp),%edi
   194c7:	83 85 c4 fe ff ff 10 	addl   $0x10,-0x13c(%ebp)
   194ce:	39 bd bc fe ff ff    	cmp    %edi,-0x144(%ebp)
   194d4:	0f 85 ed fe ff ff    	jne    193c7 <handle_request+0x1187>
	if ((nattrs.flags & (BIT(LWM2M_ATTR_PMIN) | BIT(LWM2M_ATTR_PMAX))) &&
   194da:	8a 85 3c ff ff ff    	mov    -0xc4(%ebp),%al
   194e0:	a8 03                	test   $0x3,%al
   194e2:	74 4a                	je     1952e <handle_request+0x12ee>
	    nattrs.pmin > nattrs.pmax) {
   194e4:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
   194ea:	8b 8d 38 ff ff ff    	mov    -0xc8(%ebp),%ecx
	if ((nattrs.flags & (BIT(LWM2M_ATTR_PMIN) | BIT(LWM2M_ATTR_PMAX))) &&
   194f0:	39 ca                	cmp    %ecx,%edx
   194f2:	7e 3a                	jle    1952e <handle_request+0x12ee>
		LOG_DBG("pmin (%d) > pmax (%d)", nattrs.pmin, nattrs.pmax);
   194f4:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   194fb:	0f 84 e1 00 00 00    	je     195e2 <handle_request+0x13a2>
   19501:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   19506:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1950b:	c1 e8 03             	shr    $0x3,%eax
   1950e:	c1 e0 06             	shl    $0x6,%eax
   19511:	83 c8 04             	or     $0x4,%eax
   19514:	50                   	push   %eax
   19515:	51                   	push   %ecx
   19516:	52                   	push   %edx
   19517:	68 38 62 02 00       	push   $0x26238
   1951c:	68 57 99 02 00       	push   $0x29957
   19521:	e8 0a a0 fe ff       	call   3530 <log_3>
   19526:	83 c4 14             	add    $0x14,%esp
	if (r < 0) {
   19529:	e9 b4 00 00 00       	jmp    195e2 <handle_request+0x13a2>
	if (nattrs.flags & (BIT(LWM2M_ATTR_LT) | BIT(LWM2M_ATTR_GT))) {
   1952e:	a8 0c                	test   $0xc,%al
   19530:	0f 84 b6 00 00 00    	je     195ec <handle_request+0x13ac>
		if (!((nattrs.lt.val1 < nattrs.gt.val1) ||
   19536:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
   1953c:	8b 9d 1c ff ff ff    	mov    -0xe4(%ebp),%ebx
   19542:	39 da                	cmp    %ebx,%edx
   19544:	7c 3b                	jl     19581 <handle_request+0x1341>
   19546:	8b bd 20 ff ff ff    	mov    -0xe0(%ebp),%edi
   1954c:	39 bd 28 ff ff ff    	cmp    %edi,-0xd8(%ebp)
   19552:	7c 2d                	jl     19581 <handle_request+0x1341>
			LOG_DBG("lt > gt");
   19554:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1955b:	0f 84 81 00 00 00    	je     195e2 <handle_request+0x13a2>
   19561:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   19566:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1956b:	c1 e8 03             	shr    $0x3,%eax
   1956e:	c1 e0 06             	shl    $0x6,%eax
   19571:	83 c8 04             	or     $0x4,%eax
   19574:	50                   	push   %eax
   19575:	68 38 62 02 00       	push   $0x26238
   1957a:	68 71 99 02 00       	push   $0x29971
   1957f:	eb 59                	jmp    195da <handle_request+0x139a>
		if (nattrs.flags & BIT(LWM2M_ATTR_STEP)) {
   19581:	a8 10                	test   $0x10,%al
   19583:	74 67                	je     195ec <handle_request+0x13ac>
				    nattrs.st.val2 * 2 / 1000000;
   19585:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
			s32_t st1 = nattrs.st.val1 * 2 +
   1958b:	8b 8d 2c ff ff ff    	mov    -0xd4(%ebp),%ecx
				    nattrs.st.val2 * 2 / 1000000;
   19591:	01 c0                	add    %eax,%eax
			s32_t st1 = nattrs.st.val1 * 2 +
   19593:	01 c9                	add    %ecx,%ecx
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
   19595:	01 d1                	add    %edx,%ecx
				    nattrs.st.val2 * 2 / 1000000;
   19597:	bf 40 42 0f 00       	mov    $0xf4240,%edi
   1959c:	99                   	cltd   
   1959d:	f7 ff                	idiv   %edi
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
   1959f:	01 c8                	add    %ecx,%eax
   195a1:	39 c3                	cmp    %eax,%ebx
   195a3:	7f 47                	jg     195ec <handle_request+0x13ac>
			      ((nattrs.lt.val2 + st2) < nattrs.gt.val2))) {
   195a5:	03 95 28 ff ff ff    	add    -0xd8(%ebp),%edx
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
   195ab:	3b 95 20 ff ff ff    	cmp    -0xe0(%ebp),%edx
   195b1:	7c 39                	jl     195ec <handle_request+0x13ac>
				LOG_DBG("lt + 2*st > gt");
   195b3:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   195ba:	74 26                	je     195e2 <handle_request+0x13a2>
   195bc:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   195c1:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   195c6:	c1 e8 03             	shr    $0x3,%eax
   195c9:	c1 e0 06             	shl    $0x6,%eax
   195cc:	83 c8 04             	or     $0x4,%eax
   195cf:	50                   	push   %eax
   195d0:	68 38 62 02 00       	push   $0x26238
   195d5:	68 7d 99 02 00       	push   $0x2997d
   195da:	e8 d0 9e fe ff       	call   34af <log_1>
   195df:	83 c4 0c             	add    $0xc,%esp
				return -EEXIST;
   195e2:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
   195e7:	e9 ab 05 00 00       	jmp    19b97 <handle_request+0x1957>
   195ec:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   195f1:	bb 00 28 40 00       	mov    $0x402800,%ebx
   195f6:	2d 3c 51 02 00       	sub    $0x2513c,%eax
		LOG_DBG("Update %s to %d.%06d", LWM2M_ATTR_STR[type],
   195fb:	c6 85 c4 fe ff ff 00 	movb   $0x0,-0x13c(%ebp)
   19602:	c1 e8 03             	shr    $0x3,%eax
   19605:	66 25 ff 03          	and    $0x3ff,%ax
   19609:	66 89 85 c0 fe ff ff 	mov    %ax,-0x140(%ebp)
   19610:	c1 e0 06             	shl    $0x6,%eax
   19613:	66 89 85 bc fe ff ff 	mov    %ax,-0x144(%ebp)
		if (ref != write_attr_pool[i].ref) {
   1961a:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
   19620:	3b 03                	cmp    (%ebx),%eax
   19622:	0f 85 37 01 00 00    	jne    1975f <handle_request+0x151f>
		type = attr->type;
   19628:	0f b6 7b 0c          	movzbl 0xc(%ebx),%edi
   1962c:	89 f8                	mov    %edi,%eax
   1962e:	8a 95 3c ff ff ff    	mov    -0xc4(%ebp),%dl
   19634:	88 85 d0 fe ff ff    	mov    %al,-0x130(%ebp)
		if (!(BIT(type) & nattrs.flags)) {
   1963a:	8b 8d d0 fe ff ff    	mov    -0x130(%ebp),%ecx
   19640:	0f b6 c2             	movzbl %dl,%eax
   19643:	0f a3 c8             	bt     %ecx,%eax
   19646:	72 52                	jb     1969a <handle_request+0x145a>
			LOG_DBG("Unset attr %s", LWM2M_ATTR_STR[type]);
   19648:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1964f:	74 23                	je     19674 <handle_request+0x1434>
   19651:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
   19657:	83 c8 04             	or     $0x4,%eax
   1965a:	50                   	push   %eax
   1965b:	ff 34 bd 50 63 02 00 	pushl  0x26350(,%edi,4)
   19662:	68 38 62 02 00       	push   $0x26238
   19667:	68 90 99 02 00       	push   $0x29990
   1966c:	e8 78 9e fe ff       	call   34e9 <log_2>
   19671:	83 c4 10             	add    $0x10,%esp
			(void)memset(attr, 0, sizeof(*attr));
   19674:	6a 10                	push   $0x10
   19676:	6a 00                	push   $0x0
   19678:	53                   	push   %ebx
   19679:	e8 22 13 ff ff       	call   a9a0 <memset>
   1967e:	83 c4 0c             	add    $0xc,%esp
			if (type <= LWM2M_ATTR_PMAX) {
   19681:	80 bd d0 fe ff ff 01 	cmpb   $0x1,-0x130(%ebp)
   19688:	0f 87 d1 00 00 00    	ja     1975f <handle_request+0x151f>
				update_observe_node = true;
   1968e:	c6 85 c4 fe ff ff 01 	movb   $0x1,-0x13c(%ebp)
   19695:	e9 c5 00 00 00       	jmp    1975f <handle_request+0x151f>
		nattrs.flags &= ~BIT(type);
   1969a:	8a 8d d0 fe ff ff    	mov    -0x130(%ebp),%cl
   196a0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   196a5:	d3 c0                	rol    %cl,%eax
   196a7:	21 d0                	and    %edx,%eax
   196a9:	8b 8c bd 08 ff ff ff 	mov    -0xf8(%ebp,%edi,4),%ecx
   196b0:	88 85 3c ff ff ff    	mov    %al,-0xc4(%ebp)
		if (type <= LWM2M_ATTR_PMAX) {
   196b6:	80 bd d0 fe ff ff 01 	cmpb   $0x1,-0x130(%ebp)
   196bd:	77 17                	ja     196d6 <handle_request+0x1496>
			if (attr->int_val == *(s32_t *)nattr_ptrs[type]) {
   196bf:	8b 01                	mov    (%ecx),%eax
   196c1:	39 43 04             	cmp    %eax,0x4(%ebx)
   196c4:	0f 84 95 00 00 00    	je     1975f <handle_request+0x151f>
			attr->int_val = *(s32_t *)nattr_ptrs[type];
   196ca:	89 43 04             	mov    %eax,0x4(%ebx)
			update_observe_node = true;
   196cd:	c6 85 c4 fe ff ff 01 	movb   $0x1,-0x13c(%ebp)
   196d4:	eb 37                	jmp    1970d <handle_request+0x14cd>
			if (!memcmp(&attr->float_val, nattr_ptrs[type],
   196d6:	6a 08                	push   $0x8
   196d8:	8d 53 04             	lea    0x4(%ebx),%edx
   196db:	51                   	push   %ecx
   196dc:	89 8d b8 fe ff ff    	mov    %ecx,-0x148(%ebp)
   196e2:	52                   	push   %edx
   196e3:	89 95 d0 fe ff ff    	mov    %edx,-0x130(%ebp)
   196e9:	e8 d8 11 ff ff       	call   a8c6 <memcmp>
   196ee:	83 c4 0c             	add    $0xc,%esp
   196f1:	85 c0                	test   %eax,%eax
   196f3:	74 6a                	je     1975f <handle_request+0x151f>
			memcpy(&attr->float_val, nattr_ptrs[type],
   196f5:	6a 08                	push   $0x8
   196f7:	8b 8d b8 fe ff ff    	mov    -0x148(%ebp),%ecx
   196fd:	51                   	push   %ecx
   196fe:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
   19704:	52                   	push   %edx
   19705:	e8 27 12 ff ff       	call   a931 <memcpy>
   1970a:	83 c4 0c             	add    $0xc,%esp
		LOG_DBG("Update %s to %d.%06d", LWM2M_ATTR_STR[type],
   1970d:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   19714:	74 49                	je     1975f <handle_request+0x151f>
   19716:	8b 14 bd 50 63 02 00 	mov    0x26350(,%edi,4),%edx
   1971d:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
   19723:	83 c8 04             	or     $0x4,%eax
   19726:	89 95 44 ff ff ff    	mov    %edx,-0xbc(%ebp)
   1972c:	8b 53 04             	mov    0x4(%ebx),%edx
   1972f:	c7 85 40 ff ff ff 38 	movl   $0x26238,-0xc0(%ebp)
   19736:	62 02 00 
   19739:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
   1973f:	8b 53 08             	mov    0x8(%ebx),%edx
   19742:	50                   	push   %eax
   19743:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   19749:	6a 04                	push   $0x4
   1974b:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%ebp)
   19751:	50                   	push   %eax
   19752:	68 a2 99 02 00       	push   $0x299a2
   19757:	e8 2d 9e fe ff       	call   3589 <log_n>
   1975c:	83 c4 10             	add    $0x10,%esp
   1975f:	83 c3 10             	add    $0x10,%ebx
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   19762:	b8 40 29 40 00       	mov    $0x402940,%eax
   19767:	39 d8                	cmp    %ebx,%eax
   19769:	0f 85 ab fe ff ff    	jne    1961a <handle_request+0x13da>
		LOG_DBG("Add %s to %d.%06d", LWM2M_ATTR_STR[type],
   1976f:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   19775:	c7 85 d0 fe ff ff 00 	movl   $0x0,-0x130(%ebp)
   1977c:	00 00 00 
		LOG_DBG("Add %s to %d.%06d", LWM2M_ATTR_STR[type],
   1977f:	c1 e0 06             	shl    $0x6,%eax
   19782:	66 89 85 b8 fe ff ff 	mov    %ax,-0x148(%ebp)
	for (type = 0U; nattrs.flags && type < NR_LWM2M_ATTR; type++) {
   19789:	0f b6 95 3c ff ff ff 	movzbl -0xc4(%ebp),%edx
   19790:	8a 85 d0 fe ff ff    	mov    -0x130(%ebp),%al
   19796:	3c 05                	cmp    $0x5,%al
   19798:	88 85 bc fe ff ff    	mov    %al,-0x144(%ebp)
   1979e:	0f 95 c3             	setne  %bl
   197a1:	88 c1                	mov    %al,%cl
   197a3:	84 d2                	test   %dl,%dl
   197a5:	0f 95 c0             	setne  %al
   197a8:	20 d8                	and    %bl,%al
   197aa:	0f 84 df 00 00 00    	je     1988f <handle_request+0x164f>
		if (!(BIT(type) & nattrs.flags)) {
   197b0:	8b bd d0 fe ff ff    	mov    -0x130(%ebp),%edi
   197b6:	0f a3 fa             	bt     %edi,%edx
   197b9:	0f 83 c5 00 00 00    	jae    19884 <handle_request+0x1644>
		for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   197bf:	31 db                	xor    %ebx,%ebx
			if (!write_attr_pool[i].ref) {
   197c1:	89 da                	mov    %ebx,%edx
   197c3:	c1 e2 04             	shl    $0x4,%edx
   197c6:	83 ba 00 28 40 00 00 	cmpl   $0x0,0x402800(%edx)
   197cd:	74 10                	je     197df <handle_request+0x159f>
		for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
   197cf:	43                   	inc    %ebx
   197d0:	83 fb 14             	cmp    $0x14,%ebx
   197d3:	75 ec                	jne    197c1 <handle_request+0x1581>
			return -ENOMEM;
   197d5:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   197da:	e9 b8 03 00 00       	jmp    19b97 <handle_request+0x1957>
		attr = write_attr_pool + i;
   197df:	8d ba 00 28 40 00    	lea    0x402800(%edx),%edi
		attr->ref = ref;
   197e5:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
		if (type <= LWM2M_ATTR_PMAX) {
   197eb:	80 bd bc fe ff ff 01 	cmpb   $0x1,-0x144(%ebp)
		attr->type = type;
   197f2:	88 4f 0c             	mov    %cl,0xc(%edi)
		attr->ref = ref;
   197f5:	8b 8d d0 fe ff ff    	mov    -0x130(%ebp),%ecx
   197fb:	89 9a 00 28 40 00    	mov    %ebx,0x402800(%edx)
		if (type <= LWM2M_ATTR_PMAX) {
   19801:	8b 94 8d 08 ff ff ff 	mov    -0xf8(%ebp,%ecx,4),%edx
   19808:	0f 87 55 06 00 00    	ja     19e63 <handle_request+0x1c23>
			attr->int_val = *(s32_t *)nattr_ptrs[type];
   1980e:	8b 12                	mov    (%edx),%edx
			update_observe_node = true;
   19810:	88 85 c4 fe ff ff    	mov    %al,-0x13c(%ebp)
			attr->int_val = *(s32_t *)nattr_ptrs[type];
   19816:	89 57 04             	mov    %edx,0x4(%edi)
		nattrs.flags &= ~BIT(type);
   19819:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1981e:	8a 8d d0 fe ff ff    	mov    -0x130(%ebp),%cl
   19824:	d3 c0                	rol    %cl,%eax
   19826:	20 85 3c ff ff ff    	and    %al,-0xc4(%ebp)
		LOG_DBG("Add %s to %d.%06d", LWM2M_ATTR_STR[type],
   1982c:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   19833:	74 4f                	je     19884 <handle_request+0x1644>
   19835:	8b 8d d0 fe ff ff    	mov    -0x130(%ebp),%ecx
   1983b:	8b 85 b8 fe ff ff    	mov    -0x148(%ebp),%eax
   19841:	83 c8 04             	or     $0x4,%eax
   19844:	8b 5f 08             	mov    0x8(%edi),%ebx
   19847:	8b 14 8d 50 63 02 00 	mov    0x26350(,%ecx,4),%edx
   1984e:	8b 4f 04             	mov    0x4(%edi),%ecx
   19851:	50                   	push   %eax
   19852:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   19858:	6a 04                	push   $0x4
   1985a:	c7 85 40 ff ff ff 38 	movl   $0x26238,-0xc0(%ebp)
   19861:	62 02 00 
   19864:	50                   	push   %eax
   19865:	89 95 44 ff ff ff    	mov    %edx,-0xbc(%ebp)
   1986b:	68 bb 99 02 00       	push   $0x299bb
   19870:	89 8d 48 ff ff ff    	mov    %ecx,-0xb8(%ebp)
   19876:	89 9d 4c ff ff ff    	mov    %ebx,-0xb4(%ebp)
   1987c:	e8 08 9d fe ff       	call   3589 <log_n>
   19881:	83 c4 10             	add    $0x10,%esp
   19884:	ff 85 d0 fe ff ff    	incl   -0x130(%ebp)
   1988a:	e9 fa fe ff ff       	jmp    19789 <handle_request+0x1549>
	if (!update_observe_node) {
   1988f:	80 bd c4 fe ff ff 00 	cmpb   $0x0,-0x13c(%ebp)
   19896:	0f 84 90 02 00 00    	je     19b2c <handle_request+0x18ec>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   1989c:	8b 1d a0 43 40 00    	mov    0x4043a0,%ebx
   198a2:	85 db                	test   %ebx,%ebx
   198a4:	0f 84 82 02 00 00    	je     19b2c <handle_request+0x18ec>
		LOG_DBG("%d/%d/%d(%d) updated from %d/%d to %u/%u",
   198aa:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
   198b0:	c1 e0 06             	shl    $0x6,%eax
   198b3:	66 89 85 d0 fe ff ff 	mov    %ax,-0x130(%ebp)
		if (msg->path.level > obs->path.level) {
   198ba:	8a 43 10             	mov    0x10(%ebx),%al
   198bd:	38 46 28             	cmp    %al,0x28(%esi)
   198c0:	0f 87 b8 01 00 00    	ja     19a7e <handle_request+0x183e>
		if (msg->path.obj_id != obs->path.obj_id) {
   198c6:	8b 43 08             	mov    0x8(%ebx),%eax
   198c9:	66 39 46 20          	cmp    %ax,0x20(%esi)
   198cd:	0f 85 ab 01 00 00    	jne    19a7e <handle_request+0x183e>
		ret = update_attrs(obj, &nattrs);
   198d3:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
   198d9:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
		nattrs.pmin = DEFAULT_SERVER_PMIN;
   198df:	c7 85 34 ff ff ff 0a 	movl   $0xa,-0xcc(%ebp)
   198e6:	00 00 00 
		nattrs.pmax = DEFAULT_SERVER_PMAX;
   198e9:	c7 85 38 ff ff ff 3c 	movl   $0x3c,-0xc8(%ebp)
   198f0:	00 00 00 
		ret = update_attrs(obj, &nattrs);
   198f3:	e8 62 d1 ff ff       	call   16a5a <update_attrs>
		if (ret < 0) {
   198f8:	85 c0                	test   %eax,%eax
   198fa:	0f 88 97 02 00 00    	js     19b97 <handle_request+0x1957>
		if (obs->path.level > 1) {
   19900:	80 7b 10 01          	cmpb   $0x1,0x10(%ebx)
   19904:	76 59                	jbe    1995f <handle_request+0x171f>
			if (msg->path.level > 1 &&
   19906:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
   1990a:	80 7e 28 01          	cmpb   $0x1,0x28(%esi)
   1990e:	76 0a                	jbe    1991a <handle_request+0x16da>
   19910:	66 39 56 22          	cmp    %dx,0x22(%esi)
   19914:	0f 85 64 01 00 00    	jne    19a7e <handle_request+0x183e>
			if (!obj_inst || obj_inst->obj_inst_id !=
   1991a:	83 bd d4 fe ff ff 00 	cmpl   $0x0,-0x12c(%ebp)
   19921:	74 0c                	je     1992f <handle_request+0x16ef>
   19923:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
   19929:	66 39 50 0c          	cmp    %dx,0xc(%eax)
   1992d:	74 17                	je     19946 <handle_request+0x1706>
				obj_inst = get_engine_obj_inst(
   1992f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
   19933:	e8 b2 d0 ff ff       	call   169ea <get_engine_obj_inst>
   19938:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
				if (!obj_inst) {
   1993e:	85 c0                	test   %eax,%eax
   19940:	0f 84 47 02 00 00    	je     19b8d <handle_request+0x194d>
			ret = update_attrs(obj_inst, &nattrs);
   19946:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
   1994c:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
   19952:	e8 03 d1 ff ff       	call   16a5a <update_attrs>
			if (ret < 0) {
   19957:	85 c0                	test   %eax,%eax
   19959:	0f 88 38 02 00 00    	js     19b97 <handle_request+0x1957>
		if (obs->path.level > 2) {
   1995f:	80 7b 10 02          	cmpb   $0x2,0x10(%ebx)
   19963:	77 0f                	ja     19974 <handle_request+0x1734>
		LOG_DBG("%d/%d/%d(%d) updated from %d/%d to %u/%u",
   19965:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1996c:	0f 84 e1 00 00 00    	je     19a53 <handle_request+0x1813>
   19972:	eb 5d                	jmp    199d1 <handle_request+0x1791>
			if (msg->path.level > 2 &&
   19974:	80 7e 28 02          	cmpb   $0x2,0x28(%esi)
   19978:	76 0d                	jbe    19987 <handle_request+0x1747>
   1997a:	8b 43 0c             	mov    0xc(%ebx),%eax
   1997d:	66 39 46 24          	cmp    %ax,0x24(%esi)
   19981:	0f 85 f7 00 00 00    	jne    19a7e <handle_request+0x183e>
			if (!res || res->res_id != obs->path.res_id) {
   19987:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
   1998d:	85 c0                	test   %eax,%eax
   1998f:	74 23                	je     199b4 <handle_request+0x1774>
   19991:	8b 7b 0c             	mov    0xc(%ebx),%edi
   19994:	66 39 78 1a          	cmp    %di,0x1a(%eax)
   19998:	75 1a                	jne    199b4 <handle_request+0x1774>
			ret = update_attrs(res, &nattrs);
   1999a:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
   199a0:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
   199a6:	e8 af d0 ff ff       	call   16a5a <update_attrs>
			if (ret < 0) {
   199ab:	85 c0                	test   %eax,%eax
   199ad:	79 b6                	jns    19965 <handle_request+0x1725>
   199af:	e9 e3 01 00 00       	jmp    19b97 <handle_request+0x1957>
				ret = path_to_objs(&obs->path, NULL, NULL,
   199b4:	8d 95 e0 fe ff ff    	lea    -0x120(%ebp),%edx
   199ba:	31 c9                	xor    %ecx,%ecx
   199bc:	52                   	push   %edx
   199bd:	8d 43 08             	lea    0x8(%ebx),%eax
   199c0:	31 d2                	xor    %edx,%edx
   199c2:	e8 94 db ff ff       	call   1755b <path_to_objs>
   199c7:	59                   	pop    %ecx
				if (ret < 0) {
   199c8:	85 c0                	test   %eax,%eax
   199ca:	79 ce                	jns    1999a <handle_request+0x175a>
   199cc:	e9 c6 01 00 00       	jmp    19b97 <handle_request+0x1957>
		LOG_DBG("%d/%d/%d(%d) updated from %d/%d to %u/%u",
   199d1:	0f b7 7b 08          	movzwl 0x8(%ebx),%edi
   199d5:	89 bd 44 ff ff ff    	mov    %edi,-0xbc(%ebp)
   199db:	c7 85 40 ff ff ff 38 	movl   $0x26238,-0xc0(%ebp)
   199e2:	62 02 00 
   199e5:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
   199e9:	89 bd 48 ff ff ff    	mov    %edi,-0xb8(%ebp)
   199ef:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
   199f5:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
   199f9:	89 bd 4c ff ff ff    	mov    %edi,-0xb4(%ebp)
   199ff:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
   19a05:	0f b6 7b 10          	movzbl 0x10(%ebx),%edi
   19a09:	89 bd 50 ff ff ff    	mov    %edi,-0xb0(%ebp)
   19a0f:	8b 8d d0 fe ff ff    	mov    -0x130(%ebp),%ecx
   19a15:	8b 7b 2c             	mov    0x2c(%ebx),%edi
   19a18:	83 c9 04             	or     $0x4,%ecx
   19a1b:	89 bd 54 ff ff ff    	mov    %edi,-0xac(%ebp)
   19a21:	39 d0                	cmp    %edx,%eax
   19a23:	8b 7b 30             	mov    0x30(%ebx),%edi
   19a26:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
   19a2c:	89 bd 58 ff ff ff    	mov    %edi,-0xa8(%ebp)
   19a32:	7d 02                	jge    19a36 <handle_request+0x17f6>
   19a34:	89 d0                	mov    %edx,%eax
   19a36:	51                   	push   %ecx
   19a37:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
   19a3d:	6a 09                	push   $0x9
   19a3f:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   19a45:	50                   	push   %eax
   19a46:	68 d1 99 02 00       	push   $0x299d1
   19a4b:	e8 39 9b fe ff       	call   3589 <log_n>
   19a50:	83 c4 10             	add    $0x10,%esp
		obs->min_period_sec = (u32_t)nattrs.pmin;
   19a53:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
		obs->max_period_sec = (u32_t)MAX(nattrs.pmin, nattrs.pmax);
   19a59:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
		obs->min_period_sec = (u32_t)nattrs.pmin;
   19a5f:	89 53 2c             	mov    %edx,0x2c(%ebx)
		obs->max_period_sec = (u32_t)MAX(nattrs.pmin, nattrs.pmax);
   19a62:	39 d0                	cmp    %edx,%eax
   19a64:	7d 02                	jge    19a68 <handle_request+0x1828>
   19a66:	89 d0                	mov    %edx,%eax
   19a68:	89 43 30             	mov    %eax,0x30(%ebx)
		(void)memset(&nattrs, 0, sizeof(nattrs));
   19a6b:	6a 24                	push   $0x24
   19a6d:	6a 00                	push   $0x0
   19a6f:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
   19a75:	50                   	push   %eax
   19a76:	e8 25 0f ff ff       	call   a9a0 <memset>
   19a7b:	83 c4 0c             	add    $0xc,%esp
   19a7e:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   19a80:	85 db                	test   %ebx,%ebx
   19a82:	0f 85 32 fe ff ff    	jne    198ba <handle_request+0x167a>
   19a88:	e9 9f 00 00 00       	jmp    19b2c <handle_request+0x18ec>
	struct lwm2m_engine_res_inst *res = NULL;
   19a8d:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
	if (!obj || !msg) {
   19a94:	83 bd c8 fe ff ff 00 	cmpl   $0x0,-0x138(%ebp)
   19a9b:	0f 84 e5 00 00 00    	je     19b86 <handle_request+0x1946>
	ret = path_to_objs(&msg->path, &obj_inst, NULL, &res);
   19aa1:	8d 55 a4             	lea    -0x5c(%ebp),%edx
   19aa4:	31 c9                	xor    %ecx,%ecx
   19aa6:	52                   	push   %edx
   19aa7:	8d 46 20             	lea    0x20(%esi),%eax
   19aaa:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
   19ab0:	e8 a6 da ff ff       	call   1755b <path_to_objs>
   19ab5:	5a                   	pop    %edx
	if (ret < 0) {
   19ab6:	85 c0                	test   %eax,%eax
   19ab8:	0f 88 d9 00 00 00    	js     19b97 <handle_request+0x1957>
	if (res->execute_cb) {
   19abe:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   19ac1:	8b 40 0c             	mov    0xc(%eax),%eax
   19ac4:	85 c0                	test   %eax,%eax
   19ac6:	0f 84 c1 00 00 00    	je     19b8d <handle_request+0x194d>
		return res->execute_cb(obj_inst->obj_inst_id);
   19acc:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
   19ad2:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
   19ad6:	52                   	push   %edx
   19ad7:	ff d0                	call   *%eax
   19ad9:	5f                   	pop    %edi
		break;
   19ada:	eb 4c                	jmp    19b28 <handle_request+0x18e8>
	ret = lwm2m_delete_obj_inst(msg->path.obj_id, msg->path.obj_inst_id);
   19adc:	0f b7 46 22          	movzwl 0x22(%esi),%eax
   19ae0:	50                   	push   %eax
   19ae1:	0f b7 46 20          	movzwl 0x20(%esi),%eax
   19ae5:	50                   	push   %eax
   19ae6:	e8 fc e0 ff ff       	call   17be7 <lwm2m_delete_obj_inst>
   19aeb:	59                   	pop    %ecx
	if (!ret && !msg->ctx->bootstrap_mode) {
   19aec:	85 c0                	test   %eax,%eax
	ret = lwm2m_delete_obj_inst(msg->path.obj_id, msg->path.obj_inst_id);
   19aee:	5b                   	pop    %ebx
	if (!ret && !msg->ctx->bootstrap_mode) {
   19aef:	75 37                	jne    19b28 <handle_request+0x18e8>
   19af1:	8b 06                	mov    (%esi),%eax
   19af3:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
   19afa:	75 30                	jne    19b2c <handle_request+0x18ec>
		engine_trigger_update();
   19afc:	e8 4b 55 00 00       	call   1f04c <engine_trigger_update>
   19b01:	eb 29                	jmp    19b2c <handle_request+0x18ec>
		LOG_ERR("Unknown operation: %u", msg->operation);
   19b03:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19b0a:	74 7a                	je     19b86 <handle_request+0x1946>
   19b0c:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   19b11:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   19b16:	c1 e8 03             	shr    $0x3,%eax
   19b19:	c1 e0 06             	shl    $0x6,%eax
   19b1c:	83 c8 01             	or     $0x1,%eax
   19b1f:	50                   	push   %eax
   19b20:	52                   	push   %edx
   19b21:	68 fe 99 02 00       	push   $0x299fe
   19b26:	eb 56                	jmp    19b7e <handle_request+0x193e>
	if (r < 0) {
   19b28:	85 c0                	test   %eax,%eax
   19b2a:	78 6b                	js     19b97 <handle_request+0x1957>
	if (block_ctx) {
   19b2c:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
   19b32:	85 c0                	test   %eax,%eax
   19b34:	0f 84 3d 03 00 00    	je     19e77 <handle_request+0x1c37>
		if (!last_block) {
   19b3a:	80 bd b7 fe ff ff 00 	cmpb   $0x0,-0x149(%ebp)
   19b41:	0f 85 14 01 00 00    	jne    19c5b <handle_request+0x1a1b>
			r = coap_append_block1_option(msg->out.out_cpkt,
   19b47:	50                   	push   %eax
   19b48:	ff 76 18             	pushl  0x18(%esi)
   19b4b:	e8 69 ea fe ff       	call   85b9 <coap_append_block1_option>
   19b50:	5f                   	pop    %edi
			if (r < 0) {
   19b51:	85 c0                	test   %eax,%eax
			r = coap_append_block1_option(msg->out.out_cpkt,
   19b53:	5a                   	pop    %edx
			if (r < 0) {
   19b54:	0f 89 1d 03 00 00    	jns    19e77 <handle_request+0x1c37>
				LOG_ERR("Fail adding block1 option: %d", r);
   19b5a:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19b61:	74 23                	je     19b86 <handle_request+0x1946>
   19b63:	ba cc 51 02 00       	mov    $0x251cc,%edx
   19b68:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   19b6e:	c1 ea 03             	shr    $0x3,%edx
   19b71:	c1 e2 06             	shl    $0x6,%edx
   19b74:	83 ca 01             	or     $0x1,%edx
   19b77:	52                   	push   %edx
   19b78:	50                   	push   %eax
   19b79:	68 14 9a 02 00       	push   $0x29a14
   19b7e:	e8 2c 99 fe ff       	call   34af <log_1>
   19b83:	83 c4 0c             	add    $0xc,%esp
				r = -EINVAL;
   19b86:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   19b8b:	eb 0a                	jmp    19b97 <handle_request+0x1957>
			r = -ENOENT;
   19b8d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   19b92:	eb 03                	jmp    19b97 <handle_request+0x1957>
		return -EPERM;
   19b94:	83 c8 ff             	or     $0xffffffff,%eax
	lwm2m_reset_message(msg, false);
   19b97:	6a 00                	push   $0x0
   19b99:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
   19b9f:	56                   	push   %esi
   19ba0:	e8 fd e2 ff ff       	call   17ea2 <lwm2m_reset_message>
   19ba5:	59                   	pop    %ecx
	if (r == -ENOENT) {
   19ba6:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
	lwm2m_reset_message(msg, false);
   19bac:	5b                   	pop    %ebx
	if (r == -ENOENT) {
   19bad:	83 f8 fe             	cmp    $0xfffffffe,%eax
   19bb0:	75 09                	jne    19bbb <handle_request+0x197b>
		msg->code = COAP_RESPONSE_CODE_NOT_FOUND;
   19bb2:	c6 86 83 01 00 00 84 	movb   $0x84,0x183(%esi)
   19bb9:	eb 5b                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -EPERM) {
   19bbb:	83 f8 ff             	cmp    $0xffffffff,%eax
   19bbe:	75 09                	jne    19bc9 <handle_request+0x1989>
		msg->code = COAP_RESPONSE_CODE_NOT_ALLOWED;
   19bc0:	c6 86 83 01 00 00 85 	movb   $0x85,0x183(%esi)
   19bc7:	eb 4d                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -EEXIST) {
   19bc9:	83 f8 ef             	cmp    $0xffffffef,%eax
   19bcc:	75 09                	jne    19bd7 <handle_request+0x1997>
		msg->code = COAP_RESPONSE_CODE_BAD_REQUEST;
   19bce:	c6 86 83 01 00 00 80 	movb   $0x80,0x183(%esi)
   19bd5:	eb 3f                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -EFAULT) {
   19bd7:	83 f8 f2             	cmp    $0xfffffff2,%eax
   19bda:	75 09                	jne    19be5 <handle_request+0x19a5>
		msg->code = COAP_RESPONSE_CODE_INCOMPLETE;
   19bdc:	c6 86 83 01 00 00 88 	movb   $0x88,0x183(%esi)
   19be3:	eb 31                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -EFBIG) {
   19be5:	83 f8 e5             	cmp    $0xffffffe5,%eax
   19be8:	75 09                	jne    19bf3 <handle_request+0x19b3>
		msg->code = COAP_RESPONSE_CODE_REQUEST_TOO_LARGE;
   19bea:	c6 86 83 01 00 00 8d 	movb   $0x8d,0x183(%esi)
   19bf1:	eb 23                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -ENOTSUP) {
   19bf3:	83 f8 dd             	cmp    $0xffffffdd,%eax
   19bf6:	75 09                	jne    19c01 <handle_request+0x19c1>
		msg->code = COAP_RESPONSE_CODE_NOT_IMPLEMENTED;
   19bf8:	c6 86 83 01 00 00 a1 	movb   $0xa1,0x183(%esi)
   19bff:	eb 15                	jmp    19c16 <handle_request+0x19d6>
	} else if (r == -ENOMSG) {
   19c01:	83 f8 b0             	cmp    $0xffffffb0,%eax
   19c04:	75 09                	jne    19c0f <handle_request+0x19cf>
		msg->code = COAP_RESPONSE_CODE_UNSUPPORTED_CONTENT_FORMAT;
   19c06:	c6 86 83 01 00 00 8f 	movb   $0x8f,0x183(%esi)
   19c0d:	eb 07                	jmp    19c16 <handle_request+0x19d6>
		msg->code = COAP_RESPONSE_CODE_INTERNAL_ERROR;
   19c0f:	c6 86 83 01 00 00 a0 	movb   $0xa0,0x183(%esi)
	r = lwm2m_init_message(msg);
   19c16:	56                   	push   %esi
   19c17:	e8 11 e4 ff ff       	call   1802d <lwm2m_init_message>
   19c1c:	5a                   	pop    %edx
	if (r < 0) {
   19c1d:	85 c0                	test   %eax,%eax
   19c1f:	79 2c                	jns    19c4d <handle_request+0x1a0d>
		LOG_ERR("Error recreating message: %d", r);
   19c21:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19c28:	74 23                	je     19c4d <handle_request+0x1a0d>
   19c2a:	ba cc 51 02 00       	mov    $0x251cc,%edx
   19c2f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   19c35:	c1 ea 03             	shr    $0x3,%edx
   19c38:	c1 e2 06             	shl    $0x6,%edx
   19c3b:	83 ca 01             	or     $0x1,%edx
   19c3e:	52                   	push   %edx
   19c3f:	50                   	push   %eax
   19c40:	68 32 9a 02 00       	push   $0x29a32
   19c45:	e8 65 98 fe ff       	call   34af <log_1>
   19c4a:	83 c4 0c             	add    $0xc,%esp
	free_block_ctx(block_ctx);
   19c4d:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
	if (ctx == NULL) {
   19c53:	85 c0                	test   %eax,%eax
   19c55:	0f 84 1c 02 00 00    	je     19e77 <handle_request+0x1c37>
	ctx->tkl = 0U;
   19c5b:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
   19c5f:	e9 13 02 00 00       	jmp    19e77 <handle_request+0x1c37>
		if (plen == 2 && msg->path.level <= 2) {
   19c64:	83 fb 02             	cmp    $0x2,%ebx
   19c67:	75 0a                	jne    19c73 <handle_request+0x1a33>
   19c69:	80 7e 28 02          	cmpb   $0x2,0x28(%esi)
   19c6d:	0f 86 6f f9 ff ff    	jbe    195e2 <handle_request+0x13a2>
		vlen = options[i].len - plen - 1;
   19c73:	48                   	dec    %eax
   19c74:	29 d8                	sub    %ebx,%eax
		memcpy(opt_buf, options[i].value + plen + 1, vlen);
   19c76:	50                   	push   %eax
   19c77:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
   19c7d:	8d 44 1f 01          	lea    0x1(%edi,%ebx,1),%eax
   19c81:	8d bd fb fe ff ff    	lea    -0x105(%ebp),%edi
   19c87:	50                   	push   %eax
   19c88:	57                   	push   %edi
   19c89:	e8 a3 0c ff ff       	call   a931 <memcpy>
		opt_buf[vlen] = '\0';
   19c8e:	8b 95 c0 fe ff ff    	mov    -0x140(%ebp),%edx
		memcpy(opt_buf, options[i].value + plen + 1, vlen);
   19c94:	83 c4 0c             	add    $0xc,%esp
		if (plen == 4) {
   19c97:	83 fb 04             	cmp    $0x4,%ebx
		opt_buf[vlen] = '\0';
   19c9a:	c6 84 15 fb fe ff ff 	movb   $0x0,-0x105(%ebp,%edx,1)
   19ca1:	00 
		if (plen == 4) {
   19ca2:	75 4e                	jne    19cf2 <handle_request+0x1ab2>
   19ca4:	e8 3f 90 00 00       	call   22ce8 <z_impl_z_errno>
			errno = 0;
   19ca9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			v = strtol(opt_buf, &end, 10);
   19caf:	6a 0a                	push   $0xa
   19cb1:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   19cb7:	50                   	push   %eax
   19cb8:	57                   	push   %edi
   19cb9:	e8 2d 08 ff ff       	call   a4eb <strtol>
   19cbe:	83 c4 0c             	add    $0xc,%esp
   19cc1:	89 c3                	mov    %eax,%ebx
   19cc3:	e8 20 90 00 00       	call   22ce8 <z_impl_z_errno>
			if (errno || *end || v < 0) {
   19cc8:	83 38 00             	cmpl   $0x0,(%eax)
   19ccb:	75 0f                	jne    19cdc <handle_request+0x1a9c>
   19ccd:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
   19cd3:	80 38 00             	cmpb   $0x0,(%eax)
   19cd6:	75 04                	jne    19cdc <handle_request+0x1a9c>
   19cd8:	85 db                	test   %ebx,%ebx
   19cda:	79 0b                	jns    19ce7 <handle_request+0x1aa7>
			val.val1 = v;
   19cdc:	89 9d e8 fe ff ff    	mov    %ebx,-0x118(%ebp)
		if (ret < 0) {
   19ce2:	e9 01 01 00 00       	jmp    19de8 <handle_request+0x1ba8>
			val.val1 = v;
   19ce7:	89 9d e8 fe ff ff    	mov    %ebx,-0x118(%ebp)
		if (ret < 0) {
   19ced:	e9 27 01 00 00       	jmp    19e19 <handle_request+0x1bd9>
	strncpy(buf, input, sizeof(buf) - 1);
   19cf2:	6a 17                	push   $0x17
   19cf4:	8d 9d 40 ff ff ff    	lea    -0xc0(%ebp),%ebx
   19cfa:	57                   	push   %edi
   19cfb:	53                   	push   %ebx
   19cfc:	e8 ec 0a ff ff       	call   a7ed <strncpy>
   19d01:	83 c4 0c             	add    $0xc,%esp
	buf[sizeof(buf) - 1] = '\0';
   19d04:	c6 85 57 ff ff ff 00 	movb   $0x0,-0xa9(%ebp)
	if (strchr(buf, '-')) {
   19d0b:	6a 2d                	push   $0x2d
   19d0d:	53                   	push   %ebx
   19d0e:	e8 16 0b ff ff       	call   a829 <strchr>
   19d13:	5f                   	pop    %edi
		sign = -1;
   19d14:	83 f8 01             	cmp    $0x1,%eax
   19d17:	19 ff                	sbb    %edi,%edi
	if (strchr(buf, '-')) {
   19d19:	5a                   	pop    %edx
	pos = strchr(buf, '.');
   19d1a:	6a 2e                	push   $0x2e
		sign = -1;
   19d1c:	83 e7 02             	and    $0x2,%edi
	pos = strchr(buf, '.');
   19d1f:	53                   	push   %ebx
   19d20:	e8 04 0b ff ff       	call   a829 <strchr>
   19d25:	59                   	pop    %ecx
		sign = -1;
   19d26:	4f                   	dec    %edi
	pos = strchr(buf, '.');
   19d27:	5b                   	pop    %ebx
	if (pos) {
   19d28:	85 c0                	test   %eax,%eax
	pos = strchr(buf, '.');
   19d2a:	89 c3                	mov    %eax,%ebx
	if (pos) {
   19d2c:	74 03                	je     19d31 <handle_request+0x1af1>
		*pos = '\0';
   19d2e:	c6 00 00             	movb   $0x0,(%eax)
   19d31:	e8 b2 8f 00 00       	call   22ce8 <z_impl_z_errno>
	errno = 0;
   19d36:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	val = strtol(buf, &end, 10);
   19d3c:	6a 0a                	push   $0xa
   19d3e:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
   19d44:	50                   	push   %eax
   19d45:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
   19d4b:	50                   	push   %eax
   19d4c:	e8 9a 07 ff ff       	call   a4eb <strtol>
   19d51:	83 c4 0c             	add    $0xc,%esp
   19d54:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
   19d5a:	e8 89 8f 00 00       	call   22ce8 <z_impl_z_errno>
	if (errno || *end || val < INT_MIN) {
   19d5f:	83 38 00             	cmpl   $0x0,(%eax)
   19d62:	0f 85 80 00 00 00    	jne    19de8 <handle_request+0x1ba8>
   19d68:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
   19d6e:	80 38 00             	cmpb   $0x0,(%eax)
   19d71:	75 75                	jne    19de8 <handle_request+0x1ba8>
	out->val1 = (s32_t) val;
   19d73:	8b 95 c0 fe ff ff    	mov    -0x140(%ebp),%edx
	out->val2 = 0;
   19d79:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
   19d80:	00 00 00 
	out->val1 = (s32_t) val;
   19d83:	89 95 e8 fe ff ff    	mov    %edx,-0x118(%ebp)
	s32_t base = 1000000, sign = 1;
   19d89:	b8 40 42 0f 00       	mov    $0xf4240,%eax
	if (!pos) {
   19d8e:	85 db                	test   %ebx,%ebx
   19d90:	0f 84 83 00 00 00    	je     19e19 <handle_request+0x1bd9>
	while (*(++pos) && base > 1 && isdigit((unsigned char)*pos)) {
   19d96:	43                   	inc    %ebx
   19d97:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
   19d9d:	0f be 0b             	movsbl (%ebx),%ecx
   19da0:	89 95 c0 fe ff ff    	mov    %edx,-0x140(%ebp)
   19da6:	8d 51 d0             	lea    -0x30(%ecx),%edx
   19da9:	80 fa 09             	cmp    $0x9,%dl
   19dac:	77 20                	ja     19dce <handle_request+0x1b8e>
   19dae:	83 f8 01             	cmp    $0x1,%eax
   19db1:	7e 1b                	jle    19dce <handle_request+0x1b8e>
		out->val2 = out->val2 * 10 + (*pos - '0');
   19db3:	6b 95 c0 fe ff ff 0a 	imul   $0xa,-0x140(%ebp),%edx
   19dba:	8d 54 0a d0          	lea    -0x30(%edx,%ecx,1),%edx
		base /= 10;
   19dbe:	b9 0a 00 00 00       	mov    $0xa,%ecx
		out->val2 = out->val2 * 10 + (*pos - '0');
   19dc3:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
		base /= 10;
   19dc9:	99                   	cltd   
   19dca:	f7 f9                	idiv   %ecx
   19dcc:	eb c8                	jmp    19d96 <handle_request+0x1b56>
	out->val2 *= sign * base;
   19dce:	8b 95 c0 fe ff ff    	mov    -0x140(%ebp),%edx
   19dd4:	0f af d0             	imul   %eax,%edx
   19dd7:	0f af d7             	imul   %edi,%edx
   19dda:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
	return !*pos || base == 1 ? 0 : -EINVAL;
   19de0:	80 3b 00             	cmpb   $0x0,(%ebx)
   19de3:	74 34                	je     19e19 <handle_request+0x1bd9>
   19de5:	48                   	dec    %eax
   19de6:	74 31                	je     19e19 <handle_request+0x1bd9>
			LOG_ERR("invalid attr[%s] value",
   19de8:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19def:	0f 84 ed f7 ff ff    	je     195e2 <handle_request+0x13a2>
   19df5:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   19dfa:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   19dff:	c1 e8 03             	shr    $0x3,%eax
   19e02:	c1 e0 06             	shl    $0x6,%eax
   19e05:	83 c8 01             	or     $0x1,%eax
   19e08:	50                   	push   %eax
   19e09:	ff b5 b8 fe ff ff    	pushl  -0x148(%ebp)
   19e0f:	68 40 99 02 00       	push   $0x29940
   19e14:	e9 c1 f7 ff ff       	jmp    195da <handle_request+0x139a>
		if (type <= LWM2M_ATTR_PMAX) {
   19e19:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
   19e1f:	80 bd b6 fe ff ff 01 	cmpb   $0x1,-0x14a(%ebp)
   19e26:	8b 84 85 08 ff ff ff 	mov    -0xf8(%ebp,%eax,4),%eax
   19e2d:	77 0a                	ja     19e39 <handle_request+0x1bf9>
			*(s32_t *)nattr_ptrs[type] = val.val1;
   19e2f:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
   19e35:	89 10                	mov    %edx,(%eax)
   19e37:	eb 12                	jmp    19e4b <handle_request+0x1c0b>
			memcpy(nattr_ptrs[type], &val, sizeof(float32_value_t));
   19e39:	6a 08                	push   $0x8
   19e3b:	8d 95 e8 fe ff ff    	lea    -0x118(%ebp),%edx
   19e41:	52                   	push   %edx
   19e42:	50                   	push   %eax
   19e43:	e8 e9 0a ff ff       	call   a931 <memcpy>
   19e48:	83 c4 0c             	add    $0xc,%esp
		nattrs.flags |= BIT(type);
   19e4b:	b8 01 00 00 00       	mov    $0x1,%eax
   19e50:	8a 8d d0 fe ff ff    	mov    -0x130(%ebp),%cl
   19e56:	d3 e0                	shl    %cl,%eax
   19e58:	08 85 3c ff ff ff    	or     %al,-0xc4(%ebp)
   19e5e:	e9 58 f6 ff ff       	jmp    194bb <handle_request+0x127b>
			memcpy(&attr->float_val, nattr_ptrs[type],
   19e63:	6a 08                	push   $0x8
   19e65:	8d 47 04             	lea    0x4(%edi),%eax
   19e68:	52                   	push   %edx
   19e69:	50                   	push   %eax
   19e6a:	e8 c2 0a ff ff       	call   a931 <memcpy>
   19e6f:	83 c4 0c             	add    $0xc,%esp
   19e72:	e9 a2 f9 ff ff       	jmp    19819 <handle_request+0x15d9>
}
   19e77:	8d 65 f4             	lea    -0xc(%ebp),%esp
   19e7a:	31 c0                	xor    %eax,%eax
   19e7c:	5b                   	pop    %ebx
   19e7d:	5e                   	pop    %esi
   19e7e:	5f                   	pop    %edi
   19e7f:	5d                   	pop    %ebp
   19e80:	c3                   	ret    

00019e81 <lwm2m_send_message>:
{
   19e81:	55                   	push   %ebp
   19e82:	89 e5                	mov    %esp,%ebp
   19e84:	56                   	push   %esi
   19e85:	53                   	push   %ebx
   19e86:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!msg || !msg->ctx) {
   19e89:	85 db                	test   %ebx,%ebx
   19e8b:	74 05                	je     19e92 <lwm2m_send_message+0x11>
   19e8d:	83 3b 00             	cmpl   $0x0,(%ebx)
   19e90:	75 37                	jne    19ec9 <lwm2m_send_message+0x48>
		return -EINVAL;
   19e92:	be ea ff ff ff       	mov    $0xffffffea,%esi
		LOG_ERR("LwM2M message is invalid.");
   19e97:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19e9e:	0f 84 c2 00 00 00    	je     19f66 <lwm2m_send_message+0xe5>
   19ea4:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   19ea9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   19eae:	c1 e8 03             	shr    $0x3,%eax
   19eb1:	c1 e0 06             	shl    $0x6,%eax
   19eb4:	83 c8 01             	or     $0x1,%eax
   19eb7:	50                   	push   %eax
   19eb8:	68 1c 96 02 00       	push   $0x2961c
   19ebd:	e8 c8 95 fe ff       	call   348a <log_0>
   19ec2:	58                   	pop    %eax
   19ec3:	5a                   	pop    %edx
   19ec4:	e9 9d 00 00 00       	jmp    19f66 <lwm2m_send_message+0xe5>
	if (msg->type == COAP_TYPE_CON) {
   19ec9:	80 bb 82 01 00 00 00 	cmpb   $0x0,0x182(%ebx)
   19ed0:	75 0c                	jne    19ede <lwm2m_send_message+0x5d>
		coap_pending_cycle(msg->pending);
   19ed2:	ff b3 6c 01 00 00    	pushl  0x16c(%ebx)
   19ed8:	e8 b2 e9 fe ff       	call   888f <coap_pending_cycle>
   19edd:	5e                   	pop    %esi
	msg->send_attempts++;
   19ede:	fe 83 86 01 00 00    	incb   0x186(%ebx)
   19ee4:	6a 00                	push   $0x0
   19ee6:	6a 00                	push   $0x0
	if (send(msg->ctx->sock_fd, msg->cpkt.data, msg->cpkt.offset, 0) < 0) {
   19ee8:	0f b7 43 30          	movzwl 0x30(%ebx),%eax
   19eec:	6a 00                	push   $0x0
   19eee:	50                   	push   %eax
   19eef:	8b 03                	mov    (%ebx),%eax
   19ef1:	ff 73 2c             	pushl  0x2c(%ebx)
   19ef4:	ff b0 84 01 00 00    	pushl  0x184(%eax)
   19efa:	e8 01 f1 fe ff       	call   9000 <z_impl_zsock_sendto>
   19eff:	83 c4 18             	add    $0x18,%esp
   19f02:	85 c0                	test   %eax,%eax
   19f04:	79 20                	jns    19f26 <lwm2m_send_message+0xa5>
		if (msg->type == COAP_TYPE_CON) {
   19f06:	80 bb 82 01 00 00 00 	cmpb   $0x0,0x182(%ebx)
   19f0d:	75 0c                	jne    19f1b <lwm2m_send_message+0x9a>
			coap_pending_clear(msg->pending);
   19f0f:	ff b3 6c 01 00 00    	pushl  0x16c(%ebx)
   19f15:	e8 c4 e9 fe ff       	call   88de <coap_pending_clear>
   19f1a:	59                   	pop    %ecx
   19f1b:	e8 c8 8d 00 00       	call   22ce8 <z_impl_z_errno>
		return -errno;
   19f20:	8b 30                	mov    (%eax),%esi
   19f22:	f7 de                	neg    %esi
   19f24:	eb 40                	jmp    19f66 <lwm2m_send_message+0xe5>
	if (msg->type == COAP_TYPE_CON) {
   19f26:	80 bb 82 01 00 00 00 	cmpb   $0x0,0x182(%ebx)
   19f2d:	75 2b                	jne    19f5a <lwm2m_send_message+0xd9>
			return 0;
   19f2f:	31 f6                	xor    %esi,%esi
		if (msg->send_attempts > 1) {
   19f31:	80 bb 86 01 00 00 01 	cmpb   $0x1,0x186(%ebx)
   19f38:	77 2c                	ja     19f66 <lwm2m_send_message+0xe5>
		k_delayed_work_submit(&msg->ctx->retransmit_work,
   19f3a:	8b 83 6c 01 00 00    	mov    0x16c(%ebx),%eax
   19f40:	ff 70 18             	pushl  0x18(%eax)
   19f43:	8b 03                	mov    (%ebx),%eax
   19f45:	05 58 01 00 00       	add    $0x158,%eax
   19f4a:	50                   	push   %eax
   19f4b:	68 60 41 40 00       	push   $0x404160
   19f50:	e8 80 a5 00 00       	call   244d5 <k_delayed_work_submit_to_queue>
   19f55:	83 c4 0c             	add    $0xc,%esp
   19f58:	eb 0c                	jmp    19f66 <lwm2m_send_message+0xe5>
		lwm2m_reset_message(msg, true);
   19f5a:	6a 01                	push   $0x1
	return 0;
   19f5c:	31 f6                	xor    %esi,%esi
		lwm2m_reset_message(msg, true);
   19f5e:	53                   	push   %ebx
   19f5f:	e8 3e df ff ff       	call   17ea2 <lwm2m_reset_message>
   19f64:	58                   	pop    %eax
   19f65:	5a                   	pop    %edx
}
   19f66:	8d 65 f8             	lea    -0x8(%ebp),%esp
   19f69:	89 f0                	mov    %esi,%eax
   19f6b:	5b                   	pop    %ebx
   19f6c:	5e                   	pop    %esi
   19f6d:	5d                   	pop    %ebp
   19f6e:	c3                   	ret    

00019f6f <generate_notify_message>:
{
   19f6f:	55                   	push   %ebp
   19f70:	89 e5                	mov    %esp,%ebp
   19f72:	57                   	push   %edi
   19f73:	56                   	push   %esi
   19f74:	53                   	push   %ebx
   19f75:	89 c3                	mov    %eax,%ebx
   19f77:	83 ec 30             	sub    $0x30,%esp
   19f7a:	89 55 cc             	mov    %edx,-0x34(%ebp)
	if (!obs->ctx) {
   19f7d:	8b 40 04             	mov    0x4(%eax),%eax
   19f80:	85 c0                	test   %eax,%eax
   19f82:	75 2e                	jne    19fb2 <generate_notify_message+0x43>
		return -EINVAL;
   19f84:	bf ea ff ff ff       	mov    $0xffffffea,%edi
		LOG_ERR("observer has no valid LwM2M ctx!");
   19f89:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19f90:	0f 84 d9 02 00 00    	je     1a26f <generate_notify_message+0x300>
   19f96:	ba cc 51 02 00       	mov    $0x251cc,%edx
   19f9b:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   19fa1:	c1 ea 03             	shr    $0x3,%edx
   19fa4:	c1 e2 06             	shl    $0x6,%edx
   19fa7:	83 ca 01             	or     $0x1,%edx
   19faa:	52                   	push   %edx
   19fab:	68 4f 9a 02 00       	push   $0x29a4f
   19fb0:	eb 39                	jmp    19feb <generate_notify_message+0x7c>
	msg = lwm2m_get_message(obs->ctx);
   19fb2:	50                   	push   %eax
   19fb3:	e8 bc de ff ff       	call   17e74 <lwm2m_get_message>
   19fb8:	59                   	pop    %ecx
   19fb9:	89 c6                	mov    %eax,%esi
	if (!msg) {
   19fbb:	85 c0                	test   %eax,%eax
   19fbd:	75 36                	jne    19ff5 <generate_notify_message+0x86>
		return -ENOMEM;
   19fbf:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("Unable to get a lwm2m message!");
   19fc4:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   19fcb:	0f 84 9e 02 00 00    	je     1a26f <generate_notify_message+0x300>
   19fd1:	ba cc 51 02 00       	mov    $0x251cc,%edx
   19fd6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   19fdc:	c1 ea 03             	shr    $0x3,%edx
   19fdf:	c1 e2 06             	shl    $0x6,%edx
   19fe2:	83 ca 01             	or     $0x1,%edx
   19fe5:	52                   	push   %edx
   19fe6:	68 70 9a 02 00       	push   $0x29a70
   19feb:	e8 9a 94 fe ff       	call   348a <log_0>
   19ff0:	e9 78 02 00 00       	jmp    1a26d <generate_notify_message+0x2fe>
	memcpy(&msg->path, &obs->path, sizeof(struct lwm2m_obj_path));
   19ff5:	6a 0a                	push   $0xa
   19ff7:	8d 43 08             	lea    0x8(%ebx),%eax
   19ffa:	50                   	push   %eax
   19ffb:	8d 46 20             	lea    0x20(%esi),%eax
   19ffe:	50                   	push   %eax
   19fff:	e8 2d 09 ff ff       	call   a931 <memcpy>
   1a004:	83 c4 0c             	add    $0xc,%esp
	msg->operation = LWM2M_OP_READ;
   1a007:	c6 86 85 01 00 00 00 	movb   $0x0,0x185(%esi)
	LOG_DBG("[%s] NOTIFY MSG START: %u/%u/%u(%u) token:'%s' [%s] %lld",
   1a00e:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a015:	0f 84 82 00 00 00    	je     1a09d <generate_notify_message+0x12e>
   1a01b:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1a020:	c7 45 d0 a8 62 02 00 	movl   $0x262a8,-0x30(%ebp)
   1a027:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1a02c:	c1 e8 03             	shr    $0x3,%eax
   1a02f:	c1 e0 06             	shl    $0x6,%eax
   1a032:	83 c8 04             	or     $0x4,%eax
   1a035:	89 c7                	mov    %eax,%edi
   1a037:	b8 96 9a 02 00       	mov    $0x29a96,%eax
   1a03c:	80 7d cc 00          	cmpb   $0x0,-0x34(%ebp)
   1a040:	74 05                	je     1a047 <generate_notify_message+0xd8>
   1a042:	b8 8f 9a 02 00       	mov    $0x29a8f,%eax
   1a047:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1a04a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
   1a04e:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1a051:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
   1a055:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1a058:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
   1a05c:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1a05f:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
   1a063:	0f b6 53 3a          	movzbl 0x3a(%ebx),%edx
   1a067:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1a06a:	8d 43 12             	lea    0x12(%ebx),%eax
   1a06d:	e8 f8 cf ff ff       	call   1706a <sprint_token>
   1a072:	ff 73 04             	pushl  0x4(%ebx)
   1a075:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1a078:	e8 4b d3 ff ff       	call   173c8 <lwm2m_sprint_ip_addr>
   1a07d:	5a                   	pop    %edx
   1a07e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1a081:	e8 8b a8 00 00       	call   24911 <z_impl_k_uptime_get>
   1a086:	57                   	push   %edi
   1a087:	6a 09                	push   $0x9
   1a089:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1a08c:	8d 45 d0             	lea    -0x30(%ebp),%eax
   1a08f:	50                   	push   %eax
   1a090:	68 9b 9a 02 00       	push   $0x29a9b
   1a095:	e8 ef 94 fe ff       	call   3589 <log_n>
   1a09a:	83 c4 10             	add    $0x10,%esp
	obj_inst = get_engine_obj_inst(obs->path.obj_id,
   1a09d:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
   1a0a1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
   1a0a5:	89 ca                	mov    %ecx,%edx
   1a0a7:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
   1a0aa:	89 45 c8             	mov    %eax,-0x38(%ebp)
   1a0ad:	e8 38 c9 ff ff       	call   169ea <get_engine_obj_inst>
	if (!obj_inst) {
   1a0b2:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
	obj_inst = get_engine_obj_inst(obs->path.obj_id,
   1a0b5:	89 45 cc             	mov    %eax,-0x34(%ebp)
	if (!obj_inst) {
   1a0b8:	85 c0                	test   %eax,%eax
   1a0ba:	75 3d                	jne    1a0f9 <generate_notify_message+0x18a>
		ret = -EINVAL;
   1a0bc:	bf ea ff ff ff       	mov    $0xffffffea,%edi
		LOG_ERR("unable to get engine obj for %u/%u",
   1a0c1:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a0c8:	0f 84 97 01 00 00    	je     1a265 <generate_notify_message+0x2f6>
   1a0ce:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a0d3:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a0d9:	c1 ea 03             	shr    $0x3,%edx
   1a0dc:	c1 e2 06             	shl    $0x6,%edx
   1a0df:	83 ca 01             	or     $0x1,%edx
   1a0e2:	52                   	push   %edx
   1a0e3:	51                   	push   %ecx
   1a0e4:	ff 75 c8             	pushl  -0x38(%ebp)
   1a0e7:	68 d8 9a 02 00       	push   $0x29ad8
   1a0ec:	e8 f8 93 fe ff       	call   34e9 <log_2>
   1a0f1:	83 c4 10             	add    $0x10,%esp
   1a0f4:	e9 6c 01 00 00       	jmp    1a265 <generate_notify_message+0x2f6>
	msg->token = obs->token;
   1a0f9:	8d 43 12             	lea    0x12(%ebx),%eax
	msg->mid = 0U;
   1a0fc:	c7 86 80 01 00 00 00 	movl   $0x45000000,0x180(%esi)
   1a103:	00 00 45 
	msg->token = obs->token;
   1a106:	89 86 74 01 00 00    	mov    %eax,0x174(%esi)
	msg->out.out_cpkt = &msg->cpkt;
   1a10c:	8d 56 2c             	lea    0x2c(%esi),%edx
	msg->tkl = obs->tkl;
   1a10f:	8a 43 3a             	mov    0x3a(%ebx),%al
	msg->out.out_cpkt = &msg->cpkt;
   1a112:	89 56 18             	mov    %edx,0x18(%esi)
	msg->tkl = obs->tkl;
   1a115:	88 86 84 01 00 00    	mov    %al,0x184(%esi)
	msg->reply_cb = notify_message_reply_cb;
   1a11b:	c7 86 78 01 00 00 c9 	movl   $0x171c9,0x178(%esi)
   1a122:	71 01 00 
	msg->out.out_cpkt = &msg->cpkt;
   1a125:	89 55 c8             	mov    %edx,-0x38(%ebp)
	ret = lwm2m_init_message(msg);
   1a128:	56                   	push   %esi
   1a129:	e8 ff de ff ff       	call   1802d <lwm2m_init_message>
   1a12e:	5f                   	pop    %edi
	if (ret < 0) {
   1a12f:	85 c0                	test   %eax,%eax
	ret = lwm2m_init_message(msg);
   1a131:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
   1a133:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1a136:	79 2d                	jns    1a165 <generate_notify_message+0x1f6>
		LOG_ERR("Unable to init lwm2m message! (err: %d)", ret);
   1a138:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a13f:	0f 84 20 01 00 00    	je     1a265 <generate_notify_message+0x2f6>
   1a145:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a14a:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a150:	c1 ea 03             	shr    $0x3,%edx
   1a153:	c1 e2 06             	shl    $0x6,%edx
   1a156:	83 ca 01             	or     $0x1,%edx
   1a159:	52                   	push   %edx
   1a15a:	50                   	push   %eax
   1a15b:	68 fb 9a 02 00       	push   $0x29afb
   1a160:	e9 c6 00 00 00       	jmp    1a22b <generate_notify_message+0x2bc>
	obs->counter++;
   1a165:	8b 43 34             	mov    0x34(%ebx),%eax
   1a168:	40                   	inc    %eax
	ret = coap_append_option_int(&msg->cpkt, COAP_OPTION_OBSERVE,
   1a169:	50                   	push   %eax
	obs->counter++;
   1a16a:	89 43 34             	mov    %eax,0x34(%ebx)
	ret = coap_append_option_int(&msg->cpkt, COAP_OPTION_OBSERVE,
   1a16d:	6a 06                	push   $0x6
   1a16f:	52                   	push   %edx
   1a170:	e8 33 e0 fe ff       	call   81a8 <coap_append_option_int>
   1a175:	83 c4 0c             	add    $0xc,%esp
   1a178:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
   1a17a:	85 c0                	test   %eax,%eax
   1a17c:	79 2d                	jns    1a1ab <generate_notify_message+0x23c>
		LOG_ERR("OBSERVE option error: %d", ret);
   1a17e:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a185:	0f 84 da 00 00 00    	je     1a265 <generate_notify_message+0x2f6>
   1a18b:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a190:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a196:	c1 ea 03             	shr    $0x3,%edx
   1a199:	c1 e2 06             	shl    $0x6,%edx
   1a19c:	83 ca 01             	or     $0x1,%edx
   1a19f:	52                   	push   %edx
   1a1a0:	50                   	push   %eax
   1a1a1:	68 84 97 02 00       	push   $0x29784
   1a1a6:	e9 80 00 00 00       	jmp    1a22b <generate_notify_message+0x2bc>
	select_writer(&msg->out, obs->format);
   1a1ab:	0f b7 53 38          	movzwl 0x38(%ebx),%edx
   1a1af:	8d 46 14             	lea    0x14(%esi),%eax
   1a1b2:	e8 d3 ca ff ff       	call   16c8a <select_writer>
	ret = do_read_op(obj_inst->obj, msg, obs->format);
   1a1b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1a1ba:	0f b7 4b 38          	movzwl 0x38(%ebx),%ecx
   1a1be:	8b 40 04             	mov    0x4(%eax),%eax
   1a1c1:	89 f2                	mov    %esi,%edx
   1a1c3:	e8 01 cc ff ff       	call   16dc9 <do_read_op>
   1a1c8:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
   1a1ca:	85 c0                	test   %eax,%eax
   1a1cc:	79 2a                	jns    1a1f8 <generate_notify_message+0x289>
		LOG_ERR("error in multi-format read (err:%d)", ret);
   1a1ce:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a1d5:	0f 84 8a 00 00 00    	je     1a265 <generate_notify_message+0x2f6>
   1a1db:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a1e0:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a1e6:	c1 ea 03             	shr    $0x3,%edx
   1a1e9:	c1 e2 06             	shl    $0x6,%edx
   1a1ec:	83 ca 01             	or     $0x1,%edx
   1a1ef:	52                   	push   %edx
   1a1f0:	50                   	push   %eax
   1a1f1:	68 23 9b 02 00       	push   $0x29b23
   1a1f6:	eb 33                	jmp    1a22b <generate_notify_message+0x2bc>
	ret = lwm2m_send_message(msg);
   1a1f8:	56                   	push   %esi
   1a1f9:	e8 83 fc ff ff       	call   19e81 <lwm2m_send_message>
   1a1fe:	59                   	pop    %ecx
   1a1ff:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
   1a201:	85 c0                	test   %eax,%eax
   1a203:	8b 15 a4 a8 40 00    	mov    0x40a8a4,%edx
   1a209:	79 2a                	jns    1a235 <generate_notify_message+0x2c6>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
   1a20b:	80 e2 07             	and    $0x7,%dl
   1a20e:	74 55                	je     1a265 <generate_notify_message+0x2f6>
   1a210:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a215:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a21b:	c1 ea 03             	shr    $0x3,%edx
   1a21e:	c1 e2 06             	shl    $0x6,%edx
   1a221:	83 ca 01             	or     $0x1,%edx
   1a224:	52                   	push   %edx
   1a225:	50                   	push   %eax
   1a226:	68 47 9b 02 00       	push   $0x29b47
   1a22b:	e8 7f 92 fe ff       	call   34af <log_1>
   1a230:	83 c4 0c             	add    $0xc,%esp
   1a233:	eb 30                	jmp    1a265 <generate_notify_message+0x2f6>
	return 0;
   1a235:	31 ff                	xor    %edi,%edi
	LOG_DBG("NOTIFY MSG: SENT");
   1a237:	80 e2 04             	and    $0x4,%dl
   1a23a:	74 33                	je     1a26f <generate_notify_message+0x300>
   1a23c:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a241:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a247:	c1 ea 03             	shr    $0x3,%edx
   1a24a:	c1 e2 06             	shl    $0x6,%edx
   1a24d:	83 ca 04             	or     $0x4,%edx
   1a250:	52                   	push   %edx
   1a251:	68 a8 62 02 00       	push   $0x262a8
   1a256:	68 6c 9b 02 00       	push   $0x29b6c
   1a25b:	e8 4f 92 fe ff       	call   34af <log_1>
   1a260:	83 c4 0c             	add    $0xc,%esp
   1a263:	eb 0a                	jmp    1a26f <generate_notify_message+0x300>
	lwm2m_reset_message(msg, true);
   1a265:	6a 01                	push   $0x1
   1a267:	56                   	push   %esi
   1a268:	e8 35 dc ff ff       	call   17ea2 <lwm2m_reset_message>
   1a26d:	58                   	pop    %eax
   1a26e:	5a                   	pop    %edx
}
   1a26f:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1a272:	89 f8                	mov    %edi,%eax
   1a274:	5b                   	pop    %ebx
   1a275:	5e                   	pop    %esi
   1a276:	5f                   	pop    %edi
   1a277:	5d                   	pop    %ebp
   1a278:	c3                   	ret    

0001a279 <socket_receive_loop>:
{
   1a279:	55                   	push   %ebp
   1a27a:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1a27f:	89 e5                	mov    %esp,%ebp
   1a281:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1a286:	c1 e8 03             	shr    $0x3,%eax
   1a289:	57                   	push   %edi
		LOG_ERR("No handler for response");
   1a28a:	c1 e0 06             	shl    $0x6,%eax
{
   1a28d:	56                   	push   %esi
   1a28e:	53                   	push   %ebx
   1a28f:	83 ec 28             	sub    $0x28,%esp
	from_addr_len = sizeof(from_addr);
   1a292:	c7 45 d8 18 00 00 00 	movl   $0x18,-0x28(%ebp)
		LOG_ERR("No handler for response");
   1a299:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
		if (sock_nfds < 1) {
   1a29d:	a1 70 43 40 00       	mov    0x404370,%eax
   1a2a2:	85 c0                	test   %eax,%eax
   1a2a4:	7e 49                	jle    1a2ef <socket_receive_loop+0x76>

K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_RECVFROM, zsock_recvfrom, ssize_t, int, sock, void *, buf, size_t, max_len, int, flags, struct sockaddr *, src_addr, socklen_t *, addrlen)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_FCNTL, zsock_fcntl, int, int, sock, int, cmd, int, flags)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_POLL, zsock_poll, int, struct zsock_pollfd *, fds, int, nfds, int, timeout)
   1a2a6:	68 f4 01 00 00       	push   $0x1f4
		for (i = 0; i < sock_nfds; i++) {
   1a2ab:	31 db                	xor    %ebx,%ebx
   1a2ad:	50                   	push   %eax
   1a2ae:	68 74 43 40 00       	push   $0x404374
   1a2b3:	e8 af f1 fe ff       	call   9467 <z_impl_zsock_poll>
   1a2b8:	83 c4 0c             	add    $0xc,%esp
		if (poll(sock_fds, sock_nfds, ENGINE_UPDATE_INTERVAL) < 0) {
   1a2bb:	85 c0                	test   %eax,%eax
   1a2bd:	79 72                	jns    1a331 <socket_receive_loop+0xb8>
			LOG_ERR("Error in poll:%d", errno);
   1a2bf:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a2c6:	74 1c                	je     1a2e4 <socket_receive_loop+0x6b>
   1a2c8:	66 8b 5d d6          	mov    -0x2a(%ebp),%bx
   1a2cc:	e8 17 8a 00 00       	call   22ce8 <z_impl_z_errno>
   1a2d1:	83 cb 01             	or     $0x1,%ebx
   1a2d4:	53                   	push   %ebx
   1a2d5:	ff 30                	pushl  (%eax)
   1a2d7:	68 81 9b 02 00       	push   $0x29b81
   1a2dc:	e8 ce 91 fe ff       	call   34af <log_1>
   1a2e1:	83 c4 0c             	add    $0xc,%esp
   1a2e4:	e8 ff 89 00 00       	call   22ce8 <z_impl_z_errno>
			errno = 0;
   1a2e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
   1a2ef:	68 f4 01 00 00       	push   $0x1f4
   1a2f4:	e8 a1 9b 00 00       	call   23e9a <z_impl_k_sleep>
   1a2f9:	59                   	pop    %ecx
   1a2fa:	eb a1                	jmp    1a29d <socket_receive_loop+0x24>
			if (sock_fds[i].revents & POLLERR) {
   1a2fc:	66 8b 04 dd 7a 43 40 	mov    0x40437a(,%ebx,8),%ax
   1a303:	00 
   1a304:	a8 08                	test   $0x8,%al
   1a306:	74 36                	je     1a33e <socket_receive_loop+0xc5>
				LOG_ERR("Error in poll.. waiting a moment.");
   1a308:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a30f:	74 14                	je     1a325 <socket_receive_loop+0xac>
   1a311:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a315:	83 c8 01             	or     $0x1,%eax
   1a318:	50                   	push   %eax
   1a319:	68 92 9b 02 00       	push   $0x29b92
   1a31e:	e8 67 91 fe ff       	call   348a <log_0>
   1a323:	58                   	pop    %eax
   1a324:	5a                   	pop    %edx
   1a325:	68 f4 01 00 00       	push   $0x1f4
   1a32a:	e8 6b 9b 00 00       	call   23e9a <z_impl_k_sleep>
   1a32f:	58                   	pop    %eax
		for (i = 0; i < sock_nfds; i++) {
   1a330:	43                   	inc    %ebx
   1a331:	3b 1d 70 43 40 00    	cmp    0x404370,%ebx
   1a337:	7c c3                	jl     1a2fc <socket_receive_loop+0x83>
   1a339:	e9 5f ff ff ff       	jmp    1a29d <socket_receive_loop+0x24>
			if (!(sock_fds[i].revents & POLLIN) ||
   1a33e:	a8 01                	test   $0x1,%al
   1a340:	74 0b                	je     1a34d <socket_receive_loop+0xd4>
			    sock_ctx[i] == NULL) {
   1a342:	8b 04 9d 8c 43 40 00 	mov    0x40438c(,%ebx,4),%eax
			if (!(sock_fds[i].revents & POLLIN) ||
   1a349:	85 c0                	test   %eax,%eax
   1a34b:	75 0c                	jne    1a359 <socket_receive_loop+0xe0>
				sock_fds[i].revents = 0;
   1a34d:	66 c7 04 dd 7a 43 40 	movw   $0x0,0x40437a(,%ebx,8)
   1a354:	00 00 00 
				continue;
   1a357:	eb d7                	jmp    1a330 <socket_receive_loop+0xb7>
K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_RECVFROM, zsock_recvfrom, ssize_t, int, sock, void *, buf, size_t, max_len, int, flags, struct sockaddr *, src_addr, socklen_t *, addrlen)
   1a359:	8d 55 d8             	lea    -0x28(%ebp),%edx
			sock_fds[i].revents = 0;
   1a35c:	66 c7 04 dd 7a 43 40 	movw   $0x0,0x40437a(,%ebx,8)
   1a363:	00 00 00 
   1a366:	52                   	push   %edx
   1a367:	68 58 43 40 00       	push   $0x404358
   1a36c:	6a 00                	push   $0x0
   1a36e:	68 ff 04 00 00       	push   $0x4ff
   1a373:	68 20 13 40 00       	push   $0x401320
   1a378:	ff b0 84 01 00 00    	pushl  0x184(%eax)
   1a37e:	e8 ae f0 fe ff       	call   9431 <z_impl_zsock_recvfrom>
   1a383:	83 c4 18             	add    $0x18,%esp
			if (len < 0) {
   1a386:	85 c0                	test   %eax,%eax
   1a388:	79 1f                	jns    1a3a9 <socket_receive_loop+0x130>
				LOG_ERR("Error reading response: %d", errno);
   1a38a:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a391:	74 9d                	je     1a330 <socket_receive_loop+0xb7>
   1a393:	66 8b 75 d6          	mov    -0x2a(%ebp),%si
   1a397:	e8 4c 89 00 00       	call   22ce8 <z_impl_z_errno>
   1a39c:	83 ce 01             	or     $0x1,%esi
   1a39f:	56                   	push   %esi
   1a3a0:	ff 30                	pushl  (%eax)
   1a3a2:	68 b4 9b 02 00       	push   $0x29bb4
   1a3a7:	eb 6a                	jmp    1a413 <socket_receive_loop+0x19a>
			if (len == 0) {
   1a3a9:	75 1f                	jne    1a3ca <socket_receive_loop+0x151>
				LOG_ERR("Zero length recv");
   1a3ab:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a3b2:	0f 84 78 ff ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a3b8:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a3bc:	83 c8 01             	or     $0x1,%eax
   1a3bf:	50                   	push   %eax
   1a3c0:	68 cf 9b 02 00       	push   $0x29bcf
   1a3c5:	e9 73 02 00 00       	jmp    1a63d <socket_receive_loop+0x3c4>
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
   1a3ca:	6a 00                	push   $0x0
			in_buf[len] = 0;
   1a3cc:	c6 80 20 13 40 00 00 	movb   $0x0,0x401320(%eax)
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
   1a3d3:	6a 00                	push   $0x0
			lwm2m_udp_receive(sock_ctx[i], in_buf, len, &from_addr,
   1a3d5:	8b 0c 9d 8c 43 40 00 	mov    0x40438c(,%ebx,4),%ecx
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
   1a3dc:	0f b7 c0             	movzwl %ax,%eax
   1a3df:	50                   	push   %eax
   1a3e0:	8d 75 e4             	lea    -0x1c(%ebp),%esi
   1a3e3:	68 20 13 40 00       	push   $0x401320
			lwm2m_udp_receive(sock_ctx[i], in_buf, len, &from_addr,
   1a3e8:	89 4d d0             	mov    %ecx,-0x30(%ebp)
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
   1a3eb:	56                   	push   %esi
   1a3ec:	e8 ab de fe ff       	call   829c <coap_packet_parse>
   1a3f1:	83 c4 14             	add    $0x14,%esp
	if (r < 0) {
   1a3f4:	85 c0                	test   %eax,%eax
   1a3f6:	79 28                	jns    1a420 <socket_receive_loop+0x1a7>
		LOG_ERR("Invalid data received (err:%d)", r);
   1a3f8:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a3ff:	0f 84 2b ff ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a405:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
   1a409:	83 ca 01             	or     $0x1,%edx
   1a40c:	52                   	push   %edx
   1a40d:	50                   	push   %eax
   1a40e:	68 e0 9b 02 00       	push   $0x29be0
   1a413:	e8 97 90 fe ff       	call   34af <log_1>
   1a418:	83 c4 0c             	add    $0xc,%esp
   1a41b:	e9 10 ff ff ff       	jmp    1a330 <socket_receive_loop+0xb7>
	tkl = coap_header_get_token(&response, token);
   1a420:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1a423:	50                   	push   %eax
   1a424:	56                   	push   %esi
   1a425:	e8 7a e0 fe ff       	call   84a4 <coap_header_get_token>
   1a42a:	59                   	pop    %ecx
   1a42b:	88 45 d5             	mov    %al,-0x2b(%ebp)
   1a42e:	5f                   	pop    %edi
	pending = coap_pending_received(&response, client_ctx->pendings,
   1a42f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1a432:	6a 05                	push   $0x5
   1a434:	83 c0 18             	add    $0x18,%eax
   1a437:	50                   	push   %eax
	struct lwm2m_message *msg = NULL;
   1a438:	31 ff                	xor    %edi,%edi
	pending = coap_pending_received(&response, client_ctx->pendings,
   1a43a:	56                   	push   %esi
   1a43b:	e8 f6 e3 fe ff       	call   8836 <coap_pending_received>
   1a440:	83 c4 0c             	add    $0xc,%esp
   1a443:	89 45 cc             	mov    %eax,-0x34(%ebp)
	if (pending) {
   1a446:	85 c0                	test   %eax,%eax
   1a448:	74 09                	je     1a453 <socket_receive_loop+0x1da>
		msg = find_msg(pending, NULL);
   1a44a:	31 d2                	xor    %edx,%edx
   1a44c:	e8 f6 c7 ff ff       	call   16c47 <find_msg>
   1a451:	89 c7                	mov    %eax,%edi
	LOG_DBG("checking for reply from [%s]",
   1a453:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a45a:	74 28                	je     1a484 <socket_receive_loop+0x20b>
   1a45c:	68 58 43 40 00       	push   $0x404358
   1a461:	66 8b 75 d6          	mov    -0x2a(%ebp),%si
   1a465:	e8 5e cf ff ff       	call   173c8 <lwm2m_sprint_ip_addr>
   1a46a:	83 ce 04             	or     $0x4,%esi
   1a46d:	66 89 34 24          	mov    %si,(%esp)
   1a471:	50                   	push   %eax
   1a472:	68 24 62 02 00       	push   $0x26224
   1a477:	68 ff 9b 02 00       	push   $0x29bff
   1a47c:	e8 68 90 fe ff       	call   34e9 <log_2>
   1a481:	83 c4 10             	add    $0x10,%esp
				       client_ctx->replies,
   1a484:	8b 45 d0             	mov    -0x30(%ebp),%eax
	reply = coap_response_received(&response, from_addr,
   1a487:	6a 05                	push   $0x5
				       client_ctx->replies,
   1a489:	05 e0 00 00 00       	add    $0xe0,%eax
	reply = coap_response_received(&response, from_addr,
   1a48e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
   1a491:	50                   	push   %eax
   1a492:	68 58 43 40 00       	push   $0x404358
   1a497:	52                   	push   %edx
   1a498:	e8 57 e4 fe ff       	call   88f4 <coap_response_received>
   1a49d:	83 c4 10             	add    $0x10,%esp
   1a4a0:	89 c6                	mov    %eax,%esi
	if (reply) {
   1a4a2:	85 c0                	test   %eax,%eax
   1a4a4:	74 54                	je     1a4fa <socket_receive_loop+0x281>
		if (client_ctx->handle_separate_response && !tkl &&
   1a4a6:	80 7d d5 00          	cmpb   $0x0,-0x2b(%ebp)
   1a4aa:	75 3e                	jne    1a4ea <socket_receive_loop+0x271>
   1a4ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1a4af:	8d 55 e4             	lea    -0x1c(%ebp),%edx
   1a4b2:	80 b8 81 01 00 00 00 	cmpb   $0x0,0x181(%eax)
   1a4b9:	74 2f                	je     1a4ea <socket_receive_loop+0x271>
			coap_header_get_type(&response) == COAP_TYPE_ACK) {
   1a4bb:	52                   	push   %edx
   1a4bc:	e8 c6 df fe ff       	call   8487 <coap_header_get_type>
   1a4c1:	5a                   	pop    %edx
		if (client_ctx->handle_separate_response && !tkl &&
   1a4c2:	3c 02                	cmp    $0x2,%al
   1a4c4:	75 24                	jne    1a4ea <socket_receive_loop+0x271>
			LOG_DBG("separated response, not removing reply");
   1a4c6:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a4cd:	0f 84 5d fe ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a4d3:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a4d7:	83 c8 04             	or     $0x4,%eax
   1a4da:	50                   	push   %eax
   1a4db:	68 24 62 02 00       	push   $0x26224
   1a4e0:	68 20 9c 02 00       	push   $0x29c20
   1a4e5:	e9 29 ff ff ff       	jmp    1a413 <socket_receive_loop+0x19a>
		if (!msg) {
   1a4ea:	85 ff                	test   %edi,%edi
   1a4ec:	75 0c                	jne    1a4fa <socket_receive_loop+0x281>
			msg = find_msg(pending, reply);
   1a4ee:	89 f2                	mov    %esi,%edx
   1a4f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1a4f3:	e8 4f c7 ff ff       	call   16c47 <find_msg>
   1a4f8:	89 c7                	mov    %eax,%edi
	if (reply || pending) {
   1a4fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1a4fd:	09 f0                	or     %esi,%eax
   1a4ff:	74 6e                	je     1a56f <socket_receive_loop+0x2f6>
		if (reply && reply->user_data != COAP_REPLY_STATUS_NONE) {
   1a501:	85 f6                	test   %esi,%esi
   1a503:	74 2f                	je     1a534 <socket_receive_loop+0x2bb>
   1a505:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
   1a509:	74 29                	je     1a534 <socket_receive_loop+0x2bb>
			reply->user_data = (void *)COAP_REPLY_STATUS_NONE;
   1a50b:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
			LOG_DBG("reply %p NOT removed", reply);
   1a512:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a519:	0f 84 11 fe ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a51f:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a523:	83 c8 04             	or     $0x4,%eax
   1a526:	50                   	push   %eax
   1a527:	56                   	push   %esi
   1a528:	68 24 62 02 00       	push   $0x26224
   1a52d:	68 4b 9c 02 00       	push   $0x29c4b
   1a532:	eb 2e                	jmp    1a562 <socket_receive_loop+0x2e9>
		if (msg) {
   1a534:	85 ff                	test   %edi,%edi
   1a536:	74 0a                	je     1a542 <socket_receive_loop+0x2c9>
			lwm2m_reset_message(msg, true);
   1a538:	6a 01                	push   $0x1
   1a53a:	57                   	push   %edi
   1a53b:	e8 62 d9 ff ff       	call   17ea2 <lwm2m_reset_message>
   1a540:	5f                   	pop    %edi
   1a541:	58                   	pop    %eax
		LOG_DBG("reply %p handled and removed", reply);
   1a542:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a549:	0f 84 e1 fd ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a54f:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a553:	83 c8 04             	or     $0x4,%eax
   1a556:	50                   	push   %eax
   1a557:	56                   	push   %esi
   1a558:	68 24 62 02 00       	push   $0x26224
   1a55d:	68 64 9c 02 00       	push   $0x29c64
   1a562:	e8 82 8f fe ff       	call   34e9 <log_2>
   1a567:	83 c4 10             	add    $0x10,%esp
   1a56a:	e9 c1 fd ff ff       	jmp    1a330 <socket_receive_loop+0xb7>
	    coap_header_get_type(&response) == COAP_TYPE_CON) {
   1a56f:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   1a572:	57                   	push   %edi
   1a573:	e8 0f df fe ff       	call   8487 <coap_header_get_type>
   1a578:	5e                   	pop    %esi
	if (udp_request_handler &&
   1a579:	84 c0                	test   %al,%al
   1a57b:	0f 85 a2 00 00 00    	jne    1a623 <socket_receive_loop+0x3aa>
		msg = lwm2m_get_message(client_ctx);
   1a581:	ff 75 d0             	pushl  -0x30(%ebp)
   1a584:	e8 eb d8 ff ff       	call   17e74 <lwm2m_get_message>
   1a589:	59                   	pop    %ecx
   1a58a:	89 c6                	mov    %eax,%esi
		if (!msg) {
   1a58c:	85 c0                	test   %eax,%eax
   1a58e:	75 1f                	jne    1a5af <socket_receive_loop+0x336>
			LOG_ERR("Unable to get a lwm2m message!");
   1a590:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a597:	0f 84 93 fd ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a59d:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a5a1:	83 c8 01             	or     $0x1,%eax
   1a5a4:	50                   	push   %eax
   1a5a5:	68 70 9a 02 00       	push   $0x29a70
   1a5aa:	e9 8e 00 00 00       	jmp    1a63d <socket_receive_loop+0x3c4>
		msg->type = COAP_TYPE_ACK;
   1a5af:	c6 80 82 01 00 00 02 	movb   $0x2,0x182(%eax)
		msg->code = coap_header_get_code(&response);
   1a5b6:	57                   	push   %edi
   1a5b7:	e8 1c df fe ff       	call   84d8 <coap_header_get_code>
   1a5bc:	88 86 83 01 00 00    	mov    %al,0x183(%esi)
		msg->mid = coap_header_get_id(&response);
   1a5c2:	89 3c 24             	mov    %edi,(%esp)
   1a5c5:	e8 6c df fe ff       	call   8536 <coap_header_get_id>
		msg->tkl = LWM2M_MSG_TOKEN_LEN_SKIP;
   1a5ca:	c6 86 84 01 00 00 ff 	movb   $0xff,0x184(%esi)
		msg->mid = coap_header_get_id(&response);
   1a5d1:	66 89 86 80 01 00 00 	mov    %ax,0x180(%esi)
		r = udp_request_handler(&response, msg);
   1a5d8:	89 34 24             	mov    %esi,(%esp)
   1a5db:	57                   	push   %edi
   1a5dc:	e8 5f dc ff ff       	call   18240 <handle_request>
   1a5e1:	5f                   	pop    %edi
		if (r < 0) {
   1a5e2:	85 c0                	test   %eax,%eax
		r = udp_request_handler(&response, msg);
   1a5e4:	5a                   	pop    %edx
		if (r < 0) {
   1a5e5:	0f 88 45 fd ff ff    	js     1a330 <socket_receive_loop+0xb7>
		r = lwm2m_send_message(msg);
   1a5eb:	56                   	push   %esi
   1a5ec:	e8 90 f8 ff ff       	call   19e81 <lwm2m_send_message>
   1a5f1:	59                   	pop    %ecx
		if (r < 0) {
   1a5f2:	85 c0                	test   %eax,%eax
   1a5f4:	0f 89 36 fd ff ff    	jns    1a330 <socket_receive_loop+0xb7>
			LOG_ERR("Err sending response: %d", r);
   1a5fa:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a601:	74 16                	je     1a619 <socket_receive_loop+0x3a0>
   1a603:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
   1a607:	83 ca 01             	or     $0x1,%edx
   1a60a:	52                   	push   %edx
   1a60b:	50                   	push   %eax
   1a60c:	68 85 9c 02 00       	push   $0x29c85
   1a611:	e8 99 8e fe ff       	call   34af <log_1>
   1a616:	83 c4 0c             	add    $0xc,%esp
			lwm2m_reset_message(msg, true);
   1a619:	6a 01                	push   $0x1
   1a61b:	56                   	push   %esi
   1a61c:	e8 81 d8 ff ff       	call   17ea2 <lwm2m_reset_message>
   1a621:	eb 1f                	jmp    1a642 <socket_receive_loop+0x3c9>
		LOG_ERR("No handler for response");
   1a623:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a62a:	0f 84 00 fd ff ff    	je     1a330 <socket_receive_loop+0xb7>
   1a630:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1a634:	83 c8 01             	or     $0x1,%eax
   1a637:	50                   	push   %eax
   1a638:	68 9e 9c 02 00       	push   $0x29c9e
   1a63d:	e8 48 8e fe ff       	call   348a <log_0>
   1a642:	58                   	pop    %eax
   1a643:	5a                   	pop    %edx
   1a644:	e9 e7 fc ff ff       	jmp    1a330 <socket_receive_loop+0xb7>

0001a649 <lwm2m_get_rd_data>:
{
   1a649:	55                   	push   %ebp
   1a64a:	89 e5                	mov    %esp,%ebp
   1a64c:	57                   	push   %edi
   1a64d:	56                   	push   %esi
   1a64e:	bf 1b 00 00 00       	mov    $0x1b,%edi
   1a653:	53                   	push   %ebx
   1a654:	83 ec 28             	sub    $0x28,%esp
   1a657:	8b 45 0c             	mov    0xc(%ebp),%eax
	memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
   1a65a:	6a 1b                	push   $0x1b
{
   1a65c:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
	memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
   1a660:	68 b6 9c 02 00       	push   $0x29cb6
   1a665:	ff 75 08             	pushl  0x8(%ebp)
   1a668:	e8 c4 02 ff ff       	call   a931 <memcpy>
   1a66d:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
   1a670:	8b 1d b0 43 40 00    	mov    0x4043b0,%ebx
   1a676:	85 db                	test   %ebx,%ebx
   1a678:	0f 84 d5 00 00 00    	je     1a753 <lwm2m_get_rd_data+0x10a>
		if (obj->obj_id == LWM2M_OBJECT_SECURITY_ID) {
   1a67e:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
   1a682:	66 85 c0             	test   %ax,%ax
   1a685:	0f 84 c1 00 00 00    	je     1a74c <lwm2m_get_rd_data+0x103>
		if (obj->instance_count == 0) {
   1a68b:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
   1a690:	75 4d                	jne    1a6df <lwm2m_get_rd_data+0x96>
			len = snprintk(temp, sizeof(temp), "%s</%u>",
   1a692:	66 85 ff             	test   %di,%di
   1a695:	ba ec 96 02 00       	mov    $0x296ec,%edx
   1a69a:	75 05                	jne    1a6a1 <lwm2m_get_rd_data+0x58>
   1a69c:	ba 7b 85 02 00       	mov    $0x2857b,%edx
   1a6a1:	50                   	push   %eax
   1a6a2:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1a6a5:	52                   	push   %edx
   1a6a6:	68 f4 98 02 00       	push   $0x298f4
   1a6ab:	6a 20                	push   $0x20
   1a6ad:	50                   	push   %eax
   1a6ae:	e8 2a 85 fe ff       	call   2bdd <snprintk>
   1a6b3:	89 c6                	mov    %eax,%esi
   1a6b5:	83 c4 14             	add    $0x14,%esp
			if (pos + len >= size) {
   1a6b8:	0f b7 c7             	movzwl %di,%eax
   1a6bb:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
   1a6bf:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
   1a6c2:	39 d1                	cmp    %edx,%ecx
   1a6c4:	0f 8d 89 00 00 00    	jge    1a753 <lwm2m_get_rd_data+0x10a>
			memcpy(&client_data[pos], temp, len);
   1a6ca:	56                   	push   %esi
   1a6cb:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
   1a6ce:	03 45 08             	add    0x8(%ebp),%eax
   1a6d1:	51                   	push   %ecx
   1a6d2:	50                   	push   %eax
			pos += len;
   1a6d3:	01 f7                	add    %esi,%edi
			memcpy(&client_data[pos], temp, len);
   1a6d5:	e8 57 02 ff ff       	call   a931 <memcpy>
   1a6da:	83 c4 0c             	add    $0xc,%esp
			continue;
   1a6dd:	eb 6d                	jmp    1a74c <lwm2m_get_rd_data+0x103>
		SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list,
   1a6df:	8b 35 a8 43 40 00    	mov    0x4043a8,%esi
   1a6e5:	85 f6                	test   %esi,%esi
   1a6e7:	74 63                	je     1a74c <lwm2m_get_rd_data+0x103>
			if (obj_inst->obj->obj_id == obj->obj_id) {
   1a6e9:	8b 46 04             	mov    0x4(%esi),%eax
   1a6ec:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   1a6f0:	66 3b 43 18          	cmp    0x18(%ebx),%ax
   1a6f4:	75 52                	jne    1a748 <lwm2m_get_rd_data+0xff>
				len = snprintk(temp, sizeof(temp),
   1a6f6:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
   1a6fa:	66 85 ff             	test   %di,%di
   1a6fd:	ba ec 96 02 00       	mov    $0x296ec,%edx
   1a702:	75 05                	jne    1a709 <lwm2m_get_rd_data+0xc0>
   1a704:	ba 7b 85 02 00       	mov    $0x2857b,%edx
   1a709:	51                   	push   %ecx
   1a70a:	50                   	push   %eax
   1a70b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1a70e:	52                   	push   %edx
   1a70f:	68 fc 98 02 00       	push   $0x298fc
   1a714:	6a 20                	push   $0x20
   1a716:	50                   	push   %eax
   1a717:	e8 c1 84 fe ff       	call   2bdd <snprintk>
   1a71c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1a71f:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if (pos + len >= size) {
   1a722:	0f b7 c7             	movzwl %di,%eax
   1a725:	01 c1                	add    %eax,%ecx
   1a727:	03 45 d0             	add    -0x30(%ebp),%eax
   1a72a:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
				len = snprintk(temp, sizeof(temp),
   1a72e:	83 c4 18             	add    $0x18,%esp
				if (pos + len >= size) {
   1a731:	39 d0                	cmp    %edx,%eax
   1a733:	7d 17                	jge    1a74c <lwm2m_get_rd_data+0x103>
				memcpy(&client_data[pos], temp, len);
   1a735:	ff 75 d0             	pushl  -0x30(%ebp)
   1a738:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1a73b:	50                   	push   %eax
   1a73c:	51                   	push   %ecx
   1a73d:	e8 ef 01 ff ff       	call   a931 <memcpy>
				pos += len;
   1a742:	03 7d d0             	add    -0x30(%ebp),%edi
				memcpy(&client_data[pos], temp, len);
   1a745:	83 c4 0c             	add    $0xc,%esp
   1a748:	8b 36                	mov    (%esi),%esi
	return node->next;
   1a74a:	eb 99                	jmp    1a6e5 <lwm2m_get_rd_data+0x9c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1a74c:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
   1a74e:	e9 23 ff ff ff       	jmp    1a676 <lwm2m_get_rd_data+0x2d>
	client_data[pos] = '\0';
   1a753:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1a756:	0f b7 c7             	movzwl %di,%eax
   1a759:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
}
   1a75d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1a760:	89 f8                	mov    %edi,%eax
   1a762:	5b                   	pop    %ebx
   1a763:	5e                   	pop    %esi
   1a764:	5f                   	pop    %edi
   1a765:	5d                   	pop    %ebp
   1a766:	c3                   	ret    

0001a767 <lwm2m_engine_create_obj_inst>:
{
   1a767:	55                   	push   %ebp
   1a768:	89 e5                	mov    %esp,%ebp
   1a76a:	53                   	push   %ebx
   1a76b:	83 ec 14             	sub    $0x14,%esp
   1a76e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	LOG_DBG("path:%s", pathstr);
   1a771:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
   1a778:	74 28                	je     1a7a2 <lwm2m_engine_create_obj_inst+0x3b>
   1a77a:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a77f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a785:	c1 ea 03             	shr    $0x3,%edx
   1a788:	c1 e2 06             	shl    $0x6,%edx
   1a78b:	83 ca 04             	or     $0x4,%edx
   1a78e:	52                   	push   %edx
   1a78f:	53                   	push   %ebx
   1a790:	68 10 63 02 00       	push   $0x26310
   1a795:	68 d2 9c 02 00       	push   $0x29cd2
   1a79a:	e8 4a 8d fe ff       	call   34e9 <log_2>
   1a79f:	83 c4 10             	add    $0x10,%esp
	ret = string_to_path(pathstr, &path, '/');
   1a7a2:	8d 55 f2             	lea    -0xe(%ebp),%edx
   1a7a5:	89 d8                	mov    %ebx,%eax
   1a7a7:	e8 a7 c7 ff ff       	call   16f53 <string_to_path.constprop.18>
	if (ret < 0) {
   1a7ac:	85 c0                	test   %eax,%eax
   1a7ae:	78 53                	js     1a803 <lwm2m_engine_create_obj_inst+0x9c>
	if (path.level != 2) {
   1a7b0:	80 7d fa 02          	cmpb   $0x2,-0x6(%ebp)
   1a7b4:	74 37                	je     1a7ed <lwm2m_engine_create_obj_inst+0x86>
		return -EINVAL;
   1a7b6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		LOG_ERR("path must have 2 parts");
   1a7bb:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a7c2:	74 3f                	je     1a803 <lwm2m_engine_create_obj_inst+0x9c>
   1a7c4:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a7c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1a7cc:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a7d2:	c1 ea 03             	shr    $0x3,%edx
   1a7d5:	c1 e2 06             	shl    $0x6,%edx
   1a7d8:	83 ca 01             	or     $0x1,%edx
   1a7db:	52                   	push   %edx
   1a7dc:	68 de 9c 02 00       	push   $0x29cde
   1a7e1:	e8 a4 8c fe ff       	call   348a <log_0>
   1a7e6:	58                   	pop    %eax
   1a7e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a7ea:	5a                   	pop    %edx
   1a7eb:	eb 16                	jmp    1a803 <lwm2m_engine_create_obj_inst+0x9c>
	return lwm2m_create_obj_inst(path.obj_id, path.obj_inst_id, &obj_inst);
   1a7ed:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1a7f0:	50                   	push   %eax
   1a7f1:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   1a7f5:	50                   	push   %eax
   1a7f6:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   1a7fa:	50                   	push   %eax
   1a7fb:	e8 ed d4 ff ff       	call   17ced <lwm2m_create_obj_inst>
   1a800:	83 c4 0c             	add    $0xc,%esp
}
   1a803:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1a806:	c9                   	leave  
   1a807:	c3                   	ret    

0001a808 <lwm2m_engine_set_res_data>:
{
   1a808:	55                   	push   %ebp
   1a809:	89 e5                	mov    %esp,%ebp
   1a80b:	56                   	push   %esi
   1a80c:	53                   	push   %ebx
   1a80d:	83 ec 14             	sub    $0x14,%esp
	ret = string_to_path(pathstr, &path, '/');
   1a810:	8d 55 ee             	lea    -0x12(%ebp),%edx
   1a813:	8b 45 08             	mov    0x8(%ebp),%eax
{
   1a816:	8b 75 10             	mov    0x10(%ebp),%esi
   1a819:	8b 5d 14             	mov    0x14(%ebp),%ebx
	struct lwm2m_engine_res_inst *res = NULL;
   1a81c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	ret = string_to_path(pathstr, &path, '/');
   1a823:	e8 2b c7 ff ff       	call   16f53 <string_to_path.constprop.18>
	if (ret < 0) {
   1a828:	85 c0                	test   %eax,%eax
   1a82a:	78 62                	js     1a88e <lwm2m_engine_set_res_data+0x86>
	if (path.level < 3) {
   1a82c:	80 7d f6 02          	cmpb   $0x2,-0xa(%ebp)
   1a830:	77 37                	ja     1a869 <lwm2m_engine_set_res_data+0x61>
		return -EINVAL;
   1a832:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		LOG_ERR("path must have 3 parts");
   1a837:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a83e:	74 4e                	je     1a88e <lwm2m_engine_set_res_data+0x86>
   1a840:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a845:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1a848:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a84e:	c1 ea 03             	shr    $0x3,%edx
   1a851:	c1 e2 06             	shl    $0x6,%edx
   1a854:	83 ca 01             	or     $0x1,%edx
   1a857:	52                   	push   %edx
   1a858:	68 51 94 02 00       	push   $0x29451
   1a85d:	e8 28 8c fe ff       	call   348a <log_0>
   1a862:	59                   	pop    %ecx
   1a863:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1a866:	5b                   	pop    %ebx
   1a867:	eb 25                	jmp    1a88e <lwm2m_engine_set_res_data+0x86>
	ret = path_to_objs(&path, NULL, NULL, &res);
   1a869:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1a86c:	31 d2                	xor    %edx,%edx
   1a86e:	50                   	push   %eax
   1a86f:	31 c9                	xor    %ecx,%ecx
   1a871:	8d 45 ee             	lea    -0x12(%ebp),%eax
   1a874:	e8 e2 cc ff ff       	call   1755b <path_to_objs>
   1a879:	5a                   	pop    %edx
	if (ret < 0) {
   1a87a:	85 c0                	test   %eax,%eax
   1a87c:	78 10                	js     1a88e <lwm2m_engine_set_res_data+0x86>
	res->data_ptr = data_ptr;
   1a87e:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1a881:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1a884:	89 4a 14             	mov    %ecx,0x14(%edx)
	res->data_len = data_len;
   1a887:	66 89 72 18          	mov    %si,0x18(%edx)
	res->data_flags = data_flags;
   1a88b:	88 5a 1c             	mov    %bl,0x1c(%edx)
}
   1a88e:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1a891:	5b                   	pop    %ebx
   1a892:	5e                   	pop    %esi
   1a893:	5d                   	pop    %ebp
   1a894:	c3                   	ret    

0001a895 <lwm2m_engine_set_string>:
{
   1a895:	55                   	push   %ebp
   1a896:	89 e5                	mov    %esp,%ebp
   1a898:	56                   	push   %esi
   1a899:	53                   	push   %ebx
   1a89a:	8b 75 0c             	mov    0xc(%ebp),%esi
   1a89d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
   1a8a0:	56                   	push   %esi
   1a8a1:	e8 bd ff fe ff       	call   a863 <strlen>
   1a8a6:	5a                   	pop    %edx
}
   1a8a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
   1a8aa:	0f b7 c8             	movzwl %ax,%ecx
   1a8ad:	89 d8                	mov    %ebx,%eax
}
   1a8af:	5b                   	pop    %ebx
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
   1a8b0:	89 f2                	mov    %esi,%edx
}
   1a8b2:	5e                   	pop    %esi
   1a8b3:	5d                   	pop    %ebp
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
   1a8b4:	e9 1e ce ff ff       	jmp    176d7 <lwm2m_engine_set>

0001a8b9 <lwm2m_engine_set_u8>:
{
   1a8b9:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, &value, 1);
   1a8ba:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   1a8bf:	89 e5                	mov    %esp,%ebp
   1a8c1:	50                   	push   %eax
   1a8c2:	8b 45 0c             	mov    0xc(%ebp),%eax
	return lwm2m_engine_set(pathstr, &value, 1);
   1a8c5:	8d 55 fc             	lea    -0x4(%ebp),%edx
{
   1a8c8:	88 45 fc             	mov    %al,-0x4(%ebp)
	return lwm2m_engine_set(pathstr, &value, 1);
   1a8cb:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8ce:	e8 04 ce ff ff       	call   176d7 <lwm2m_engine_set>
}
   1a8d3:	c9                   	leave  
   1a8d4:	c3                   	ret    

0001a8d5 <lwm2m_engine_set_u32>:
{
   1a8d5:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, &value, 4);
   1a8d6:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   1a8db:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_set(pathstr, &value, 4);
   1a8dd:	8d 55 0c             	lea    0xc(%ebp),%edx
   1a8e0:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8e3:	e8 ef cd ff ff       	call   176d7 <lwm2m_engine_set>
}
   1a8e8:	5d                   	pop    %ebp
   1a8e9:	c3                   	ret    

0001a8ea <lwm2m_engine_set_s32>:
{
   1a8ea:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, &value, 4);
   1a8eb:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   1a8f0:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_set(pathstr, &value, 4);
   1a8f2:	8d 55 0c             	lea    0xc(%ebp),%edx
   1a8f5:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8f8:	e8 da cd ff ff       	call   176d7 <lwm2m_engine_set>
}
   1a8fd:	5d                   	pop    %ebp
   1a8fe:	c3                   	ret    

0001a8ff <lwm2m_engine_set_bool>:
{
   1a8ff:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, &temp, 1);
   1a900:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   1a905:	89 e5                	mov    %esp,%ebp
   1a907:	50                   	push   %eax
	u8_t temp = (value != 0 ? 1 : 0);
   1a908:	8b 45 0c             	mov    0xc(%ebp),%eax
	return lwm2m_engine_set(pathstr, &temp, 1);
   1a90b:	8d 55 ff             	lea    -0x1(%ebp),%edx
	u8_t temp = (value != 0 ? 1 : 0);
   1a90e:	88 45 ff             	mov    %al,-0x1(%ebp)
	return lwm2m_engine_set(pathstr, &temp, 1);
   1a911:	8b 45 08             	mov    0x8(%ebp),%eax
   1a914:	e8 be cd ff ff       	call   176d7 <lwm2m_engine_set>
}
   1a919:	c9                   	leave  
   1a91a:	c3                   	ret    

0001a91b <lwm2m_engine_set_float32>:
{
   1a91b:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, value, sizeof(float32_value_t));
   1a91c:	b9 08 00 00 00       	mov    $0x8,%ecx
{
   1a921:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_set(pathstr, value, sizeof(float32_value_t));
   1a923:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a926:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1a929:	5d                   	pop    %ebp
	return lwm2m_engine_set(pathstr, value, sizeof(float32_value_t));
   1a92a:	e9 a8 cd ff ff       	jmp    176d7 <lwm2m_engine_set>

0001a92f <lwm2m_engine_get_res_data>:
{
   1a92f:	55                   	push   %ebp
   1a930:	89 e5                	mov    %esp,%ebp
   1a932:	83 ec 14             	sub    $0x14,%esp
	ret = string_to_path(pathstr, &path, '/');
   1a935:	8d 55 f6             	lea    -0xa(%ebp),%edx
   1a938:	8b 45 08             	mov    0x8(%ebp),%eax
	struct lwm2m_engine_res_inst *res = NULL;
   1a93b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	ret = string_to_path(pathstr, &path, '/');
   1a942:	e8 0c c6 ff ff       	call   16f53 <string_to_path.constprop.18>
	if (ret < 0) {
   1a947:	85 c0                	test   %eax,%eax
   1a949:	78 70                	js     1a9bb <lwm2m_engine_get_res_data+0x8c>
	if (path.level < 3) {
   1a94b:	80 7d fe 02          	cmpb   $0x2,-0x2(%ebp)
   1a94f:	77 37                	ja     1a988 <lwm2m_engine_get_res_data+0x59>
		LOG_ERR("path must have 3 parts");
   1a951:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1a956:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1a95d:	74 5c                	je     1a9bb <lwm2m_engine_get_res_data+0x8c>
   1a95f:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1a964:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1a967:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1a96d:	c1 ea 03             	shr    $0x3,%edx
   1a970:	c1 e2 06             	shl    $0x6,%edx
   1a973:	83 ca 01             	or     $0x1,%edx
   1a976:	52                   	push   %edx
   1a977:	68 51 94 02 00       	push   $0x29451
   1a97c:	e8 09 8b fe ff       	call   348a <log_0>
   1a981:	59                   	pop    %ecx
   1a982:	58                   	pop    %eax
   1a983:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1a986:	eb 33                	jmp    1a9bb <lwm2m_engine_get_res_data+0x8c>
	ret = path_to_objs(&path, NULL, NULL, &res);
   1a988:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1a98b:	31 d2                	xor    %edx,%edx
   1a98d:	50                   	push   %eax
   1a98e:	31 c9                	xor    %ecx,%ecx
   1a990:	8d 45 f6             	lea    -0xa(%ebp),%eax
   1a993:	e8 c3 cb ff ff       	call   1755b <path_to_objs>
   1a998:	5a                   	pop    %edx
	if (ret < 0) {
   1a999:	85 c0                	test   %eax,%eax
   1a99b:	78 1e                	js     1a9bb <lwm2m_engine_get_res_data+0x8c>
	*data_ptr = res->data_ptr;
   1a99d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1a9a0:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a9a3:	8b 48 14             	mov    0x14(%eax),%ecx
   1a9a6:	89 0a                	mov    %ecx,(%edx)
	*data_len = res->data_len;
   1a9a8:	8b 55 10             	mov    0x10(%ebp),%edx
   1a9ab:	8b 48 18             	mov    0x18(%eax),%ecx
   1a9ae:	66 89 0a             	mov    %cx,(%edx)
	*data_flags = res->data_flags;
   1a9b1:	8a 50 1c             	mov    0x1c(%eax),%dl
   1a9b4:	8b 45 14             	mov    0x14(%ebp),%eax
   1a9b7:	88 10                	mov    %dl,(%eax)
	return 0;
   1a9b9:	31 c0                	xor    %eax,%eax
}
   1a9bb:	c9                   	leave  
   1a9bc:	c3                   	ret    

0001a9bd <lwm2m_engine_get_u32>:
{
   1a9bd:	55                   	push   %ebp
	return lwm2m_engine_get(pathstr, value, 4);
   1a9be:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   1a9c3:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_get(pathstr, value, 4);
   1a9c5:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a9c8:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1a9cb:	5d                   	pop    %ebp
	return lwm2m_engine_get(pathstr, value, 4);
   1a9cc:	e9 0e d0 ff ff       	jmp    179df <lwm2m_engine_get>

0001a9d1 <lwm2m_engine_get_s8>:
{
   1a9d1:	55                   	push   %ebp
	return lwm2m_engine_get(pathstr, value, 1);
   1a9d2:	b9 01 00 00 00       	mov    $0x1,%ecx
{
   1a9d7:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_get(pathstr, value, 1);
   1a9d9:	8b 55 0c             	mov    0xc(%ebp),%edx
   1a9dc:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1a9df:	5d                   	pop    %ebp
	return lwm2m_engine_get(pathstr, value, 1);
   1a9e0:	e9 fa cf ff ff       	jmp    179df <lwm2m_engine_get>

0001a9e5 <lwm2m_engine_get_bool>:
{
   1a9e5:	55                   	push   %ebp
   1a9e6:	89 e5                	mov    %esp,%ebp
   1a9e8:	50                   	push   %eax
	ret = lwm2m_engine_get_s8(pathstr, &temp);
   1a9e9:	8d 45 ff             	lea    -0x1(%ebp),%eax
	s8_t temp = 0;
   1a9ec:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
	ret = lwm2m_engine_get_s8(pathstr, &temp);
   1a9f0:	50                   	push   %eax
   1a9f1:	ff 75 08             	pushl  0x8(%ebp)
   1a9f4:	e8 d8 ff ff ff       	call   1a9d1 <lwm2m_engine_get_s8>
   1a9f9:	5a                   	pop    %edx
	if (!ret) {
   1a9fa:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_s8(pathstr, &temp);
   1a9fc:	59                   	pop    %ecx
	if (!ret) {
   1a9fd:	75 0a                	jne    1aa09 <lwm2m_engine_get_bool+0x24>
		*value = temp != 0;
   1a9ff:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aa02:	80 7d ff 00          	cmpb   $0x0,-0x1(%ebp)
   1aa06:	0f 95 02             	setne  (%edx)
}
   1aa09:	c9                   	leave  
   1aa0a:	c3                   	ret    

0001aa0b <lwm2m_engine_get_resource>:
{
   1aa0b:	55                   	push   %ebp
   1aa0c:	89 e5                	mov    %esp,%ebp
   1aa0e:	83 ec 10             	sub    $0x10,%esp
	ret = string_to_path(pathstr, &path, '/');
   1aa11:	8d 55 f6             	lea    -0xa(%ebp),%edx
   1aa14:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa17:	e8 37 c5 ff ff       	call   16f53 <string_to_path.constprop.18>
	if (ret < 0) {
   1aa1c:	85 c0                	test   %eax,%eax
   1aa1e:	78 4d                	js     1aa6d <lwm2m_engine_get_resource+0x62>
	if (path.level < 3) {
   1aa20:	80 7d fe 02          	cmpb   $0x2,-0x2(%ebp)
   1aa24:	77 37                	ja     1aa5d <lwm2m_engine_get_resource+0x52>
		LOG_ERR("path must have 3 parts");
   1aa26:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1aa2b:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1aa32:	74 39                	je     1aa6d <lwm2m_engine_get_resource+0x62>
   1aa34:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1aa39:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1aa3c:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1aa42:	c1 ea 03             	shr    $0x3,%edx
   1aa45:	c1 e2 06             	shl    $0x6,%edx
   1aa48:	83 ca 01             	or     $0x1,%edx
   1aa4b:	52                   	push   %edx
   1aa4c:	68 51 94 02 00       	push   $0x29451
   1aa51:	e8 34 8a fe ff       	call   348a <log_0>
   1aa56:	59                   	pop    %ecx
   1aa57:	58                   	pop    %eax
   1aa58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1aa5b:	eb 10                	jmp    1aa6d <lwm2m_engine_get_resource+0x62>
	return path_to_objs(&path, NULL, NULL, res);
   1aa5d:	ff 75 0c             	pushl  0xc(%ebp)
   1aa60:	31 d2                	xor    %edx,%edx
   1aa62:	31 c9                	xor    %ecx,%ecx
   1aa64:	8d 45 f6             	lea    -0xa(%ebp),%eax
   1aa67:	e8 ef ca ff ff       	call   1755b <path_to_objs>
   1aa6c:	5a                   	pop    %edx
}
   1aa6d:	c9                   	leave  
   1aa6e:	c3                   	ret    

0001aa6f <lwm2m_engine_register_pre_write_callback>:
{
   1aa6f:	55                   	push   %ebp
   1aa70:	89 e5                	mov    %esp,%ebp
   1aa72:	50                   	push   %eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aa73:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct lwm2m_engine_res_inst *res = NULL;
   1aa76:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aa7d:	50                   	push   %eax
   1aa7e:	ff 75 08             	pushl  0x8(%ebp)
   1aa81:	e8 85 ff ff ff       	call   1aa0b <lwm2m_engine_get_resource>
   1aa86:	5a                   	pop    %edx
	if (ret < 0) {
   1aa87:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aa89:	59                   	pop    %ecx
	if (ret < 0) {
   1aa8a:	78 0b                	js     1aa97 <lwm2m_engine_register_pre_write_callback+0x28>
	res->pre_write_cb = cb;
   1aa8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1aa8f:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aa92:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
   1aa95:	31 c0                	xor    %eax,%eax
}
   1aa97:	c9                   	leave  
   1aa98:	c3                   	ret    

0001aa99 <lwm2m_engine_register_post_write_callback>:
{
   1aa99:	55                   	push   %ebp
   1aa9a:	89 e5                	mov    %esp,%ebp
   1aa9c:	50                   	push   %eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aa9d:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct lwm2m_engine_res_inst *res = NULL;
   1aaa0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aaa7:	50                   	push   %eax
   1aaa8:	ff 75 08             	pushl  0x8(%ebp)
   1aaab:	e8 5b ff ff ff       	call   1aa0b <lwm2m_engine_get_resource>
   1aab0:	5a                   	pop    %edx
	if (ret < 0) {
   1aab1:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aab3:	59                   	pop    %ecx
	if (ret < 0) {
   1aab4:	78 0b                	js     1aac1 <lwm2m_engine_register_post_write_callback+0x28>
	res->post_write_cb = cb;
   1aab6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1aab9:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aabc:	89 50 08             	mov    %edx,0x8(%eax)
	return 0;
   1aabf:	31 c0                	xor    %eax,%eax
}
   1aac1:	c9                   	leave  
   1aac2:	c3                   	ret    

0001aac3 <lwm2m_engine_register_exec_callback>:
{
   1aac3:	55                   	push   %ebp
   1aac4:	89 e5                	mov    %esp,%ebp
   1aac6:	50                   	push   %eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aac7:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct lwm2m_engine_res_inst *res = NULL;
   1aaca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aad1:	50                   	push   %eax
   1aad2:	ff 75 08             	pushl  0x8(%ebp)
   1aad5:	e8 31 ff ff ff       	call   1aa0b <lwm2m_engine_get_resource>
   1aada:	5a                   	pop    %edx
	if (ret < 0) {
   1aadb:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
   1aadd:	59                   	pop    %ecx
	if (ret < 0) {
   1aade:	78 0b                	js     1aaeb <lwm2m_engine_register_exec_callback+0x28>
	res->execute_cb = cb;
   1aae0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1aae3:	8b 55 0c             	mov    0xc(%ebp),%edx
   1aae6:	89 50 0c             	mov    %edx,0xc(%eax)
	return 0;
   1aae9:	31 c0                	xor    %eax,%eax
}
   1aaeb:	c9                   	leave  
   1aaec:	c3                   	ret    

0001aaed <lwm2m_engine_get_opaque_more>:
{
   1aaed:	55                   	push   %ebp
   1aaee:	89 e5                	mov    %esp,%ebp
   1aaf0:	57                   	push   %edi
   1aaf1:	56                   	push   %esi
   1aaf2:	53                   	push   %ebx
   1aaf3:	50                   	push   %eax
   1aaf4:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1aaf7:	8b 4d 10             	mov    0x10(%ebp),%ecx
		in_len = buflen;
   1aafa:	89 ce                	mov    %ecx,%esi
	u16_t in_len = in->opaque_len;
   1aafc:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
   1ab00:	89 d0                	mov    %edx,%eax
	if (in_len > buflen) {
   1ab02:	39 ca                	cmp    %ecx,%edx
   1ab04:	77 02                	ja     1ab08 <lwm2m_engine_get_opaque_more+0x1b>
   1ab06:	89 d6                	mov    %edx,%esi
	in->opaque_len -= in_len;
   1ab08:	29 f0                	sub    %esi,%eax
	if (in->opaque_len == 0) {
   1ab0a:	66 85 c0             	test   %ax,%ax
	in->opaque_len -= in_len;
   1ab0d:	66 89 43 0a          	mov    %ax,0xa(%ebx)
	if (in->opaque_len == 0) {
   1ab11:	75 06                	jne    1ab19 <lwm2m_engine_get_opaque_more+0x2c>
		*last_block = true;
   1ab13:	8b 45 14             	mov    0x14(%ebp),%eax
   1ab16:	c6 00 01             	movb   $0x1,(%eax)
	if (buf_read(buf, in_len, CPKT_BUF_READ(in->in_cpkt),
   1ab19:	8b 43 04             	mov    0x4(%ebx),%eax
   1ab1c:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   1ab20:	8b 10                	mov    (%eax),%edx
   1ab22:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1ab25:	0f b7 c6             	movzwl %si,%eax

/* read */
static inline int buf_read(u8_t *dst, u16_t len, u8_t *src, u16_t src_len,
			   u16_t *offset)
{
	if (!src) {
   1ab28:	85 d2                	test   %edx,%edx
   1ab2a:	74 29                	je     1ab55 <lwm2m_engine_get_opaque_more+0x68>
		return -EINVAL;
	}

	if (*offset + len > src_len) {
   1ab2c:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
   1ab30:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
   1ab33:	39 7d f0             	cmp    %edi,-0x10(%ebp)
   1ab36:	7c 1d                	jl     1ab55 <lwm2m_engine_get_opaque_more+0x68>
		return -ENOMEM;
	}

	if (dst) {
   1ab38:	89 c7                	mov    %eax,%edi
   1ab3a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1ab3e:	74 0f                	je     1ab4f <lwm2m_engine_get_opaque_more+0x62>
		/* copy data at offset into dst */
		memcpy(dst, src + *offset, len);
   1ab40:	50                   	push   %eax
   1ab41:	01 ca                	add    %ecx,%edx
   1ab43:	52                   	push   %edx
   1ab44:	ff 75 0c             	pushl  0xc(%ebp)
   1ab47:	e8 e5 fd fe ff       	call   a931 <memcpy>
   1ab4c:	83 c4 0c             	add    $0xc,%esp
	}

	*offset += len;
   1ab4f:	66 01 73 08          	add    %si,0x8(%ebx)
	return (size_t)in_len;
   1ab53:	eb 08                	jmp    1ab5d <lwm2m_engine_get_opaque_more+0x70>
		*last_block = true;
   1ab55:	8b 45 14             	mov    0x14(%ebp),%eax
		return 0;
   1ab58:	31 ff                	xor    %edi,%edi
		*last_block = true;
   1ab5a:	c6 00 01             	movb   $0x1,(%eax)
}
   1ab5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1ab60:	89 f8                	mov    %edi,%eax
   1ab62:	5b                   	pop    %ebx
   1ab63:	5e                   	pop    %esi
   1ab64:	5f                   	pop    %edi
   1ab65:	5d                   	pop    %ebp
   1ab66:	c3                   	ret    

0001ab67 <lwm2m_write_handler>:
{
   1ab67:	55                   	push   %ebp
   1ab68:	89 e5                	mov    %esp,%ebp
   1ab6a:	57                   	push   %edi
   1ab6b:	56                   	push   %esi
   1ab6c:	53                   	push   %ebx
   1ab6d:	83 ec 40             	sub    $0x40,%esp
	struct block_context *block_ctx = NULL;
   1ab70:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
{
   1ab77:	8b 75 14             	mov    0x14(%ebp),%esi
	s64_t temp64 = 0;
   1ab7a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
   1ab81:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	s32_t temp32 = 0;
   1ab88:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	if (!obj_inst || !res || !obj_field || !msg) {
   1ab8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1ab93:	0f 84 2c 03 00 00    	je     1aec5 <lwm2m_write_handler+0x35e>
   1ab99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1ab9d:	0f 84 22 03 00 00    	je     1aec5 <lwm2m_write_handler+0x35e>
   1aba3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1aba7:	0f 84 18 03 00 00    	je     1aec5 <lwm2m_write_handler+0x35e>
   1abad:	85 f6                	test   %esi,%esi
   1abaf:	0f 84 10 03 00 00    	je     1aec5 <lwm2m_write_handler+0x35e>
	if (LWM2M_HAS_RES_FLAG(res, LWM2M_RES_DATA_FLAG_RO)) {
   1abb5:	8b 45 0c             	mov    0xc(%ebp),%eax
		return -EACCES;
   1abb8:	bf f3 ff ff ff       	mov    $0xfffffff3,%edi
	if (LWM2M_HAS_RES_FLAG(res, LWM2M_RES_DATA_FLAG_RO)) {
   1abbd:	f6 40 1c 01          	testb  $0x1,0x1c(%eax)
   1abc1:	0f 85 03 03 00 00    	jne    1aeca <lwm2m_write_handler+0x363>
	data_ptr = res->data_ptr;
   1abc7:	8b 58 14             	mov    0x14(%eax),%ebx
	data_len = res->data_len;
   1abca:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   1abce:	89 45 cc             	mov    %eax,-0x34(%ebp)
	if (res->pre_write_cb) {
   1abd1:	8b 45 0c             	mov    0xc(%ebp),%eax
   1abd4:	8b 40 04             	mov    0x4(%eax),%eax
   1abd7:	85 c0                	test   %eax,%eax
   1abd9:	74 12                	je     1abed <lwm2m_write_handler+0x86>
		data_ptr = res->pre_write_cb(obj_inst->obj_inst_id, &data_len);
   1abdb:	8b 7d 08             	mov    0x8(%ebp),%edi
   1abde:	8d 55 cc             	lea    -0x34(%ebp),%edx
   1abe1:	52                   	push   %edx
   1abe2:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
   1abe6:	52                   	push   %edx
   1abe7:	ff d0                	call   *%eax
   1abe9:	5b                   	pop    %ebx
   1abea:	89 c3                	mov    %eax,%ebx
   1abec:	5f                   	pop    %edi
	if (res->post_write_cb) {
   1abed:	8b 45 0c             	mov    0xc(%ebp),%eax
   1abf0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   1abf4:	0f 84 a2 00 00 00    	je     1ac9c <lwm2m_write_handler+0x135>
		ret = get_option_int(msg->in.in_cpkt, COAP_OPTION_BLOCK1);
   1abfa:	8b 46 08             	mov    0x8(%esi),%eax
   1abfd:	ba 1b 00 00 00       	mov    $0x1b,%edx
   1ac02:	e8 fe bf ff ff       	call   16c05 <get_option_int>
   1ac07:	89 c7                	mov    %eax,%edi
		if (ret >= 0) {
   1ac09:	85 c0                	test   %eax,%eax
   1ac0b:	0f 88 93 00 00 00    	js     1aca4 <lwm2m_write_handler+0x13d>
			last_block = !GET_MORE(ret);
   1ac11:	c1 e8 03             	shr    $0x3,%eax
   1ac14:	83 f0 01             	xor    $0x1,%eax
   1ac17:	83 e0 01             	and    $0x1,%eax
   1ac1a:	88 45 c3             	mov    %al,-0x3d(%ebp)
			tkl = coap_header_get_token(msg->in.in_cpkt, token);
   1ac1d:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1ac20:	50                   	push   %eax
   1ac21:	ff 76 08             	pushl  0x8(%esi)
   1ac24:	e8 7b d8 fe ff       	call   84a4 <coap_header_get_token>
	size_t total_size = 0;
   1ac29:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
			tkl = coap_header_get_token(msg->in.in_cpkt, token);
   1ac30:	5a                   	pop    %edx
			if (tkl && !get_block_ctx(token, tkl, &block_ctx)) {
   1ac31:	84 c0                	test   %al,%al
			tkl = coap_header_get_token(msg->in.in_cpkt, token);
   1ac33:	59                   	pop    %ecx
			if (tkl && !get_block_ctx(token, tkl, &block_ctx)) {
   1ac34:	74 79                	je     1acaf <lwm2m_write_handler+0x148>
   1ac36:	0f b6 d0             	movzbl %al,%edx
   1ac39:	8d 4d c8             	lea    -0x38(%ebp),%ecx
   1ac3c:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1ac3f:	e8 d5 c0 ff ff       	call   16d19 <get_block_ctx>
   1ac44:	85 c0                	test   %eax,%eax
   1ac46:	75 67                	jne    1acaf <lwm2m_write_handler+0x148>
				total_size = block_ctx->ctx.total_size;
   1ac48:	8b 55 c8             	mov    -0x38(%ebp),%edx
				LOG_DBG("BLOCK1: total:%zu current:%zu"
   1ac4b:	f6 05 a4 a8 40 00 04 	testb  $0x4,0x40a8a4
				total_size = block_ctx->ctx.total_size;
   1ac52:	8b 02                	mov    (%edx),%eax
   1ac54:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				LOG_DBG("BLOCK1: total:%zu current:%zu"
   1ac57:	74 56                	je     1acaf <lwm2m_write_handler+0x148>
   1ac59:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1ac5e:	8b 52 04             	mov    0x4(%edx),%edx
   1ac61:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ac66:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1ac69:	c1 e8 03             	shr    $0x3,%eax
   1ac6c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
   1ac6f:	c1 e0 06             	shl    $0x6,%eax
   1ac72:	c7 45 e4 d4 62 02 00 	movl   $0x262d4,-0x1c(%ebp)
   1ac79:	83 c8 04             	or     $0x4,%eax
   1ac7c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   1ac7f:	50                   	push   %eax
   1ac80:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1ac83:	6a 04                	push   $0x4
   1ac85:	50                   	push   %eax
   1ac86:	0f b6 55 c3          	movzbl -0x3d(%ebp),%edx
   1ac8a:	68 f5 9c 02 00       	push   $0x29cf5
   1ac8f:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1ac92:	e8 f2 88 fe ff       	call   3589 <log_n>
   1ac97:	83 c4 10             	add    $0x10,%esp
   1ac9a:	eb 13                	jmp    1acaf <lwm2m_write_handler+0x148>
	bool last_block = true;
   1ac9c:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
	int ret = 0;
   1aca0:	31 ff                	xor    %edi,%edi
   1aca2:	eb 04                	jmp    1aca8 <lwm2m_write_handler+0x141>
	bool last_block = true;
   1aca4:	c6 45 c3 01          	movb   $0x1,-0x3d(%ebp)
	size_t total_size = 0;
   1aca8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
	if (data_ptr && data_len > 0) {
   1acaf:	85 db                	test   %ebx,%ebx
   1acb1:	0f 84 07 02 00 00    	je     1aebe <lwm2m_write_handler+0x357>
   1acb7:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1acba:	89 45 bc             	mov    %eax,-0x44(%ebp)
   1acbd:	85 c0                	test   %eax,%eax
   1acbf:	0f 84 f9 01 00 00    	je     1aebe <lwm2m_write_handler+0x357>
		switch (obj_field->data_type) {
   1acc5:	8b 45 10             	mov    0x10(%ebp),%eax
   1acc8:	0f b6 50 03          	movzbl 0x3(%eax),%edx
   1accc:	8d 42 ff             	lea    -0x1(%edx),%eax
   1accf:	3c 0d                	cmp    $0xd,%al
   1acd1:	0f 87 7b 01 00 00    	ja     1ae52 <lwm2m_write_handler+0x2eb>
   1acd7:	0f b6 c0             	movzbl %al,%eax
   1acda:	8d 4e 04             	lea    0x4(%esi),%ecx
   1acdd:	ff 24 85 b4 61 02 00 	jmp    *0x261b4(,%eax,4)
	bool last_pkt_block = false, first_read = true;
   1ace4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
	int ret = 0;
   1ace8:	31 ff                	xor    %edi,%edi
	bool last_pkt_block = false, first_read = true;
   1acea:	c6 45 c2 01          	movb   $0x1,-0x3e(%ebp)
   1acee:	8a 55 c2             	mov    -0x3e(%ebp),%dl
	while (!last_pkt_block && len > 0) {
   1acf1:	8a 45 e4             	mov    -0x1c(%ebp),%al
   1acf4:	88 45 c2             	mov    %al,-0x3e(%ebp)
   1acf7:	84 c0                	test   %al,%al
   1acf9:	0f 85 82 01 00 00    	jne    1ae81 <lwm2m_write_handler+0x31a>
		if (first_read) {
   1acff:	84 d2                	test   %dl,%dl
   1ad01:	74 2b                	je     1ad2e <lwm2m_write_handler+0x1c7>

static inline size_t engine_get_opaque(struct lwm2m_input_context *in,
				       u8_t *buf, size_t buflen,
				       bool *last_block)
{
	if (in->reader->get_opaque) {
   1ad03:	8b 46 04             	mov    0x4(%esi),%eax
   1ad06:	8b 40 18             	mov    0x18(%eax),%eax
   1ad09:	85 c0                	test   %eax,%eax
   1ad0b:	0f 84 6e 01 00 00    	je     1ae7f <lwm2m_write_handler+0x318>
		return in->reader->get_opaque(in, buf, buflen, last_block);
   1ad11:	8d 55 e4             	lea    -0x1c(%ebp),%edx
   1ad14:	89 4d b8             	mov    %ecx,-0x48(%ebp)
   1ad17:	52                   	push   %edx
   1ad18:	ff 75 bc             	pushl  -0x44(%ebp)
   1ad1b:	53                   	push   %ebx
   1ad1c:	51                   	push   %ecx
   1ad1d:	ff d0                	call   *%eax
   1ad1f:	83 c4 10             	add    $0x10,%esp
			if (len == 0) {
   1ad22:	8b 4d b8             	mov    -0x48(%ebp),%ecx
   1ad25:	85 c0                	test   %eax,%eax
   1ad27:	75 24                	jne    1ad4d <lwm2m_write_handler+0x1e6>
   1ad29:	e9 51 01 00 00       	jmp    1ae7f <lwm2m_write_handler+0x318>
			len = lwm2m_engine_get_opaque_more(in, (u8_t *)data_ptr,
   1ad2e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1ad31:	89 4d b8             	mov    %ecx,-0x48(%ebp)
   1ad34:	50                   	push   %eax
   1ad35:	ff 75 bc             	pushl  -0x44(%ebp)
   1ad38:	53                   	push   %ebx
   1ad39:	51                   	push   %ecx
   1ad3a:	e8 ae fd ff ff       	call   1aaed <lwm2m_engine_get_opaque_more>
   1ad3f:	83 c4 10             	add    $0x10,%esp
		if (len == 0) {
   1ad42:	8b 4d b8             	mov    -0x48(%ebp),%ecx
   1ad45:	85 c0                	test   %eax,%eax
   1ad47:	0f 84 78 01 00 00    	je     1aec5 <lwm2m_write_handler+0x35e>
		if (res->post_write_cb) {
   1ad4d:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ad50:	8b 52 08             	mov    0x8(%edx),%edx
   1ad53:	89 55 b8             	mov    %edx,-0x48(%ebp)
   1ad56:	31 d2                	xor    %edx,%edx
   1ad58:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   1ad5c:	74 93                	je     1acf1 <lwm2m_write_handler+0x18a>
			ret = res->post_write_cb(obj_inst->obj_inst_id,
   1ad5e:	ff 75 c4             	pushl  -0x3c(%ebp)
						 last_pkt_block && last_block,
   1ad61:	8a 55 c3             	mov    -0x3d(%ebp),%dl
   1ad64:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   1ad67:	23 55 e4             	and    -0x1c(%ebp),%edx
   1ad6a:	0f b6 d2             	movzbl %dl,%edx
			ret = res->post_write_cb(obj_inst->obj_inst_id,
   1ad6d:	52                   	push   %edx
   1ad6e:	0f b7 c0             	movzwl %ax,%eax
   1ad71:	50                   	push   %eax
   1ad72:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad75:	53                   	push   %ebx
   1ad76:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   1ad7a:	50                   	push   %eax
   1ad7b:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1ad7e:	ff d0                	call   *%eax
   1ad80:	83 c4 14             	add    $0x14,%esp
   1ad83:	89 c7                	mov    %eax,%edi
			if (ret < 0) {
   1ad85:	85 c0                	test   %eax,%eax
   1ad87:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
   1ad8a:	0f 89 5e ff ff ff    	jns    1acee <lwm2m_write_handler+0x187>
   1ad90:	e9 35 01 00 00       	jmp    1aeca <lwm2m_write_handler+0x363>
	return in->reader->get_string(in, buf, buflen);
   1ad95:	8b 46 04             	mov    0x4(%esi),%eax
   1ad98:	ff 75 bc             	pushl  -0x44(%ebp)
   1ad9b:	53                   	push   %ebx
   1ad9c:	51                   	push   %ecx
   1ad9d:	ff 50 08             	call   *0x8(%eax)
   1ada0:	83 c4 0c             	add    $0xc,%esp
			len = strlen((char *)data_ptr);
   1ada3:	53                   	push   %ebx
   1ada4:	e8 ba fa fe ff       	call   a863 <strlen>
   1ada9:	59                   	pop    %ecx
			break;
   1adaa:	e9 d4 00 00 00       	jmp    1ae83 <lwm2m_write_handler+0x31c>
	return in->reader->get_s64(in, value);
   1adaf:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   1adb2:	8b 46 04             	mov    0x4(%esi),%eax
   1adb5:	52                   	push   %edx
   1adb6:	51                   	push   %ecx
   1adb7:	ff 50 04             	call   *0x4(%eax)
   1adba:	58                   	pop    %eax
			*(u64_t *)data_ptr = temp64;
   1adbb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1adbe:	5a                   	pop    %edx
   1adbf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1adc2:	89 53 04             	mov    %edx,0x4(%ebx)
   1adc5:	89 03                	mov    %eax,(%ebx)
   1adc7:	eb 71                	jmp    1ae3a <lwm2m_write_handler+0x2d3>
			engine_get_s32(&msg->in, &temp32);
   1adc9:	8d 55 d0             	lea    -0x30(%ebp),%edx
   1adcc:	89 c8                	mov    %ecx,%eax
   1adce:	e8 f1 bb ff ff       	call   169c4 <engine_get_s32>
			*(u32_t *)data_ptr = temp32;
   1add3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1add6:	89 03                	mov    %eax,(%ebx)
			break;
   1add8:	eb 13                	jmp    1aded <lwm2m_write_handler+0x286>
   1adda:	8b 46 04             	mov    0x4(%esi),%eax
   1addd:	53                   	push   %ebx
   1adde:	51                   	push   %ecx
   1addf:	ff 50 04             	call   *0x4(%eax)
   1ade2:	eb 54                	jmp    1ae38 <lwm2m_write_handler+0x2d1>
			engine_get_s32(&msg->in, (s32_t *)data_ptr);
   1ade4:	89 da                	mov    %ebx,%edx
   1ade6:	89 c8                	mov    %ecx,%eax
   1ade8:	e8 d7 bb ff ff       	call   169c4 <engine_get_s32>
			len = 4;
   1aded:	b8 04 00 00 00       	mov    $0x4,%eax
			break;
   1adf2:	e9 8c 00 00 00       	jmp    1ae83 <lwm2m_write_handler+0x31c>
			engine_get_s32(&msg->in, &temp32);
   1adf7:	8d 55 d0             	lea    -0x30(%ebp),%edx
   1adfa:	89 c8                	mov    %ecx,%eax
   1adfc:	e8 c3 bb ff ff       	call   169c4 <engine_get_s32>
			*(s16_t *)data_ptr = temp32;
   1ae01:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1ae04:	66 89 03             	mov    %ax,(%ebx)
			len = 2;
   1ae07:	b8 02 00 00 00       	mov    $0x2,%eax
			break;
   1ae0c:	eb 75                	jmp    1ae83 <lwm2m_write_handler+0x31c>
			engine_get_s32(&msg->in, &temp32);
   1ae0e:	8d 55 d0             	lea    -0x30(%ebp),%edx
   1ae11:	89 c8                	mov    %ecx,%eax
   1ae13:	e8 ac bb ff ff       	call   169c4 <engine_get_s32>
			*(s8_t *)data_ptr = temp32;
   1ae18:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1ae1b:	88 03                	mov    %al,(%ebx)
			break;
   1ae1d:	eb 0a                	jmp    1ae29 <lwm2m_write_handler+0x2c2>
	return in->reader->get_bool(in, value);
   1ae1f:	8b 46 04             	mov    0x4(%esi),%eax
   1ae22:	53                   	push   %ebx
   1ae23:	51                   	push   %ecx
   1ae24:	ff 50 14             	call   *0x14(%eax)
   1ae27:	59                   	pop    %ecx
   1ae28:	58                   	pop    %eax
			len = 1;
   1ae29:	b8 01 00 00 00       	mov    $0x1,%eax
   1ae2e:	eb 53                	jmp    1ae83 <lwm2m_write_handler+0x31c>
	return in->reader->get_float32fix(in, value);
   1ae30:	8b 46 04             	mov    0x4(%esi),%eax
   1ae33:	53                   	push   %ebx
   1ae34:	51                   	push   %ecx
   1ae35:	ff 50 0c             	call   *0xc(%eax)
   1ae38:	58                   	pop    %eax
   1ae39:	5a                   	pop    %edx
			len = sizeof(float32_value_t);
   1ae3a:	b8 08 00 00 00       	mov    $0x8,%eax
   1ae3f:	eb 42                	jmp    1ae83 <lwm2m_write_handler+0x31c>
	return in->reader->get_float64fix(in, value);
   1ae41:	8b 46 04             	mov    0x4(%esi),%eax
   1ae44:	53                   	push   %ebx
   1ae45:	51                   	push   %ecx
   1ae46:	ff 50 10             	call   *0x10(%eax)
   1ae49:	5a                   	pop    %edx
   1ae4a:	59                   	pop    %ecx
			len = sizeof(float64_value_t);
   1ae4b:	b8 10 00 00 00       	mov    $0x10,%eax
   1ae50:	eb 31                	jmp    1ae83 <lwm2m_write_handler+0x31c>
			LOG_ERR("unknown obj data_type %d",
   1ae52:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1ae59:	74 6a                	je     1aec5 <lwm2m_write_handler+0x35e>
   1ae5b:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1ae60:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ae65:	c1 e8 03             	shr    $0x3,%eax
   1ae68:	c1 e0 06             	shl    $0x6,%eax
   1ae6b:	83 c8 01             	or     $0x1,%eax
   1ae6e:	50                   	push   %eax
   1ae6f:	52                   	push   %edx
   1ae70:	68 ca 94 02 00       	push   $0x294ca
   1ae75:	e8 35 86 fe ff       	call   34af <log_1>
   1ae7a:	83 c4 0c             	add    $0xc,%esp
   1ae7d:	eb 46                	jmp    1aec5 <lwm2m_write_handler+0x35e>
				return 0;
   1ae7f:	31 ff                	xor    %edi,%edi
	size_t len = 0;
   1ae81:	31 c0                	xor    %eax,%eax
	if (res->post_write_cb &&
   1ae83:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   1ae86:	8b 51 08             	mov    0x8(%ecx),%edx
   1ae89:	85 d2                	test   %edx,%edx
   1ae8b:	74 25                	je     1aeb2 <lwm2m_write_handler+0x34b>
   1ae8d:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1ae90:	80 79 03 01          	cmpb   $0x1,0x3(%ecx)
   1ae94:	74 1c                	je     1aeb2 <lwm2m_write_handler+0x34b>
		ret = res->post_write_cb(obj_inst->obj_inst_id, data_ptr, len,
   1ae96:	ff 75 c4             	pushl  -0x3c(%ebp)
   1ae99:	0f b6 4d c3          	movzbl -0x3d(%ebp),%ecx
   1ae9d:	0f b7 c0             	movzwl %ax,%eax
   1aea0:	51                   	push   %ecx
   1aea1:	50                   	push   %eax
   1aea2:	8b 45 08             	mov    0x8(%ebp),%eax
   1aea5:	53                   	push   %ebx
   1aea6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   1aeaa:	50                   	push   %eax
   1aeab:	ff d2                	call   *%edx
   1aead:	83 c4 14             	add    $0x14,%esp
   1aeb0:	89 c7                	mov    %eax,%edi
	NOTIFY_OBSERVER_PATH(&msg->path);
   1aeb2:	83 c6 20             	add    $0x20,%esi
   1aeb5:	56                   	push   %esi
   1aeb6:	e8 3d c6 ff ff       	call   174f8 <lwm2m_notify_observer_path>
   1aebb:	58                   	pop    %eax
	return ret;
   1aebc:	eb 0c                	jmp    1aeca <lwm2m_write_handler+0x363>
		return -ENOENT;
   1aebe:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
   1aec3:	eb 05                	jmp    1aeca <lwm2m_write_handler+0x363>
			return -EINVAL;
   1aec5:	bf ea ff ff ff       	mov    $0xffffffea,%edi
}
   1aeca:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1aecd:	89 f8                	mov    %edi,%eax
   1aecf:	5b                   	pop    %ebx
   1aed0:	5e                   	pop    %esi
   1aed1:	5f                   	pop    %edi
   1aed2:	5d                   	pop    %ebp
   1aed3:	c3                   	ret    

0001aed4 <lwm2m_perform_read_op>:
{
   1aed4:	55                   	push   %ebp
   1aed5:	89 e5                	mov    %esp,%ebp
   1aed7:	57                   	push   %edi
   1aed8:	56                   	push   %esi
   1aed9:	53                   	push   %ebx
   1aeda:	83 ec 34             	sub    $0x34,%esp
   1aedd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1aee0:	8b 75 10             	mov    0x10(%ebp),%esi
	if (msg->path.level >= 2) {
   1aee3:	80 7b 28 01          	cmpb   $0x1,0x28(%ebx)
   1aee7:	76 0f                	jbe    1aef8 <lwm2m_perform_read_op+0x24>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
   1aee9:	0f b7 53 22          	movzwl 0x22(%ebx),%edx
   1aeed:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
   1aef1:	e8 f4 ba ff ff       	call   169ea <get_engine_obj_inst>
   1aef6:	eb 18                	jmp    1af10 <lwm2m_perform_read_op+0x3c>
	} else if (msg->path.level == 1) {
   1aef8:	74 0a                	je     1af04 <lwm2m_perform_read_op+0x30>
		return -ENOENT;
   1aefa:	be fe ff ff ff       	mov    $0xfffffffe,%esi
   1aeff:	e9 1f 04 00 00       	jmp    1b323 <lwm2m_perform_read_op+0x44f>
		obj_inst = next_engine_obj_inst(msg->path.obj_id, -1);
   1af04:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
   1af08:	83 ca ff             	or     $0xffffffff,%edx
   1af0b:	e8 09 bb ff ff       	call   16a19 <next_engine_obj_inst>
   1af10:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!obj_inst) {
   1af13:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1af17:	74 e1                	je     1aefa <lwm2m_perform_read_op+0x26>
	ret = coap_append_option_int(msg->out.out_cpkt,
   1af19:	0f b7 f6             	movzwl %si,%esi
   1af1c:	56                   	push   %esi
   1af1d:	6a 0c                	push   $0xc
   1af1f:	ff 73 18             	pushl  0x18(%ebx)
   1af22:	e8 81 d2 fe ff       	call   81a8 <coap_append_option_int>
   1af27:	83 c4 0c             	add    $0xc,%esp
   1af2a:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1af2c:	85 c0                	test   %eax,%eax
   1af2e:	79 29                	jns    1af59 <lwm2m_perform_read_op+0x85>
		LOG_ERR("Error setting response content-format: %d", ret);
   1af30:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1af37:	0f 84 e6 03 00 00    	je     1b323 <lwm2m_perform_read_op+0x44f>
   1af3d:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1af42:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1af47:	c1 e8 03             	shr    $0x3,%eax
   1af4a:	c1 e0 06             	shl    $0x6,%eax
   1af4d:	83 c8 01             	or     $0x1,%eax
   1af50:	50                   	push   %eax
   1af51:	56                   	push   %esi
   1af52:	68 af 98 02 00       	push   $0x298af
   1af57:	eb 36                	jmp    1af8f <lwm2m_perform_read_op+0xbb>
	ret = coap_packet_append_payload_marker(msg->out.out_cpkt);
   1af59:	ff 73 18             	pushl  0x18(%ebx)
   1af5c:	e8 04 d3 fe ff       	call   8265 <coap_packet_append_payload_marker>
   1af61:	5a                   	pop    %edx
   1af62:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1af64:	85 c0                	test   %eax,%eax
   1af66:	79 34                	jns    1af9c <lwm2m_perform_read_op+0xc8>
		LOG_ERR("Error appending payload marker: %d", ret);
   1af68:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1af6f:	0f 84 ae 03 00 00    	je     1b323 <lwm2m_perform_read_op+0x44f>
   1af75:	b8 cc 51 02 00       	mov    $0x251cc,%eax
   1af7a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1af7f:	c1 e8 03             	shr    $0x3,%eax
   1af82:	c1 e0 06             	shl    $0x6,%eax
   1af85:	83 c8 01             	or     $0x1,%eax
   1af88:	50                   	push   %eax
   1af89:	56                   	push   %esi
   1af8a:	68 1f 9d 02 00       	push   $0x29d1f
   1af8f:	e8 1b 85 fe ff       	call   34af <log_1>
   1af94:	83 c4 0c             	add    $0xc,%esp
   1af97:	e9 87 03 00 00       	jmp    1b323 <lwm2m_perform_read_op+0x44f>
	memcpy(&temp_path, &msg->path, sizeof(temp_path));
   1af9c:	6a 0a                	push   $0xa
   1af9e:	8d 7b 20             	lea    0x20(%ebx),%edi
   1afa1:	57                   	push   %edi
   1afa2:	8d 45 ea             	lea    -0x16(%ebp),%eax
   1afa5:	50                   	push   %eax
   1afa6:	e8 86 f9 fe ff       	call   a931 <memcpy>
	engine_put_begin(&msg->out, &msg->path);
   1afab:	8d 43 14             	lea    0x14(%ebx),%eax
	memcpy(&temp_path, &msg->path, sizeof(temp_path));
   1afae:	83 c4 0c             	add    $0xc,%esp
	engine_put_begin(&msg->out, &msg->path);
   1afb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (out->writer->put_begin) {
   1afb4:	8b 43 14             	mov    0x14(%ebx),%eax
   1afb7:	8b 00                	mov    (%eax),%eax
   1afb9:	85 c0                	test   %eax,%eax
   1afbb:	74 08                	je     1afc5 <lwm2m_perform_read_op+0xf1>
		return out->writer->put_begin(out, path);
   1afbd:	57                   	push   %edi
   1afbe:	ff 75 e0             	pushl  -0x20(%ebp)
   1afc1:	ff d0                	call   *%eax
   1afc3:	59                   	pop    %ecx
   1afc4:	58                   	pop    %eax
   1afc5:	b8 cc 51 02 00       	mov    $0x251cc,%eax
			LOG_ERR("unknown obj data_type %d",
   1afca:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
   1afce:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1afd3:	c1 e8 03             	shr    $0x3,%eax
						LOG_ERR("READ OP: %d", ret);
   1afd6:	c1 e0 06             	shl    $0x6,%eax
   1afd9:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
		if (!obj_inst->resources || obj_inst->resource_count == 0) {
   1afdd:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1afe0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
   1afe4:	0f 84 c7 02 00 00    	je     1b2b1 <lwm2m_perform_read_op+0x3dd>
   1afea:	66 83 78 0e 00       	cmpw   $0x0,0xe(%eax)
   1afef:	0f 84 bc 02 00 00    	je     1b2b1 <lwm2m_perform_read_op+0x3dd>
		msg->path.obj_inst_id = obj_inst->obj_inst_id;
   1aff5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1aff8:	8b 43 14             	mov    0x14(%ebx),%eax
		if (msg->path.level <= 1) {
   1affb:	80 7b 28 01          	cmpb   $0x1,0x28(%ebx)
		msg->path.obj_inst_id = obj_inst->obj_inst_id;
   1afff:	8b 51 0c             	mov    0xc(%ecx),%edx
   1b002:	66 89 53 22          	mov    %dx,0x22(%ebx)
		if (msg->path.level <= 1) {
   1b006:	77 0f                	ja     1b017 <lwm2m_perform_read_op+0x143>
	if (out->writer->put_begin_oi) {
   1b008:	8b 40 08             	mov    0x8(%eax),%eax
   1b00b:	85 c0                	test   %eax,%eax
   1b00d:	74 08                	je     1b017 <lwm2m_perform_read_op+0x143>
		return out->writer->put_begin_oi(out, path);
   1b00f:	57                   	push   %edi
   1b010:	ff 75 e0             	pushl  -0x20(%ebp)
   1b013:	ff d0                	call   *%eax
   1b015:	58                   	pop    %eax
   1b016:	5a                   	pop    %edx
			ret = 0;
   1b017:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
		for (index = 0; index < obj_inst->resource_count; index++) {
   1b01e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b021:	8a 53 28             	mov    0x28(%ebx),%dl
   1b024:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   1b028:	3b 45 cc             	cmp    -0x34(%ebp),%eax
   1b02b:	0f 8e 80 02 00 00    	jle    1b2b1 <lwm2m_perform_read_op+0x3dd>
			if (msg->path.level > 2 &&
   1b031:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1b034:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1b037:	c1 e0 05             	shl    $0x5,%eax
   1b03a:	03 41 08             	add    0x8(%ecx),%eax
   1b03d:	80 fa 02             	cmp    $0x2,%dl
   1b040:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1b043:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   1b047:	76 0a                	jbe    1b053 <lwm2m_perform_read_op+0x17f>
   1b049:	66 39 43 24          	cmp    %ax,0x24(%ebx)
   1b04d:	0f 85 56 02 00 00    	jne    1b2a9 <lwm2m_perform_read_op+0x3d5>
			msg->path.res_id = res->res_id;
   1b053:	66 89 43 24          	mov    %ax,0x24(%ebx)
			obj_field = lwm2m_get_engine_obj_field(obj_inst->obj,
   1b057:	50                   	push   %eax
   1b058:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b05b:	ff 70 04             	pushl  0x4(%eax)
   1b05e:	e8 c4 c4 ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   1b063:	59                   	pop    %ecx
   1b064:	89 45 d0             	mov    %eax,-0x30(%ebp)
   1b067:	5e                   	pop    %esi
			if (!obj_field) {
   1b068:	85 c0                	test   %eax,%eax
   1b06a:	0f 84 2c 02 00 00    	je     1b29c <lwm2m_perform_read_op+0x3c8>
				ret = -EPERM;
   1b070:	83 ce ff             	or     $0xffffffff,%esi
			} else if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_R)) {
   1b073:	f6 40 02 01          	testb  $0x1,0x2(%eax)
   1b077:	0f 84 24 02 00 00    	je     1b2a1 <lwm2m_perform_read_op+0x3cd>
	if (out->writer->put_begin_r) {
   1b07d:	8b 43 14             	mov    0x14(%ebx),%eax
   1b080:	8b 40 10             	mov    0x10(%eax),%eax
   1b083:	85 c0                	test   %eax,%eax
   1b085:	74 08                	je     1b08f <lwm2m_perform_read_op+0x1bb>
		return out->writer->put_begin_r(out, path);
   1b087:	57                   	push   %edi
   1b088:	ff 75 e0             	pushl  -0x20(%ebp)
   1b08b:	ff d0                	call   *%eax
   1b08d:	58                   	pop    %eax
   1b08e:	5a                   	pop    %edx
	data_ptr = res->data_ptr;
   1b08f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b092:	8b 70 14             	mov    0x14(%eax),%esi
	data_len = res->data_len;
   1b095:	0f b7 40 18          	movzwl 0x18(%eax),%eax
   1b099:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (res->read_cb) {
   1b09c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b09f:	8b 00                	mov    (%eax),%eax
   1b0a1:	85 c0                	test   %eax,%eax
   1b0a3:	74 12                	je     1b0b7 <lwm2m_perform_read_op+0x1e3>
		data_ptr = res->read_cb(obj_inst->obj_inst_id, &data_len);
   1b0a5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1b0a8:	8d 55 e4             	lea    -0x1c(%ebp),%edx
   1b0ab:	52                   	push   %edx
   1b0ac:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
   1b0b0:	52                   	push   %edx
   1b0b1:	ff d0                	call   *%eax
   1b0b3:	59                   	pop    %ecx
   1b0b4:	5e                   	pop    %esi
   1b0b5:	89 c6                	mov    %eax,%esi
	if (!data_ptr || data_len == 0) {
   1b0b7:	85 f6                	test   %esi,%esi
   1b0b9:	0f 84 8b 01 00 00    	je     1b24a <lwm2m_perform_read_op+0x376>
   1b0bf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1b0c3:	0f 84 81 01 00 00    	je     1b24a <lwm2m_perform_read_op+0x376>
	if (res->multi_count_var != NULL) {
   1b0c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b0cc:	8b 40 10             	mov    0x10(%eax),%eax
   1b0cf:	85 c0                	test   %eax,%eax
   1b0d1:	74 31                	je     1b104 <lwm2m_perform_read_op+0x230>
		if (*res->multi_count_var == 0) {
   1b0d3:	80 38 00             	cmpb   $0x0,(%eax)
   1b0d6:	0f 84 6e 01 00 00    	je     1b24a <lwm2m_perform_read_op+0x376>
	if (out->writer->put_begin_ri) {
   1b0dc:	8b 43 14             	mov    0x14(%ebx),%eax
   1b0df:	8b 40 18             	mov    0x18(%eax),%eax
   1b0e2:	85 c0                	test   %eax,%eax
   1b0e4:	74 08                	je     1b0ee <lwm2m_perform_read_op+0x21a>
		return out->writer->put_begin_ri(out, path);
   1b0e6:	57                   	push   %edi
   1b0e7:	ff 75 e0             	pushl  -0x20(%ebp)
   1b0ea:	ff d0                	call   *%eax
   1b0ec:	58                   	pop    %eax
   1b0ed:	5a                   	pop    %edx
		loop_max = *res->multi_count_var;
   1b0ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b0f1:	8b 40 10             	mov    0x10(%eax),%eax
   1b0f4:	0f b6 00             	movzbl (%eax),%eax
   1b0f7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		res_inst_id_tmp = msg->path.res_inst_id;
   1b0fa:	66 8b 43 26          	mov    0x26(%ebx),%ax
   1b0fe:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
   1b102:	eb 0d                	jmp    1b111 <lwm2m_perform_read_op+0x23d>
	u16_t res_inst_id_tmp = 0U;
   1b104:	66 c7 45 c8 00 00    	movw   $0x0,-0x38(%ebp)
	int i, loop_max = 1;
   1b10a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
	for (i = 0; i < loop_max; i++) {
   1b111:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1b118:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b11b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1b11e:	39 55 dc             	cmp    %edx,-0x24(%ebp)
   1b121:	8b 40 10             	mov    0x10(%eax),%eax
   1b124:	0f 84 01 01 00 00    	je     1b22b <lwm2m_perform_read_op+0x357>
		if (res->multi_count_var != NULL) {
   1b12a:	85 c0                	test   %eax,%eax
   1b12c:	74 07                	je     1b135 <lwm2m_perform_read_op+0x261>
			msg->path.res_inst_id = (u16_t) i;
   1b12e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b131:	66 89 43 26          	mov    %ax,0x26(%ebx)
		switch (obj_field->data_type) {
   1b135:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b138:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1b13c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1b13f:	80 fa 0d             	cmp    $0xd,%dl
   1b142:	0f 87 b5 00 00 00    	ja     1b1fd <lwm2m_perform_read_op+0x329>
   1b148:	0f b6 d2             	movzbl %dl,%edx
   1b14b:	ff 24 95 ec 61 02 00 	jmp    *0x261ec(,%edx,4)
			engine_put_string(&msg->out, &msg->path,
   1b152:	56                   	push   %esi
   1b153:	e8 0b f7 fe ff       	call   a863 <strlen>
	return out->writer->put_string(out, path, buf, buflen);
   1b158:	8b 53 14             	mov    0x14(%ebx),%edx
   1b15b:	89 04 24             	mov    %eax,(%esp)
   1b15e:	56                   	push   %esi
   1b15f:	57                   	push   %edi
   1b160:	ff 75 e0             	pushl  -0x20(%ebp)
   1b163:	ff 52 30             	call   *0x30(%edx)
   1b166:	eb 14                	jmp    1b17c <lwm2m_perform_read_op+0x2a8>
	return out->writer->put_s64(out, path, value);
   1b168:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1b16b:	8b 43 14             	mov    0x14(%ebx),%eax
   1b16e:	ff 74 ce 04          	pushl  0x4(%esi,%ecx,8)
   1b172:	ff 34 ce             	pushl  (%esi,%ecx,8)
   1b175:	57                   	push   %edi
   1b176:	ff 75 e0             	pushl  -0x20(%ebp)
   1b179:	ff 50 2c             	call   *0x2c(%eax)
   1b17c:	83 c4 10             	add    $0x10,%esp
   1b17f:	e9 9f 00 00 00       	jmp    1b223 <lwm2m_perform_read_op+0x34f>
	return out->writer->put_s32(out, path, value);
   1b184:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1b187:	8b 43 14             	mov    0x14(%ebx),%eax
   1b18a:	ff 34 8e             	pushl  (%esi,%ecx,4)
   1b18d:	57                   	push   %edi
   1b18e:	ff 75 e0             	pushl  -0x20(%ebp)
   1b191:	ff 50 28             	call   *0x28(%eax)
   1b194:	eb 62                	jmp    1b1f8 <lwm2m_perform_read_op+0x324>
			engine_put_s16(&msg->out, &msg->path,
   1b196:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	return out->writer->put_s16(out, path, value);
   1b199:	8b 43 14             	mov    0x14(%ebx),%eax
   1b19c:	0f bf 14 4e          	movswl (%esi,%ecx,2),%edx
   1b1a0:	52                   	push   %edx
   1b1a1:	57                   	push   %edi
   1b1a2:	ff 75 e0             	pushl  -0x20(%ebp)
   1b1a5:	ff 50 24             	call   *0x24(%eax)
   1b1a8:	eb 4e                	jmp    1b1f8 <lwm2m_perform_read_op+0x324>
			engine_put_s8(&msg->out, &msg->path,
   1b1aa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	return out->writer->put_s8(out, path, value);
   1b1ad:	8b 43 14             	mov    0x14(%ebx),%eax
   1b1b0:	0f be 14 0e          	movsbl (%esi,%ecx,1),%edx
   1b1b4:	52                   	push   %edx
   1b1b5:	57                   	push   %edi
   1b1b6:	ff 75 e0             	pushl  -0x20(%ebp)
   1b1b9:	ff 50 20             	call   *0x20(%eax)
   1b1bc:	eb 3a                	jmp    1b1f8 <lwm2m_perform_read_op+0x324>
			engine_put_bool(&msg->out, &msg->path,
   1b1be:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	return out->writer->put_bool(out, path, value);
   1b1c1:	8b 43 14             	mov    0x14(%ebx),%eax
   1b1c4:	0f b6 14 0e          	movzbl (%esi,%ecx,1),%edx
   1b1c8:	52                   	push   %edx
   1b1c9:	57                   	push   %edi
   1b1ca:	ff 75 e0             	pushl  -0x20(%ebp)
   1b1cd:	ff 50 3c             	call   *0x3c(%eax)
   1b1d0:	eb 26                	jmp    1b1f8 <lwm2m_perform_read_op+0x324>
	return out->writer->put_float32fix(out, path, value);
   1b1d2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1b1d5:	8b 43 14             	mov    0x14(%ebx),%eax
   1b1d8:	8d 14 ce             	lea    (%esi,%ecx,8),%edx
   1b1db:	52                   	push   %edx
   1b1dc:	57                   	push   %edi
   1b1dd:	ff 75 e0             	pushl  -0x20(%ebp)
   1b1e0:	ff 50 34             	call   *0x34(%eax)
   1b1e3:	eb 13                	jmp    1b1f8 <lwm2m_perform_read_op+0x324>
	return out->writer->put_float64fix(out, path, value);
   1b1e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b1e8:	8b 53 14             	mov    0x14(%ebx),%edx
   1b1eb:	c1 e0 04             	shl    $0x4,%eax
   1b1ee:	01 f0                	add    %esi,%eax
   1b1f0:	50                   	push   %eax
   1b1f1:	57                   	push   %edi
   1b1f2:	ff 75 e0             	pushl  -0x20(%ebp)
   1b1f5:	ff 52 38             	call   *0x38(%edx)
   1b1f8:	83 c4 0c             	add    $0xc,%esp
   1b1fb:	eb 26                	jmp    1b223 <lwm2m_perform_read_op+0x34f>
			return -EINVAL;
   1b1fd:	be ea ff ff ff       	mov    $0xffffffea,%esi
			LOG_ERR("unknown obj data_type %d",
   1b202:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b209:	74 44                	je     1b24f <lwm2m_perform_read_op+0x37b>
   1b20b:	66 8b 55 c2          	mov    -0x3e(%ebp),%dx
   1b20f:	83 ca 01             	or     $0x1,%edx
   1b212:	52                   	push   %edx
   1b213:	50                   	push   %eax
   1b214:	68 ca 94 02 00       	push   $0x294ca
   1b219:	e8 91 82 fe ff       	call   34af <log_1>
   1b21e:	83 c4 0c             	add    $0xc,%esp
				if (ret < 0) {
   1b221:	eb 2c                	jmp    1b24f <lwm2m_perform_read_op+0x37b>
	for (i = 0; i < loop_max; i++) {
   1b223:	ff 45 dc             	incl   -0x24(%ebp)
   1b226:	e9 ed fe ff ff       	jmp    1b118 <lwm2m_perform_read_op+0x244>
	if (res->multi_count_var != NULL) {
   1b22b:	85 c0                	test   %eax,%eax
   1b22d:	74 50                	je     1b27f <lwm2m_perform_read_op+0x3ab>
	if (out->writer->put_end_ri) {
   1b22f:	8b 43 14             	mov    0x14(%ebx),%eax
   1b232:	8b 40 1c             	mov    0x1c(%eax),%eax
   1b235:	85 c0                	test   %eax,%eax
   1b237:	74 08                	je     1b241 <lwm2m_perform_read_op+0x36d>
		return out->writer->put_end_ri(out, path);
   1b239:	57                   	push   %edi
   1b23a:	ff 75 e0             	pushl  -0x20(%ebp)
   1b23d:	ff d0                	call   *%eax
   1b23f:	59                   	pop    %ecx
   1b240:	5e                   	pop    %esi
		msg->path.res_inst_id = res_inst_id_tmp;
   1b241:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1b244:	66 89 43 26          	mov    %ax,0x26(%ebx)
				if (ret < 0) {
   1b248:	eb 35                	jmp    1b27f <lwm2m_perform_read_op+0x3ab>
			return -ENOENT;
   1b24a:	be fe ff ff ff       	mov    $0xfffffffe,%esi
					if (msg->path.level > 2 &&
   1b24f:	80 7b 28 02          	cmpb   $0x2,0x28(%ebx)
   1b253:	76 2f                	jbe    1b284 <lwm2m_perform_read_op+0x3b0>
   1b255:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b258:	80 78 02 00          	cmpb   $0x0,0x2(%eax)
   1b25c:	78 26                	js     1b284 <lwm2m_perform_read_op+0x3b0>
						LOG_ERR("READ OP: %d", ret);
   1b25e:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b265:	74 1d                	je     1b284 <lwm2m_perform_read_op+0x3b0>
   1b267:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
   1b26b:	83 c8 01             	or     $0x1,%eax
   1b26e:	50                   	push   %eax
   1b26f:	56                   	push   %esi
   1b270:	68 42 9d 02 00       	push   $0x29d42
   1b275:	e8 35 82 fe ff       	call   34af <log_1>
   1b27a:	83 c4 0c             	add    $0xc,%esp
   1b27d:	eb 05                	jmp    1b284 <lwm2m_perform_read_op+0x3b0>
					num_read += 1;
   1b27f:	fe 45 cb             	incb   -0x35(%ebp)
   1b282:	31 f6                	xor    %esi,%esi
	if (out->writer->put_end_r) {
   1b284:	8b 43 14             	mov    0x14(%ebx),%eax
   1b287:	8b 40 14             	mov    0x14(%eax),%eax
   1b28a:	85 c0                	test   %eax,%eax
   1b28c:	74 08                	je     1b296 <lwm2m_perform_read_op+0x3c2>
		return out->writer->put_end_r(out, path);
   1b28e:	57                   	push   %edi
   1b28f:	ff 75 e0             	pushl  -0x20(%ebp)
   1b292:	ff d0                	call   *%eax
   1b294:	58                   	pop    %eax
   1b295:	5a                   	pop    %edx
			if (ret < 0 && msg->path.level > 2) {
   1b296:	85 f6                	test   %esi,%esi
   1b298:	74 0f                	je     1b2a9 <lwm2m_perform_read_op+0x3d5>
   1b29a:	eb 05                	jmp    1b2a1 <lwm2m_perform_read_op+0x3cd>
				ret = -ENOENT;
   1b29c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
			if (ret < 0 && msg->path.level > 2) {
   1b2a1:	80 7b 28 02          	cmpb   $0x2,0x28(%ebx)
   1b2a5:	77 0a                	ja     1b2b1 <lwm2m_perform_read_op+0x3dd>
			ret = 0;
   1b2a7:	31 f6                	xor    %esi,%esi
		for (index = 0; index < obj_inst->resource_count; index++) {
   1b2a9:	ff 45 cc             	incl   -0x34(%ebp)
   1b2ac:	e9 6d fd ff ff       	jmp    1b01e <lwm2m_perform_read_op+0x14a>
		if (msg->path.level <= 1) {
   1b2b1:	80 7b 28 01          	cmpb   $0x1,0x28(%ebx)
   1b2b5:	77 18                	ja     1b2cf <lwm2m_perform_read_op+0x3fb>
	if (out->writer->put_end_oi) {
   1b2b7:	8b 43 14             	mov    0x14(%ebx),%eax
   1b2ba:	8b 40 0c             	mov    0xc(%eax),%eax
   1b2bd:	85 c0                	test   %eax,%eax
   1b2bf:	74 22                	je     1b2e3 <lwm2m_perform_read_op+0x40f>
		return out->writer->put_end_oi(out, path);
   1b2c1:	57                   	push   %edi
   1b2c2:	ff 75 e0             	pushl  -0x20(%ebp)
   1b2c5:	ff d0                	call   *%eax
   1b2c7:	59                   	pop    %ecx
   1b2c8:	58                   	pop    %eax
		if (msg->path.level <= 1) {
   1b2c9:	80 7b 28 01          	cmpb   $0x1,0x28(%ebx)
   1b2cd:	76 14                	jbe    1b2e3 <lwm2m_perform_read_op+0x40f>
	if (out->writer->put_end) {
   1b2cf:	8b 43 14             	mov    0x14(%ebx),%eax
   1b2d2:	8b 40 04             	mov    0x4(%eax),%eax
   1b2d5:	85 c0                	test   %eax,%eax
   1b2d7:	74 27                	je     1b300 <lwm2m_perform_read_op+0x42c>
		return out->writer->put_end(out, path);
   1b2d9:	57                   	push   %edi
   1b2da:	ff 75 e0             	pushl  -0x20(%ebp)
   1b2dd:	ff d0                	call   *%eax
   1b2df:	58                   	pop    %eax
   1b2e0:	5a                   	pop    %edx
   1b2e1:	eb 1d                	jmp    1b300 <lwm2m_perform_read_op+0x42c>
			obj_inst = next_engine_obj_inst(msg->path.obj_id,
   1b2e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b2e6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   1b2ea:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
   1b2ee:	e8 26 b7 ff ff       	call   16a19 <next_engine_obj_inst>
   1b2f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	while (obj_inst) {
   1b2f6:	85 c0                	test   %eax,%eax
   1b2f8:	0f 85 df fc ff ff    	jne    1afdd <lwm2m_perform_read_op+0x109>
   1b2fe:	eb cf                	jmp    1b2cf <lwm2m_perform_read_op+0x3fb>
	memcpy(&msg->path, &temp_path, sizeof(temp_path));
   1b300:	6a 0a                	push   $0xa
   1b302:	8d 45 ea             	lea    -0x16(%ebp),%eax
   1b305:	50                   	push   %eax
   1b306:	57                   	push   %edi
   1b307:	e8 25 f6 fe ff       	call   a931 <memcpy>
   1b30c:	83 c4 0c             	add    $0xc,%esp
	if (ret == 0 && num_read == 0 && msg->path.level == 3) {
   1b30f:	85 f6                	test   %esi,%esi
   1b311:	75 10                	jne    1b323 <lwm2m_perform_read_op+0x44f>
   1b313:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
   1b317:	75 0a                	jne    1b323 <lwm2m_perform_read_op+0x44f>
   1b319:	80 7b 28 03          	cmpb   $0x3,0x28(%ebx)
   1b31d:	0f 84 d7 fb ff ff    	je     1aefa <lwm2m_perform_read_op+0x26>
}
   1b323:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b326:	89 f0                	mov    %esi,%eax
   1b328:	5b                   	pop    %ebx
   1b329:	5e                   	pop    %esi
   1b32a:	5f                   	pop    %edi
   1b32b:	5d                   	pop    %ebp
   1b32c:	c3                   	ret    

0001b32d <lwm2m_get_or_create_engine_obj>:
{
   1b32d:	55                   	push   %ebp
   1b32e:	89 e5                	mov    %esp,%ebp
   1b330:	57                   	push   %edi
   1b331:	56                   	push   %esi
   1b332:	53                   	push   %ebx
   1b333:	50                   	push   %eax
   1b334:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1b337:	8b 75 08             	mov    0x8(%ebp),%esi
	if (created) {
   1b33a:	85 db                	test   %ebx,%ebx
   1b33c:	74 03                	je     1b341 <lwm2m_get_or_create_engine_obj+0x14>
		*created = 0U;
   1b33e:	c6 03 00             	movb   $0x0,(%ebx)
	*obj_inst = get_engine_obj_inst(msg->path.obj_id,
   1b341:	0f b7 4e 22          	movzwl 0x22(%esi),%ecx
   1b345:	0f b7 7e 20          	movzwl 0x20(%esi),%edi
   1b349:	89 ca                	mov    %ecx,%edx
   1b34b:	89 f8                	mov    %edi,%eax
   1b34d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1b350:	e8 95 b6 ff ff       	call   169ea <get_engine_obj_inst>
   1b355:	89 c2                	mov    %eax,%edx
   1b357:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (!*obj_inst) {
   1b35a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	*obj_inst = get_engine_obj_inst(msg->path.obj_id,
   1b35d:	89 10                	mov    %edx,(%eax)
	int ret = 0;
   1b35f:	31 c0                	xor    %eax,%eax
	if (!*obj_inst) {
   1b361:	85 d2                	test   %edx,%edx
   1b363:	75 2e                	jne    1b393 <lwm2m_get_or_create_engine_obj+0x66>
		ret = lwm2m_create_obj_inst(msg->path.obj_id,
   1b365:	ff 75 0c             	pushl  0xc(%ebp)
   1b368:	51                   	push   %ecx
   1b369:	57                   	push   %edi
   1b36a:	e8 7e c9 ff ff       	call   17ced <lwm2m_create_obj_inst>
   1b36f:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
   1b372:	85 c0                	test   %eax,%eax
   1b374:	78 1d                	js     1b393 <lwm2m_get_or_create_engine_obj+0x66>
		if (created) {
   1b376:	85 db                	test   %ebx,%ebx
   1b378:	74 03                	je     1b37d <lwm2m_get_or_create_engine_obj+0x50>
			*created = 1U;
   1b37a:	c6 03 01             	movb   $0x1,(%ebx)
		if (!msg->ctx->bootstrap_mode) {
   1b37d:	8b 16                	mov    (%esi),%edx
   1b37f:	80 ba 80 01 00 00 00 	cmpb   $0x0,0x180(%edx)
   1b386:	75 0b                	jne    1b393 <lwm2m_get_or_create_engine_obj+0x66>
   1b388:	89 45 f0             	mov    %eax,-0x10(%ebp)
			engine_trigger_update();
   1b38b:	e8 bc 3c 00 00       	call   1f04c <engine_trigger_update>
   1b390:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1b393:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b396:	5b                   	pop    %ebx
   1b397:	5e                   	pop    %esi
   1b398:	5f                   	pop    %edi
   1b399:	5d                   	pop    %ebp
   1b39a:	c3                   	ret    

0001b39b <engine_next_service_timeout_ms>:
{
   1b39b:	55                   	push   %ebp
   1b39c:	89 e5                	mov    %esp,%ebp
   1b39e:	57                   	push   %edi
   1b39f:	56                   	push   %esi
   1b3a0:	53                   	push   %ebx
   1b3a1:	83 ec 0c             	sub    $0xc,%esp
   1b3a4:	8b 45 08             	mov    0x8(%ebp),%eax
   1b3a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   1b3aa:	e8 62 95 00 00       	call   24911 <z_impl_k_uptime_get>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_service_list, srv, node) {
   1b3af:	8b 35 98 43 40 00    	mov    0x404398,%esi
   1b3b5:	85 f6                	test   %esi,%esi
   1b3b7:	74 35                	je     1b3ee <engine_next_service_timeout_ms+0x53>
				  K_MSEC(srv->min_call_period);
   1b3b9:	8b 4e 10             	mov    0x10(%esi),%ecx
   1b3bc:	31 db                	xor    %ebx,%ebx
		time_left_ms = srv->last_timestamp +
   1b3be:	03 4e 14             	add    0x14(%esi),%ecx
   1b3c1:	13 5e 18             	adc    0x18(%esi),%ebx
		if (time_left_ms < timestamp) {
   1b3c4:	39 c1                	cmp    %eax,%ecx
   1b3c6:	89 df                	mov    %ebx,%edi
   1b3c8:	19 d7                	sbb    %edx,%edi
   1b3ca:	72 27                	jb     1b3f3 <engine_next_service_timeout_ms+0x58>
		time_left_ms -= timestamp;
   1b3cc:	29 c1                	sub    %eax,%ecx
		if (time_left_ms < timeout) {
   1b3ce:	8b 7d f0             	mov    -0x10(%ebp),%edi
		time_left_ms -= timestamp;
   1b3d1:	19 d3                	sbb    %edx,%ebx
		if (time_left_ms < timeout) {
   1b3d3:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
   1b3d6:	89 7d e8             	mov    %edi,-0x18(%ebp)
   1b3d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1b3e0:	89 df                	mov    %ebx,%edi
   1b3e2:	1b 7d ec             	sbb    -0x14(%ebp),%edi
   1b3e5:	73 03                	jae    1b3ea <engine_next_service_timeout_ms+0x4f>
			timeout = time_left_ms;
   1b3e7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1b3ea:	8b 36                	mov    (%esi),%esi
	return node->next;
   1b3ec:	eb c7                	jmp    1b3b5 <engine_next_service_timeout_ms+0x1a>
	return timeout;
   1b3ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b3f1:	eb 02                	jmp    1b3f5 <engine_next_service_timeout_ms+0x5a>
			return 0;
   1b3f3:	31 c0                	xor    %eax,%eax
}
   1b3f5:	83 c4 0c             	add    $0xc,%esp
   1b3f8:	5b                   	pop    %ebx
   1b3f9:	5e                   	pop    %esi
   1b3fa:	5f                   	pop    %edi
   1b3fb:	5d                   	pop    %ebp
   1b3fc:	c3                   	ret    

0001b3fd <lwm2m_engine_service>:
{
   1b3fd:	55                   	push   %ebp
   1b3fe:	89 e5                	mov    %esp,%ebp
   1b400:	57                   	push   %edi
   1b401:	56                   	push   %esi
   1b402:	53                   	push   %ebx
   1b403:	e8 09 95 00 00       	call   24911 <z_impl_k_uptime_get>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   1b408:	8b 1d a0 43 40 00    	mov    0x4043a0,%ebx
   1b40e:	85 db                	test   %ebx,%ebx
   1b410:	75 14                	jne    1b426 <lwm2m_engine_service+0x29>
   1b412:	e8 fa 94 00 00       	call   24911 <z_impl_k_uptime_get>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_service_list, srv, node) {
   1b417:	8b 1d 98 43 40 00    	mov    0x404398,%ebx
   1b41d:	89 c6                	mov    %eax,%esi
   1b41f:	89 d7                	mov    %edx,%edi
	return list->head;
   1b421:	e9 a5 00 00 00       	jmp    1b4cb <lwm2m_engine_service+0xce>
   1b426:	89 c6                	mov    %eax,%esi
   1b428:	89 d7                	mov    %edx,%edi
		if (obs->event_timestamp > obs->last_timestamp &&
   1b42a:	69 43 2c e8 03 00 00 	imul   $0x3e8,0x2c(%ebx),%eax
   1b431:	31 d2                	xor    %edx,%edx
   1b433:	03 43 24             	add    0x24(%ebx),%eax
   1b436:	13 53 28             	adc    0x28(%ebx),%edx
   1b439:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
   1b43c:	39 4b 24             	cmp    %ecx,0x24(%ebx)
   1b43f:	8b 4b 28             	mov    0x28(%ebx),%ecx
   1b442:	1b 4b 20             	sbb    0x20(%ebx),%ecx
   1b445:	7d 1a                	jge    1b461 <lwm2m_engine_service+0x64>
   1b447:	39 f0                	cmp    %esi,%eax
   1b449:	89 d0                	mov    %edx,%eax
   1b44b:	19 f8                	sbb    %edi,%eax
   1b44d:	7d 2e                	jge    1b47d <lwm2m_engine_service+0x80>
   1b44f:	e8 bd 94 00 00       	call   24911 <z_impl_k_uptime_get>
			obs->last_timestamp = k_uptime_get();
   1b454:	89 53 28             	mov    %edx,0x28(%ebx)
   1b457:	89 43 24             	mov    %eax,0x24(%ebx)
			generate_notify_message(obs, true);
   1b45a:	ba 01 00 00 00       	mov    $0x1,%edx
   1b45f:	eb 15                	jmp    1b476 <lwm2m_engine_service+0x79>
		} else if (timestamp > obs->last_timestamp +
   1b461:	39 f0                	cmp    %esi,%eax
   1b463:	89 d0                	mov    %edx,%eax
   1b465:	19 f8                	sbb    %edi,%eax
   1b467:	7d 14                	jge    1b47d <lwm2m_engine_service+0x80>
   1b469:	e8 a3 94 00 00       	call   24911 <z_impl_k_uptime_get>
			obs->last_timestamp = k_uptime_get();
   1b46e:	89 53 28             	mov    %edx,0x28(%ebx)
   1b471:	89 43 24             	mov    %eax,0x24(%ebx)
			generate_notify_message(obs, false);
   1b474:	31 d2                	xor    %edx,%edx
   1b476:	89 d8                	mov    %ebx,%eax
   1b478:	e8 f2 ea ff ff       	call   19f6f <generate_notify_message>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1b47d:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
   1b47f:	85 db                	test   %ebx,%ebx
   1b481:	75 a7                	jne    1b42a <lwm2m_engine_service+0x2d>
   1b483:	eb 8d                	jmp    1b412 <lwm2m_engine_service+0x15>
					K_MSEC(srv->min_call_period);
   1b485:	8b 43 10             	mov    0x10(%ebx),%eax
   1b488:	31 d2                	xor    %edx,%edx
		service_due_timestamp = srv->last_timestamp +
   1b48a:	03 43 14             	add    0x14(%ebx),%eax
   1b48d:	13 53 18             	adc    0x18(%ebx),%edx
		if (timestamp > service_due_timestamp) {
   1b490:	39 f0                	cmp    %esi,%eax
   1b492:	89 d0                	mov    %edx,%eax
   1b494:	19 f8                	sbb    %edi,%eax
   1b496:	7d 31                	jge    1b4c9 <lwm2m_engine_service+0xcc>
   1b498:	e8 74 94 00 00       	call   24911 <z_impl_k_uptime_get>
			srv->last_timestamp = k_uptime_get();
   1b49d:	89 43 14             	mov    %eax,0x14(%ebx)
   1b4a0:	89 53 18             	mov    %edx,0x18(%ebx)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b4a3:	8b 43 0c             	mov    0xc(%ebx),%eax
   1b4a6:	89 c1                	mov    %eax,%ecx
   1b4a8:	89 c2                	mov    %eax,%edx
   1b4aa:	83 c9 01             	or     $0x1,%ecx
   1b4ad:	f0 0f b1 4b 0c       	lock cmpxchg %ecx,0xc(%ebx)
   1b4b2:	75 f2                	jne    1b4a6 <lwm2m_engine_service+0xa9>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1b4b4:	80 e2 01             	and    $0x1,%dl
   1b4b7:	75 10                	jne    1b4c9 <lwm2m_engine_service+0xcc>
			k_work_submit(&srv->service_work);
   1b4b9:	8d 43 04             	lea    0x4(%ebx),%eax
		k_queue_append(&work_q->queue, work);
   1b4bc:	50                   	push   %eax
   1b4bd:	68 60 41 40 00       	push   $0x404160
   1b4c2:	e8 df 81 00 00       	call   236a6 <k_queue_append>
   1b4c7:	58                   	pop    %eax
   1b4c8:	5a                   	pop    %edx
   1b4c9:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_service_list, srv, node) {
   1b4cb:	85 db                	test   %ebx,%ebx
   1b4cd:	75 b6                	jne    1b485 <lwm2m_engine_service+0x88>
	sleep_ms = engine_next_service_timeout_ms(ENGINE_UPDATE_INTERVAL);
   1b4cf:	68 f4 01 00 00       	push   $0x1f4
   1b4d4:	e8 c2 fe ff ff       	call   1b39b <engine_next_service_timeout_ms>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1b4d9:	89 04 24             	mov    %eax,(%esp)
   1b4dc:	68 e0 27 40 00       	push   $0x4027e0
   1b4e1:	68 60 41 40 00       	push   $0x404160
   1b4e6:	e8 ea 8f 00 00       	call   244d5 <k_delayed_work_submit_to_queue>
   1b4eb:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1b4ee:	85 c0                	test   %eax,%eax
   1b4f0:	79 2c                	jns    1b51e <lwm2m_engine_service+0x121>
		LOG_ERR("Work submit error:%d", ret);
   1b4f2:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b4f9:	74 23                	je     1b51e <lwm2m_engine_service+0x121>
   1b4fb:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1b500:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1b506:	c1 ea 03             	shr    $0x3,%edx
   1b509:	c1 e2 06             	shl    $0x6,%edx
   1b50c:	83 ca 01             	or     $0x1,%edx
   1b50f:	52                   	push   %edx
   1b510:	50                   	push   %eax
   1b511:	68 4e 9d 02 00       	push   $0x29d4e
   1b516:	e8 94 7f fe ff       	call   34af <log_1>
   1b51b:	83 c4 0c             	add    $0xc,%esp
}
   1b51e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b521:	5b                   	pop    %ebx
   1b522:	5e                   	pop    %esi
   1b523:	5f                   	pop    %edi
   1b524:	5d                   	pop    %ebp
   1b525:	c3                   	ret    

0001b526 <lwm2m_engine_add_service>:
	for (i = 0; i < MAX_PERIODIC_SERVICE; i++) {
   1b526:	31 c0                	xor    %eax,%eax
		if (!service_node_data[i].service_work.handler) {
   1b528:	6b d0 1c             	imul   $0x1c,%eax,%edx
   1b52b:	83 ba e8 29 40 00 00 	cmpl   $0x0,0x4029e8(%edx)
   1b532:	74 0c                	je     1b540 <lwm2m_engine_add_service+0x1a>
	for (i = 0; i < MAX_PERIODIC_SERVICE; i++) {
   1b534:	40                   	inc    %eax
   1b535:	83 f8 0a             	cmp    $0xa,%eax
   1b538:	75 ee                	jne    1b528 <lwm2m_engine_add_service+0x2>
		return -ENOMEM;
   1b53a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
   1b53f:	c3                   	ret    
{
   1b540:	55                   	push   %ebp
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1b541:	81 c2 e0 29 40 00    	add    $0x4029e0,%edx
   1b547:	89 e5                	mov    %esp,%ebp
   1b549:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   1b550:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
   1b557:	8b 45 08             	mov    0x8(%ebp),%eax
	service_node_data[i].last_timestamp = 0;
   1b55a:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
   1b561:	89 42 08             	mov    %eax,0x8(%edx)
	service_node_data[i].min_call_period = period_ms;
   1b564:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b567:	89 42 10             	mov    %eax,0x10(%edx)
	service_node_data[i].last_timestamp = 0;
   1b56a:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	sys_slist_append(&engine_service_list,
   1b571:	b8 98 43 40 00       	mov    $0x404398,%eax
   1b576:	e8 e1 b3 ff ff       	call   1695c <sys_slist_append>
	return 0;
   1b57b:	31 c0                	xor    %eax,%eax
}
   1b57d:	5d                   	pop    %ebp
   1b57e:	c3                   	ret    

0001b57f <lwm2m_engine_context_init>:
{
   1b57f:	55                   	push   %ebp
   1b580:	89 e5                	mov    %esp,%ebp
	k_delayed_work_init(&client_ctx->retransmit_work, retransmit_request);
   1b582:	68 03 7f 01 00       	push   $0x17f03
   1b587:	8b 45 08             	mov    0x8(%ebp),%eax
   1b58a:	05 58 01 00 00       	add    $0x158,%eax
   1b58f:	50                   	push   %eax
   1b590:	e8 10 8f 00 00       	call   244a5 <k_delayed_work_init>
   1b595:	58                   	pop    %eax
   1b596:	5a                   	pop    %edx
}
   1b597:	c9                   	leave  
   1b598:	c3                   	ret    

0001b599 <lwm2m_socket_add>:
{
   1b599:	55                   	push   %ebp
	if (sock_nfds < MAX_POLL_FD) {
   1b59a:	a1 70 43 40 00       	mov    0x404370,%eax
{
   1b59f:	89 e5                	mov    %esp,%ebp
	if (sock_nfds < MAX_POLL_FD) {
   1b5a1:	83 f8 02             	cmp    $0x2,%eax
{
   1b5a4:	8b 55 08             	mov    0x8(%ebp),%edx
	if (sock_nfds < MAX_POLL_FD) {
   1b5a7:	7e 27                	jle    1b5d0 <lwm2m_socket_add+0x37>
			if (sock_ctx[i] == NULL) {
   1b5a9:	83 3d 8c 43 40 00 00 	cmpl   $0x0,0x40438c
   1b5b0:	74 29                	je     1b5db <lwm2m_socket_add+0x42>
   1b5b2:	83 3d 90 43 40 00 00 	cmpl   $0x0,0x404390
   1b5b9:	74 24                	je     1b5df <lwm2m_socket_add+0x46>
		return -ENOMEM;
   1b5bb:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			if (sock_ctx[i] == NULL) {
   1b5c0:	83 3d 94 43 40 00 00 	cmpl   $0x0,0x404394
   1b5c7:	75 3b                	jne    1b604 <lwm2m_socket_add+0x6b>
		for (i = 0; i < MAX_POLL_FD; i++) {
   1b5c9:	b8 02 00 00 00       	mov    $0x2,%eax
   1b5ce:	eb 14                	jmp    1b5e4 <lwm2m_socket_add+0x4b>
		i = sock_nfds++;
   1b5d0:	8d 48 01             	lea    0x1(%eax),%ecx
   1b5d3:	89 0d 70 43 40 00    	mov    %ecx,0x404370
   1b5d9:	eb 09                	jmp    1b5e4 <lwm2m_socket_add+0x4b>
		for (i = 0; i < MAX_POLL_FD; i++) {
   1b5db:	31 c0                	xor    %eax,%eax
   1b5dd:	eb 05                	jmp    1b5e4 <lwm2m_socket_add+0x4b>
   1b5df:	b8 01 00 00 00       	mov    $0x1,%eax
	sock_ctx[i] = ctx;
   1b5e4:	89 14 85 8c 43 40 00 	mov    %edx,0x40438c(,%eax,4)
	sock_fds[i].fd = ctx->sock_fd;
   1b5eb:	8b 92 84 01 00 00    	mov    0x184(%edx),%edx
   1b5f1:	89 14 c5 74 43 40 00 	mov    %edx,0x404374(,%eax,8)
	sock_fds[i].events = POLLIN;
   1b5f8:	66 c7 04 c5 78 43 40 	movw   $0x1,0x404378(,%eax,8)
   1b5ff:	00 01 00 
	return 0;
   1b602:	31 c0                	xor    %eax,%eax
}
   1b604:	5d                   	pop    %ebp
   1b605:	c3                   	ret    

0001b606 <lwm2m_socket_del>:
{
   1b606:	55                   	push   %ebp
	for (int i = 0; i < sock_nfds; i++) {
   1b607:	8b 15 70 43 40 00    	mov    0x404370,%edx
{
   1b60d:	89 e5                	mov    %esp,%ebp
	for (int i = 0; i < sock_nfds; i++) {
   1b60f:	31 c0                	xor    %eax,%eax
{
   1b611:	8b 4d 08             	mov    0x8(%ebp),%ecx
	for (int i = 0; i < sock_nfds; i++) {
   1b614:	39 c2                	cmp    %eax,%edx
   1b616:	7e 2b                	jle    1b643 <lwm2m_socket_del+0x3d>
		if (sock_ctx[i] == ctx) {
   1b618:	39 0c 85 8c 43 40 00 	cmp    %ecx,0x40438c(,%eax,4)
   1b61f:	75 1f                	jne    1b640 <lwm2m_socket_del+0x3a>
			sock_nfds--;
   1b621:	4a                   	dec    %edx
			sock_ctx[i] = NULL;
   1b622:	c7 04 85 8c 43 40 00 	movl   $0x0,0x40438c(,%eax,4)
   1b629:	00 00 00 00 
			sock_fds[i].fd = -1;
   1b62d:	c7 04 c5 74 43 40 00 	movl   $0xffffffff,0x404374(,%eax,8)
   1b634:	ff ff ff ff 
			sock_nfds--;
   1b638:	89 15 70 43 40 00    	mov    %edx,0x404370
			break;
   1b63e:	eb 03                	jmp    1b643 <lwm2m_socket_del+0x3d>
	for (int i = 0; i < sock_nfds; i++) {
   1b640:	40                   	inc    %eax
   1b641:	eb d1                	jmp    1b614 <lwm2m_socket_del+0xe>
}
   1b643:	5d                   	pop    %ebp
   1b644:	c3                   	ret    

0001b645 <lwm2m_engine_context_close>:
{
   1b645:	55                   	push   %ebp
   1b646:	89 e5                	mov    %esp,%ebp
   1b648:	57                   	push   %edi
   1b649:	56                   	push   %esi
   1b64a:	53                   	push   %ebx
   1b64b:	83 ec 08             	sub    $0x8,%esp
   1b64e:	8b 7d 08             	mov    0x8(%ebp),%edi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
   1b651:	8b 1d a0 43 40 00    	mov    0x4043a0,%ebx
   1b657:	85 db                	test   %ebx,%ebx
	int sock_fd = client_ctx->sock_fd;
   1b659:	8b 87 84 01 00 00    	mov    0x184(%edi),%eax
   1b65f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
   1b662:	75 29                	jne    1b68d <lwm2m_engine_context_close+0x48>
	lwm2m_socket_del(client_ctx);
   1b664:	57                   	push   %edi
   1b665:	e8 9c ff ff ff       	call   1b606 <lwm2m_socket_del>
   1b66a:	58                   	pop    %eax
	client_ctx->sock_fd = -1;
   1b66b:	c7 87 84 01 00 00 ff 	movl   $0xffffffff,0x184(%edi)
   1b672:	ff ff ff 
	if (sock_fd >= 0) {
   1b675:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1b679:	78 4c                	js     1b6c7 <lwm2m_engine_context_close+0x82>
K_SYSCALL_DECLARE1(K_SYSCALL_ZSOCK_CLOSE, zsock_close, int, int, sock)
   1b67b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1b67e:	89 45 08             	mov    %eax,0x8(%ebp)
}
   1b681:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b684:	5b                   	pop    %ebx
   1b685:	5e                   	pop    %esi
   1b686:	5f                   	pop    %edi
   1b687:	5d                   	pop    %ebp
   1b688:	e9 a0 d6 fe ff       	jmp    8d2d <z_impl_zsock_close>
   1b68d:	8b 33                	mov    (%ebx),%esi
   1b68f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (obs->ctx == client_ctx) {
   1b696:	39 7b 04             	cmp    %edi,0x4(%ebx)
   1b699:	75 1f                	jne    1b6ba <lwm2m_engine_context_close+0x75>
			sys_slist_remove(&engine_observer_list, prev_node,
   1b69b:	89 d9                	mov    %ebx,%ecx
   1b69d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1b6a0:	b8 a0 43 40 00       	mov    $0x4043a0,%eax
   1b6a5:	e8 cb b2 ff ff       	call   16975 <sys_slist_remove>
			(void)memset(obs, 0, sizeof(*obs));
   1b6aa:	6a 3c                	push   $0x3c
   1b6ac:	6a 00                	push   $0x0
   1b6ae:	53                   	push   %ebx
   1b6af:	e8 ec f2 fe ff       	call   a9a0 <memset>
   1b6b4:	83 c4 0c             	add    $0xc,%esp
   1b6b7:	8b 5d f0             	mov    -0x10(%ebp),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
   1b6ba:	85 f6                	test   %esi,%esi
   1b6bc:	74 a6                	je     1b664 <lwm2m_engine_context_close+0x1f>
   1b6be:	89 5d f0             	mov    %ebx,-0x10(%ebp)
   1b6c1:	89 f3                	mov    %esi,%ebx
   1b6c3:	8b 36                	mov    (%esi),%esi
   1b6c5:	eb cf                	jmp    1b696 <lwm2m_engine_context_close+0x51>
}
   1b6c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b6ca:	31 c0                	xor    %eax,%eax
   1b6cc:	5b                   	pop    %ebx
   1b6cd:	5e                   	pop    %esi
   1b6ce:	5f                   	pop    %edi
   1b6cf:	5d                   	pop    %ebp
   1b6d0:	c3                   	ret    

0001b6d1 <lwm2m_socket_start>:
{
   1b6d1:	55                   	push   %ebp
   1b6d2:	89 e5                	mov    %esp,%ebp
   1b6d4:	56                   	push   %esi
   1b6d5:	53                   	push   %ebx
   1b6d6:	8b 75 08             	mov    0x8(%ebp),%esi
K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_SOCKET, zsock_socket, int, int, family, int, type, int, proto)
   1b6d9:	6a 11                	push   $0x11
   1b6db:	6a 02                	push   $0x2
		client_ctx->sock_fd = socket(client_ctx->remote_addr.sa_family,
   1b6dd:	0f b7 06             	movzwl (%esi),%eax
   1b6e0:	50                   	push   %eax
   1b6e1:	e8 98 d4 fe ff       	call   8b7e <z_impl_zsock_socket>
   1b6e6:	83 c4 0c             	add    $0xc,%esp
   1b6e9:	89 86 84 01 00 00    	mov    %eax,0x184(%esi)
	if (client_ctx->sock_fd < 0) {
   1b6ef:	85 c0                	test   %eax,%eax
   1b6f1:	79 34                	jns    1b727 <lwm2m_socket_start+0x56>
		LOG_ERR("Failed to create socket: %d", errno);
   1b6f3:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b6fa:	74 74                	je     1b770 <lwm2m_socket_start+0x9f>
   1b6fc:	e8 e7 75 00 00       	call   22ce8 <z_impl_z_errno>
   1b701:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   1b706:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   1b70c:	c1 eb 03             	shr    $0x3,%ebx
   1b70f:	c1 e3 06             	shl    $0x6,%ebx
   1b712:	83 cb 01             	or     $0x1,%ebx
   1b715:	53                   	push   %ebx
   1b716:	ff 30                	pushl  (%eax)
   1b718:	68 63 9d 02 00       	push   $0x29d63
   1b71d:	e8 8d 7d fe ff       	call   34af <log_1>
   1b722:	83 c4 0c             	add    $0xc,%esp
   1b725:	eb 49                	jmp    1b770 <lwm2m_socket_start+0x9f>
K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_CONNECT, zsock_connect, int, int, sock, const struct sockaddr *, addr, socklen_t, addrlen)
   1b727:	6a 18                	push   $0x18
   1b729:	56                   	push   %esi
   1b72a:	50                   	push   %eax
   1b72b:	e8 fe d6 fe ff       	call   8e2e <z_impl_zsock_connect>
   1b730:	83 c4 0c             	add    $0xc,%esp
	if (connect(client_ctx->sock_fd, &client_ctx->remote_addr,
   1b733:	85 c0                	test   %eax,%eax
   1b735:	79 44                	jns    1b77b <lwm2m_socket_start+0xaa>
		LOG_ERR("Cannot connect UDP (-%d)", errno);
   1b737:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b73e:	74 29                	je     1b769 <lwm2m_socket_start+0x98>
   1b740:	e8 a3 75 00 00       	call   22ce8 <z_impl_z_errno>
   1b745:	bb cc 51 02 00       	mov    $0x251cc,%ebx
   1b74a:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   1b750:	c1 eb 03             	shr    $0x3,%ebx
   1b753:	c1 e3 06             	shl    $0x6,%ebx
   1b756:	83 cb 01             	or     $0x1,%ebx
   1b759:	53                   	push   %ebx
   1b75a:	ff 30                	pushl  (%eax)
   1b75c:	68 7f 9d 02 00       	push   $0x29d7f
   1b761:	e8 49 7d fe ff       	call   34af <log_1>
   1b766:	83 c4 0c             	add    $0xc,%esp
		lwm2m_engine_context_close(client_ctx);
   1b769:	56                   	push   %esi
   1b76a:	e8 d6 fe ff ff       	call   1b645 <lwm2m_engine_context_close>
   1b76f:	5a                   	pop    %edx
   1b770:	e8 73 75 00 00       	call   22ce8 <z_impl_z_errno>
		return -errno;
   1b775:	8b 00                	mov    (%eax),%eax
   1b777:	f7 d8                	neg    %eax
   1b779:	eb 09                	jmp    1b784 <lwm2m_socket_start+0xb3>
	lwm2m_socket_add(client_ctx);
   1b77b:	56                   	push   %esi
   1b77c:	e8 18 fe ff ff       	call   1b599 <lwm2m_socket_add>
   1b781:	58                   	pop    %eax
	return 0;
   1b782:	31 c0                	xor    %eax,%eax
}
   1b784:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1b787:	5b                   	pop    %ebx
   1b788:	5e                   	pop    %esi
   1b789:	5d                   	pop    %ebp
   1b78a:	c3                   	ret    

0001b78b <lwm2m_parse_peerinfo>:
{
   1b78b:	55                   	push   %ebp
   1b78c:	89 e5                	mov    %esp,%ebp
   1b78e:	57                   	push   %edi
   1b78f:	56                   	push   %esi
   1b790:	53                   	push   %ebx
	http_parser_url_init(&parser);
   1b791:	8d 5d d4             	lea    -0x2c(%ebp),%ebx
{
   1b794:	83 ec 28             	sub    $0x28,%esp
   1b797:	8b 7d 08             	mov    0x8(%ebp),%edi
   1b79a:	8b 75 0c             	mov    0xc(%ebp),%esi
	http_parser_url_init(&parser);
   1b79d:	53                   	push   %ebx
   1b79e:	e8 02 6e 00 00       	call   225a5 <http_parser_url_init>
	ret = http_parser_parse_url(url, strlen(url), 0, &parser);
   1b7a3:	89 3c 24             	mov    %edi,(%esp)
   1b7a6:	e8 b8 f0 fe ff       	call   a863 <strlen>
   1b7ab:	89 1c 24             	mov    %ebx,(%esp)
   1b7ae:	6a 00                	push   $0x0
   1b7b0:	50                   	push   %eax
   1b7b1:	57                   	push   %edi
   1b7b2:	e8 02 6e 00 00       	call   225b9 <http_parser_parse_url>
   1b7b7:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
   1b7ba:	85 c0                	test   %eax,%eax
   1b7bc:	79 40                	jns    1b7fe <lwm2m_parse_peerinfo+0x73>
		return -ENOTSUP;
   1b7be:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		LOG_ERR("Invalid url: %s", url);
   1b7c3:	f6 05 a4 a8 40 00 07 	testb  $0x7,0x40a8a4
   1b7ca:	0f 84 0a 01 00 00    	je     1b8da <lwm2m_parse_peerinfo+0x14f>
   1b7d0:	ba cc 51 02 00       	mov    $0x251cc,%edx
   1b7d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
   1b7d8:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1b7de:	c1 ea 03             	shr    $0x3,%edx
   1b7e1:	c1 e2 06             	shl    $0x6,%edx
   1b7e4:	83 ca 01             	or     $0x1,%edx
   1b7e7:	52                   	push   %edx
   1b7e8:	57                   	push   %edi
   1b7e9:	68 98 9d 02 00       	push   $0x29d98
   1b7ee:	e8 bc 7c fe ff       	call   34af <log_1>
   1b7f3:	83 c4 0c             	add    $0xc,%esp
   1b7f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b7f9:	e9 dc 00 00 00       	jmp    1b8da <lwm2m_parse_peerinfo+0x14f>
	len = parser.field_data[UF_SCHEMA].len;
   1b7fe:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
	if (strncmp(url + off, "coaps", len) != 0) {
   1b802:	0f b7 5d d8          	movzwl -0x28(%ebp),%ebx
   1b806:	50                   	push   %eax
   1b807:	01 fb                	add    %edi,%ebx
   1b809:	68 a8 9d 02 00       	push   $0x29da8
   1b80e:	89 45 d0             	mov    %eax,-0x30(%ebp)
   1b811:	53                   	push   %ebx
   1b812:	e8 7f f0 fe ff       	call   a896 <strncmp>
   1b817:	83 c4 0c             	add    $0xc,%esp
   1b81a:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1b81d:	85 c0                	test   %eax,%eax
   1b81f:	74 0a                	je     1b82b <lwm2m_parse_peerinfo+0xa0>
		return -EPROTONOSUPPORT;
   1b821:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
   1b826:	e9 af 00 00 00       	jmp    1b8da <lwm2m_parse_peerinfo+0x14f>
	if (len == 5 && strncmp(url + off, "coaps", len) == 0) {
   1b82b:	66 83 fa 05          	cmp    $0x5,%dx
	*use_dtls = false;
   1b82f:	8b 45 10             	mov    0x10(%ebp),%eax
   1b832:	c6 00 00             	movb   $0x0,(%eax)
	if (len == 5 && strncmp(url + off, "coaps", len) == 0) {
   1b835:	74 0e                	je     1b845 <lwm2m_parse_peerinfo+0xba>
	if (!(parser.field_set & (1 << UF_PORT))) {
   1b837:	f6 45 d4 04          	testb  $0x4,-0x2c(%ebp)
   1b83b:	75 1e                	jne    1b85b <lwm2m_parse_peerinfo+0xd0>
		parser.port = CONFIG_LWM2M_PEER_PORT;
   1b83d:	66 c7 45 d6 33 16    	movw   $0x1633,-0x2a(%ebp)
   1b843:	eb 16                	jmp    1b85b <lwm2m_parse_peerinfo+0xd0>
	if (len == 5 && strncmp(url + off, "coaps", len) == 0) {
   1b845:	6a 05                	push   $0x5
   1b847:	68 a8 9d 02 00       	push   $0x29da8
   1b84c:	53                   	push   %ebx
   1b84d:	e8 44 f0 fe ff       	call   a896 <strncmp>
   1b852:	83 c4 0c             	add    $0xc,%esp
   1b855:	85 c0                	test   %eax,%eax
   1b857:	75 de                	jne    1b837 <lwm2m_parse_peerinfo+0xac>
   1b859:	eb c6                	jmp    1b821 <lwm2m_parse_peerinfo+0x96>
	tmp = url[off + len];
   1b85b:	0f b7 4d dc          	movzwl -0x24(%ebp),%ecx
   1b85f:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
   1b863:	01 cb                	add    %ecx,%ebx
   1b865:	89 4d cc             	mov    %ecx,-0x34(%ebp)
   1b868:	01 fb                	add    %edi,%ebx
   1b86a:	8a 03                	mov    (%ebx),%al
	url[off + len] = '\0';
   1b86c:	c6 03 00             	movb   $0x0,(%ebx)
	(void)memset(addr, 0, sizeof(*addr));
   1b86f:	6a 18                	push   $0x18
	tmp = url[off + len];
   1b871:	88 45 d0             	mov    %al,-0x30(%ebp)
	(void)memset(addr, 0, sizeof(*addr));
   1b874:	6a 00                	push   $0x0
   1b876:	56                   	push   %esi
   1b877:	e8 24 f1 fe ff       	call   a9a0 <memset>
   1b87c:	83 c4 0c             	add    $0xc,%esp
			    &((struct sockaddr_in6 *)addr)->sin6_addr);
   1b87f:	8d 56 04             	lea    0x4(%esi),%edx
	ret = net_addr_pton(AF_INET6, url + off,
   1b882:	8b 4d cc             	mov    -0x34(%ebp),%ecx
	addr->sa_family = AF_INET6;
   1b885:	66 c7 06 02 00       	movw   $0x2,(%esi)
	ret = net_addr_pton(AF_INET6, url + off,
   1b88a:	01 cf                	add    %ecx,%edi
   1b88c:	52                   	push   %edx
   1b88d:	57                   	push   %edi
   1b88e:	89 55 cc             	mov    %edx,-0x34(%ebp)
   1b891:	6a 02                	push   $0x2
   1b893:	e8 39 52 ff ff       	call   10ad1 <net_addr_pton>
   1b898:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1b89b:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1b89e:	85 c0                	test   %eax,%eax
   1b8a0:	79 15                	jns    1b8b7 <lwm2m_parse_peerinfo+0x12c>
		addr->sa_family = AF_INET;
   1b8a2:	66 c7 06 01 00       	movw   $0x1,(%esi)
		ret = net_addr_pton(AF_INET, url + off,
   1b8a7:	52                   	push   %edx
   1b8a8:	57                   	push   %edi
   1b8a9:	6a 01                	push   $0x1
   1b8ab:	e8 21 52 ff ff       	call   10ad1 <net_addr_pton>
   1b8b0:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1b8b3:	85 c0                	test   %eax,%eax
   1b8b5:	78 1e                	js     1b8d5 <lwm2m_parse_peerinfo+0x14a>
	if (addr->sa_family == AF_INET6) {
   1b8b7:	66 8b 16             	mov    (%esi),%dx
   1b8ba:	66 83 fa 02          	cmp    $0x2,%dx
   1b8be:	74 04                	je     1b8c4 <lwm2m_parse_peerinfo+0x139>
	} else if (addr->sa_family == AF_INET) {
   1b8c0:	66 4a                	dec    %dx
   1b8c2:	75 0c                	jne    1b8d0 <lwm2m_parse_peerinfo+0x145>
		net_sin(addr)->sin_port = htons(parser.port);
   1b8c4:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
   1b8c8:	86 f2                	xchg   %dh,%dl
   1b8ca:	66 89 56 02          	mov    %dx,0x2(%esi)
   1b8ce:	eb 05                	jmp    1b8d5 <lwm2m_parse_peerinfo+0x14a>
		ret = -EPROTONOSUPPORT;
   1b8d0:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
	url[off + len] = tmp;
   1b8d5:	8a 4d d0             	mov    -0x30(%ebp),%cl
   1b8d8:	88 0b                	mov    %cl,(%ebx)
}
   1b8da:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1b8dd:	5b                   	pop    %ebx
   1b8de:	5e                   	pop    %esi
   1b8df:	5f                   	pop    %edi
   1b8e0:	5d                   	pop    %ebp
   1b8e1:	c3                   	ret    

0001b8e2 <lwm2m_engine_start>:
{
   1b8e2:	55                   	push   %ebp
   1b8e3:	89 e5                	mov    %esp,%ebp
   1b8e5:	56                   	push   %esi
   1b8e6:	53                   	push   %ebx
   1b8e7:	83 ec 1c             	sub    $0x1c,%esp
	snprintk(pathstr, sizeof(pathstr), "0/%d/0", client_ctx->sec_obj_inst);
   1b8ea:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
   1b8ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
	snprintk(pathstr, sizeof(pathstr), "0/%d/0", client_ctx->sec_obj_inst);
   1b8f0:	ff b3 7c 01 00 00    	pushl  0x17c(%ebx)
   1b8f6:	68 ae 9d 02 00       	push   $0x29dae
   1b8fb:	6a 14                	push   $0x14
   1b8fd:	56                   	push   %esi
   1b8fe:	e8 da 72 fe ff       	call   2bdd <snprintk>
   1b903:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_get_res_data(pathstr, (void **)&url, &url_len,
   1b906:	8d 45 dd             	lea    -0x23(%ebp),%eax
   1b909:	50                   	push   %eax
   1b90a:	8d 45 de             	lea    -0x22(%ebp),%eax
   1b90d:	50                   	push   %eax
   1b90e:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1b911:	50                   	push   %eax
   1b912:	56                   	push   %esi
   1b913:	e8 17 f0 ff ff       	call   1a92f <lwm2m_engine_get_res_data>
   1b918:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
   1b91b:	85 c0                	test   %eax,%eax
   1b91d:	78 31                	js     1b950 <lwm2m_engine_start+0x6e>
	url[url_len] = '\0';
   1b91f:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
   1b923:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1b926:	c6 04 02 00          	movb   $0x0,(%edx,%eax,1)
	ret = lwm2m_parse_peerinfo(url, &client_ctx->remote_addr,
   1b92a:	8d 83 78 01 00 00    	lea    0x178(%ebx),%eax
   1b930:	50                   	push   %eax
   1b931:	53                   	push   %ebx
   1b932:	ff 75 e0             	pushl  -0x20(%ebp)
   1b935:	e8 51 fe ff ff       	call   1b78b <lwm2m_parse_peerinfo>
   1b93a:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1b93d:	85 c0                	test   %eax,%eax
   1b93f:	78 0f                	js     1b950 <lwm2m_engine_start+0x6e>
	lwm2m_engine_context_init(client_ctx);
   1b941:	53                   	push   %ebx
   1b942:	e8 38 fc ff ff       	call   1b57f <lwm2m_engine_context_init>
	return lwm2m_socket_start(client_ctx);
   1b947:	89 1c 24             	mov    %ebx,(%esp)
   1b94a:	e8 82 fd ff ff       	call   1b6d1 <lwm2m_socket_start>
   1b94f:	5a                   	pop    %edx
}
   1b950:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1b953:	5b                   	pop    %ebx
   1b954:	5e                   	pop    %esi
   1b955:	5d                   	pop    %ebp
   1b956:	c3                   	ret    

0001b957 <lwm2m_security_init>:

	return inst[index].obj_inst_id;
}

static int lwm2m_security_init(struct device *dev)
{
   1b957:	55                   	push   %ebp
   1b958:	89 e5                	mov    %esp,%ebp
   1b95a:	83 ec 08             	sub    $0x8,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	/* Set default values */
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   1b95d:	6a 10                	push   $0x10
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1b95f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   1b966:	6a 00                	push   $0x0
   1b968:	68 b8 43 40 00       	push   $0x4043b8
   1b96d:	e8 2e f0 fe ff       	call   a9a0 <memset>
   1b972:	83 c4 0c             	add    $0xc,%esp
	(void)memset(res, 0, sizeof(struct lwm2m_engine_res_inst) *
   1b975:	68 a0 01 00 00       	push   $0x1a0
   1b97a:	6a 00                	push   $0x0
   1b97c:	68 60 2d 40 00       	push   $0x402d60
   1b981:	e8 1a f0 fe ff       	call   a9a0 <memset>
   1b986:	83 c4 0c             	add    $0xc,%esp
			MAX_INSTANCE_COUNT * SECURITY_MAX_ID);

	security.obj_id = LWM2M_OBJECT_SECURITY_ID;
	security.fields = fields;
   1b989:	c7 05 04 2f 40 00 e0 	movl   $0x40a3e0,0x402f04
   1b990:	a3 40 00 
	security.obj_id = LWM2M_OBJECT_SECURITY_ID;
   1b993:	c7 05 18 2f 40 00 00 	movl   $0xd0000,0x402f18
   1b99a:	00 0d 00 
	security.field_count = ARRAY_SIZE(fields);
	security.max_instance_count = MAX_INSTANCE_COUNT;
   1b99d:	66 c7 05 1e 2f 40 00 	movw   $0x1,0x402f1e
   1b9a4:	01 00 
	security.create_cb = security_create;
	lwm2m_register_obj(&security);
   1b9a6:	68 00 2f 40 00       	push   $0x402f00
	security.create_cb = security_create;
   1b9ab:	c7 05 08 2f 40 00 04 	movl   $0x1ba04,0x402f08
   1b9b2:	ba 01 00 
	lwm2m_register_obj(&security);
   1b9b5:	e8 5c bb ff ff       	call   17516 <lwm2m_register_obj>

	/* auto create the first instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_SECURITY_ID, 0, &obj_inst);
   1b9ba:	8d 45 fc             	lea    -0x4(%ebp),%eax
   1b9bd:	89 04 24             	mov    %eax,(%esp)
   1b9c0:	6a 00                	push   $0x0
   1b9c2:	6a 00                	push   $0x0
   1b9c4:	e8 24 c3 ff ff       	call   17ced <lwm2m_create_obj_inst>
   1b9c9:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1b9cc:	85 c0                	test   %eax,%eax
   1b9ce:	79 32                	jns    1ba02 <lwm2m_security_init+0xab>
		LOG_ERR("Create LWM2M security instance 0 error: %d", ret);
   1b9d0:	f6 05 b8 a8 40 00 07 	testb  $0x7,0x40a8b8
   1b9d7:	74 29                	je     1ba02 <lwm2m_security_init+0xab>
   1b9d9:	ba f4 51 02 00       	mov    $0x251f4,%edx
   1b9de:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1b9e1:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1b9e7:	c1 ea 03             	shr    $0x3,%edx
   1b9ea:	c1 e2 06             	shl    $0x6,%edx
   1b9ed:	83 ca 01             	or     $0x1,%edx
   1b9f0:	52                   	push   %edx
   1b9f1:	50                   	push   %eax
   1b9f2:	68 d3 9d 02 00       	push   $0x29dd3
   1b9f7:	e8 b3 7a fe ff       	call   34af <log_1>
   1b9fc:	83 c4 0c             	add    $0xc,%esp
   1b9ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
   1ba02:	c9                   	leave  
   1ba03:	c3                   	ret    

0001ba04 <security_create>:
{
   1ba04:	55                   	push   %ebp
   1ba05:	a1 b8 a8 40 00       	mov    0x40a8b8,%eax
   1ba0a:	89 e5                	mov    %esp,%ebp
   1ba0c:	53                   	push   %ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1ba0d:	83 3d bc 43 40 00 00 	cmpl   $0x0,0x4043bc
{
   1ba14:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1ba17:	74 68                	je     1ba81 <security_create+0x7d>
   1ba19:	83 e0 07             	and    $0x7,%eax
			return NULL;
   1ba1c:	31 db                	xor    %ebx,%ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1ba1e:	66 39 15 c4 43 40 00 	cmp    %dx,0x4043c4
   1ba25:	75 27                	jne    1ba4e <security_create+0x4a>
			LOG_ERR("Can not create instance - "
   1ba27:	85 c0                	test   %eax,%eax
   1ba29:	0f 84 a7 02 00 00    	je     1bcd6 <security_create+0x2d2>
   1ba2f:	b8 f4 51 02 00       	mov    $0x251f4,%eax
   1ba34:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ba39:	c1 e8 03             	shr    $0x3,%eax
   1ba3c:	c1 e0 06             	shl    $0x6,%eax
   1ba3f:	83 c8 01             	or     $0x1,%eax
   1ba42:	50                   	push   %eax
   1ba43:	0f b7 d2             	movzwl %dx,%edx
   1ba46:	52                   	push   %edx
   1ba47:	68 fe 9d 02 00       	push   $0x29dfe
   1ba4c:	eb 26                	jmp    1ba74 <security_create+0x70>
		LOG_ERR("Can not create instance - "
   1ba4e:	85 c0                	test   %eax,%eax
   1ba50:	0f 84 80 02 00 00    	je     1bcd6 <security_create+0x2d2>
   1ba56:	b9 f4 51 02 00       	mov    $0x251f4,%ecx
   1ba5b:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   1ba61:	c1 e9 03             	shr    $0x3,%ecx
   1ba64:	c1 e1 06             	shl    $0x6,%ecx
   1ba67:	83 c9 01             	or     $0x1,%ecx
   1ba6a:	51                   	push   %ecx
   1ba6b:	0f b7 d2             	movzwl %dx,%edx
   1ba6e:	52                   	push   %edx
   1ba6f:	68 2d 9e 02 00       	push   $0x29e2d
   1ba74:	e8 36 7a fe ff       	call   34af <log_1>
   1ba79:	83 c4 0c             	add    $0xc,%esp
   1ba7c:	e9 55 02 00 00       	jmp    1bcd6 <security_create+0x2d2>
	security_uri[index][0] = '\0';
   1ba81:	c6 05 a0 2f 40 00 00 	movb   $0x0,0x402fa0
	client_identity[index][0] = '\0';
   1ba88:	c6 05 20 2f 40 00 00 	movb   $0x0,0x402f20
	bootstrap_flag[index] = 0;
   1ba8f:	c6 05 5a 45 40 00 00 	movb   $0x0,0x40455a
	security_mode[index] = 0;
   1ba96:	c6 05 59 45 40 00 00 	movb   $0x0,0x404559
	short_server_id[index] = 0;
   1ba9d:	66 c7 05 52 45 40 00 	movw   $0x0,0x404552
   1baa4:	00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_SERVER_URI_ID,
   1baa6:	c7 05 70 2d 40 00 00 	movl   $0x0,0x402d70
   1baad:	00 00 00 
   1bab0:	c7 05 74 2d 40 00 a0 	movl   $0x402fa0,0x402d74
   1bab7:	2f 40 00 
   1baba:	c7 05 78 2d 40 00 ff 	movl   $0xff,0x402d78
   1bac1:	00 00 00 
   1bac4:	c7 05 60 2d 40 00 00 	movl   $0x0,0x402d60
   1bacb:	00 00 00 
   1bace:	c7 05 64 2d 40 00 00 	movl   $0x0,0x402d64
   1bad5:	00 00 00 
   1bad8:	c7 05 68 2d 40 00 00 	movl   $0x0,0x402d68
   1badf:	00 00 00 
   1bae2:	c7 05 6c 2d 40 00 00 	movl   $0x0,0x402d6c
   1bae9:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_BOOTSTRAP_FLAG_ID,
   1baec:	c7 05 90 2d 40 00 00 	movl   $0x0,0x402d90
   1baf3:	00 00 00 
   1baf6:	c7 05 94 2d 40 00 5a 	movl   $0x40455a,0x402d94
   1bafd:	45 40 00 
   1bb00:	c7 05 98 2d 40 00 01 	movl   $0x10001,0x402d98
   1bb07:	00 01 00 
   1bb0a:	c7 05 80 2d 40 00 00 	movl   $0x0,0x402d80
   1bb11:	00 00 00 
   1bb14:	c7 05 84 2d 40 00 00 	movl   $0x0,0x402d84
   1bb1b:	00 00 00 
   1bb1e:	c7 05 88 2d 40 00 00 	movl   $0x0,0x402d88
   1bb25:	00 00 00 
   1bb28:	c7 05 8c 2d 40 00 00 	movl   $0x0,0x402d8c
   1bb2f:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_MODE_ID,
   1bb32:	c7 05 b0 2d 40 00 00 	movl   $0x0,0x402db0
   1bb39:	00 00 00 
   1bb3c:	c7 05 b4 2d 40 00 59 	movl   $0x404559,0x402db4
   1bb43:	45 40 00 
   1bb46:	c7 05 b8 2d 40 00 01 	movl   $0x20001,0x402db8
   1bb4d:	00 02 00 
   1bb50:	c7 05 a0 2d 40 00 00 	movl   $0x0,0x402da0
   1bb57:	00 00 00 
   1bb5a:	c7 05 a4 2d 40 00 00 	movl   $0x0,0x402da4
   1bb61:	00 00 00 
   1bb64:	c7 05 a8 2d 40 00 00 	movl   $0x0,0x402da8
   1bb6b:	00 00 00 
   1bb6e:	c7 05 ac 2d 40 00 00 	movl   $0x0,0x402dac
   1bb75:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_CLIENT_PK_ID,
   1bb78:	c7 05 d0 2d 40 00 00 	movl   $0x0,0x402dd0
   1bb7f:	00 00 00 
   1bb82:	c7 05 d4 2d 40 00 20 	movl   $0x402f20,0x402dd4
   1bb89:	2f 40 00 
   1bb8c:	c7 05 d8 2d 40 00 80 	movl   $0x30080,0x402dd8
   1bb93:	00 03 00 
   1bb96:	c7 05 c0 2d 40 00 00 	movl   $0x0,0x402dc0
   1bb9d:	00 00 00 
   1bba0:	c7 05 c4 2d 40 00 00 	movl   $0x0,0x402dc4
   1bba7:	00 00 00 
   1bbaa:	c7 05 c8 2d 40 00 00 	movl   $0x0,0x402dc8
   1bbb1:	00 00 00 
	LOG_DBG("Create LWM2M security instance: %d", obj_inst_id);
   1bbb4:	a8 04                	test   $0x4,%al
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_CLIENT_PK_ID,
   1bbb6:	c7 05 cc 2d 40 00 00 	movl   $0x0,0x402dcc
   1bbbd:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_SERVER_PK_ID,
   1bbc0:	c7 05 f0 2d 40 00 00 	movl   $0x0,0x402df0
   1bbc7:	00 00 00 
   1bbca:	c7 05 f4 2d 40 00 d8 	movl   $0x4043d8,0x402df4
   1bbd1:	43 40 00 
   1bbd4:	c7 05 f8 2d 40 00 10 	movl   $0x40010,0x402df8
   1bbdb:	00 04 00 
   1bbde:	c7 05 e0 2d 40 00 00 	movl   $0x0,0x402de0
   1bbe5:	00 00 00 
   1bbe8:	c7 05 e4 2d 40 00 00 	movl   $0x0,0x402de4
   1bbef:	00 00 00 
   1bbf2:	c7 05 e8 2d 40 00 00 	movl   $0x0,0x402de8
   1bbf9:	00 00 00 
   1bbfc:	c7 05 ec 2d 40 00 00 	movl   $0x0,0x402dec
   1bc03:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_SECRET_KEY_ID,
   1bc06:	c7 05 10 2e 40 00 00 	movl   $0x0,0x402e10
   1bc0d:	00 00 00 
   1bc10:	c7 05 14 2e 40 00 c8 	movl   $0x4043c8,0x402e14
   1bc17:	43 40 00 
   1bc1a:	c7 05 18 2e 40 00 10 	movl   $0x50010,0x402e18
   1bc21:	00 05 00 
   1bc24:	c7 05 00 2e 40 00 00 	movl   $0x0,0x402e00
   1bc2b:	00 00 00 
   1bc2e:	c7 05 04 2e 40 00 00 	movl   $0x0,0x402e04
   1bc35:	00 00 00 
   1bc38:	c7 05 08 2e 40 00 00 	movl   $0x0,0x402e08
   1bc3f:	00 00 00 
   1bc42:	c7 05 0c 2e 40 00 00 	movl   $0x0,0x402e0c
   1bc49:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SECURITY_SHORT_SERVER_ID,
   1bc4c:	c7 05 30 2e 40 00 00 	movl   $0x0,0x402e30
   1bc53:	00 00 00 
   1bc56:	c7 05 34 2e 40 00 52 	movl   $0x404552,0x402e34
   1bc5d:	45 40 00 
   1bc60:	c7 05 38 2e 40 00 02 	movl   $0xa0002,0x402e38
   1bc67:	00 0a 00 
   1bc6a:	c7 05 20 2e 40 00 00 	movl   $0x0,0x402e20
   1bc71:	00 00 00 
   1bc74:	c7 05 24 2e 40 00 00 	movl   $0x0,0x402e24
   1bc7b:	00 00 00 
   1bc7e:	c7 05 28 2e 40 00 00 	movl   $0x0,0x402e28
   1bc85:	00 00 00 
   1bc88:	c7 05 2c 2e 40 00 00 	movl   $0x0,0x402e2c
   1bc8f:	00 00 00 
	inst[index].resources = res[index];
   1bc92:	c7 05 c0 43 40 00 60 	movl   $0x402d60,0x4043c0
   1bc99:	2d 40 00 
	inst[index].resource_count = i;
   1bc9c:	66 c7 05 c6 43 40 00 	movw   $0x7,0x4043c6
   1bca3:	07 00 
	LOG_DBG("Create LWM2M security instance: %d", obj_inst_id);
   1bca5:	74 2a                	je     1bcd1 <security_create+0x2cd>
   1bca7:	b8 f4 51 02 00       	mov    $0x251f4,%eax
   1bcac:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1bcb1:	c1 e8 03             	shr    $0x3,%eax
   1bcb4:	c1 e0 06             	shl    $0x6,%eax
   1bcb7:	83 c8 04             	or     $0x4,%eax
   1bcba:	50                   	push   %eax
   1bcbb:	0f b7 d2             	movzwl %dx,%edx
   1bcbe:	52                   	push   %edx
   1bcbf:	68 64 63 02 00       	push   $0x26364
   1bcc4:	68 58 9e 02 00       	push   $0x29e58
   1bcc9:	e8 1b 78 fe ff       	call   34e9 <log_2>
   1bcce:	83 c4 10             	add    $0x10,%esp
	return &inst[index];
   1bcd1:	bb b8 43 40 00       	mov    $0x4043b8,%ebx
}
   1bcd6:	89 d8                	mov    %ebx,%eax
   1bcd8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1bcdb:	c9                   	leave  
   1bcdc:	c3                   	ret    

0001bcdd <lwm2m_security_inst_id_to_index>:
{
   1bcdd:	55                   	push   %ebp
   1bcde:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1bce3:	89 e5                	mov    %esp,%ebp
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   1bce5:	83 3d bc 43 40 00 00 	cmpl   $0x0,0x4043bc
{
   1bcec:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   1bcef:	74 10                	je     1bd01 <lwm2m_security_inst_id_to_index+0x24>
   1bcf1:	31 c0                	xor    %eax,%eax
   1bcf3:	66 39 15 c4 43 40 00 	cmp    %dx,0x4043c4
   1bcfa:	0f 94 c0             	sete   %al
   1bcfd:	8d 44 00 fe          	lea    -0x2(%eax,%eax,1),%eax
}
   1bd01:	5d                   	pop    %ebp
   1bd02:	c3                   	ret    

0001bd03 <lwm2m_security_index_to_inst_id>:
{
   1bd03:	55                   	push   %ebp
		return -EINVAL;
   1bd04:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
   1bd09:	89 e5                	mov    %esp,%ebp
   1bd0b:	8b 55 08             	mov    0x8(%ebp),%edx
	if (index >= MAX_INSTANCE_COUNT) {
   1bd0e:	85 d2                	test   %edx,%edx
   1bd10:	7f 18                	jg     1bd2a <lwm2m_security_index_to_inst_id+0x27>
	if (!inst[index].obj) {
   1bd12:	c1 e2 04             	shl    $0x4,%edx
		return -ENOENT;
   1bd15:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!inst[index].obj) {
   1bd1a:	81 c2 b8 43 40 00    	add    $0x4043b8,%edx
   1bd20:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
   1bd24:	74 04                	je     1bd2a <lwm2m_security_index_to_inst_id+0x27>
	return inst[index].obj_inst_id;
   1bd26:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
}
   1bd2a:	5d                   	pop    %ebp
   1bd2b:	c3                   	ret    

0001bd2c <lwm2m_server_init>:
	LOG_DBG("Create LWM2M server instance: %d", obj_inst_id);
	return &inst[index];
}

static int lwm2m_server_init(struct device *dev)
{
   1bd2c:	55                   	push   %ebp
   1bd2d:	89 e5                	mov    %esp,%ebp
   1bd2f:	83 ec 08             	sub    $0x8,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	/* Set default values */
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   1bd32:	6a 10                	push   $0x10
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1bd34:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   1bd3b:	6a 00                	push   $0x0
   1bd3d:	68 e8 43 40 00       	push   $0x4043e8
   1bd42:	e8 59 ec fe ff       	call   a9a0 <memset>
   1bd47:	83 c4 0c             	add    $0xc,%esp
	(void)memset(res, 0, sizeof(struct lwm2m_engine_res_inst) *
   1bd4a:	68 20 01 00 00       	push   $0x120
   1bd4f:	6a 00                	push   $0x0
   1bd51:	68 a0 30 40 00       	push   $0x4030a0
   1bd56:	e8 45 ec fe ff       	call   a9a0 <memset>
   1bd5b:	83 c4 0c             	add    $0xc,%esp
			MAX_INSTANCE_COUNT * SERVER_MAX_ID);

	server.obj_id = LWM2M_OBJECT_SERVER_ID;
	server.fields = fields;
   1bd5e:	c7 05 c4 31 40 00 40 	movl   $0x40a440,0x4031c4
   1bd65:	a4 40 00 
	server.obj_id = LWM2M_OBJECT_SERVER_ID;
   1bd68:	c7 05 d8 31 40 00 01 	movl   $0x90001,0x4031d8
   1bd6f:	00 09 00 
	server.field_count = ARRAY_SIZE(fields);
	server.max_instance_count = MAX_INSTANCE_COUNT;
   1bd72:	66 c7 05 de 31 40 00 	movw   $0x1,0x4031de
   1bd79:	01 00 
	server.create_cb = server_create;
	lwm2m_register_obj(&server);
   1bd7b:	68 c0 31 40 00       	push   $0x4031c0
	server.create_cb = server_create;
   1bd80:	c7 05 c8 31 40 00 42 	movl   $0x1be42,0x4031c8
   1bd87:	be 01 00 
	lwm2m_register_obj(&server);
   1bd8a:	e8 87 b7 ff ff       	call   17516 <lwm2m_register_obj>

	/* auto create the first instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_SERVER_ID, 0, &obj_inst);
   1bd8f:	8d 45 fc             	lea    -0x4(%ebp),%eax
   1bd92:	89 04 24             	mov    %eax,(%esp)
   1bd95:	6a 00                	push   $0x0
   1bd97:	6a 01                	push   $0x1
   1bd99:	e8 4f bf ff ff       	call   17ced <lwm2m_create_obj_inst>
   1bd9e:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1bda1:	85 c0                	test   %eax,%eax
   1bda3:	79 32                	jns    1bdd7 <lwm2m_server_init+0xab>
		LOG_ERR("Create LWM2M server instance 0 error: %d", ret);
   1bda5:	f6 05 bc a8 40 00 07 	testb  $0x7,0x40a8bc
   1bdac:	74 29                	je     1bdd7 <lwm2m_server_init+0xab>
   1bdae:	ba fc 51 02 00       	mov    $0x251fc,%edx
   1bdb3:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1bdb6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1bdbc:	c1 ea 03             	shr    $0x3,%edx
   1bdbf:	c1 e2 06             	shl    $0x6,%edx
   1bdc2:	83 ca 01             	or     $0x1,%edx
   1bdc5:	52                   	push   %edx
   1bdc6:	50                   	push   %eax
   1bdc7:	68 96 9e 02 00       	push   $0x29e96
   1bdcc:	e8 de 76 fe ff       	call   34af <log_1>
   1bdd1:	83 c4 0c             	add    $0xc,%esp
   1bdd4:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
   1bdd7:	c9                   	leave  
   1bdd8:	c3                   	ret    

0001bdd9 <disable_cb>:
{
   1bdd9:	55                   	push   %ebp
	LOG_DBG("DISABLE %d", obj_inst_id);
   1bdda:	f6 05 bc a8 40 00 04 	testb  $0x4,0x40a8bc
{
   1bde1:	89 e5                	mov    %esp,%ebp
   1bde3:	53                   	push   %ebx
   1bde4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	LOG_DBG("DISABLE %d", obj_inst_id);
   1bde7:	74 2a                	je     1be13 <disable_cb+0x3a>
   1bde9:	b8 fc 51 02 00       	mov    $0x251fc,%eax
   1bdee:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1bdf3:	c1 e8 03             	shr    $0x3,%eax
   1bdf6:	c1 e0 06             	shl    $0x6,%eax
   1bdf9:	83 c8 04             	or     $0x4,%eax
   1bdfc:	50                   	push   %eax
   1bdfd:	0f b7 c3             	movzwl %bx,%eax
   1be00:	50                   	push   %eax
   1be01:	68 74 63 02 00       	push   $0x26374
   1be06:	68 bf 9e 02 00       	push   $0x29ebf
   1be0b:	e8 d9 76 fe ff       	call   34e9 <log_2>
   1be10:	83 c4 10             	add    $0x10,%esp
	return -ENOENT;
   1be13:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   1be18:	83 3d ec 43 40 00 00 	cmpl   $0x0,0x4043ec
   1be1f:	74 10                	je     1be31 <disable_cb+0x58>
			return 0;
   1be21:	31 c0                	xor    %eax,%eax
   1be23:	66 39 1d f4 43 40 00 	cmp    %bx,0x4043f4
   1be2a:	0f 94 c0             	sete   %al
   1be2d:	8d 44 00 fe          	lea    -0x2(%eax,%eax,1),%eax
}
   1be31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1be34:	c9                   	leave  
   1be35:	c3                   	ret    

0001be36 <update_trigger_cb>:
{
   1be36:	55                   	push   %ebp
   1be37:	89 e5                	mov    %esp,%ebp
	engine_trigger_update();
   1be39:	e8 0e 32 00 00       	call   1f04c <engine_trigger_update>
}
   1be3e:	31 c0                	xor    %eax,%eax
   1be40:	5d                   	pop    %ebp
   1be41:	c3                   	ret    

0001be42 <server_create>:
{
   1be42:	55                   	push   %ebp
   1be43:	89 e5                	mov    %esp,%ebp
   1be45:	56                   	push   %esi
   1be46:	53                   	push   %ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1be47:	83 3d ec 43 40 00 00 	cmpl   $0x0,0x4043ec
{
   1be4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1be51:	74 6d                	je     1bec0 <server_create+0x7e>
   1be53:	a1 bc a8 40 00       	mov    0x40a8bc,%eax
			return NULL;
   1be58:	31 f6                	xor    %esi,%esi
   1be5a:	83 e0 07             	and    $0x7,%eax
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   1be5d:	66 39 1d f4 43 40 00 	cmp    %bx,0x4043f4
   1be64:	75 27                	jne    1be8d <server_create+0x4b>
			LOG_ERR("Can not create instance - "
   1be66:	85 c0                	test   %eax,%eax
   1be68:	0f 84 5c 03 00 00    	je     1c1ca <server_create+0x388>
   1be6e:	b8 fc 51 02 00       	mov    $0x251fc,%eax
   1be73:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1be78:	c1 e8 03             	shr    $0x3,%eax
   1be7b:	c1 e0 06             	shl    $0x6,%eax
   1be7e:	83 c8 01             	or     $0x1,%eax
   1be81:	50                   	push   %eax
   1be82:	0f b7 db             	movzwl %bx,%ebx
   1be85:	53                   	push   %ebx
   1be86:	68 fe 9d 02 00       	push   $0x29dfe
   1be8b:	eb 26                	jmp    1beb3 <server_create+0x71>
		LOG_ERR("Can not create instance - "
   1be8d:	85 c0                	test   %eax,%eax
   1be8f:	0f 84 35 03 00 00    	je     1c1ca <server_create+0x388>
   1be95:	ba fc 51 02 00       	mov    $0x251fc,%edx
   1be9a:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1bea0:	c1 ea 03             	shr    $0x3,%edx
   1bea3:	c1 e2 06             	shl    $0x6,%edx
   1bea6:	83 ca 01             	or     $0x1,%edx
   1bea9:	52                   	push   %edx
   1beaa:	0f b7 db             	movzwl %bx,%ebx
   1bead:	53                   	push   %ebx
   1beae:	68 2d 9e 02 00       	push   $0x29e2d
   1beb3:	e8 f7 75 fe ff       	call   34af <log_1>
   1beb8:	83 c4 0c             	add    $0xc,%esp
   1bebb:	e9 0a 03 00 00       	jmp    1c1ca <server_create+0x388>
	strcpy(transport_binding[index], "U");
   1bec0:	68 f3 9e 02 00       	push   $0x29ef3
	server_flag_store_notify[index] = 0U;
   1bec5:	c6 05 5b 45 40 00 00 	movb   $0x0,0x40455b
	strcpy(transport_binding[index], "U");
   1becc:	68 f8 43 40 00       	push   $0x4043f8
	server_id[index] = index + 1;
   1bed1:	66 c7 05 54 45 40 00 	movw   $0x1,0x404554
   1bed8:	01 00 
	lifetime[index] = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
   1beda:	c7 05 08 44 40 00 1e 	movl   $0x1e,0x404408
   1bee1:	00 00 00 
	default_min_period[index] = 0U;
   1bee4:	c7 05 04 44 40 00 00 	movl   $0x0,0x404404
   1beeb:	00 00 00 
	default_max_period[index] = 0U;
   1beee:	c7 05 00 44 40 00 00 	movl   $0x0,0x404400
   1bef5:	00 00 00 
	disabled_timeout[index] = 86400U;
   1bef8:	c7 05 fc 43 40 00 80 	movl   $0x15180,0x4043fc
   1beff:	51 01 00 
	strcpy(transport_binding[index], "U");
   1bf02:	e8 c4 e8 fe ff       	call   a7cb <strcpy>
   1bf07:	58                   	pop    %eax
   1bf08:	5a                   	pop    %edx
	INIT_OBJ_RES_DATA(res[index], i, SERVER_SHORT_SERVER_ID,
   1bf09:	c7 05 b0 30 40 00 00 	movl   $0x0,0x4030b0
   1bf10:	00 00 00 
   1bf13:	c7 05 b4 30 40 00 54 	movl   $0x404554,0x4030b4
   1bf1a:	45 40 00 
   1bf1d:	c7 05 b8 30 40 00 02 	movl   $0x2,0x4030b8
   1bf24:	00 00 00 
   1bf27:	c7 05 a0 30 40 00 00 	movl   $0x0,0x4030a0
   1bf2e:	00 00 00 
   1bf31:	c7 05 a4 30 40 00 00 	movl   $0x0,0x4030a4
   1bf38:	00 00 00 
   1bf3b:	c7 05 a8 30 40 00 00 	movl   $0x0,0x4030a8
   1bf42:	00 00 00 
   1bf45:	c7 05 ac 30 40 00 00 	movl   $0x0,0x4030ac
   1bf4c:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_LIFETIME_ID,
   1bf4f:	c7 05 d0 30 40 00 00 	movl   $0x0,0x4030d0
   1bf56:	00 00 00 
   1bf59:	c7 05 d4 30 40 00 08 	movl   $0x404408,0x4030d4
   1bf60:	44 40 00 
   1bf63:	c7 05 d8 30 40 00 04 	movl   $0x10004,0x4030d8
   1bf6a:	00 01 00 
   1bf6d:	c7 05 c0 30 40 00 00 	movl   $0x0,0x4030c0
   1bf74:	00 00 00 
   1bf77:	c7 05 c4 30 40 00 00 	movl   $0x0,0x4030c4
   1bf7e:	00 00 00 
   1bf81:	c7 05 c8 30 40 00 00 	movl   $0x0,0x4030c8
   1bf88:	00 00 00 
   1bf8b:	c7 05 cc 30 40 00 00 	movl   $0x0,0x4030cc
   1bf92:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_DEFAULT_MIN_PERIOD_ID,
   1bf95:	c7 05 f0 30 40 00 00 	movl   $0x0,0x4030f0
   1bf9c:	00 00 00 
   1bf9f:	c7 05 f4 30 40 00 04 	movl   $0x404404,0x4030f4
   1bfa6:	44 40 00 
   1bfa9:	c7 05 f8 30 40 00 04 	movl   $0x20004,0x4030f8
   1bfb0:	00 02 00 
   1bfb3:	c7 05 e0 30 40 00 00 	movl   $0x0,0x4030e0
   1bfba:	00 00 00 
   1bfbd:	c7 05 e4 30 40 00 00 	movl   $0x0,0x4030e4
   1bfc4:	00 00 00 
   1bfc7:	c7 05 e8 30 40 00 00 	movl   $0x0,0x4030e8
   1bfce:	00 00 00 
   1bfd1:	c7 05 ec 30 40 00 00 	movl   $0x0,0x4030ec
   1bfd8:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_DEFAULT_MAX_PERIOD_ID,
   1bfdb:	c7 05 10 31 40 00 00 	movl   $0x0,0x403110
   1bfe2:	00 00 00 
   1bfe5:	c7 05 14 31 40 00 00 	movl   $0x404400,0x403114
   1bfec:	44 40 00 
   1bfef:	c7 05 18 31 40 00 04 	movl   $0x30004,0x403118
   1bff6:	00 03 00 
   1bff9:	c7 05 00 31 40 00 00 	movl   $0x0,0x403100
   1c000:	00 00 00 
   1c003:	c7 05 04 31 40 00 00 	movl   $0x0,0x403104
   1c00a:	00 00 00 
   1c00d:	c7 05 08 31 40 00 00 	movl   $0x0,0x403108
   1c014:	00 00 00 
   1c017:	c7 05 0c 31 40 00 00 	movl   $0x0,0x40310c
   1c01e:	00 00 00 
	INIT_OBJ_RES_EXECUTE(res[index], i, SERVER_DISABLE_ID, disable_cb);
   1c021:	c7 05 30 31 40 00 00 	movl   $0x0,0x403130
   1c028:	00 00 00 
   1c02b:	c7 05 34 31 40 00 00 	movl   $0x0,0x403134
   1c032:	00 00 00 
   1c035:	c7 05 38 31 40 00 00 	movl   $0x40000,0x403138
   1c03c:	00 04 00 
   1c03f:	c7 05 20 31 40 00 00 	movl   $0x0,0x403120
   1c046:	00 00 00 
   1c049:	c7 05 24 31 40 00 00 	movl   $0x0,0x403124
   1c050:	00 00 00 
   1c053:	c7 05 28 31 40 00 00 	movl   $0x0,0x403128
   1c05a:	00 00 00 
   1c05d:	c7 05 2c 31 40 00 d9 	movl   $0x1bdd9,0x40312c
   1c064:	bd 01 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_DISABLE_TIMEOUT_ID,
   1c067:	c7 05 50 31 40 00 00 	movl   $0x0,0x403150
   1c06e:	00 00 00 
   1c071:	c7 05 54 31 40 00 fc 	movl   $0x4043fc,0x403154
   1c078:	43 40 00 
   1c07b:	c7 05 58 31 40 00 04 	movl   $0x50004,0x403158
   1c082:	00 05 00 
   1c085:	c7 05 40 31 40 00 00 	movl   $0x0,0x403140
   1c08c:	00 00 00 
   1c08f:	c7 05 44 31 40 00 00 	movl   $0x0,0x403144
   1c096:	00 00 00 
   1c099:	c7 05 48 31 40 00 00 	movl   $0x0,0x403148
   1c0a0:	00 00 00 
   1c0a3:	c7 05 4c 31 40 00 00 	movl   $0x0,0x40314c
   1c0aa:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_STORE_NOTIFY_ID,
   1c0ad:	c7 05 70 31 40 00 00 	movl   $0x0,0x403170
   1c0b4:	00 00 00 
   1c0b7:	c7 05 74 31 40 00 5b 	movl   $0x40455b,0x403174
   1c0be:	45 40 00 
   1c0c1:	c7 05 78 31 40 00 01 	movl   $0x60001,0x403178
   1c0c8:	00 06 00 
   1c0cb:	c7 05 60 31 40 00 00 	movl   $0x0,0x403160
   1c0d2:	00 00 00 
   1c0d5:	c7 05 64 31 40 00 00 	movl   $0x0,0x403164
   1c0dc:	00 00 00 
   1c0df:	c7 05 68 31 40 00 00 	movl   $0x0,0x403168
   1c0e6:	00 00 00 
   1c0e9:	c7 05 6c 31 40 00 00 	movl   $0x0,0x40316c
   1c0f0:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, SERVER_TRANSPORT_BINDING_ID,
   1c0f3:	c7 05 90 31 40 00 00 	movl   $0x0,0x403190
   1c0fa:	00 00 00 
   1c0fd:	c7 05 94 31 40 00 f8 	movl   $0x4043f8,0x403194
   1c104:	43 40 00 
   1c107:	c7 05 98 31 40 00 04 	movl   $0x70004,0x403198
   1c10e:	00 07 00 
   1c111:	c7 05 80 31 40 00 00 	movl   $0x0,0x403180
   1c118:	00 00 00 
   1c11b:	c7 05 84 31 40 00 00 	movl   $0x0,0x403184
   1c122:	00 00 00 
   1c125:	c7 05 88 31 40 00 00 	movl   $0x0,0x403188
   1c12c:	00 00 00 
   1c12f:	c7 05 8c 31 40 00 00 	movl   $0x0,0x40318c
   1c136:	00 00 00 
	INIT_OBJ_RES_EXECUTE(res[index], i, SERVER_REG_UPDATE_TRIGGER_ID,
   1c139:	c7 05 b0 31 40 00 00 	movl   $0x0,0x4031b0
   1c140:	00 00 00 
   1c143:	c7 05 b4 31 40 00 00 	movl   $0x0,0x4031b4
   1c14a:	00 00 00 
   1c14d:	c7 05 b8 31 40 00 00 	movl   $0x80000,0x4031b8
   1c154:	00 08 00 
   1c157:	c7 05 a0 31 40 00 00 	movl   $0x0,0x4031a0
   1c15e:	00 00 00 
   1c161:	c7 05 a4 31 40 00 00 	movl   $0x0,0x4031a4
   1c168:	00 00 00 
   1c16b:	c7 05 a8 31 40 00 00 	movl   $0x0,0x4031a8
   1c172:	00 00 00 
   1c175:	c7 05 ac 31 40 00 36 	movl   $0x1be36,0x4031ac
   1c17c:	be 01 00 
	inst[index].resources = res[index];
   1c17f:	c7 05 f0 43 40 00 a0 	movl   $0x4030a0,0x4043f0
   1c186:	30 40 00 
	inst[index].resource_count = i;
   1c189:	66 c7 05 f6 43 40 00 	movw   $0x9,0x4043f6
   1c190:	09 00 
	LOG_DBG("Create LWM2M server instance: %d", obj_inst_id);
   1c192:	f6 05 bc a8 40 00 04 	testb  $0x4,0x40a8bc
   1c199:	74 2a                	je     1c1c5 <server_create+0x383>
   1c19b:	b8 fc 51 02 00       	mov    $0x251fc,%eax
   1c1a0:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1c1a5:	c1 e8 03             	shr    $0x3,%eax
   1c1a8:	c1 e0 06             	shl    $0x6,%eax
   1c1ab:	83 c8 04             	or     $0x4,%eax
   1c1ae:	50                   	push   %eax
   1c1af:	0f b7 db             	movzwl %bx,%ebx
   1c1b2:	53                   	push   %ebx
   1c1b3:	68 80 63 02 00       	push   $0x26380
   1c1b8:	68 ce 9e 02 00       	push   $0x29ece
   1c1bd:	e8 27 73 fe ff       	call   34e9 <log_2>
   1c1c2:	83 c4 10             	add    $0x10,%esp
	return &inst[index];
   1c1c5:	be e8 43 40 00       	mov    $0x4043e8,%esi
}
   1c1ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1c1cd:	89 f0                	mov    %esi,%eax
   1c1cf:	5b                   	pop    %ebx
   1c1d0:	5e                   	pop    %esi
   1c1d1:	5d                   	pop    %ebp
   1c1d2:	c3                   	ret    

0001c1d3 <reset_error_list_cb>:
	return -EPERM;
}

static int reset_error_list_cb(u16_t obj_inst_id)
{
	error_code_count = 0U;
   1c1d3:	c6 05 5c 45 40 00 00 	movb   $0x0,0x40455c
	return 0;
}
   1c1da:	31 c0                	xor    %eax,%eax
   1c1dc:	c3                   	ret    

0001c1dd <current_time_pre_write_cb>:

	return &time_temp;
}

static void *current_time_pre_write_cb(u16_t obj_inst_id, size_t *data_len)
{
   1c1dd:	55                   	push   %ebp
   1c1de:	89 e5                	mov    %esp,%ebp
	*data_len = sizeof(time_temp);
   1c1e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c1e3:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
	return &time_temp;
}
   1c1e9:	b8 2c 44 40 00       	mov    $0x40442c,%eax
   1c1ee:	5d                   	pop    %ebp
   1c1ef:	c3                   	ret    

0001c1f0 <device_periodic_service>:

	return -ENOMEM;
}

static void device_periodic_service(struct k_work *work)
{
   1c1f0:	55                   	push   %ebp
   1c1f1:	89 e5                	mov    %esp,%ebp
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0, DEVICE_CURRENT_TIME_ID);
   1c1f3:	6a 0d                	push   $0xd
   1c1f5:	6a 00                	push   $0x0
   1c1f7:	6a 03                	push   $0x3
   1c1f9:	e8 42 b2 ff ff       	call   17440 <lwm2m_notify_observer>
   1c1fe:	83 c4 0c             	add    $0xc,%esp
}
   1c201:	c9                   	leave  
   1c202:	c3                   	ret    

0001c203 <device_create>:

static struct lwm2m_engine_obj_inst *device_create(u16_t obj_inst_id)
{
   1c203:	55                   	push   %ebp
	int i = 0;

	/* initialize instance resource data */
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_MANUFACTURER_ID);
   1c204:	c7 05 e0 31 40 00 00 	movl   $0x0,0x4031e0
   1c20b:	00 00 00 
{
   1c20e:	89 e5                	mov    %esp,%ebp
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_MANUFACTURER_ID);
   1c210:	c7 05 e4 31 40 00 00 	movl   $0x0,0x4031e4
   1c217:	00 00 00 
   1c21a:	c7 05 e8 31 40 00 00 	movl   $0x0,0x4031e8
   1c221:	00 00 00 
   1c224:	c7 05 ec 31 40 00 00 	movl   $0x0,0x4031ec
   1c22b:	00 00 00 
{
   1c22e:	8b 55 08             	mov    0x8(%ebp),%edx
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_MANUFACTURER_ID);
   1c231:	c7 05 f0 31 40 00 00 	movl   $0x0,0x4031f0
   1c238:	00 00 00 
   1c23b:	c7 05 f4 31 40 00 00 	movl   $0x0,0x4031f4
   1c242:	00 00 00 
   1c245:	c7 05 f8 31 40 00 00 	movl   $0x0,0x4031f8
   1c24c:	00 00 00 
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_MODEL_NUMBER_ID);
   1c24f:	c7 05 00 32 40 00 00 	movl   $0x0,0x403200
   1c256:	00 00 00 
   1c259:	c7 05 04 32 40 00 00 	movl   $0x0,0x403204
   1c260:	00 00 00 
   1c263:	c7 05 08 32 40 00 00 	movl   $0x0,0x403208
   1c26a:	00 00 00 
   1c26d:	c7 05 0c 32 40 00 00 	movl   $0x0,0x40320c
   1c274:	00 00 00 
   1c277:	c7 05 10 32 40 00 00 	movl   $0x0,0x403210
   1c27e:	00 00 00 
   1c281:	c7 05 14 32 40 00 00 	movl   $0x0,0x403214
   1c288:	00 00 00 
   1c28b:	c7 05 18 32 40 00 00 	movl   $0x10000,0x403218
   1c292:	00 01 00 
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_SERIAL_NUMBER_ID);
   1c295:	c7 05 20 32 40 00 00 	movl   $0x0,0x403220
   1c29c:	00 00 00 
   1c29f:	c7 05 24 32 40 00 00 	movl   $0x0,0x403224
   1c2a6:	00 00 00 
   1c2a9:	c7 05 28 32 40 00 00 	movl   $0x0,0x403228
   1c2b0:	00 00 00 
   1c2b3:	c7 05 2c 32 40 00 00 	movl   $0x0,0x40322c
   1c2ba:	00 00 00 
   1c2bd:	c7 05 30 32 40 00 00 	movl   $0x0,0x403230
   1c2c4:	00 00 00 
   1c2c7:	c7 05 34 32 40 00 00 	movl   $0x0,0x403234
   1c2ce:	00 00 00 
   1c2d1:	c7 05 38 32 40 00 00 	movl   $0x20000,0x403238
   1c2d8:	00 02 00 
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_FIRMWARE_VERSION_ID);
   1c2db:	c7 05 40 32 40 00 00 	movl   $0x0,0x403240
   1c2e2:	00 00 00 
   1c2e5:	c7 05 44 32 40 00 00 	movl   $0x0,0x403244
   1c2ec:	00 00 00 
   1c2ef:	c7 05 48 32 40 00 00 	movl   $0x0,0x403248
   1c2f6:	00 00 00 
   1c2f9:	c7 05 4c 32 40 00 00 	movl   $0x0,0x40324c
   1c300:	00 00 00 
   1c303:	c7 05 50 32 40 00 00 	movl   $0x0,0x403250
   1c30a:	00 00 00 
   1c30d:	c7 05 54 32 40 00 00 	movl   $0x0,0x403254
   1c314:	00 00 00 
   1c317:	c7 05 58 32 40 00 00 	movl   $0x30000,0x403258
   1c31e:	00 03 00 
	INIT_OBJ_RES_EXECUTE(res, i, DEVICE_REBOOT_ID, reboot_cb);
   1c321:	c7 05 70 32 40 00 00 	movl   $0x0,0x403270
   1c328:	00 00 00 
   1c32b:	c7 05 74 32 40 00 00 	movl   $0x0,0x403274
   1c332:	00 00 00 
   1c335:	c7 05 78 32 40 00 00 	movl   $0x40000,0x403278
   1c33c:	00 04 00 
   1c33f:	c7 05 60 32 40 00 00 	movl   $0x0,0x403260
   1c346:	00 00 00 
   1c349:	c7 05 64 32 40 00 00 	movl   $0x0,0x403264
   1c350:	00 00 00 
   1c353:	c7 05 68 32 40 00 00 	movl   $0x0,0x403268
   1c35a:	00 00 00 
   1c35d:	c7 05 6c 32 40 00 29 	movl   $0x1c929,0x40326c
   1c364:	c9 01 00 
	INIT_OBJ_RES_EXECUTE(res, i, DEVICE_FACTORY_DEFAULT_ID,
   1c367:	c7 05 90 32 40 00 00 	movl   $0x0,0x403290
   1c36e:	00 00 00 
   1c371:	c7 05 94 32 40 00 00 	movl   $0x0,0x403294
   1c378:	00 00 00 
   1c37b:	c7 05 98 32 40 00 00 	movl   $0x50000,0x403298
   1c382:	00 05 00 
   1c385:	c7 05 80 32 40 00 00 	movl   $0x0,0x403280
   1c38c:	00 00 00 
   1c38f:	c7 05 84 32 40 00 00 	movl   $0x0,0x403284
   1c396:	00 00 00 
   1c399:	c7 05 88 32 40 00 00 	movl   $0x0,0x403288
   1c3a0:	00 00 00 
   1c3a3:	c7 05 8c 32 40 00 ee 	movl   $0x1c8ee,0x40328c
   1c3aa:	c8 01 00 
			     factory_default_cb);
	INIT_OBJ_RES_MULTI_DATA(res, i, DEVICE_AVAILABLE_POWER_SOURCES_ID,
   1c3ad:	c7 05 b0 32 40 00 5d 	movl   $0x40455d,0x4032b0
   1c3b4:	45 40 00 
   1c3b7:	c7 05 b4 32 40 00 68 	movl   $0x404468,0x4032b4
   1c3be:	44 40 00 
   1c3c1:	c7 05 b8 32 40 00 01 	movl   $0x60001,0x4032b8
   1c3c8:	00 06 00 
   1c3cb:	c7 05 a0 32 40 00 00 	movl   $0x0,0x4032a0
   1c3d2:	00 00 00 
   1c3d5:	c7 05 a4 32 40 00 00 	movl   $0x0,0x4032a4
   1c3dc:	00 00 00 
   1c3df:	c7 05 a8 32 40 00 00 	movl   $0x0,0x4032a8
   1c3e6:	00 00 00 
   1c3e9:	c7 05 ac 32 40 00 00 	movl   $0x0,0x4032ac
   1c3f0:	00 00 00 
				&pwrsrc_count, pwrsrc_available,
				sizeof(*pwrsrc_available));
	INIT_OBJ_RES_MULTI_DATA(res, i, DEVICE_POWER_SOURCE_VOLTAGE_ID,
   1c3f3:	c7 05 d0 32 40 00 5d 	movl   $0x40455d,0x4032d0
   1c3fa:	45 40 00 
   1c3fd:	c7 05 d4 32 40 00 54 	movl   $0x404454,0x4032d4
   1c404:	44 40 00 
   1c407:	c7 05 d8 32 40 00 04 	movl   $0x70004,0x4032d8
   1c40e:	00 07 00 
   1c411:	c7 05 c0 32 40 00 00 	movl   $0x0,0x4032c0
   1c418:	00 00 00 
   1c41b:	c7 05 c4 32 40 00 00 	movl   $0x0,0x4032c4
   1c422:	00 00 00 
   1c425:	c7 05 c8 32 40 00 00 	movl   $0x0,0x4032c8
   1c42c:	00 00 00 
   1c42f:	c7 05 cc 32 40 00 00 	movl   $0x0,0x4032cc
   1c436:	00 00 00 
				&pwrsrc_count, pwrsrc_voltage_mv,
				sizeof(*pwrsrc_voltage_mv));
	INIT_OBJ_RES_MULTI_DATA(res, i, DEVICE_POWER_SOURCE_CURRENT_ID,
   1c439:	c7 05 f0 32 40 00 5d 	movl   $0x40455d,0x4032f0
   1c440:	45 40 00 
   1c443:	c7 05 f4 32 40 00 40 	movl   $0x404440,0x4032f4
   1c44a:	44 40 00 
   1c44d:	c7 05 f8 32 40 00 04 	movl   $0x80004,0x4032f8
   1c454:	00 08 00 
   1c457:	c7 05 e0 32 40 00 00 	movl   $0x0,0x4032e0
   1c45e:	00 00 00 
   1c461:	c7 05 e4 32 40 00 00 	movl   $0x0,0x4032e4
   1c468:	00 00 00 
   1c46b:	c7 05 e8 32 40 00 00 	movl   $0x0,0x4032e8
   1c472:	00 00 00 
   1c475:	c7 05 ec 32 40 00 00 	movl   $0x0,0x4032ec
   1c47c:	00 00 00 
				&pwrsrc_count, pwrsrc_current_ma,
				sizeof(*pwrsrc_current_ma));
	INIT_OBJ_RES_DATA(res, i, DEVICE_BATTERY_LEVEL_ID,
   1c47f:	c7 05 10 33 40 00 00 	movl   $0x0,0x403310
   1c486:	00 00 00 
   1c489:	c7 05 14 33 40 00 5f 	movl   $0x40455f,0x403314
   1c490:	45 40 00 
   1c493:	c7 05 18 33 40 00 01 	movl   $0x90001,0x403318
   1c49a:	00 09 00 
   1c49d:	c7 05 00 33 40 00 00 	movl   $0x0,0x403300
   1c4a4:	00 00 00 
   1c4a7:	c7 05 04 33 40 00 00 	movl   $0x0,0x403304
   1c4ae:	00 00 00 
   1c4b1:	c7 05 08 33 40 00 00 	movl   $0x0,0x403308
   1c4b8:	00 00 00 
   1c4bb:	c7 05 0c 33 40 00 00 	movl   $0x0,0x40330c
   1c4c2:	00 00 00 
			  &battery_level, sizeof(battery_level));
	INIT_OBJ_RES_DATA(res, i, DEVICE_MEMORY_FREE_ID,
   1c4c5:	c7 05 30 33 40 00 00 	movl   $0x0,0x403330
   1c4cc:	00 00 00 
   1c4cf:	c7 05 34 33 40 00 3c 	movl   $0x40443c,0x403334
   1c4d6:	44 40 00 
   1c4d9:	c7 05 38 33 40 00 04 	movl   $0xa0004,0x403338
   1c4e0:	00 0a 00 
   1c4e3:	c7 05 20 33 40 00 00 	movl   $0x0,0x403320
   1c4ea:	00 00 00 
   1c4ed:	c7 05 24 33 40 00 00 	movl   $0x0,0x403324
   1c4f4:	00 00 00 
   1c4f7:	c7 05 28 33 40 00 00 	movl   $0x0,0x403328
   1c4fe:	00 00 00 
   1c501:	c7 05 2c 33 40 00 00 	movl   $0x0,0x40332c
   1c508:	00 00 00 
			  &mem_free_kb, sizeof(mem_free_kb));
	INIT_OBJ_RES_MULTI_DATA(res, i, DEVICE_ERROR_CODE_ID,
   1c50b:	c7 05 50 33 40 00 5c 	movl   $0x40455c,0x403350
   1c512:	45 40 00 
   1c515:	c7 05 54 33 40 00 30 	movl   $0x404430,0x403354
   1c51c:	44 40 00 
   1c51f:	c7 05 58 33 40 00 01 	movl   $0xb0001,0x403358
   1c526:	00 0b 00 
   1c529:	c7 05 40 33 40 00 00 	movl   $0x0,0x403340
   1c530:	00 00 00 
   1c533:	c7 05 44 33 40 00 00 	movl   $0x0,0x403344
   1c53a:	00 00 00 
   1c53d:	c7 05 48 33 40 00 00 	movl   $0x0,0x403348
   1c544:	00 00 00 
   1c547:	c7 05 4c 33 40 00 00 	movl   $0x0,0x40334c
   1c54e:	00 00 00 
				&error_code_count, error_code_list,
				sizeof(*error_code_list));
	INIT_OBJ_RES_EXECUTE(res, i, DEVICE_RESET_ERROR_CODE_ID,
   1c551:	c7 05 70 33 40 00 00 	movl   $0x0,0x403370
   1c558:	00 00 00 
   1c55b:	c7 05 74 33 40 00 00 	movl   $0x0,0x403374
   1c562:	00 00 00 
   1c565:	c7 05 78 33 40 00 00 	movl   $0xc0000,0x403378
   1c56c:	00 0c 00 
   1c56f:	c7 05 60 33 40 00 00 	movl   $0x0,0x403360
   1c576:	00 00 00 
   1c579:	c7 05 64 33 40 00 00 	movl   $0x0,0x403364
   1c580:	00 00 00 
   1c583:	c7 05 68 33 40 00 00 	movl   $0x0,0x403368
   1c58a:	00 00 00 
   1c58d:	c7 05 6c 33 40 00 d3 	movl   $0x1c1d3,0x40336c
   1c594:	c1 01 00 
			     reset_error_list_cb);
	INIT_OBJ_RES(res, i, DEVICE_CURRENT_TIME_ID, 0, NULL, 0,
   1c597:	c7 05 80 33 40 00 ba 	movl   $0x1c8ba,0x403380
   1c59e:	c8 01 00 
   1c5a1:	c7 05 84 33 40 00 dd 	movl   $0x1c1dd,0x403384
   1c5a8:	c1 01 00 
   1c5ab:	c7 05 88 33 40 00 64 	movl   $0x1c964,0x403388
   1c5b2:	c9 01 00 
   1c5b5:	c7 05 8c 33 40 00 00 	movl   $0x0,0x40338c
   1c5bc:	00 00 00 
   1c5bf:	c7 05 90 33 40 00 00 	movl   $0x0,0x403390
   1c5c6:	00 00 00 
   1c5c9:	c7 05 94 33 40 00 00 	movl   $0x0,0x403394
   1c5d0:	00 00 00 
   1c5d3:	c7 05 98 33 40 00 00 	movl   $0xd0000,0x403398
   1c5da:	00 0d 00 
		     current_time_read_cb, current_time_pre_write_cb,
		     current_time_post_write_cb, NULL);
	INIT_OBJ_RES_DATA(res, i, DEVICE_SUPPORTED_BINDING_MODES_ID,
   1c5dd:	c7 05 b0 33 40 00 00 	movl   $0x0,0x4033b0
   1c5e4:	00 00 00 
   1c5e7:	c7 05 b4 33 40 00 20 	movl   $0x404420,0x4033b4
   1c5ee:	44 40 00 
   1c5f1:	c7 05 b8 33 40 00 08 	movl   $0x100008,0x4033b8
   1c5f8:	00 10 00 
   1c5fb:	c7 05 a0 33 40 00 00 	movl   $0x0,0x4033a0
   1c602:	00 00 00 
   1c605:	c7 05 a4 33 40 00 00 	movl   $0x0,0x4033a4
   1c60c:	00 00 00 
   1c60f:	c7 05 a8 33 40 00 00 	movl   $0x0,0x4033a8
   1c616:	00 00 00 
   1c619:	c7 05 ac 33 40 00 00 	movl   $0x0,0x4033ac
   1c620:	00 00 00 
			  binding_mode, DEVICE_STRING_SHORT);
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_TYPE_ID);
   1c623:	c7 05 c0 33 40 00 00 	movl   $0x0,0x4033c0
   1c62a:	00 00 00 
   1c62d:	c7 05 c4 33 40 00 00 	movl   $0x0,0x4033c4
   1c634:	00 00 00 
   1c637:	c7 05 c8 33 40 00 00 	movl   $0x0,0x4033c8
   1c63e:	00 00 00 
   1c641:	c7 05 cc 33 40 00 00 	movl   $0x0,0x4033cc
   1c648:	00 00 00 
   1c64b:	c7 05 d0 33 40 00 00 	movl   $0x0,0x4033d0
   1c652:	00 00 00 
   1c655:	c7 05 d4 33 40 00 00 	movl   $0x0,0x4033d4
   1c65c:	00 00 00 
   1c65f:	c7 05 d8 33 40 00 00 	movl   $0x110000,0x4033d8
   1c666:	00 11 00 
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_HARDWARE_VERSION_ID);
   1c669:	c7 05 e0 33 40 00 00 	movl   $0x0,0x4033e0
   1c670:	00 00 00 
   1c673:	c7 05 e4 33 40 00 00 	movl   $0x0,0x4033e4
   1c67a:	00 00 00 
   1c67d:	c7 05 e8 33 40 00 00 	movl   $0x0,0x4033e8
   1c684:	00 00 00 
   1c687:	c7 05 ec 33 40 00 00 	movl   $0x0,0x4033ec
   1c68e:	00 00 00 
   1c691:	c7 05 f0 33 40 00 00 	movl   $0x0,0x4033f0
   1c698:	00 00 00 
   1c69b:	c7 05 f4 33 40 00 00 	movl   $0x0,0x4033f4
   1c6a2:	00 00 00 
   1c6a5:	c7 05 f8 33 40 00 00 	movl   $0x120000,0x4033f8
   1c6ac:	00 12 00 
	INIT_OBJ_RES_DUMMY(res, i, DEVICE_SOFTWARE_VERSION_ID);
   1c6af:	c7 05 00 34 40 00 00 	movl   $0x0,0x403400
   1c6b6:	00 00 00 
   1c6b9:	c7 05 04 34 40 00 00 	movl   $0x0,0x403404
   1c6c0:	00 00 00 
   1c6c3:	c7 05 08 34 40 00 00 	movl   $0x0,0x403408
   1c6ca:	00 00 00 
   1c6cd:	c7 05 0c 34 40 00 00 	movl   $0x0,0x40340c
   1c6d4:	00 00 00 
   1c6d7:	c7 05 10 34 40 00 00 	movl   $0x0,0x403410
   1c6de:	00 00 00 
   1c6e1:	c7 05 14 34 40 00 00 	movl   $0x0,0x403414
   1c6e8:	00 00 00 
   1c6eb:	c7 05 18 34 40 00 00 	movl   $0x130000,0x403418
   1c6f2:	00 13 00 
	INIT_OBJ_RES_DATA(res, i, DEVICE_BATTERY_STATUS_ID,
   1c6f5:	66 c7 05 3a 34 40 00 	movw   $0x14,0x40343a
   1c6fc:	14 00 
   1c6fe:	c7 05 30 34 40 00 00 	movl   $0x0,0x403430
   1c705:	00 00 00 
   1c708:	c7 05 34 34 40 00 5e 	movl   $0x40455e,0x403434
   1c70f:	45 40 00 
   1c712:	66 c7 05 38 34 40 00 	movw   $0x1,0x403438
   1c719:	01 00 
   1c71b:	c7 05 20 34 40 00 00 	movl   $0x0,0x403420
   1c722:	00 00 00 
   1c725:	c7 05 24 34 40 00 00 	movl   $0x0,0x403424
   1c72c:	00 00 00 
   1c72f:	c7 05 28 34 40 00 00 	movl   $0x0,0x403428
   1c736:	00 00 00 
   1c739:	c7 05 2c 34 40 00 00 	movl   $0x0,0x40342c
   1c740:	00 00 00 
			  &battery_status, sizeof(battery_status));
	INIT_OBJ_RES_DATA(res, i, DEVICE_MEMORY_TOTAL_ID,
   1c743:	c7 05 50 34 40 00 00 	movl   $0x0,0x403450
   1c74a:	00 00 00 
   1c74d:	c7 05 54 34 40 00 1c 	movl   $0x40441c,0x403454
   1c754:	44 40 00 
   1c757:	c7 05 58 34 40 00 04 	movl   $0x150004,0x403458
   1c75e:	00 15 00 
   1c761:	c7 05 40 34 40 00 00 	movl   $0x0,0x403440
   1c768:	00 00 00 
   1c76b:	c7 05 44 34 40 00 00 	movl   $0x0,0x403444
   1c772:	00 00 00 
   1c775:	c7 05 48 34 40 00 00 	movl   $0x0,0x403448
   1c77c:	00 00 00 
   1c77f:	c7 05 4c 34 40 00 00 	movl   $0x0,0x40344c
   1c786:	00 00 00 
			  &mem_total_kb, sizeof(mem_total_kb));

	inst.resources = res;
   1c789:	c7 05 14 44 40 00 e0 	movl   $0x4031e0,0x404414
   1c790:	31 40 00 
	inst.resource_count = i;
   1c793:	66 c7 05 1a 44 40 00 	movw   $0x14,0x40441a
   1c79a:	14 00 
	LOG_DBG("Create LWM2M device instance: %d", obj_inst_id);
   1c79c:	f6 05 ac a8 40 00 04 	testb  $0x4,0x40a8ac
   1c7a3:	74 2a                	je     1c7cf <device_create+0x5cc>
   1c7a5:	b8 dc 51 02 00       	mov    $0x251dc,%eax
   1c7aa:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1c7af:	c1 e8 03             	shr    $0x3,%eax
   1c7b2:	c1 e0 06             	shl    $0x6,%eax
   1c7b5:	83 c8 04             	or     $0x4,%eax
   1c7b8:	50                   	push   %eax
   1c7b9:	0f b7 c2             	movzwl %dx,%eax
   1c7bc:	50                   	push   %eax
   1c7bd:	68 b0 63 02 00       	push   $0x263b0
   1c7c2:	68 0a 9f 02 00       	push   $0x29f0a
   1c7c7:	e8 1d 6d fe ff       	call   34e9 <log_2>
   1c7cc:	83 c4 10             	add    $0x10,%esp
	return &inst;
}
   1c7cf:	b8 0c 44 40 00       	mov    $0x40440c,%eax
   1c7d4:	c9                   	leave  
   1c7d5:	c3                   	ret    

0001c7d6 <lwm2m_device_init>:

static int lwm2m_device_init(struct device *dev)
{
   1c7d6:	55                   	push   %ebp
   1c7d7:	89 e5                	mov    %esp,%ebp
   1c7d9:	50                   	push   %eax
	mem_total_kb = 0;
	mem_free_kb = -1;
	pwrsrc_count = 0U;
	error_code_count = 0U;
	/* currently only support UDP binding mode (no SMS or Queue mode) */
	strcpy(binding_mode, "U");
   1c7da:	68 f3 9e 02 00       	push   $0x29ef3
	time_offset = 0U;
   1c7df:	c7 05 28 44 40 00 00 	movl   $0x0,0x404428
   1c7e6:	00 00 00 
	strcpy(binding_mode, "U");
   1c7e9:	68 20 44 40 00       	push   $0x404420
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1c7ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	mem_total_kb = 0;
   1c7f5:	c7 05 1c 44 40 00 00 	movl   $0x0,0x40441c
   1c7fc:	00 00 00 
	mem_free_kb = -1;
   1c7ff:	c7 05 3c 44 40 00 ff 	movl   $0xffffffff,0x40443c
   1c806:	ff ff ff 
	pwrsrc_count = 0U;
   1c809:	c6 05 5d 45 40 00 00 	movb   $0x0,0x40455d
	error_code_count = 0U;
   1c810:	c6 05 5c 45 40 00 00 	movb   $0x0,0x40455c
	strcpy(binding_mode, "U");
   1c817:	e8 af df fe ff       	call   a7cb <strcpy>
   1c81c:	58                   	pop    %eax
   1c81d:	5a                   	pop    %edx

	for (i = 0; i < DEVICE_PWRSRC_MAX; i++) {
		pwrsrc_available[i] = -1;
   1c81e:	c7 05 68 44 40 00 ff 	movl   $0xffffffff,0x404468
   1c825:	ff ff ff 
	device.obj_id = LWM2M_OBJECT_DEVICE_ID;
	device.fields = fields;
	device.field_count = ARRAY_SIZE(fields);
	device.max_instance_count = 1U;
	device.create_cb = device_create;
	lwm2m_register_obj(&device);
   1c828:	68 c0 34 40 00       	push   $0x4034c0
		pwrsrc_available[i] = -1;
   1c82d:	c6 05 6c 44 40 00 ff 	movb   $0xff,0x40446c
	device.fields = fields;
   1c834:	c7 05 c4 34 40 00 80 	movl   $0x40a480,0x4034c4
   1c83b:	a4 40 00 
	device.obj_id = LWM2M_OBJECT_DEVICE_ID;
   1c83e:	c7 05 d8 34 40 00 03 	movl   $0x170003,0x4034d8
   1c845:	00 17 00 
	device.max_instance_count = 1U;
   1c848:	66 c7 05 de 34 40 00 	movw   $0x1,0x4034de
   1c84f:	01 00 
	device.create_cb = device_create;
   1c851:	c7 05 c8 34 40 00 03 	movl   $0x1c203,0x4034c8
   1c858:	c2 01 00 
	lwm2m_register_obj(&device);
   1c85b:	e8 b6 ac ff ff       	call   17516 <lwm2m_register_obj>

	/* auto create the only instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_DEVICE_ID, 0, &obj_inst);
   1c860:	8d 45 fc             	lea    -0x4(%ebp),%eax
   1c863:	89 04 24             	mov    %eax,(%esp)
   1c866:	6a 00                	push   $0x0
   1c868:	6a 03                	push   $0x3
   1c86a:	e8 7e b4 ff ff       	call   17ced <lwm2m_create_obj_inst>
   1c86f:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1c872:	85 c0                	test   %eax,%eax
   1c874:	79 31                	jns    1c8a7 <lwm2m_device_init+0xd1>
		LOG_DBG("Create LWM2M instance 0 error: %d", ret);
   1c876:	f6 05 ac a8 40 00 04 	testb  $0x4,0x40a8ac
   1c87d:	74 28                	je     1c8a7 <lwm2m_device_init+0xd1>
   1c87f:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1c884:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1c88a:	c1 ea 03             	shr    $0x3,%edx
   1c88d:	c1 e2 06             	shl    $0x6,%edx
   1c890:	83 ca 04             	or     $0x4,%edx
   1c893:	52                   	push   %edx
   1c894:	50                   	push   %eax
   1c895:	68 c0 63 02 00       	push   $0x263c0
   1c89a:	68 2f 9f 02 00       	push   $0x29f2f
   1c89f:	e8 45 6c fe ff       	call   34e9 <log_2>
   1c8a4:	83 c4 10             	add    $0x10,%esp
	}

	/* call device_periodic_service() every 10 seconds */
	ret = lwm2m_engine_add_service(device_periodic_service,
   1c8a7:	68 10 27 00 00       	push   $0x2710
   1c8ac:	68 f0 c1 01 00       	push   $0x1c1f0
   1c8b1:	e8 70 ec ff ff       	call   1b526 <lwm2m_engine_add_service>
   1c8b6:	5a                   	pop    %edx
   1c8b7:	59                   	pop    %ecx
				       DEVICE_SERVICE_INTERVAL);
	return ret;
}
   1c8b8:	c9                   	leave  
   1c8b9:	c3                   	ret    

0001c8ba <current_time_read_cb>:
{
   1c8ba:	55                   	push   %ebp
   1c8bb:	89 e5                	mov    %esp,%ebp
   1c8bd:	e8 4f 80 00 00       	call   24911 <z_impl_k_uptime_get>
	time_temp = time_offset + (k_uptime_get() / 1000);
   1c8c2:	6a 00                	push   $0x0
   1c8c4:	68 e8 03 00 00       	push   $0x3e8
   1c8c9:	52                   	push   %edx
   1c8ca:	50                   	push   %eax
   1c8cb:	e8 00 48 fe ff       	call   10d0 <__divdi3>
   1c8d0:	03 05 28 44 40 00    	add    0x404428,%eax
   1c8d6:	83 c4 10             	add    $0x10,%esp
   1c8d9:	a3 2c 44 40 00       	mov    %eax,0x40442c
	*data_len = sizeof(time_temp);
   1c8de:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c8e1:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
}
   1c8e7:	b8 2c 44 40 00       	mov    $0x40442c,%eax
   1c8ec:	c9                   	leave  
   1c8ed:	c3                   	ret    

0001c8ee <factory_default_cb>:
	LOG_DBG("FACTORY_DEFAULT");
   1c8ee:	f6 05 ac a8 40 00 04 	testb  $0x4,0x40a8ac
   1c8f5:	74 2e                	je     1c925 <factory_default_cb+0x37>
   1c8f7:	b8 dc 51 02 00       	mov    $0x251dc,%eax
{
   1c8fc:	55                   	push   %ebp
   1c8fd:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1c902:	89 e5                	mov    %esp,%ebp
   1c904:	c1 e8 03             	shr    $0x3,%eax
	LOG_DBG("FACTORY_DEFAULT");
   1c907:	c1 e0 06             	shl    $0x6,%eax
   1c90a:	83 c8 04             	or     $0x4,%eax
   1c90d:	50                   	push   %eax
   1c90e:	68 9c 63 02 00       	push   $0x2639c
   1c913:	68 55 9f 02 00       	push   $0x29f55
   1c918:	e8 92 6b fe ff       	call   34af <log_1>
   1c91d:	83 c4 0c             	add    $0xc,%esp
}
   1c920:	83 c8 ff             	or     $0xffffffff,%eax
   1c923:	c9                   	leave  
   1c924:	c3                   	ret    
   1c925:	83 c8 ff             	or     $0xffffffff,%eax
   1c928:	c3                   	ret    

0001c929 <reboot_cb>:
	LOG_DBG("REBOOT");
   1c929:	f6 05 ac a8 40 00 04 	testb  $0x4,0x40a8ac
   1c930:	74 2e                	je     1c960 <reboot_cb+0x37>
   1c932:	b8 dc 51 02 00       	mov    $0x251dc,%eax
{
   1c937:	55                   	push   %ebp
   1c938:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1c93d:	89 e5                	mov    %esp,%ebp
   1c93f:	c1 e8 03             	shr    $0x3,%eax
	LOG_DBG("REBOOT");
   1c942:	c1 e0 06             	shl    $0x6,%eax
   1c945:	83 c8 04             	or     $0x4,%eax
   1c948:	50                   	push   %eax
   1c949:	68 90 63 02 00       	push   $0x26390
   1c94e:	68 69 9f 02 00       	push   $0x29f69
   1c953:	e8 57 6b fe ff       	call   34af <log_1>
   1c958:	83 c4 0c             	add    $0xc,%esp
}
   1c95b:	83 c8 ff             	or     $0xffffffff,%eax
   1c95e:	c9                   	leave  
   1c95f:	c3                   	ret    
   1c960:	83 c8 ff             	or     $0xffffffff,%eax
   1c963:	c3                   	ret    

0001c964 <current_time_post_write_cb>:
{
   1c964:	55                   	push   %ebp
   1c965:	89 e5                	mov    %esp,%ebp
   1c967:	53                   	push   %ebx
   1c968:	8b 4d 10             	mov    0x10(%ebp),%ecx
	if (data_len == 4) {
   1c96b:	66 83 f9 04          	cmp    $0x4,%cx
   1c96f:	75 27                	jne    1c998 <current_time_post_write_cb+0x34>
		time_offset = *(s32_t *)data - (s32_t)(k_uptime_get() / 1000);
   1c971:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c974:	8b 18                	mov    (%eax),%ebx
   1c976:	e8 96 7f 00 00       	call   24911 <z_impl_k_uptime_get>
   1c97b:	6a 00                	push   $0x0
   1c97d:	68 e8 03 00 00       	push   $0x3e8
   1c982:	52                   	push   %edx
   1c983:	50                   	push   %eax
   1c984:	e8 47 47 fe ff       	call   10d0 <__divdi3>
   1c989:	29 c3                	sub    %eax,%ebx
   1c98b:	83 c4 10             	add    $0x10,%esp
   1c98e:	89 1d 28 44 40 00    	mov    %ebx,0x404428
   1c994:	31 db                	xor    %ebx,%ebx
   1c996:	eb 34                	jmp    1c9cc <current_time_post_write_cb+0x68>
	return -EINVAL;
   1c998:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	LOG_ERR("unknown size %u", data_len);
   1c99d:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1c9a4:	74 26                	je     1c9cc <current_time_post_write_cb+0x68>
   1c9a6:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1c9ab:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1c9b1:	c1 ea 03             	shr    $0x3,%edx
   1c9b4:	c1 e2 06             	shl    $0x6,%edx
   1c9b7:	83 ca 01             	or     $0x1,%edx
   1c9ba:	52                   	push   %edx
   1c9bb:	0f b7 c9             	movzwl %cx,%ecx
   1c9be:	51                   	push   %ecx
   1c9bf:	68 74 9f 02 00       	push   $0x29f74
   1c9c4:	e8 e6 6a fe ff       	call   34af <log_1>
   1c9c9:	83 c4 0c             	add    $0xc,%esp
}
   1c9cc:	89 d8                	mov    %ebx,%eax
   1c9ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1c9d1:	c9                   	leave  
   1c9d2:	c3                   	ret    

0001c9d3 <lwm2m_device_add_pwrsrc>:
{
   1c9d3:	55                   	push   %ebp
   1c9d4:	89 e5                	mov    %esp,%ebp
   1c9d6:	53                   	push   %ebx
   1c9d7:	31 db                	xor    %ebx,%ebx
   1c9d9:	8b 55 08             	mov    0x8(%ebp),%edx
	if (pwrsrc_type >= LWM2M_DEVICE_PWR_SRC_TYPE_MAX) {
   1c9dc:	80 fa 07             	cmp    $0x7,%dl
   1c9df:	76 32                	jbe    1ca13 <lwm2m_device_add_pwrsrc+0x40>
		return -EINVAL;
   1c9e1:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("power source id %d is invalid", pwrsrc_type);
   1c9e6:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1c9ed:	74 6a                	je     1ca59 <lwm2m_device_add_pwrsrc+0x86>
   1c9ef:	b8 dc 51 02 00       	mov    $0x251dc,%eax
   1c9f4:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1c9f9:	c1 e8 03             	shr    $0x3,%eax
   1c9fc:	c1 e0 06             	shl    $0x6,%eax
   1c9ff:	83 c8 01             	or     $0x1,%eax
   1ca02:	50                   	push   %eax
   1ca03:	0f b6 d2             	movzbl %dl,%edx
   1ca06:	52                   	push   %edx
   1ca07:	68 84 9f 02 00       	push   $0x29f84
   1ca0c:	e8 9e 6a fe ff       	call   34af <log_1>
   1ca11:	eb 43                	jmp    1ca56 <lwm2m_device_add_pwrsrc+0x83>
		if (pwrsrc_available[index] < 0) {
   1ca13:	80 bb 68 44 40 00 00 	cmpb   $0x0,0x404468(%ebx)
   1ca1a:	78 0d                	js     1ca29 <lwm2m_device_add_pwrsrc+0x56>
	for (index = 0; index < DEVICE_PWRSRC_MAX; index++) {
   1ca1c:	43                   	inc    %ebx
   1ca1d:	83 fb 05             	cmp    $0x5,%ebx
   1ca20:	75 f1                	jne    1ca13 <lwm2m_device_add_pwrsrc+0x40>
		return -ENOMEM;
   1ca22:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
   1ca27:	eb 30                	jmp    1ca59 <lwm2m_device_add_pwrsrc+0x86>
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1ca29:	6a 06                	push   $0x6
	pwrsrc_available[index] = pwrsrc_type;
   1ca2b:	88 93 68 44 40 00    	mov    %dl,0x404468(%ebx)
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1ca31:	6a 00                	push   $0x0
	pwrsrc_voltage_mv[index] = 0;
   1ca33:	c7 04 9d 54 44 40 00 	movl   $0x0,0x404454(,%ebx,4)
   1ca3a:	00 00 00 00 
	pwrsrc_current_ma[index] = 0;
   1ca3e:	c7 04 9d 40 44 40 00 	movl   $0x0,0x404440(,%ebx,4)
   1ca45:	00 00 00 00 
	pwrsrc_count++;
   1ca49:	fe 05 5d 45 40 00    	incb   0x40455d
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1ca4f:	6a 03                	push   $0x3
   1ca51:	e8 ea a9 ff ff       	call   17440 <lwm2m_notify_observer>
   1ca56:	83 c4 0c             	add    $0xc,%esp
}
   1ca59:	89 d8                	mov    %ebx,%eax
   1ca5b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1ca5e:	c9                   	leave  
   1ca5f:	c3                   	ret    

0001ca60 <lwm2m_device_set_pwrsrc_voltage_mv>:
{
   1ca60:	55                   	push   %ebp
   1ca61:	89 e5                	mov    %esp,%ebp
   1ca63:	53                   	push   %ebx
   1ca64:	8b 45 08             	mov    0x8(%ebp),%eax
	if (index < 0 || index >= DEVICE_PWRSRC_MAX) {
   1ca67:	83 f8 04             	cmp    $0x4,%eax
   1ca6a:	76 2b                	jbe    1ca97 <lwm2m_device_set_pwrsrc_voltage_mv+0x37>
		return -EINVAL;
   1ca6c:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("index is out of range: %d", index);
   1ca71:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1ca78:	74 73                	je     1caed <lwm2m_device_set_pwrsrc_voltage_mv+0x8d>
   1ca7a:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1ca7f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1ca85:	c1 ea 03             	shr    $0x3,%edx
   1ca88:	c1 e2 06             	shl    $0x6,%edx
   1ca8b:	83 ca 01             	or     $0x1,%edx
   1ca8e:	52                   	push   %edx
   1ca8f:	50                   	push   %eax
   1ca90:	68 a2 9f 02 00       	push   $0x29fa2
   1ca95:	eb 32                	jmp    1cac9 <lwm2m_device_set_pwrsrc_voltage_mv+0x69>
	if (pwrsrc_available[index] < 0) {
   1ca97:	80 b8 68 44 40 00 00 	cmpb   $0x0,0x404468(%eax)
   1ca9e:	79 33                	jns    1cad3 <lwm2m_device_set_pwrsrc_voltage_mv+0x73>
		return -EINVAL;
   1caa0:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("Power source index %d isn't registered.", index);
   1caa5:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1caac:	74 3f                	je     1caed <lwm2m_device_set_pwrsrc_voltage_mv+0x8d>
   1caae:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1cab3:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1cab9:	c1 ea 03             	shr    $0x3,%edx
   1cabc:	c1 e2 06             	shl    $0x6,%edx
   1cabf:	83 ca 01             	or     $0x1,%edx
   1cac2:	52                   	push   %edx
   1cac3:	50                   	push   %eax
   1cac4:	68 e3 9f 02 00       	push   $0x29fe3
   1cac9:	e8 e1 69 fe ff       	call   34af <log_1>
   1cace:	83 c4 0c             	add    $0xc,%esp
   1cad1:	eb 1a                	jmp    1caed <lwm2m_device_set_pwrsrc_voltage_mv+0x8d>
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cad3:	6a 07                	push   $0x7
	pwrsrc_voltage_mv[index] = voltage_mv;
   1cad5:	8b 55 0c             	mov    0xc(%ebp),%edx
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cad8:	6a 00                	push   $0x0
	pwrsrc_voltage_mv[index] = voltage_mv;
   1cada:	89 14 85 54 44 40 00 	mov    %edx,0x404454(,%eax,4)
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cae1:	6a 03                	push   $0x3
	return 0;
   1cae3:	31 db                	xor    %ebx,%ebx
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cae5:	e8 56 a9 ff ff       	call   17440 <lwm2m_notify_observer>
   1caea:	83 c4 0c             	add    $0xc,%esp
}
   1caed:	89 d8                	mov    %ebx,%eax
   1caef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1caf2:	c9                   	leave  
   1caf3:	c3                   	ret    

0001caf4 <lwm2m_device_set_pwrsrc_current_ma>:
{
   1caf4:	55                   	push   %ebp
   1caf5:	89 e5                	mov    %esp,%ebp
   1caf7:	53                   	push   %ebx
   1caf8:	8b 45 08             	mov    0x8(%ebp),%eax
	if (index < 0 || index >= DEVICE_PWRSRC_MAX) {
   1cafb:	83 f8 04             	cmp    $0x4,%eax
   1cafe:	76 2b                	jbe    1cb2b <lwm2m_device_set_pwrsrc_current_ma+0x37>
		return -EINVAL;
   1cb00:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("index is out of range: %d", index);
   1cb05:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1cb0c:	74 73                	je     1cb81 <lwm2m_device_set_pwrsrc_current_ma+0x8d>
   1cb0e:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1cb13:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1cb19:	c1 ea 03             	shr    $0x3,%edx
   1cb1c:	c1 e2 06             	shl    $0x6,%edx
   1cb1f:	83 ca 01             	or     $0x1,%edx
   1cb22:	52                   	push   %edx
   1cb23:	50                   	push   %eax
   1cb24:	68 a2 9f 02 00       	push   $0x29fa2
   1cb29:	eb 32                	jmp    1cb5d <lwm2m_device_set_pwrsrc_current_ma+0x69>
	if (pwrsrc_available[index] < 0) {
   1cb2b:	80 b8 68 44 40 00 00 	cmpb   $0x0,0x404468(%eax)
   1cb32:	79 33                	jns    1cb67 <lwm2m_device_set_pwrsrc_current_ma+0x73>
		return -EINVAL;
   1cb34:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("Power source index %d isn't registered.", index);
   1cb39:	f6 05 ac a8 40 00 07 	testb  $0x7,0x40a8ac
   1cb40:	74 3f                	je     1cb81 <lwm2m_device_set_pwrsrc_current_ma+0x8d>
   1cb42:	ba dc 51 02 00       	mov    $0x251dc,%edx
   1cb47:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1cb4d:	c1 ea 03             	shr    $0x3,%edx
   1cb50:	c1 e2 06             	shl    $0x6,%edx
   1cb53:	83 ca 01             	or     $0x1,%edx
   1cb56:	52                   	push   %edx
   1cb57:	50                   	push   %eax
   1cb58:	68 e3 9f 02 00       	push   $0x29fe3
   1cb5d:	e8 4d 69 fe ff       	call   34af <log_1>
   1cb62:	83 c4 0c             	add    $0xc,%esp
   1cb65:	eb 1a                	jmp    1cb81 <lwm2m_device_set_pwrsrc_current_ma+0x8d>
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cb67:	6a 08                	push   $0x8
	pwrsrc_current_ma[index] = current_ma;
   1cb69:	8b 55 0c             	mov    0xc(%ebp),%edx
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cb6c:	6a 00                	push   $0x0
	pwrsrc_current_ma[index] = current_ma;
   1cb6e:	89 14 85 40 44 40 00 	mov    %edx,0x404440(,%eax,4)
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cb75:	6a 03                	push   $0x3
	return 0;
   1cb77:	31 db                	xor    %ebx,%ebx
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0,
   1cb79:	e8 c2 a8 ff ff       	call   17440 <lwm2m_notify_observer>
   1cb7e:	83 c4 0c             	add    $0xc,%esp
}
   1cb81:	89 d8                	mov    %ebx,%eax
   1cb83:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1cb86:	c9                   	leave  
   1cb87:	c3                   	ret    

0001cb88 <lwm2m_device_add_err>:
{
   1cb88:	55                   	push   %ebp
	if (error_code_count < DEVICE_ERROR_CODE_MAX) {
   1cb89:	8a 15 5c 45 40 00    	mov    0x40455c,%dl
{
   1cb8f:	89 e5                	mov    %esp,%ebp
   1cb91:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (error_code_count < DEVICE_ERROR_CODE_MAX) {
   1cb96:	80 fa 09             	cmp    $0x9,%dl
{
   1cb99:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (error_code_count < DEVICE_ERROR_CODE_MAX) {
   1cb9c:	77 12                	ja     1cbb0 <lwm2m_device_add_err+0x28>
		error_code_list[error_code_count] = error_code;
   1cb9e:	0f b6 c2             	movzbl %dl,%eax
		error_code_count++;
   1cba1:	42                   	inc    %edx
		error_code_list[error_code_count] = error_code;
   1cba2:	88 88 30 44 40 00    	mov    %cl,0x404430(%eax)
		error_code_count++;
   1cba8:	88 15 5c 45 40 00    	mov    %dl,0x40455c
		return 0;
   1cbae:	31 c0                	xor    %eax,%eax
}
   1cbb0:	5d                   	pop    %ebp
   1cbb1:	c3                   	ret    

0001cbb2 <buf_read>:
{
   1cbb2:	55                   	push   %ebp
   1cbb3:	89 e5                	mov    %esp,%ebp
   1cbb5:	57                   	push   %edi
   1cbb6:	56                   	push   %esi
   1cbb7:	53                   	push   %ebx
   1cbb8:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
   1cbbb:	85 c9                	test   %ecx,%ecx
{
   1cbbd:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!src) {
   1cbc0:	74 3e                	je     1cc00 <buf_read+0x4e>
   1cbc2:	89 c3                	mov    %eax,%ebx
	if (*offset + len > src_len) {
   1cbc4:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cbc7:	0f b7 fa             	movzwl %dx,%edi
   1cbca:	0f b7 00             	movzwl (%eax),%eax
   1cbcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1cbd0:	01 f8                	add    %edi,%eax
   1cbd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
   1cbd5:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (*offset + len > src_len) {
   1cbda:	0f b7 f6             	movzwl %si,%esi
   1cbdd:	39 75 ec             	cmp    %esi,-0x14(%ebp)
   1cbe0:	7f 23                	jg     1cc05 <buf_read+0x53>
   1cbe2:	89 d6                	mov    %edx,%esi
	if (dst) {
   1cbe4:	85 db                	test   %ebx,%ebx
   1cbe6:	74 0e                	je     1cbf6 <buf_read+0x44>
		memcpy(dst, src + *offset, len);
   1cbe8:	03 4d f0             	add    -0x10(%ebp),%ecx
   1cbeb:	57                   	push   %edi
   1cbec:	51                   	push   %ecx
   1cbed:	53                   	push   %ebx
   1cbee:	e8 3e dd fe ff       	call   a931 <memcpy>
   1cbf3:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
   1cbf6:	8b 45 0c             	mov    0xc(%ebp),%eax
   1cbf9:	66 01 30             	add    %si,(%eax)
	return 0;
   1cbfc:	31 c0                	xor    %eax,%eax
   1cbfe:	eb 05                	jmp    1cc05 <buf_read+0x53>
		return -EINVAL;
   1cc00:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   1cc05:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1cc08:	5b                   	pop    %ebx
   1cc09:	5e                   	pop    %esi
   1cc0a:	5f                   	pop    %edi
   1cc0b:	5d                   	pop    %ebp
   1cc0c:	c3                   	ret    

0001cc0d <get_bool>:
				      true, true);
}

static size_t get_bool(struct lwm2m_input_context *in,
		       bool *value)
{
   1cc0d:	55                   	push   %ebp
   1cc0e:	89 e5                	mov    %esp,%ebp
   1cc10:	50                   	push   %eax
   1cc11:	8b 45 08             	mov    0x8(%ebp),%eax
	u8_t tmp;

	if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
   1cc14:	83 c0 08             	add    $0x8,%eax
   1cc17:	8b 50 fc             	mov    -0x4(%eax),%edx
}

static inline int buf_read_u8(u8_t *value, u8_t *src, u16_t src_len,
			      u16_t *offset)
{
	return buf_read(value, sizeof(u8_t), src, src_len, offset);
   1cc1a:	50                   	push   %eax
   1cc1b:	0f b7 42 06          	movzwl 0x6(%edx),%eax
   1cc1f:	8b 0a                	mov    (%edx),%ecx
   1cc21:	50                   	push   %eax
   1cc22:	ba 01 00 00 00       	mov    $0x1,%edx
   1cc27:	8d 45 ff             	lea    -0x1(%ebp),%eax
   1cc2a:	e8 83 ff ff ff       	call   1cbb2 <buf_read>
   1cc2f:	5a                   	pop    %edx
   1cc30:	59                   	pop    %ecx
		return 0;
   1cc31:	31 d2                	xor    %edx,%edx
	if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
   1cc33:	85 c0                	test   %eax,%eax
   1cc35:	78 18                	js     1cc4f <get_bool+0x42>
	}

	if (tmp == '1' || tmp == '0') {
   1cc37:	8a 45 ff             	mov    -0x1(%ebp),%al
   1cc3a:	8d 48 d0             	lea    -0x30(%eax),%ecx
   1cc3d:	80 f9 01             	cmp    $0x1,%cl
   1cc40:	77 0d                	ja     1cc4f <get_bool+0x42>
		*value = (tmp == '1') ? true : false;
   1cc42:	3c 31                	cmp    $0x31,%al
   1cc44:	8b 45 0c             	mov    0xc(%ebp),%eax
		return 1;
   1cc47:	ba 01 00 00 00       	mov    $0x1,%edx
		*value = (tmp == '1') ? true : false;
   1cc4c:	0f 94 00             	sete   (%eax)
	}

	return 0;
}
   1cc4f:	89 d0                	mov    %edx,%eax
   1cc51:	c9                   	leave  
   1cc52:	c3                   	ret    

0001cc53 <get_string>:
{
   1cc53:	55                   	push   %ebp
   1cc54:	89 e5                	mov    %esp,%ebp
   1cc56:	57                   	push   %edi
   1cc57:	56                   	push   %esi
   1cc58:	8b 55 08             	mov    0x8(%ebp),%edx
   1cc5b:	53                   	push   %ebx
   1cc5c:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1cc5f:	8b 75 0c             	mov    0xc(%ebp),%esi
	return in->in_cpkt->offset - in->offset;
   1cc62:	8b 4a 04             	mov    0x4(%edx),%ecx
	u16_t in_len = get_length_left(in);
   1cc65:	8b 41 04             	mov    0x4(%ecx),%eax
   1cc68:	2b 42 08             	sub    0x8(%edx),%eax
	if (in_len > buflen) {
   1cc6b:	0f b7 f8             	movzwl %ax,%edi
   1cc6e:	39 df                	cmp    %ebx,%edi
   1cc70:	76 03                	jbe    1cc75 <get_string+0x22>
		in_len = buflen - 1;
   1cc72:	8d 43 ff             	lea    -0x1(%ebx),%eax
	if (buf_read(value, in_len, CPKT_BUF_READ(in->in_cpkt),
   1cc75:	83 c2 08             	add    $0x8,%edx
   1cc78:	0f b7 d8             	movzwl %ax,%ebx
   1cc7b:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
   1cc7f:	52                   	push   %edx
   1cc80:	8b 09                	mov    (%ecx),%ecx
   1cc82:	50                   	push   %eax
   1cc83:	89 da                	mov    %ebx,%edx
   1cc85:	89 f0                	mov    %esi,%eax
   1cc87:	e8 26 ff ff ff       	call   1cbb2 <buf_read>
   1cc8c:	5a                   	pop    %edx
   1cc8d:	59                   	pop    %ecx
   1cc8e:	85 c0                	test   %eax,%eax
   1cc90:	79 07                	jns    1cc99 <get_string+0x46>
		value[0] = '\0';
   1cc92:	c6 06 00             	movb   $0x0,(%esi)
		return 0;
   1cc95:	31 c0                	xor    %eax,%eax
   1cc97:	eb 06                	jmp    1cc9f <get_string+0x4c>
	value[in_len] = '\0';
   1cc99:	89 d8                	mov    %ebx,%eax
   1cc9b:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)
}
   1cc9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1cca2:	5b                   	pop    %ebx
   1cca3:	5e                   	pop    %esi
   1cca4:	5f                   	pop    %edi
   1cca5:	5d                   	pop    %ebp
   1cca6:	c3                   	ret    

0001cca7 <get_opaque>:

static size_t get_opaque(struct lwm2m_input_context *in,
			 u8_t *value, size_t buflen, bool *last_block)
{
   1cca7:	55                   	push   %ebp
   1cca8:	89 e5                	mov    %esp,%ebp
   1ccaa:	8b 45 08             	mov    0x8(%ebp),%eax
	return in->in_cpkt->offset - in->offset;
   1ccad:	8b 50 04             	mov    0x4(%eax),%edx
	in->opaque_len = get_length_left(in);
   1ccb0:	8b 52 04             	mov    0x4(%edx),%edx
   1ccb3:	2b 50 08             	sub    0x8(%eax),%edx
   1ccb6:	66 89 50 0a          	mov    %dx,0xa(%eax)
	return lwm2m_engine_get_opaque_more(in, value, buflen, last_block);
}
   1ccba:	5d                   	pop    %ebp
	return lwm2m_engine_get_opaque_more(in, value, buflen, last_block);
   1ccbb:	e9 2d de ff ff       	jmp    1aaed <lwm2m_engine_get_opaque_more>

0001ccc0 <plain_text_read_number.constprop.1>:
static size_t plain_text_read_number(struct lwm2m_input_context *in,
   1ccc0:	55                   	push   %ebp
   1ccc1:	89 e5                	mov    %esp,%ebp
   1ccc3:	57                   	push   %edi
   1ccc4:	56                   	push   %esi
   1ccc5:	53                   	push   %ebx
   1ccc6:	89 c3                	mov    %eax,%ebx
   1ccc8:	83 ec 1c             	sub    $0x1c,%esp
   1cccb:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1ccce:	8a 45 08             	mov    0x8(%ebp),%al
   1ccd1:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   1ccd4:	88 45 e5             	mov    %al,-0x1b(%ebp)
	*value1 = 0;
   1ccd7:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   1ccdd:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	if (value2) {
   1cce4:	85 c9                	test   %ecx,%ecx
   1cce6:	74 0d                	je     1ccf5 <plain_text_read_number.constprop.1+0x35>
		*value2 = 0;
   1cce8:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   1ccee:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
		} else if (tmp == '.' && i > 0 && accept_dot && !dot_found &&
   1ccf5:	8b 75 e8             	mov    -0x18(%ebp),%esi
   1ccf8:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
   1ccfc:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
   1cd00:	31 ff                	xor    %edi,%edi
	while (in->offset < in->in_cpkt->offset) {
   1cd02:	8b 43 04             	mov    0x4(%ebx),%eax
   1cd05:	8b 48 04             	mov    0x4(%eax),%ecx
   1cd08:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
   1cd0c:	0f 83 9b 00 00 00    	jae    1cdad <plain_text_read_number.constprop.1+0xed>
		if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt),
   1cd12:	8d 53 08             	lea    0x8(%ebx),%edx
   1cd15:	8b 08                	mov    (%eax),%ecx
   1cd17:	52                   	push   %edx
   1cd18:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1cd1c:	8d 45 f3             	lea    -0xd(%ebp),%eax
   1cd1f:	52                   	push   %edx
   1cd20:	ba 01 00 00 00       	mov    $0x1,%edx
   1cd25:	e8 88 fe ff ff       	call   1cbb2 <buf_read>
   1cd2a:	5a                   	pop    %edx
   1cd2b:	59                   	pop    %ecx
   1cd2c:	85 c0                	test   %eax,%eax
   1cd2e:	78 7d                	js     1cdad <plain_text_read_number.constprop.1+0xed>
		if (tmp == '-' && accept_sign && i == 0) {
   1cd30:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1cd34:	3c 2d                	cmp    $0x2d,%al
   1cd36:	75 06                	jne    1cd3e <plain_text_read_number.constprop.1+0x7e>
   1cd38:	85 ff                	test   %edi,%edi
   1cd3a:	74 5f                	je     1cd9b <plain_text_read_number.constprop.1+0xdb>
   1cd3c:	eb 1f                	jmp    1cd5d <plain_text_read_number.constprop.1+0x9d>
		} else if (tmp == '.' && i > 0 && accept_dot && !dot_found &&
   1cd3e:	3c 2e                	cmp    $0x2e,%al
   1cd40:	75 1b                	jne    1cd5d <plain_text_read_number.constprop.1+0x9d>
   1cd42:	85 ff                	test   %edi,%edi
   1cd44:	7e 17                	jle    1cd5d <plain_text_read_number.constprop.1+0x9d>
   1cd46:	80 7d e5 00          	cmpb   $0x0,-0x1b(%ebp)
   1cd4a:	74 11                	je     1cd5d <plain_text_read_number.constprop.1+0x9d>
   1cd4c:	8a 55 e7             	mov    -0x19(%ebp),%dl
   1cd4f:	83 f2 01             	xor    $0x1,%edx
   1cd52:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1cd56:	0f 95 c1             	setne  %cl
   1cd59:	20 ca                	and    %cl,%dl
   1cd5b:	75 44                	jne    1cda1 <plain_text_read_number.constprop.1+0xe1>
   1cd5d:	8d 48 d0             	lea    -0x30(%eax),%ecx
		} else if (isdigit(tmp)) {
   1cd60:	83 f9 09             	cmp    $0x9,%ecx
   1cd63:	77 30                	ja     1cd95 <plain_text_read_number.constprop.1+0xd5>
			*counter = *counter * 10 + (tmp - '0');
   1cd65:	6b 46 04 0a          	imul   $0xa,0x4(%esi),%eax
   1cd69:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1cd6c:	b8 0a 00 00 00       	mov    $0xa,%eax
   1cd71:	f7 26                	mull   (%esi)
   1cd73:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1cd76:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1cd79:	89 ca                	mov    %ecx,%edx
   1cd7b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1cd7e:	c1 f9 1f             	sar    $0x1f,%ecx
   1cd81:	01 45 e0             	add    %eax,-0x20(%ebp)
   1cd84:	89 d0                	mov    %edx,%eax
   1cd86:	89 ca                	mov    %ecx,%edx
   1cd88:	03 45 dc             	add    -0x24(%ebp),%eax
   1cd8b:	13 55 e0             	adc    -0x20(%ebp),%edx
   1cd8e:	89 06                	mov    %eax,(%esi)
   1cd90:	89 56 04             	mov    %edx,0x4(%esi)
   1cd93:	eb 12                	jmp    1cda7 <plain_text_read_number.constprop.1+0xe7>
			in->offset--;
   1cd95:	66 ff 4b 08          	decw   0x8(%ebx)
			break;
   1cd99:	eb 12                	jmp    1cdad <plain_text_read_number.constprop.1+0xed>
			neg = true;
   1cd9b:	c6 45 e6 01          	movb   $0x1,-0x1a(%ebp)
   1cd9f:	eb 06                	jmp    1cda7 <plain_text_read_number.constprop.1+0xe7>
			dot_found = true;
   1cda1:	88 55 e7             	mov    %dl,-0x19(%ebp)
		} else if (tmp == '.' && i > 0 && accept_dot && !dot_found &&
   1cda4:	8b 75 ec             	mov    -0x14(%ebp),%esi
		i++;
   1cda7:	47                   	inc    %edi
   1cda8:	e9 55 ff ff ff       	jmp    1cd02 <plain_text_read_number.constprop.1+0x42>
	if (neg) {
   1cdad:	80 7d e6 00          	cmpb   $0x0,-0x1a(%ebp)
   1cdb1:	74 0c                	je     1cdbf <plain_text_read_number.constprop.1+0xff>
		*value1 = -*value1;
   1cdb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1cdb6:	f7 18                	negl   (%eax)
   1cdb8:	83 50 04 00          	adcl   $0x0,0x4(%eax)
   1cdbc:	f7 58 04             	negl   0x4(%eax)
}
   1cdbf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1cdc2:	89 f8                	mov    %edi,%eax
   1cdc4:	5b                   	pop    %ebx
   1cdc5:	5e                   	pop    %esi
   1cdc6:	5f                   	pop    %edi
   1cdc7:	5d                   	pop    %ebp
   1cdc8:	c3                   	ret    

0001cdc9 <get_s32>:
{
   1cdc9:	55                   	push   %ebp
	len = plain_text_read_number(in, &tmp, NULL, true, false);
   1cdca:	31 c9                	xor    %ecx,%ecx
{
   1cdcc:	89 e5                	mov    %esp,%ebp
   1cdce:	83 ec 08             	sub    $0x8,%esp
	len = plain_text_read_number(in, &tmp, NULL, true, false);
   1cdd1:	8d 55 f8             	lea    -0x8(%ebp),%edx
   1cdd4:	8b 45 08             	mov    0x8(%ebp),%eax
   1cdd7:	6a 00                	push   $0x0
	s64_t tmp = 0;
   1cdd9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1cde0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	len = plain_text_read_number(in, &tmp, NULL, true, false);
   1cde7:	e8 d4 fe ff ff       	call   1ccc0 <plain_text_read_number.constprop.1>
   1cdec:	5a                   	pop    %edx
	if (len > 0) {
   1cded:	85 c0                	test   %eax,%eax
   1cdef:	74 08                	je     1cdf9 <get_s32+0x30>
		*value = (s32_t)tmp;
   1cdf1:	8b 55 0c             	mov    0xc(%ebp),%edx
   1cdf4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   1cdf7:	89 0a                	mov    %ecx,(%edx)
}
   1cdf9:	c9                   	leave  
   1cdfa:	c3                   	ret    

0001cdfb <get_s64>:
{
   1cdfb:	55                   	push   %ebp
	return plain_text_read_number(in, value, NULL, true, false);
   1cdfc:	31 c9                	xor    %ecx,%ecx
{
   1cdfe:	89 e5                	mov    %esp,%ebp
   1ce00:	8b 45 08             	mov    0x8(%ebp),%eax
	return plain_text_read_number(in, value, NULL, true, false);
   1ce03:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ce06:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
   1ce0d:	5d                   	pop    %ebp
	return plain_text_read_number(in, value, NULL, true, false);
   1ce0e:	e9 ad fe ff ff       	jmp    1ccc0 <plain_text_read_number.constprop.1>

0001ce13 <get_float32fix>:
{
   1ce13:	55                   	push   %ebp
   1ce14:	89 e5                	mov    %esp,%ebp
   1ce16:	53                   	push   %ebx
   1ce17:	83 ec 10             	sub    $0x10,%esp
	len = plain_text_read_number(in, &tmp1, &tmp2, true, true);
   1ce1a:	8d 55 ec             	lea    -0x14(%ebp),%edx
   1ce1d:	8d 4d f4             	lea    -0xc(%ebp),%ecx
   1ce20:	8b 45 08             	mov    0x8(%ebp),%eax
   1ce23:	6a 01                	push   $0x1
{
   1ce25:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = plain_text_read_number(in, &tmp1, &tmp2, true, true);
   1ce28:	e8 93 fe ff ff       	call   1ccc0 <plain_text_read_number.constprop.1>
   1ce2d:	5a                   	pop    %edx
	if (len > 0) {
   1ce2e:	85 c0                	test   %eax,%eax
   1ce30:	74 0b                	je     1ce3d <get_float32fix+0x2a>
		value->val1 = (s32_t)tmp1;
   1ce32:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1ce35:	89 13                	mov    %edx,(%ebx)
		value->val2 = (s32_t)tmp2;
   1ce37:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1ce3a:	89 53 04             	mov    %edx,0x4(%ebx)
}
   1ce3d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1ce40:	c9                   	leave  
   1ce41:	c3                   	ret    

0001ce42 <get_float64fix>:
{
   1ce42:	55                   	push   %ebp
   1ce43:	89 e5                	mov    %esp,%ebp
   1ce45:	8b 55 0c             	mov    0xc(%ebp),%edx
   1ce48:	8b 45 08             	mov    0x8(%ebp),%eax
	return plain_text_read_number(in, &value->val1, &value->val2,
   1ce4b:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
   1ce52:	5d                   	pop    %ebp
	return plain_text_read_number(in, &value->val1, &value->val2,
   1ce53:	8d 4a 08             	lea    0x8(%edx),%ecx
   1ce56:	e9 65 fe ff ff       	jmp    1ccc0 <plain_text_read_number.constprop.1>

0001ce5b <put_string>:
{
   1ce5b:	55                   	push   %ebp
   1ce5c:	89 e5                	mov    %esp,%ebp
   1ce5e:	57                   	push   %edi
   1ce5f:	56                   	push   %esi
   1ce60:	53                   	push   %ebx
   1ce61:	83 ec 08             	sub    $0x8,%esp
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, buflen) < 0) {
   1ce64:	8b 45 08             	mov    0x8(%ebp),%eax
{
   1ce67:	8b 75 14             	mov    0x14(%ebp),%esi
   1ce6a:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, buflen) < 0) {
   1ce6e:	8b 58 04             	mov    0x4(%eax),%ebx
   1ce71:	8b 3b                	mov    (%ebx),%edi
   1ce73:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
   1ce77:	89 7d f0             	mov    %edi,-0x10(%ebp)
	if (!dst || !src) {
   1ce7a:	85 ff                	test   %edi,%edi
   1ce7c:	74 2e                	je     1ceac <put_string+0x51>
   1ce7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1ce82:	74 28                	je     1ceac <put_string+0x51>
	if (*dst_len + src_len > dst_size) {
   1ce84:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
   1ce88:	0f b7 ce             	movzwl %si,%ecx
   1ce8b:	89 c7                	mov    %eax,%edi
   1ce8d:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
   1ce90:	39 c7                	cmp    %eax,%edi
   1ce92:	7c 18                	jl     1ceac <put_string+0x51>
	memcpy(dst + *dst_len, src, src_len);
   1ce94:	51                   	push   %ecx
   1ce95:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1ce98:	ff 75 10             	pushl  0x10(%ebp)
   1ce9b:	01 d0                	add    %edx,%eax
   1ce9d:	50                   	push   %eax
   1ce9e:	e8 8e da fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1cea3:	66 01 73 04          	add    %si,0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
   1cea7:	83 c4 0c             	add    $0xc,%esp
	return 0;
   1ceaa:	eb 02                	jmp    1ceae <put_string+0x53>
		return 0;
   1ceac:	31 f6                	xor    %esi,%esi
}
   1ceae:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1ceb1:	89 f0                	mov    %esi,%eax
   1ceb3:	5b                   	pop    %ebx
   1ceb4:	5e                   	pop    %esi
   1ceb5:	5f                   	pop    %edi
   1ceb6:	5d                   	pop    %ebp
   1ceb7:	c3                   	ret    

0001ceb8 <plain_text_put_format>:
{
   1ceb8:	55                   	push   %ebp
   1ceb9:	89 e5                	mov    %esp,%ebp
   1cebb:	57                   	push   %edi
   1cebc:	56                   	push   %esi
   1cebd:	53                   	push   %ebx
	va_start(vargs, format);
   1cebe:	8d 45 10             	lea    0x10(%ebp),%eax
{
   1cec1:	83 ec 08             	sub    $0x8,%esp
	n = vsnprintk(pt_buffer, sizeof(pt_buffer), format, vargs);
   1cec4:	50                   	push   %eax
   1cec5:	ff 75 0c             	pushl  0xc(%ebp)
   1cec8:	6a 2a                	push   $0x2a
   1ceca:	68 e0 34 40 00       	push   $0x4034e0
   1cecf:	e8 4c 5d fe ff       	call   2c20 <vsnprintk>
   1ced4:	83 c4 10             	add    $0x10,%esp
	if (n < 0) {
   1ced7:	85 c0                	test   %eax,%eax
   1ced9:	79 04                	jns    1cedf <plain_text_put_format+0x27>
		return 0;
   1cedb:	31 f6                	xor    %esi,%esi
   1cedd:	eb 4c                	jmp    1cf2b <plain_text_put_format+0x73>
	n = strlen(pt_buffer);
   1cedf:	68 e0 34 40 00       	push   $0x4034e0
   1cee4:	e8 7a d9 fe ff       	call   a863 <strlen>
   1cee9:	89 c6                	mov    %eax,%esi
   1ceeb:	5a                   	pop    %edx
   1ceec:	0f b7 c8             	movzwl %ax,%ecx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), pt_buffer, n) < 0) {
   1ceef:	8b 45 08             	mov    0x8(%ebp),%eax
   1cef2:	66 89 75 ee          	mov    %si,-0x12(%ebp)
   1cef6:	8b 58 04             	mov    0x4(%eax),%ebx
   1cef9:	8b 3b                	mov    (%ebx),%edi
   1cefb:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
   1ceff:	89 7d f0             	mov    %edi,-0x10(%ebp)
	if (!dst || !src) {
   1cf02:	85 ff                	test   %edi,%edi
   1cf04:	74 d5                	je     1cedb <plain_text_put_format+0x23>
	if (*dst_len + src_len > dst_size) {
   1cf06:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
   1cf0a:	89 c7                	mov    %eax,%edi
   1cf0c:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
   1cf0f:	39 c7                	cmp    %eax,%edi
   1cf11:	7c c8                	jl     1cedb <plain_text_put_format+0x23>
	memcpy(dst + *dst_len, src, src_len);
   1cf13:	51                   	push   %ecx
   1cf14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1cf17:	68 e0 34 40 00       	push   $0x4034e0
   1cf1c:	01 d0                	add    %edx,%eax
   1cf1e:	50                   	push   %eax
   1cf1f:	e8 0d da fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1cf24:	66 01 73 04          	add    %si,0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
   1cf28:	83 c4 0c             	add    $0xc,%esp
}
   1cf2b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1cf2e:	89 f0                	mov    %esi,%eax
   1cf30:	5b                   	pop    %ebx
   1cf31:	5e                   	pop    %esi
   1cf32:	5f                   	pop    %edi
   1cf33:	5d                   	pop    %ebp
   1cf34:	c3                   	ret    

0001cf35 <put_bool>:
{
   1cf35:	55                   	push   %ebp
   1cf36:	89 e5                	mov    %esp,%ebp
	if (value) {
   1cf38:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
   1cf3c:	74 09                	je     1cf47 <put_bool+0x12>
		return plain_text_put_format(out, "%u", 1);
   1cf3e:	c7 45 10 01 00 00 00 	movl   $0x1,0x10(%ebp)
   1cf45:	eb 07                	jmp    1cf4e <put_bool+0x19>
		return plain_text_put_format(out, "%u", 0);
   1cf47:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
   1cf4e:	c7 45 0c 50 a3 02 00 	movl   $0x2a350,0xc(%ebp)
}
   1cf55:	5d                   	pop    %ebp
		return plain_text_put_format(out, "%u", 0);
   1cf56:	e9 5d ff ff ff       	jmp    1ceb8 <plain_text_put_format>

0001cf5b <put_float64fix>:
{
   1cf5b:	55                   	push   %ebp
   1cf5c:	89 e5                	mov    %esp,%ebp
   1cf5e:	8b 45 10             	mov    0x10(%ebp),%eax
	return plain_text_put_format(out, "%lld.%lld",
   1cf61:	ff 70 0c             	pushl  0xc(%eax)
   1cf64:	ff 70 08             	pushl  0x8(%eax)
   1cf67:	ff 70 04             	pushl  0x4(%eax)
   1cf6a:	ff 30                	pushl  (%eax)
   1cf6c:	68 20 a0 02 00       	push   $0x2a020
   1cf71:	ff 75 08             	pushl  0x8(%ebp)
   1cf74:	e8 3f ff ff ff       	call   1ceb8 <plain_text_put_format>
   1cf79:	83 c4 18             	add    $0x18,%esp
}
   1cf7c:	c9                   	leave  
   1cf7d:	c3                   	ret    

0001cf7e <put_float32fix>:
{
   1cf7e:	55                   	push   %ebp
   1cf7f:	89 e5                	mov    %esp,%ebp
   1cf81:	8b 45 10             	mov    0x10(%ebp),%eax
	return plain_text_put_format(out, "%d.%d",
   1cf84:	ff 70 04             	pushl  0x4(%eax)
   1cf87:	ff 30                	pushl  (%eax)
   1cf89:	68 09 a7 02 00       	push   $0x2a709
   1cf8e:	ff 75 08             	pushl  0x8(%ebp)
   1cf91:	e8 22 ff ff ff       	call   1ceb8 <plain_text_put_format>
   1cf96:	83 c4 10             	add    $0x10,%esp
}
   1cf99:	c9                   	leave  
   1cf9a:	c3                   	ret    

0001cf9b <put_s64>:
{
   1cf9b:	55                   	push   %ebp
   1cf9c:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%lld", value);
   1cf9e:	c7 45 0c d3 9a 02 00 	movl   $0x29ad3,0xc(%ebp)
}
   1cfa5:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%lld", value);
   1cfa6:	e9 0d ff ff ff       	jmp    1ceb8 <plain_text_put_format>

0001cfab <put_s32>:
{
   1cfab:	55                   	push   %ebp
   1cfac:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
   1cfae:	c7 45 0c 4b 9d 02 00 	movl   $0x29d4b,0xc(%ebp)
}
   1cfb5:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
   1cfb6:	e9 fd fe ff ff       	jmp    1ceb8 <plain_text_put_format>

0001cfbb <put_s16>:
{
   1cfbb:	55                   	push   %ebp
   1cfbc:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
   1cfbe:	0f bf 45 10          	movswl 0x10(%ebp),%eax
   1cfc2:	c7 45 0c 4b 9d 02 00 	movl   $0x29d4b,0xc(%ebp)
   1cfc9:	89 45 10             	mov    %eax,0x10(%ebp)
}
   1cfcc:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
   1cfcd:	e9 e6 fe ff ff       	jmp    1ceb8 <plain_text_put_format>

0001cfd2 <put_s8>:
{
   1cfd2:	55                   	push   %ebp
   1cfd3:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
   1cfd5:	0f be 45 10          	movsbl 0x10(%ebp),%eax
   1cfd9:	c7 45 0c 4b 9d 02 00 	movl   $0x29d4b,0xc(%ebp)
   1cfe0:	89 45 10             	mov    %eax,0x10(%ebp)
}
   1cfe3:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
   1cfe4:	e9 cf fe ff ff       	jmp    1ceb8 <plain_text_put_format>

0001cfe9 <do_read_op_plain_text>:
	.get_opaque = get_opaque,
};

int do_read_op_plain_text(struct lwm2m_engine_obj *obj,
			  struct lwm2m_message *msg, int content_format)
{
   1cfe9:	55                   	push   %ebp
   1cfea:	89 e5                	mov    %esp,%ebp
	/* Plain text can only return single resource */
	if (msg->path.level != 3) {
   1cfec:	8b 55 0c             	mov    0xc(%ebp),%edx
{
   1cfef:	8b 45 10             	mov    0x10(%ebp),%eax
	if (msg->path.level != 3) {
   1cff2:	80 7a 28 03          	cmpb   $0x3,0x28(%edx)
   1cff6:	75 0c                	jne    1d004 <do_read_op_plain_text+0x1b>
		return -EPERM; /* NOT_ALLOWED */
	}

	return lwm2m_perform_read_op(obj, msg, content_format);
   1cff8:	0f b7 c0             	movzwl %ax,%eax
   1cffb:	89 45 10             	mov    %eax,0x10(%ebp)
}
   1cffe:	5d                   	pop    %ebp
	return lwm2m_perform_read_op(obj, msg, content_format);
   1cfff:	e9 d0 de ff ff       	jmp    1aed4 <lwm2m_perform_read_op>
}
   1d004:	83 c8 ff             	or     $0xffffffff,%eax
   1d007:	5d                   	pop    %ebp
   1d008:	c3                   	ret    

0001d009 <do_write_op_plain_text>:

int do_write_op_plain_text(struct lwm2m_engine_obj *obj,
			   struct lwm2m_message *msg)
{
   1d009:	55                   	push   %ebp
   1d00a:	89 e5                	mov    %esp,%ebp
   1d00c:	57                   	push   %edi
   1d00d:	56                   	push   %esi
   1d00e:	53                   	push   %ebx
	struct lwm2m_engine_obj_field *obj_field;
	struct lwm2m_engine_res_inst *res = NULL;
	int ret, i;
	u8_t created = 0U;

	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
   1d00f:	8d 45 ef             	lea    -0x11(%ebp),%eax
{
   1d012:	83 ec 10             	sub    $0x10,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1d015:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
{
   1d01c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	u8_t created = 0U;
   1d01f:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
   1d023:	50                   	push   %eax
   1d024:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1d027:	50                   	push   %eax
   1d028:	53                   	push   %ebx
   1d029:	e8 ff e2 ff ff       	call   1b32d <lwm2m_get_or_create_engine_obj>
   1d02e:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1d031:	85 c0                	test   %eax,%eax
   1d033:	78 76                	js     1d0ab <do_write_op_plain_text+0xa2>
		return ret;
	}

	obj_field = lwm2m_get_engine_obj_field(obj, msg->path.res_id);
   1d035:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
   1d039:	50                   	push   %eax
   1d03a:	ff 75 08             	pushl  0x8(%ebp)
   1d03d:	e8 e5 a4 ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   1d042:	5a                   	pop    %edx
   1d043:	89 c7                	mov    %eax,%edi
   1d045:	59                   	pop    %ecx
	if (!obj_field) {
		return -ENOENT;
   1d046:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!obj_field) {
   1d04b:	85 ff                	test   %edi,%edi
   1d04d:	74 5c                	je     1d0ab <do_write_op_plain_text+0xa2>
	}

	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
   1d04f:	8a 57 02             	mov    0x2(%edi),%dl
		return -EPERM;
   1d052:	83 c8 ff             	or     $0xffffffff,%eax
	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
   1d055:	83 e2 06             	and    $0x6,%edx
   1d058:	80 fa 06             	cmp    $0x6,%dl
   1d05b:	75 4e                	jne    1d0ab <do_write_op_plain_text+0xa2>
	}

	if (!obj_inst->resources || obj_inst->resource_count == 0) {
   1d05d:	8b 75 f0             	mov    -0x10(%ebp),%esi
		return -EINVAL;
   1d060:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!obj_inst->resources || obj_inst->resource_count == 0) {
   1d065:	8b 56 08             	mov    0x8(%esi),%edx
   1d068:	85 d2                	test   %edx,%edx
   1d06a:	74 3f                	je     1d0ab <do_write_op_plain_text+0xa2>
   1d06c:	0f b7 4e 0e          	movzwl 0xe(%esi),%ecx
   1d070:	66 85 c9             	test   %cx,%cx
   1d073:	74 36                	je     1d0ab <do_write_op_plain_text+0xa2>
	}

	for (i = 0; i < obj_inst->resource_count; i++) {
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d075:	8b 43 24             	mov    0x24(%ebx),%eax
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d078:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d07b:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d07f:	31 c0                	xor    %eax,%eax
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d081:	66 8b 4d ea          	mov    -0x16(%ebp),%cx
   1d085:	66 39 4a 1a          	cmp    %cx,0x1a(%edx)
   1d089:	74 10                	je     1d09b <do_write_op_plain_text+0x92>
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d08b:	40                   	inc    %eax
   1d08c:	83 c2 20             	add    $0x20,%edx
   1d08f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
   1d092:	7f ed                	jg     1d081 <do_write_op_plain_text+0x78>
		return -ENOENT;
   1d094:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1d099:	eb 10                	jmp    1d0ab <do_write_op_plain_text+0xa2>

	if (!res) {
		return -ENOENT;
	}

	msg->path.level = 3;
   1d09b:	c6 43 28 03          	movb   $0x3,0x28(%ebx)
	return lwm2m_write_handler(obj_inst, res, obj_field, msg);
   1d09f:	53                   	push   %ebx
   1d0a0:	57                   	push   %edi
   1d0a1:	52                   	push   %edx
   1d0a2:	56                   	push   %esi
   1d0a3:	e8 bf da ff ff       	call   1ab67 <lwm2m_write_handler>
   1d0a8:	83 c4 10             	add    $0x10,%esp
}
   1d0ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d0ae:	5b                   	pop    %ebx
   1d0af:	5e                   	pop    %esi
   1d0b0:	5f                   	pop    %edi
   1d0b1:	5d                   	pop    %ebp
   1d0b2:	c3                   	ret    

0001d0b3 <put_begin_oi>:
	return 0;
}

static size_t put_begin_oi(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
   1d0b3:	55                   	push   %ebp
   1d0b4:	89 e5                	mov    %esp,%ebp
   1d0b6:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tlv_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
   1d0b9:	8b 42 08             	mov    0x8(%edx),%eax
	if (!fd) {
   1d0bc:	85 c0                	test   %eax,%eax
   1d0be:	74 0a                	je     1d0ca <put_begin_oi+0x17>
	*mark_pos = out->out_cpkt->offset;
   1d0c0:	8b 52 04             	mov    0x4(%edx),%edx
   1d0c3:	8b 52 04             	mov    0x4(%edx),%edx
   1d0c6:	66 89 50 02          	mov    %dx,0x2(%eax)
		return 0;
	}

	return put_begin_tlv(out, &fd->mark_pos_oi, &fd->writer_flags, 0);
}
   1d0ca:	31 c0                	xor    %eax,%eax
   1d0cc:	5d                   	pop    %ebp
   1d0cd:	c3                   	ret    

0001d0ce <put_begin_ri>:
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
}

static size_t put_begin_ri(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
   1d0ce:	55                   	push   %ebp
   1d0cf:	89 e5                	mov    %esp,%ebp
   1d0d1:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tlv_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
   1d0d4:	8b 42 08             	mov    0x8(%edx),%eax
	if (!fd) {
   1d0d7:	85 c0                	test   %eax,%eax
   1d0d9:	74 0e                	je     1d0e9 <put_begin_ri+0x1b>
	*writer_flags |= writer_flag;
   1d0db:	80 48 06 02          	orb    $0x2,0x6(%eax)
	*mark_pos = out->out_cpkt->offset;
   1d0df:	8b 52 04             	mov    0x4(%edx),%edx
   1d0e2:	8b 52 04             	mov    0x4(%edx),%edx
   1d0e5:	66 89 50 04          	mov    %dx,0x4(%eax)
		return 0;
	}

	return put_begin_tlv(out, &fd->mark_pos_ri, &fd->writer_flags,
			     WRITER_RESOURCE_INSTANCE);
}
   1d0e9:	31 c0                	xor    %eax,%eax
   1d0eb:	5d                   	pop    %ebp
   1d0ec:	c3                   	ret    

0001d0ed <buf_read>:
{
   1d0ed:	55                   	push   %ebp
   1d0ee:	89 e5                	mov    %esp,%ebp
   1d0f0:	57                   	push   %edi
   1d0f1:	56                   	push   %esi
   1d0f2:	53                   	push   %ebx
   1d0f3:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
   1d0f6:	85 c9                	test   %ecx,%ecx
{
   1d0f8:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!src) {
   1d0fb:	74 3e                	je     1d13b <buf_read+0x4e>
   1d0fd:	89 c3                	mov    %eax,%ebx
	if (*offset + len > src_len) {
   1d0ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d102:	0f b7 fa             	movzwl %dx,%edi
   1d105:	0f b7 00             	movzwl (%eax),%eax
   1d108:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1d10b:	01 f8                	add    %edi,%eax
   1d10d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
   1d110:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (*offset + len > src_len) {
   1d115:	0f b7 f6             	movzwl %si,%esi
   1d118:	39 75 ec             	cmp    %esi,-0x14(%ebp)
   1d11b:	7f 23                	jg     1d140 <buf_read+0x53>
   1d11d:	89 d6                	mov    %edx,%esi
	if (dst) {
   1d11f:	85 db                	test   %ebx,%ebx
   1d121:	74 0e                	je     1d131 <buf_read+0x44>
		memcpy(dst, src + *offset, len);
   1d123:	03 4d f0             	add    -0x10(%ebp),%ecx
   1d126:	57                   	push   %edi
   1d127:	51                   	push   %ecx
   1d128:	53                   	push   %ebx
   1d129:	e8 03 d8 fe ff       	call   a931 <memcpy>
   1d12e:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
   1d131:	8b 45 0c             	mov    0xc(%ebp),%eax
   1d134:	66 01 30             	add    %si,(%eax)
	return 0;
   1d137:	31 c0                	xor    %eax,%eax
   1d139:	eb 05                	jmp    1d140 <buf_read+0x53>
		return -EINVAL;
   1d13b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   1d140:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d143:	5b                   	pop    %ebx
   1d144:	5e                   	pop    %esi
   1d145:	5f                   	pop    %edi
   1d146:	5d                   	pop    %ebp
   1d147:	c3                   	ret    

0001d148 <oma_tlv_get>:
{
   1d148:	55                   	push   %ebp
   1d149:	89 e5                	mov    %esp,%ebp
   1d14b:	57                   	push   %edi
   1d14c:	56                   	push   %esi
   1d14d:	89 d6                	mov    %edx,%esi
   1d14f:	53                   	push   %ebx
	return buf_read(value, sizeof(u8_t), src, src_len, offset);
   1d150:	8d 7d f0             	lea    -0x10(%ebp),%edi
   1d153:	83 ec 10             	sub    $0x10,%esp
   1d156:	89 45 e8             	mov    %eax,-0x18(%ebp)
	tmp_offset = in->offset;
   1d159:	8b 42 08             	mov    0x8(%edx),%eax
{
   1d15c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	tmp_offset = in->offset;
   1d15f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	if (buf_read_u8(&buf[0], CPKT_BUF_READ(in->in_cpkt), &tmp_offset) < 0) {
   1d163:	8b 42 04             	mov    0x4(%edx),%eax
   1d166:	57                   	push   %edi
   1d167:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d16b:	8b 08                	mov    (%eax),%ecx
   1d16d:	52                   	push   %edx
   1d16e:	8d 45 f2             	lea    -0xe(%ebp),%eax
   1d171:	ba 01 00 00 00       	mov    $0x1,%edx
   1d176:	e8 72 ff ff ff       	call   1d0ed <buf_read>
   1d17b:	59                   	pop    %ecx
   1d17c:	5b                   	pop    %ebx
   1d17d:	85 c0                	test   %eax,%eax
   1d17f:	0f 88 e9 00 00 00    	js     1d26e <oma_tlv_get+0x126>
	tlv->type = (buf[0] >> 6) & 3;
   1d185:	8a 5d f2             	mov    -0xe(%ebp),%bl
   1d188:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1d18b:	88 d8                	mov    %bl,%al
   1d18d:	c0 e8 06             	shr    $0x6,%al
   1d190:	88 01                	mov    %al,(%ecx)
   1d192:	57                   	push   %edi
	len_pos = 1 + (((buf[0] & (1 << 5)) != 0) ? 2 : 1);
   1d193:	f6 c3 20             	test   $0x20,%bl
   1d196:	0f 95 c0             	setne  %al
   1d199:	83 c0 02             	add    $0x2,%eax
   1d19c:	88 45 ef             	mov    %al,-0x11(%ebp)
	if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt), &tmp_offset) < 0) {
   1d19f:	8b 46 04             	mov    0x4(%esi),%eax
   1d1a2:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d1a6:	8b 08                	mov    (%eax),%ecx
   1d1a8:	52                   	push   %edx
   1d1a9:	8d 45 f3             	lea    -0xd(%ebp),%eax
   1d1ac:	ba 01 00 00 00       	mov    $0x1,%edx
   1d1b1:	e8 37 ff ff ff       	call   1d0ed <buf_read>
   1d1b6:	59                   	pop    %ecx
   1d1b7:	5a                   	pop    %edx
   1d1b8:	85 c0                	test   %eax,%eax
   1d1ba:	0f 88 bb 00 00 00    	js     1d27b <oma_tlv_get+0x133>
	tlv->id = buf[1];
   1d1c0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1d1c4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	if (len_pos > 2) {
   1d1c7:	80 7d ef 03          	cmpb   $0x3,-0x11(%ebp)
	tlv->id = buf[1];
   1d1cb:	66 89 41 02          	mov    %ax,0x2(%ecx)
	if (len_pos > 2) {
   1d1cf:	75 37                	jne    1d208 <oma_tlv_get+0xc0>
		if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt),
   1d1d1:	8b 46 04             	mov    0x4(%esi),%eax
   1d1d4:	57                   	push   %edi
   1d1d5:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d1d9:	8b 08                	mov    (%eax),%ecx
   1d1db:	52                   	push   %edx
   1d1dc:	8d 45 f3             	lea    -0xd(%ebp),%eax
   1d1df:	ba 01 00 00 00       	mov    $0x1,%edx
   1d1e4:	e8 04 ff ff ff       	call   1d0ed <buf_read>
   1d1e9:	5f                   	pop    %edi
   1d1ea:	5a                   	pop    %edx
   1d1eb:	85 c0                	test   %eax,%eax
   1d1ed:	78 7f                	js     1d26e <oma_tlv_get+0x126>
		tlv->id = (tlv->id << 8) + buf[1];
   1d1ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1d1f2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1d1f5:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   1d1f9:	c1 e0 08             	shl    $0x8,%eax
   1d1fc:	89 c2                	mov    %eax,%edx
   1d1fe:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1d202:	01 d0                	add    %edx,%eax
   1d204:	66 89 41 02          	mov    %ax,0x2(%ecx)
	len_type = (buf[0] >> 3) & 3;
   1d208:	c0 eb 03             	shr    $0x3,%bl
	if (len_type == 0) {
   1d20b:	80 e3 03             	and    $0x3,%bl
   1d20e:	75 0d                	jne    1d21d <oma_tlv_get+0xd5>
		tlv_len = buf[0] & 7;
   1d210:	8a 45 f2             	mov    -0xe(%ebp),%al
   1d213:	8a 5d ef             	mov    -0x11(%ebp),%bl
   1d216:	89 c7                	mov    %eax,%edi
   1d218:	83 e7 07             	and    $0x7,%edi
   1d21b:	eb 37                	jmp    1d254 <oma_tlv_get+0x10c>
   1d21d:	02 5d ef             	add    -0x11(%ebp),%bl
		tlv_len = 0;
   1d220:	31 ff                	xor    %edi,%edi
			if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt),
   1d222:	8b 46 04             	mov    0x4(%esi),%eax
   1d225:	8d 55 f0             	lea    -0x10(%ebp),%edx
   1d228:	52                   	push   %edx
   1d229:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d22d:	8b 08                	mov    (%eax),%ecx
   1d22f:	52                   	push   %edx
   1d230:	8d 45 f3             	lea    -0xd(%ebp),%eax
   1d233:	ba 01 00 00 00       	mov    $0x1,%edx
   1d238:	e8 b0 fe ff ff       	call   1d0ed <buf_read>
   1d23d:	5a                   	pop    %edx
   1d23e:	59                   	pop    %ecx
   1d23f:	85 c0                	test   %eax,%eax
   1d241:	78 2b                	js     1d26e <oma_tlv_get+0x126>
			len_pos++;
   1d243:	fe 45 ef             	incb   -0x11(%ebp)
			tlv_len = tlv_len << 8 | buf[1];
   1d246:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1d24a:	c1 e7 08             	shl    $0x8,%edi
   1d24d:	09 c7                	or     %eax,%edi
		while (len_type > 0) {
   1d24f:	3a 5d ef             	cmp    -0x11(%ebp),%bl
   1d252:	75 ce                	jne    1d222 <oma_tlv_get+0xda>
	tlv->length = tlv_len;
   1d254:	8b 45 e8             	mov    -0x18(%ebp),%eax
	if (!dont_advance) {
   1d257:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
	tlv->length = tlv_len;
   1d25b:	89 78 04             	mov    %edi,0x4(%eax)
	if (!dont_advance) {
   1d25e:	75 07                	jne    1d267 <oma_tlv_get+0x11f>
		in->offset = tmp_offset;
   1d260:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d263:	66 89 46 08          	mov    %ax,0x8(%esi)
	return len_pos + tlv_len;
   1d267:	0f b6 c3             	movzbl %bl,%eax
   1d26a:	01 f8                	add    %edi,%eax
   1d26c:	eb 0f                	jmp    1d27d <oma_tlv_get+0x135>
	if (!dont_advance) {
   1d26e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
   1d272:	75 07                	jne    1d27b <oma_tlv_get+0x133>
		in->offset = tmp_offset;
   1d274:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d277:	66 89 46 08          	mov    %ax,0x8(%esi)
	return 0;
   1d27b:	31 c0                	xor    %eax,%eax
}
   1d27d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d280:	5b                   	pop    %ebx
   1d281:	5e                   	pop    %esi
   1d282:	5f                   	pop    %edi
   1d283:	5d                   	pop    %ebp
   1d284:	c3                   	ret    

0001d285 <do_write_op_tlv_dummy_read>:
	engine_clear_out_user_data(&msg->out);
	return ret;
}

static int do_write_op_tlv_dummy_read(struct lwm2m_message *msg)
{
   1d285:	55                   	push   %ebp
	struct oma_tlv tlv;
	u8_t read_char;

	oma_tlv_get(&tlv, &msg->in, false);
   1d286:	8d 50 04             	lea    0x4(%eax),%edx
{
   1d289:	89 e5                	mov    %esp,%ebp
   1d28b:	53                   	push   %ebx
   1d28c:	83 ec 0c             	sub    $0xc,%esp
   1d28f:	89 c3                	mov    %eax,%ebx
	oma_tlv_get(&tlv, &msg->in, false);
   1d291:	31 c9                	xor    %ecx,%ecx
   1d293:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1d296:	e8 ad fe ff ff       	call   1d148 <oma_tlv_get>
	while (tlv.length--) {
   1d29b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1d29e:	85 c0                	test   %eax,%eax
   1d2a0:	8d 50 ff             	lea    -0x1(%eax),%edx
   1d2a3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1d2a6:	74 21                	je     1d2c9 <do_write_op_tlv_dummy_read+0x44>
		if (buf_read_u8(&read_char, CPKT_BUF_READ(msg->in.in_cpkt),
   1d2a8:	8b 43 08             	mov    0x8(%ebx),%eax
   1d2ab:	8d 53 0c             	lea    0xc(%ebx),%edx
   1d2ae:	52                   	push   %edx
   1d2af:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d2b3:	8b 08                	mov    (%eax),%ecx
   1d2b5:	52                   	push   %edx
   1d2b6:	8d 45 f3             	lea    -0xd(%ebp),%eax
   1d2b9:	ba 01 00 00 00       	mov    $0x1,%edx
   1d2be:	e8 2a fe ff ff       	call   1d0ed <buf_read>
   1d2c3:	5a                   	pop    %edx
   1d2c4:	59                   	pop    %ecx
   1d2c5:	85 c0                	test   %eax,%eax
   1d2c7:	79 d2                	jns    1d29b <do_write_op_tlv_dummy_read+0x16>
			break;
		}
	}

	return 0;
}
   1d2c9:	31 c0                	xor    %eax,%eax
   1d2cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1d2ce:	c9                   	leave  
   1d2cf:	c3                   	ret    

0001d2d0 <do_write_op_tlv_item>:

static int do_write_op_tlv_item(struct lwm2m_message *msg)
{
   1d2d0:	55                   	push   %ebp
   1d2d1:	89 e5                	mov    %esp,%ebp
   1d2d3:	57                   	push   %edi
   1d2d4:	56                   	push   %esi
   1d2d5:	53                   	push   %ebx
   1d2d6:	89 c3                	mov    %eax,%ebx
   1d2d8:	83 ec 10             	sub    $0x10,%esp
	struct lwm2m_engine_res_inst *res = NULL;
	struct lwm2m_engine_obj_field *obj_field = NULL;
	u8_t created = 0U;
	int ret, i;

	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
   1d2db:	8d 45 ef             	lea    -0x11(%ebp),%eax
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1d2de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	u8_t created = 0U;
   1d2e5:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
   1d2e9:	50                   	push   %eax
   1d2ea:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1d2ed:	50                   	push   %eax
   1d2ee:	53                   	push   %ebx
   1d2ef:	e8 39 e0 ff ff       	call   1b32d <lwm2m_get_or_create_engine_obj>
   1d2f4:	83 c4 0c             	add    $0xc,%esp
   1d2f7:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1d2f9:	85 c0                	test   %eax,%eax
   1d2fb:	78 6a                	js     1d367 <do_write_op_tlv_item+0x97>
		goto error;
	}

	obj_field = lwm2m_get_engine_obj_field(obj_inst->obj,
   1d2fd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
   1d301:	50                   	push   %eax
   1d302:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d305:	ff 70 04             	pushl  0x4(%eax)
   1d308:	e8 1a a2 ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   1d30d:	5a                   	pop    %edx
					       msg->path.res_id);
	if (!obj_field) {
   1d30e:	85 c0                	test   %eax,%eax
	obj_field = lwm2m_get_engine_obj_field(obj_inst->obj,
   1d310:	59                   	pop    %ecx
	if (!obj_field) {
   1d311:	74 43                	je     1d356 <do_write_op_tlv_item+0x86>
		ret = -ENOENT;
		goto error;
	}

	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
   1d313:	8a 48 02             	mov    0x2(%eax),%cl
   1d316:	88 ca                	mov    %cl,%dl
   1d318:	88 4d eb             	mov    %cl,-0x15(%ebp)
   1d31b:	83 e2 06             	and    $0x6,%edx
   1d31e:	80 fa 06             	cmp    $0x6,%dl
   1d321:	75 3a                	jne    1d35d <do_write_op_tlv_item+0x8d>
		ret = -EPERM;
		goto error;
	}

	if (!obj_inst->resources || obj_inst->resource_count == 0) {
   1d323:	8b 75 f0             	mov    -0x10(%ebp),%esi
   1d326:	8b 56 08             	mov    0x8(%esi),%edx
   1d329:	85 d2                	test   %edx,%edx
   1d32b:	74 35                	je     1d362 <do_write_op_tlv_item+0x92>
   1d32d:	0f b7 4e 0e          	movzwl 0xe(%esi),%ecx
   1d331:	66 85 c9             	test   %cx,%cx
   1d334:	74 2c                	je     1d362 <do_write_op_tlv_item+0x92>
		ret = -EINVAL;
		goto error;
	}

	for (i = 0; i < obj_inst->resource_count; i++) {
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d336:	8b 7b 24             	mov    0x24(%ebx),%edi
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d339:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d33c:	66 89 7d e8          	mov    %di,-0x18(%ebp)
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d340:	31 ff                	xor    %edi,%edi
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
   1d342:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1d345:	66 39 4a 1a          	cmp    %cx,0x1a(%edx)
   1d349:	74 25                	je     1d370 <do_write_op_tlv_item+0xa0>
	for (i = 0; i < obj_inst->resource_count; i++) {
   1d34b:	47                   	inc    %edi
   1d34c:	83 c2 20             	add    $0x20,%edx
   1d34f:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
   1d352:	7f ee                	jg     1d342 <do_write_op_tlv_item+0x72>
   1d354:	eb 3f                	jmp    1d395 <do_write_op_tlv_item+0xc5>
		    LWM2M_HAS_PERM(obj_field, BIT(LWM2M_FLAG_OPTIONAL))) {
			ret = -ENOTSUP;
			goto error;
		}

		ret = -ENOENT;
   1d356:	be fe ff ff ff       	mov    $0xfffffffe,%esi
   1d35b:	eb 0a                	jmp    1d367 <do_write_op_tlv_item+0x97>
		ret = -EPERM;
   1d35d:	83 ce ff             	or     $0xffffffff,%esi
   1d360:	eb 05                	jmp    1d367 <do_write_op_tlv_item+0x97>
		ret = -EINVAL;
   1d362:	be ea ff ff ff       	mov    $0xffffffea,%esi
	}

	return ret;

error:
	do_write_op_tlv_dummy_read(msg);
   1d367:	89 d8                	mov    %ebx,%eax
   1d369:	e8 17 ff ff ff       	call   1d285 <do_write_op_tlv_dummy_read>
	return ret;
   1d36e:	eb 4d                	jmp    1d3bd <do_write_op_tlv_item+0xed>
	ret = lwm2m_write_handler(obj_inst, res, obj_field, msg);
   1d370:	53                   	push   %ebx
   1d371:	50                   	push   %eax
   1d372:	52                   	push   %edx
   1d373:	56                   	push   %esi
   1d374:	e8 ee d7 ff ff       	call   1ab67 <lwm2m_write_handler>
   1d379:	83 c4 10             	add    $0x10,%esp
   1d37c:	89 c6                	mov    %eax,%esi
	if (ret == -EACCES || ret == -ENOENT) {
   1d37e:	83 f8 f3             	cmp    $0xfffffff3,%eax
   1d381:	75 0b                	jne    1d38e <do_write_op_tlv_item+0xbe>
		do_write_op_tlv_dummy_read(msg);
   1d383:	89 d8                	mov    %ebx,%eax
		ret = 0;
   1d385:	31 f6                	xor    %esi,%esi
		do_write_op_tlv_dummy_read(msg);
   1d387:	e8 f9 fe ff ff       	call   1d285 <do_write_op_tlv_dummy_read>
		ret = 0;
   1d38c:	eb 2f                	jmp    1d3bd <do_write_op_tlv_item+0xed>
	if (ret == -EACCES || ret == -ENOENT) {
   1d38e:	83 f8 fe             	cmp    $0xfffffffe,%eax
   1d391:	75 2a                	jne    1d3bd <do_write_op_tlv_item+0xed>
   1d393:	eb ee                	jmp    1d383 <do_write_op_tlv_item+0xb3>
		if ((msg->ctx->bootstrap_mode ||
   1d395:	8b 03                	mov    (%ebx),%eax
   1d397:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
   1d39e:	75 0e                	jne    1d3ae <do_write_op_tlv_item+0xde>
		ret = -ENOENT;
   1d3a0:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		if ((msg->ctx->bootstrap_mode ||
   1d3a5:	80 bb 85 01 00 00 02 	cmpb   $0x2,0x185(%ebx)
   1d3ac:	75 b9                	jne    1d367 <do_write_op_tlv_item+0x97>
			ret = -ENOTSUP;
   1d3ae:	0f be 75 eb          	movsbl -0x15(%ebp),%esi
   1d3b2:	c1 fe 1f             	sar    $0x1f,%esi
   1d3b5:	83 e6 df             	and    $0xffffffdf,%esi
   1d3b8:	83 ee 02             	sub    $0x2,%esi
   1d3bb:	eb aa                	jmp    1d367 <do_write_op_tlv_item+0x97>
}
   1d3bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d3c0:	89 f0                	mov    %esi,%eax
   1d3c2:	5b                   	pop    %ebx
   1d3c3:	5e                   	pop    %esi
   1d3c4:	5f                   	pop    %edi
   1d3c5:	5d                   	pop    %ebp
   1d3c6:	c3                   	ret    

0001d3c7 <get_number>:
{
   1d3c7:	55                   	push   %ebp
   1d3c8:	89 e5                	mov    %esp,%ebp
   1d3ca:	57                   	push   %edi
   1d3cb:	56                   	push   %esi
   1d3cc:	89 c7                	mov    %eax,%edi
   1d3ce:	53                   	push   %ebx
   1d3cf:	89 d3                	mov    %edx,%ebx
   1d3d1:	83 ec 14             	sub    $0x14,%esp
	size_t size = oma_tlv_get(&tlv, in, false);
   1d3d4:	89 c2                	mov    %eax,%edx
{
   1d3d6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	size_t size = oma_tlv_get(&tlv, in, false);
   1d3d9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1d3dc:	31 c9                	xor    %ecx,%ecx
   1d3de:	e8 65 fd ff ff       	call   1d148 <oma_tlv_get>
	*value = 0;
   1d3e3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   1d3e9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	if (size > 0) {
   1d3f0:	85 c0                	test   %eax,%eax
   1d3f2:	0f 84 a6 00 00 00    	je     1d49e <get_number+0xd7>
   1d3f8:	89 c6                	mov    %eax,%esi
		if (tlv.length > max_len) {
   1d3fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1d3fd:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
   1d401:	39 c2                	cmp    %eax,%edx
   1d403:	77 6e                	ja     1d473 <get_number+0xac>
			     CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
   1d405:	8b 47 04             	mov    0x4(%edi),%eax
		if (buf_read((u8_t *)&temp, tlv.length,
   1d408:	83 c7 08             	add    $0x8,%edi
   1d40b:	57                   	push   %edi
   1d40c:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   1d410:	51                   	push   %ecx
   1d411:	8b 08                	mov    (%eax),%ecx
   1d413:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1d416:	e8 d2 fc ff ff       	call   1d0ed <buf_read>
   1d41b:	5a                   	pop    %edx
   1d41c:	59                   	pop    %ecx
   1d41d:	85 c0                	test   %eax,%eax
   1d41f:	78 7d                	js     1d49e <get_number+0xd7>
		switch (tlv.length) {
   1d421:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1d424:	83 fa 02             	cmp    $0x2,%edx
   1d427:	74 30                	je     1d459 <get_number+0x92>
   1d429:	77 13                	ja     1d43e <get_number+0x77>
   1d42b:	83 fa 01             	cmp    $0x1,%edx
   1d42e:	75 43                	jne    1d473 <get_number+0xac>
			*value = (s8_t)temp;
   1d430:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   1d434:	89 03                	mov    %eax,(%ebx)
   1d436:	c1 f8 1f             	sar    $0x1f,%eax
   1d439:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
   1d43c:	eb 62                	jmp    1d4a0 <get_number+0xd9>
		switch (tlv.length) {
   1d43e:	83 fa 04             	cmp    $0x4,%edx
   1d441:	74 20                	je     1d463 <get_number+0x9c>
   1d443:	83 fa 08             	cmp    $0x8,%edx
   1d446:	75 2b                	jne    1d473 <get_number+0xac>
			*value = sys_cpu_to_be64(temp);
   1d448:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1d44b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1d44e:	0f c8                	bswap  %eax
   1d450:	0f ca                	bswap  %edx
   1d452:	89 13                	mov    %edx,(%ebx)
   1d454:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
   1d457:	eb 47                	jmp    1d4a0 <get_number+0xd9>
			*value = sys_cpu_to_be16((s16_t)temp);
   1d459:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1d45c:	86 e0                	xchg   %ah,%al
   1d45e:	0f b7 c0             	movzwl %ax,%eax
   1d461:	eb 05                	jmp    1d468 <get_number+0xa1>
			*value = sys_cpu_to_be32((s32_t)temp);
   1d463:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1d466:	0f c8                	bswap  %eax
   1d468:	89 03                	mov    %eax,(%ebx)
   1d46a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
			break;
   1d471:	eb 2d                	jmp    1d4a0 <get_number+0xd9>
			LOG_ERR("invalid length: %u", tlv.length);
   1d473:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d47a:	74 22                	je     1d49e <get_number+0xd7>
   1d47c:	b8 04 52 02 00       	mov    $0x25204,%eax
   1d481:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1d486:	c1 e8 03             	shr    $0x3,%eax
   1d489:	c1 e0 06             	shl    $0x6,%eax
   1d48c:	83 c8 01             	or     $0x1,%eax
   1d48f:	50                   	push   %eax
   1d490:	52                   	push   %edx
   1d491:	68 3f a0 02 00       	push   $0x2a03f
   1d496:	e8 14 60 fe ff       	call   34af <log_1>
   1d49b:	83 c4 0c             	add    $0xc,%esp
			return 0;
   1d49e:	31 f6                	xor    %esi,%esi
}
   1d4a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d4a3:	89 f0                	mov    %esi,%eax
   1d4a5:	5b                   	pop    %ebx
   1d4a6:	5e                   	pop    %esi
   1d4a7:	5f                   	pop    %edi
   1d4a8:	5d                   	pop    %ebp
   1d4a9:	c3                   	ret    

0001d4aa <get_bool>:
{
   1d4aa:	55                   	push   %ebp
	size = get_number(in, &temp, 2);
   1d4ab:	b9 02 00 00 00       	mov    $0x2,%ecx
{
   1d4b0:	89 e5                	mov    %esp,%ebp
   1d4b2:	53                   	push   %ebx
   1d4b3:	83 ec 08             	sub    $0x8,%esp
   1d4b6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size = get_number(in, &temp, 2);
   1d4b9:	8d 55 f4             	lea    -0xc(%ebp),%edx
   1d4bc:	8b 45 08             	mov    0x8(%ebp),%eax
	*value = 0;
   1d4bf:	c6 03 00             	movb   $0x0,(%ebx)
	size = get_number(in, &temp, 2);
   1d4c2:	e8 00 ff ff ff       	call   1d3c7 <get_number>
	if (size > 0) {
   1d4c7:	85 c0                	test   %eax,%eax
   1d4c9:	74 09                	je     1d4d4 <get_bool+0x2a>
		*value = (temp != 0);
   1d4cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1d4ce:	0b 55 f8             	or     -0x8(%ebp),%edx
   1d4d1:	0f 95 03             	setne  (%ebx)
}
   1d4d4:	5a                   	pop    %edx
   1d4d5:	59                   	pop    %ecx
   1d4d6:	5b                   	pop    %ebx
   1d4d7:	5d                   	pop    %ebp
   1d4d8:	c3                   	ret    

0001d4d9 <get_s64>:
{
   1d4d9:	55                   	push   %ebp
	return get_number(in, value, 8);
   1d4da:	b9 08 00 00 00       	mov    $0x8,%ecx
{
   1d4df:	89 e5                	mov    %esp,%ebp
	return get_number(in, value, 8);
   1d4e1:	8b 55 0c             	mov    0xc(%ebp),%edx
   1d4e4:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1d4e7:	5d                   	pop    %ebp
	return get_number(in, value, 8);
   1d4e8:	e9 da fe ff ff       	jmp    1d3c7 <get_number>

0001d4ed <get_s32>:
{
   1d4ed:	55                   	push   %ebp
	size = get_number(in, &temp, 4);
   1d4ee:	b9 04 00 00 00       	mov    $0x4,%ecx
{
   1d4f3:	89 e5                	mov    %esp,%ebp
   1d4f5:	53                   	push   %ebx
   1d4f6:	83 ec 08             	sub    $0x8,%esp
   1d4f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size = get_number(in, &temp, 4);
   1d4fc:	8d 55 f4             	lea    -0xc(%ebp),%edx
   1d4ff:	8b 45 08             	mov    0x8(%ebp),%eax
	*value = 0;
   1d502:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	size = get_number(in, &temp, 4);
   1d508:	e8 ba fe ff ff       	call   1d3c7 <get_number>
	if (size > 0) {
   1d50d:	85 c0                	test   %eax,%eax
   1d50f:	74 05                	je     1d516 <get_s32+0x29>
		*value = (s32_t)temp;
   1d511:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1d514:	89 13                	mov    %edx,(%ebx)
}
   1d516:	5a                   	pop    %edx
   1d517:	59                   	pop    %ecx
   1d518:	5b                   	pop    %ebx
   1d519:	5d                   	pop    %ebp
   1d51a:	c3                   	ret    

0001d51b <get_string>:
{
   1d51b:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
   1d51c:	31 c9                	xor    %ecx,%ecx
{
   1d51e:	89 e5                	mov    %esp,%ebp
   1d520:	57                   	push   %edi
   1d521:	56                   	push   %esi
   1d522:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
   1d523:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   1d526:	83 ec 08             	sub    $0x8,%esp
   1d529:	8b 5d 08             	mov    0x8(%ebp),%ebx
   1d52c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	size_t size = oma_tlv_get(&tlv, in, false);
   1d52f:	89 da                	mov    %ebx,%edx
   1d531:	e8 12 fc ff ff       	call   1d148 <oma_tlv_get>
	if (size > 0) {
   1d536:	85 c0                	test   %eax,%eax
   1d538:	75 04                	jne    1d53e <get_string+0x23>
{
   1d53a:	31 f6                	xor    %esi,%esi
   1d53c:	eb 2f                	jmp    1d56d <get_string+0x52>
		if (buflen <= tlv.length) {
   1d53e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1d541:	3b 55 10             	cmp    0x10(%ebp),%edx
   1d544:	73 f4                	jae    1d53a <get_string+0x1f>
   1d546:	89 c6                	mov    %eax,%esi
		if (buf_read(buf, tlv.length, CPKT_BUF_READ(in->in_cpkt),
   1d548:	8b 43 04             	mov    0x4(%ebx),%eax
   1d54b:	83 c3 08             	add    $0x8,%ebx
   1d54e:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   1d552:	53                   	push   %ebx
   1d553:	51                   	push   %ecx
   1d554:	8b 08                	mov    (%eax),%ecx
   1d556:	0f b7 d2             	movzwl %dx,%edx
   1d559:	89 f8                	mov    %edi,%eax
   1d55b:	e8 8d fb ff ff       	call   1d0ed <buf_read>
   1d560:	5a                   	pop    %edx
   1d561:	59                   	pop    %ecx
   1d562:	85 c0                	test   %eax,%eax
   1d564:	78 d4                	js     1d53a <get_string+0x1f>
		buf[tlv.length] = '\0';
   1d566:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d569:	c6 04 07 00          	movb   $0x0,(%edi,%eax,1)
}
   1d56d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d570:	89 f0                	mov    %esi,%eax
   1d572:	5b                   	pop    %ebx
   1d573:	5e                   	pop    %esi
   1d574:	5f                   	pop    %edi
   1d575:	5d                   	pop    %ebp
   1d576:	c3                   	ret    

0001d577 <get_opaque>:
{
   1d577:	55                   	push   %ebp
	oma_tlv_get(&tlv, in, false);
   1d578:	31 c9                	xor    %ecx,%ecx
{
   1d57a:	89 e5                	mov    %esp,%ebp
   1d57c:	53                   	push   %ebx
   1d57d:	83 ec 08             	sub    $0x8,%esp
   1d580:	8b 5d 08             	mov    0x8(%ebp),%ebx
	oma_tlv_get(&tlv, in, false);
   1d583:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1d586:	89 da                	mov    %ebx,%edx
   1d588:	e8 bb fb ff ff       	call   1d148 <oma_tlv_get>
	in->opaque_len = tlv.length;
   1d58d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1d590:	66 89 43 0a          	mov    %ax,0xa(%ebx)
	return lwm2m_engine_get_opaque_more(in, value, buflen, last_block);
   1d594:	ff 75 14             	pushl  0x14(%ebp)
   1d597:	ff 75 10             	pushl  0x10(%ebp)
   1d59a:	ff 75 0c             	pushl  0xc(%ebp)
   1d59d:	53                   	push   %ebx
   1d59e:	e8 4a d5 ff ff       	call   1aaed <lwm2m_engine_get_opaque_more>
   1d5a3:	83 c4 10             	add    $0x10,%esp
}
   1d5a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1d5a9:	c9                   	leave  
   1d5aa:	c3                   	ret    

0001d5ab <get_float64fix>:
{
   1d5ab:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
   1d5ac:	31 c9                	xor    %ecx,%ecx
{
   1d5ae:	89 e5                	mov    %esp,%ebp
   1d5b0:	57                   	push   %edi
   1d5b1:	56                   	push   %esi
   1d5b2:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
   1d5b3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
{
   1d5b6:	83 ec 10             	sub    $0x10,%esp
   1d5b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t size = oma_tlv_get(&tlv, in, false);
   1d5bc:	89 da                	mov    %ebx,%edx
   1d5be:	e8 85 fb ff ff       	call   1d148 <oma_tlv_get>
	if (size > 0) {
   1d5c3:	85 c0                	test   %eax,%eax
   1d5c5:	0f 84 c8 00 00 00    	je     1d693 <get_float64fix+0xe8>
		if (tlv.length != 8) {
   1d5cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1d5ce:	83 fa 08             	cmp    $0x8,%edx
   1d5d1:	74 5d                	je     1d630 <get_float64fix+0x85>
			LOG_ERR("invalid float64 length: %d", tlv.length);
   1d5d3:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d5da:	74 45                	je     1d621 <get_float64fix+0x76>
   1d5dc:	b8 04 52 02 00       	mov    $0x25204,%eax
   1d5e1:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1d5e6:	c1 e8 03             	shr    $0x3,%eax
   1d5e9:	c1 e0 06             	shl    $0x6,%eax
   1d5ec:	83 c8 01             	or     $0x1,%eax
   1d5ef:	50                   	push   %eax
   1d5f0:	52                   	push   %edx
   1d5f1:	68 52 a0 02 00       	push   $0x2a052
   1d5f6:	e8 b4 5e fe ff       	call   34af <log_1>
   1d5fb:	83 c4 0c             	add    $0xc,%esp
   1d5fe:	eb 21                	jmp    1d621 <get_float64fix+0x76>
						CPKT_BUF_READ(in->in_cpkt),
   1d600:	8b 43 04             	mov    0x4(%ebx),%eax
				if (buf_read_u8(b64,
   1d603:	8d 53 08             	lea    0x8(%ebx),%edx
   1d606:	52                   	push   %edx
   1d607:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d60b:	8b 08                	mov    (%eax),%ecx
   1d60d:	52                   	push   %edx
   1d60e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1d611:	ba 01 00 00 00       	mov    $0x1,%edx
   1d616:	e8 d2 fa ff ff       	call   1d0ed <buf_read>
   1d61b:	5e                   	pop    %esi
   1d61c:	5f                   	pop    %edi
   1d61d:	85 c0                	test   %eax,%eax
   1d61f:	78 72                	js     1d693 <get_float64fix+0xe8>
			while (tlv.length--) {
   1d621:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1d624:	85 c0                	test   %eax,%eax
   1d626:	8d 50 ff             	lea    -0x1(%eax),%edx
   1d629:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1d62c:	75 d2                	jne    1d600 <get_float64fix+0x55>
   1d62e:	eb 63                	jmp    1d693 <get_float64fix+0xe8>
   1d630:	89 c6                	mov    %eax,%esi
		if (buf_read(b64, tlv.length, CPKT_BUF_READ(in->in_cpkt),
   1d632:	8b 43 04             	mov    0x4(%ebx),%eax
   1d635:	83 c3 08             	add    $0x8,%ebx
   1d638:	8d 7d ec             	lea    -0x14(%ebp),%edi
   1d63b:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d63f:	53                   	push   %ebx
   1d640:	8b 08                	mov    (%eax),%ecx
   1d642:	52                   	push   %edx
   1d643:	89 f8                	mov    %edi,%eax
   1d645:	ba 08 00 00 00       	mov    $0x8,%edx
   1d64a:	e8 9e fa ff ff       	call   1d0ed <buf_read>
   1d64f:	5a                   	pop    %edx
   1d650:	59                   	pop    %ecx
   1d651:	85 c0                	test   %eax,%eax
   1d653:	78 3e                	js     1d693 <get_float64fix+0xe8>
		ret = lwm2m_b64_to_f64(b64, sizeof(b64), value);
   1d655:	ff 75 0c             	pushl  0xc(%ebp)
   1d658:	6a 08                	push   $0x8
   1d65a:	57                   	push   %edi
   1d65b:	e8 f8 0b 00 00       	call   1e258 <lwm2m_b64_to_f64>
   1d660:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
   1d663:	85 c0                	test   %eax,%eax
   1d665:	79 2e                	jns    1d695 <get_float64fix+0xea>
			LOG_ERR("binary64 conversion error: %d", ret);
   1d667:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d66e:	74 23                	je     1d693 <get_float64fix+0xe8>
   1d670:	ba 04 52 02 00       	mov    $0x25204,%edx
   1d675:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1d67b:	c1 ea 03             	shr    $0x3,%edx
   1d67e:	c1 e2 06             	shl    $0x6,%edx
   1d681:	83 ca 01             	or     $0x1,%edx
   1d684:	52                   	push   %edx
   1d685:	50                   	push   %eax
   1d686:	68 6d a0 02 00       	push   $0x2a06d
   1d68b:	e8 1f 5e fe ff       	call   34af <log_1>
   1d690:	83 c4 0c             	add    $0xc,%esp
			return 0;
   1d693:	31 f6                	xor    %esi,%esi
}
   1d695:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d698:	89 f0                	mov    %esi,%eax
   1d69a:	5b                   	pop    %ebx
   1d69b:	5e                   	pop    %esi
   1d69c:	5f                   	pop    %edi
   1d69d:	5d                   	pop    %ebp
   1d69e:	c3                   	ret    

0001d69f <get_float32fix>:
{
   1d69f:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
   1d6a0:	31 c9                	xor    %ecx,%ecx
{
   1d6a2:	89 e5                	mov    %esp,%ebp
   1d6a4:	57                   	push   %edi
   1d6a5:	56                   	push   %esi
   1d6a6:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
   1d6a7:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
   1d6aa:	83 ec 0c             	sub    $0xc,%esp
   1d6ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t size = oma_tlv_get(&tlv, in, false);
   1d6b0:	89 da                	mov    %ebx,%edx
   1d6b2:	e8 91 fa ff ff       	call   1d148 <oma_tlv_get>
	if (size > 0) {
   1d6b7:	85 c0                	test   %eax,%eax
   1d6b9:	0f 84 c8 00 00 00    	je     1d787 <get_float32fix+0xe8>
		if (tlv.length != 4) {
   1d6bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1d6c2:	83 fa 04             	cmp    $0x4,%edx
   1d6c5:	74 5d                	je     1d724 <get_float32fix+0x85>
			LOG_ERR("Invalid float32 length: %d", tlv.length);
   1d6c7:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d6ce:	74 45                	je     1d715 <get_float32fix+0x76>
   1d6d0:	b8 04 52 02 00       	mov    $0x25204,%eax
   1d6d5:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1d6da:	c1 e8 03             	shr    $0x3,%eax
   1d6dd:	c1 e0 06             	shl    $0x6,%eax
   1d6e0:	83 c8 01             	or     $0x1,%eax
   1d6e3:	50                   	push   %eax
   1d6e4:	52                   	push   %edx
   1d6e5:	68 8b a0 02 00       	push   $0x2a08b
   1d6ea:	e8 c0 5d fe ff       	call   34af <log_1>
   1d6ef:	83 c4 0c             	add    $0xc,%esp
   1d6f2:	eb 21                	jmp    1d715 <get_float32fix+0x76>
						CPKT_BUF_READ(in->in_cpkt),
   1d6f4:	8b 43 04             	mov    0x4(%ebx),%eax
				if (buf_read_u8(b32,
   1d6f7:	8d 53 08             	lea    0x8(%ebx),%edx
   1d6fa:	52                   	push   %edx
   1d6fb:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d6ff:	8b 08                	mov    (%eax),%ecx
   1d701:	52                   	push   %edx
   1d702:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1d705:	ba 01 00 00 00       	mov    $0x1,%edx
   1d70a:	e8 de f9 ff ff       	call   1d0ed <buf_read>
   1d70f:	5e                   	pop    %esi
   1d710:	5f                   	pop    %edi
   1d711:	85 c0                	test   %eax,%eax
   1d713:	78 72                	js     1d787 <get_float32fix+0xe8>
			while (tlv.length--) {
   1d715:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d718:	85 c0                	test   %eax,%eax
   1d71a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1d71d:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1d720:	75 d2                	jne    1d6f4 <get_float32fix+0x55>
   1d722:	eb 63                	jmp    1d787 <get_float32fix+0xe8>
   1d724:	89 c6                	mov    %eax,%esi
		if (buf_read(b32, tlv.length, CPKT_BUF_READ(in->in_cpkt),
   1d726:	8b 43 04             	mov    0x4(%ebx),%eax
   1d729:	83 c3 08             	add    $0x8,%ebx
   1d72c:	8d 7d e8             	lea    -0x18(%ebp),%edi
   1d72f:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   1d733:	53                   	push   %ebx
   1d734:	8b 08                	mov    (%eax),%ecx
   1d736:	52                   	push   %edx
   1d737:	89 f8                	mov    %edi,%eax
   1d739:	ba 04 00 00 00       	mov    $0x4,%edx
   1d73e:	e8 aa f9 ff ff       	call   1d0ed <buf_read>
   1d743:	5a                   	pop    %edx
   1d744:	59                   	pop    %ecx
   1d745:	85 c0                	test   %eax,%eax
   1d747:	78 3e                	js     1d787 <get_float32fix+0xe8>
		ret = lwm2m_b32_to_f32(b32, sizeof(b32), value);
   1d749:	ff 75 0c             	pushl  0xc(%ebp)
   1d74c:	6a 04                	push   $0x4
   1d74e:	57                   	push   %edi
   1d74f:	e8 37 0a 00 00       	call   1e18b <lwm2m_b32_to_f32>
   1d754:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
   1d757:	85 c0                	test   %eax,%eax
   1d759:	79 2e                	jns    1d789 <get_float32fix+0xea>
			LOG_ERR("binary32 conversion error: %d", ret);
   1d75b:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d762:	74 23                	je     1d787 <get_float32fix+0xe8>
   1d764:	ba 04 52 02 00       	mov    $0x25204,%edx
   1d769:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1d76f:	c1 ea 03             	shr    $0x3,%edx
   1d772:	c1 e2 06             	shl    $0x6,%edx
   1d775:	83 ca 01             	or     $0x1,%edx
   1d778:	52                   	push   %edx
   1d779:	50                   	push   %eax
   1d77a:	68 a6 a0 02 00       	push   $0x2a0a6
   1d77f:	e8 2b 5d fe ff       	call   34af <log_1>
   1d784:	83 c4 0c             	add    $0xc,%esp
			return 0;
   1d787:	31 f6                	xor    %esi,%esi
}
   1d789:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d78c:	89 f0                	mov    %esi,%eax
   1d78e:	5b                   	pop    %ebx
   1d78f:	5e                   	pop    %esi
   1d790:	5f                   	pop    %edi
   1d791:	5d                   	pop    %ebp
   1d792:	c3                   	ret    

0001d793 <oma_tlv_put_u8>:
{
   1d793:	55                   	push   %ebp
   1d794:	89 e5                	mov    %esp,%ebp
   1d796:	57                   	push   %edi
   1d797:	56                   	push   %esi
   1d798:	53                   	push   %ebx
   1d799:	83 ec 10             	sub    $0x10,%esp
   1d79c:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if (insert) {
   1d79f:	84 c9                	test   %cl,%cl
   1d7a1:	74 72                	je     1d815 <oma_tlv_put_u8+0x82>
		fd = engine_get_out_user_data(out);
   1d7a3:	8b 70 08             	mov    0x8(%eax),%esi
			return 0;
   1d7a6:	31 ff                	xor    %edi,%edi
		if (!fd) {
   1d7a8:	85 f6                	test   %esi,%esi
   1d7aa:	0f 84 9e 00 00 00    	je     1d84e <oma_tlv_put_u8+0xbb>
		ret = buf_insert(CPKT_BUF_WRITE(out->out_cpkt),
   1d7b0:	8b 58 04             	mov    0x4(%eax),%ebx
		return -EINVAL;
   1d7b3:	bf ea ff ff ff       	mov    $0xffffffea,%edi
   1d7b8:	0f b7 0e             	movzwl (%esi),%ecx
   1d7bb:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
   1d7bf:	89 c2                	mov    %eax,%edx
   1d7c1:	8b 03                	mov    (%ebx),%eax
	if (!dst || !src) {
   1d7c3:	85 c0                	test   %eax,%eax
   1d7c5:	0f 84 83 00 00 00    	je     1d84e <oma_tlv_put_u8+0xbb>
	if (*dst_len + src_len > dst_size) {
   1d7cb:	0f b7 7b 04          	movzwl 0x4(%ebx),%edi
   1d7cf:	89 7d ec             	mov    %edi,-0x14(%ebp)
   1d7d2:	47                   	inc    %edi
   1d7d3:	89 7d e8             	mov    %edi,-0x18(%ebp)
   1d7d6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1d7d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
		return -ENOMEM;
   1d7dc:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (*dst_len + src_len > dst_size) {
   1d7e1:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
   1d7e4:	7c 68                	jl     1d84e <oma_tlv_put_u8+0xbb>
	memmove(dst + offset + src_len, dst + offset, *dst_len - offset);
   1d7e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1d7e9:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
   1d7ec:	29 ca                	sub    %ecx,%edx
   1d7ee:	8d 44 08 01          	lea    0x1(%eax,%ecx,1),%eax
   1d7f2:	52                   	push   %edx
   1d7f3:	57                   	push   %edi
   1d7f4:	50                   	push   %eax
   1d7f5:	e8 fe d0 fe ff       	call   a8f8 <memmove>
   1d7fa:	83 c4 0c             	add    $0xc,%esp
	memcpy(dst + offset, src, src_len);
   1d7fd:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1d800:	6a 01                	push   $0x1
   1d802:	50                   	push   %eax
   1d803:	57                   	push   %edi
   1d804:	e8 28 d1 fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1d809:	66 ff 43 04          	incw   0x4(%ebx)
	memcpy(dst + offset, src, src_len);
   1d80d:	83 c4 0c             	add    $0xc,%esp
		fd->mark_pos++;
   1d810:	66 ff 06             	incw   (%esi)
   1d813:	eb 37                	jmp    1d84c <oma_tlv_put_u8+0xb9>
		ret = buf_append(CPKT_BUF_WRITE(out->out_cpkt), &value, 1);
   1d815:	8b 58 04             	mov    0x4(%eax),%ebx
		return -EINVAL;
   1d818:	bf ea ff ff ff       	mov    $0xffffffea,%edi
   1d81d:	8b 03                	mov    (%ebx),%eax
   1d81f:	0f b7 73 06          	movzwl 0x6(%ebx),%esi
	if (!dst || !src) {
   1d823:	85 c0                	test   %eax,%eax
   1d825:	74 27                	je     1d84e <oma_tlv_put_u8+0xbb>
	if (*dst_len + src_len > dst_size) {
   1d827:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
		return -ENOMEM;
   1d82b:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (*dst_len + src_len > dst_size) {
   1d830:	8d 4a 01             	lea    0x1(%edx),%ecx
   1d833:	39 ce                	cmp    %ecx,%esi
   1d835:	7c 17                	jl     1d84e <oma_tlv_put_u8+0xbb>
	memcpy(dst + *dst_len, src, src_len);
   1d837:	6a 01                	push   $0x1
   1d839:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1d83c:	51                   	push   %ecx
   1d83d:	01 d0                	add    %edx,%eax
   1d83f:	50                   	push   %eax
   1d840:	e8 ec d0 fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1d845:	66 ff 43 04          	incw   0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
   1d849:	83 c4 0c             	add    $0xc,%esp
	return 0;
   1d84c:	31 ff                	xor    %edi,%edi
}
   1d84e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d851:	89 f8                	mov    %edi,%eax
   1d853:	5b                   	pop    %ebx
   1d854:	5e                   	pop    %esi
   1d855:	5f                   	pop    %edi
   1d856:	5d                   	pop    %ebp
   1d857:	c3                   	ret    

0001d858 <oma_tlv_put>:
{
   1d858:	55                   	push   %ebp
   1d859:	89 e5                	mov    %esp,%ebp
   1d85b:	57                   	push   %edi
   1d85c:	56                   	push   %esi
   1d85d:	89 c7                	mov    %eax,%edi
   1d85f:	53                   	push   %ebx
   1d860:	83 ec 14             	sub    $0x14,%esp
   1d863:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1d866:	8b 45 08             	mov    0x8(%ebp),%eax
	len_type = get_len_type(tlv);
   1d869:	8b 57 04             	mov    0x4(%edi),%edx
{
   1d86c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   1d86f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return 0;
   1d872:	31 c9                	xor    %ecx,%ecx
	if (tlv->length < 8) {
   1d874:	83 fa 07             	cmp    $0x7,%edx
   1d877:	76 16                	jbe    1d88f <oma_tlv_put+0x37>
		return 1;
   1d879:	b1 01                	mov    $0x1,%cl
	} else if (tlv->length < 0x100) {
   1d87b:	81 fa ff 00 00 00    	cmp    $0xff,%edx
   1d881:	76 0c                	jbe    1d88f <oma_tlv_put+0x37>
		return 2;
   1d883:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
   1d889:	0f 97 c1             	seta   %cl
   1d88c:	83 c1 02             	add    $0x2,%ecx
	tmp = (tlv->type << 6) |
   1d88f:	0f b6 07             	movzbl (%edi),%eax
   1d892:	c1 e0 06             	shl    $0x6,%eax
   1d895:	66 81 7f 02 00 01    	cmpw   $0x100,0x2(%edi)
	      (len_type << 3) |
   1d89b:	0f b6 f1             	movzbl %cl,%esi
	tmp = (tlv->type << 6) |
   1d89e:	19 db                	sbb    %ebx,%ebx
	      (len_type << 3) |
   1d8a0:	89 75 e0             	mov    %esi,-0x20(%ebp)
	tmp = (tlv->type << 6) |
   1d8a3:	f7 d3                	not    %ebx
	      (len_type << 3) |
   1d8a5:	c1 e6 03             	shl    $0x3,%esi
	tmp = (tlv->type << 6) |
   1d8a8:	83 e3 20             	and    $0x20,%ebx
	      (tlv->id > 255 ? (1 << 5) : 0) |
   1d8ab:	09 f0                	or     %esi,%eax
   1d8ad:	09 d8                	or     %ebx,%eax
	      (len_type << 3) |
   1d8af:	84 c9                	test   %cl,%cl
   1d8b1:	74 02                	je     1d8b5 <oma_tlv_put+0x5d>
   1d8b3:	31 d2                	xor    %edx,%edx
	ret = oma_tlv_put_u8(out, tmp, insert);
   1d8b5:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
	tmp = (tlv->type << 6) |
   1d8b9:	09 c2                	or     %eax,%edx
	ret = oma_tlv_put_u8(out, tmp, insert);
   1d8bb:	89 f1                	mov    %esi,%ecx
   1d8bd:	0f b6 d2             	movzbl %dl,%edx
   1d8c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d8c3:	e8 cb fe ff ff       	call   1d793 <oma_tlv_put_u8>
	if (ret < 0) {
   1d8c8:	85 c0                	test   %eax,%eax
   1d8ca:	79 07                	jns    1d8d3 <oma_tlv_put+0x7b>
		return 0;
   1d8cc:	31 c0                	xor    %eax,%eax
   1d8ce:	e9 d3 00 00 00       	jmp    1d9a6 <oma_tlv_put+0x14e>
	if (tlv->id > 255) {
   1d8d3:	66 8b 57 02          	mov    0x2(%edi),%dx
   1d8d7:	66 81 fa ff 00       	cmp    $0xff,%dx
   1d8dc:	76 18                	jbe    1d8f6 <oma_tlv_put+0x9e>
		ret = oma_tlv_put_u8(out, (tlv->id >> 8) & 0xff, insert);
   1d8de:	0f b6 d6             	movzbl %dh,%edx
   1d8e1:	89 f1                	mov    %esi,%ecx
   1d8e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d8e6:	e8 a8 fe ff ff       	call   1d793 <oma_tlv_put_u8>
		pos++;
   1d8eb:	bb 02 00 00 00       	mov    $0x2,%ebx
		if (ret < 0) {
   1d8f0:	85 c0                	test   %eax,%eax
   1d8f2:	79 07                	jns    1d8fb <oma_tlv_put+0xa3>
   1d8f4:	eb d6                	jmp    1d8cc <oma_tlv_put+0x74>
	pos = 1;
   1d8f6:	bb 01 00 00 00       	mov    $0x1,%ebx
	ret = oma_tlv_put_u8(out, tlv->id & 0xff, insert);
   1d8fb:	0f b6 57 02          	movzbl 0x2(%edi),%edx
   1d8ff:	89 f1                	mov    %esi,%ecx
   1d901:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d904:	e8 8a fe ff ff       	call   1d793 <oma_tlv_put_u8>
	if (ret < 0) {
   1d909:	85 c0                	test   %eax,%eax
   1d90b:	78 bf                	js     1d8cc <oma_tlv_put+0x74>
	pos++;
   1d90d:	8d 43 01             	lea    0x1(%ebx),%eax
	for (i = 2; i >= 0; i--) {
   1d910:	bb 02 00 00 00       	mov    $0x2,%ebx
	pos++;
   1d915:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (len_type > i) {
   1d918:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
   1d91b:	7e 20                	jle    1d93d <oma_tlv_put+0xe5>
					     (tlv->length >> (i * 8)) & 0xff,
   1d91d:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
   1d924:	8b 57 04             	mov    0x4(%edi),%edx
   1d927:	d3 ea                	shr    %cl,%edx
			ret = oma_tlv_put_u8(out,
   1d929:	0f b6 d2             	movzbl %dl,%edx
   1d92c:	89 f1                	mov    %esi,%ecx
   1d92e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d931:	e8 5d fe ff ff       	call   1d793 <oma_tlv_put_u8>
			if (ret < 0) {
   1d936:	85 c0                	test   %eax,%eax
   1d938:	78 92                	js     1d8cc <oma_tlv_put+0x74>
			pos++;
   1d93a:	ff 45 ec             	incl   -0x14(%ebp)
	for (i = 2; i >= 0; i--) {
   1d93d:	4b                   	dec    %ebx
   1d93e:	83 fb ff             	cmp    $0xffffffff,%ebx
   1d941:	75 d5                	jne    1d918 <oma_tlv_put+0xc0>
	if (value != NULL && tlv->length > 0 && !insert) {
   1d943:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1d947:	74 57                	je     1d9a0 <oma_tlv_put+0x148>
   1d949:	8b 77 04             	mov    0x4(%edi),%esi
   1d94c:	85 f6                	test   %esi,%esi
   1d94e:	74 50                	je     1d9a0 <oma_tlv_put+0x148>
   1d950:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
   1d954:	75 4a                	jne    1d9a0 <oma_tlv_put+0x148>
		if (buf_append(CPKT_BUF_WRITE(out->out_cpkt),
   1d956:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1d959:	0f b7 d6             	movzwl %si,%edx
   1d95c:	8b 58 04             	mov    0x4(%eax),%ebx
   1d95f:	8b 0b                	mov    (%ebx),%ecx
   1d961:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
   1d965:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (!dst || !src) {
   1d968:	85 c9                	test   %ecx,%ecx
   1d96a:	0f 84 5c ff ff ff    	je     1d8cc <oma_tlv_put+0x74>
	if (*dst_len + src_len > dst_size) {
   1d970:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
   1d974:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
   1d977:	01 d1                	add    %edx,%ecx
   1d979:	89 4d e0             	mov    %ecx,-0x20(%ebp)
   1d97c:	89 c1                	mov    %eax,%ecx
   1d97e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1d981:	39 c1                	cmp    %eax,%ecx
   1d983:	0f 8c 43 ff ff ff    	jl     1d8cc <oma_tlv_put+0x74>
	memcpy(dst + *dst_len, src, src_len);
   1d989:	52                   	push   %edx
   1d98a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1d98d:	ff 75 e8             	pushl  -0x18(%ebp)
   1d990:	03 45 f0             	add    -0x10(%ebp),%eax
   1d993:	50                   	push   %eax
   1d994:	e8 98 cf fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1d999:	66 01 73 04          	add    %si,0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
   1d99d:	83 c4 0c             	add    $0xc,%esp
	return pos + tlv->length;
   1d9a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1d9a3:	03 47 04             	add    0x4(%edi),%eax
}
   1d9a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1d9a9:	5b                   	pop    %ebx
   1d9aa:	5e                   	pop    %esi
   1d9ab:	5f                   	pop    %edi
   1d9ac:	5d                   	pop    %ebp
   1d9ad:	c3                   	ret    

0001d9ae <put_float64fix>:
{
   1d9ae:	55                   	push   %ebp
   1d9af:	89 e5                	mov    %esp,%ebp
   1d9b1:	57                   	push   %edi
   1d9b2:	56                   	push   %esi
   1d9b3:	53                   	push   %ebx
   1d9b4:	83 ec 10             	sub    $0x10,%esp
	fd = engine_get_out_user_data(out);
   1d9b7:	8b 45 08             	mov    0x8(%ebp),%eax
{
   1d9ba:	8b 75 0c             	mov    0xc(%ebp),%esi
	fd = engine_get_out_user_data(out);
   1d9bd:	8b 58 08             	mov    0x8(%eax),%ebx
	if (!fd) {
   1d9c0:	85 db                	test   %ebx,%ebx
   1d9c2:	74 41                	je     1da05 <put_float64fix+0x57>
	ret = lwm2m_f64_to_b64(value, b64, sizeof(b64));
   1d9c4:	6a 08                	push   $0x8
   1d9c6:	8d 7d ec             	lea    -0x14(%ebp),%edi
   1d9c9:	57                   	push   %edi
   1d9ca:	ff 75 10             	pushl  0x10(%ebp)
   1d9cd:	e8 c0 05 00 00       	call   1df92 <lwm2m_f64_to_b64>
   1d9d2:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1d9d5:	85 c0                	test   %eax,%eax
   1d9d7:	79 30                	jns    1da09 <put_float64fix+0x5b>
		LOG_ERR("float64 conversion error: %d", ret);
   1d9d9:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1d9e0:	74 23                	je     1da05 <put_float64fix+0x57>
   1d9e2:	ba 04 52 02 00       	mov    $0x25204,%edx
   1d9e7:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1d9ed:	c1 ea 03             	shr    $0x3,%edx
   1d9f0:	c1 e2 06             	shl    $0x6,%edx
   1d9f3:	83 ca 01             	or     $0x1,%edx
   1d9f6:	52                   	push   %edx
   1d9f7:	50                   	push   %eax
   1d9f8:	68 c4 a0 02 00       	push   $0x2a0c4
   1d9fd:	e8 ad 5a fe ff       	call   34af <log_1>
   1da02:	83 c4 0c             	add    $0xc,%esp
		return 0;
   1da05:	31 c0                	xor    %eax,%eax
   1da07:	eb 32                	jmp    1da3b <put_float64fix+0x8d>
			path->res_inst_id : path->res_id;
   1da09:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
   1da0d:	74 08                	je     1da17 <put_float64fix+0x69>
   1da0f:	66 8b 46 06          	mov    0x6(%esi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1da13:	b2 01                	mov    $0x1,%dl
   1da15:	eb 06                	jmp    1da1d <put_float64fix+0x6f>
			path->res_inst_id : path->res_id;
   1da17:	66 8b 46 04          	mov    0x4(%esi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1da1b:	b2 03                	mov    $0x3,%dl
		tlv->type = type;
   1da1d:	88 55 e4             	mov    %dl,-0x1c(%ebp)
		tlv->id = id;
   1da20:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	len = oma_tlv_put(&tlv, out, b64, false);
   1da24:	6a 00                	push   $0x0
   1da26:	8b 55 08             	mov    0x8(%ebp),%edx
   1da29:	89 f9                	mov    %edi,%ecx
   1da2b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		tlv->length = buflen;
   1da2e:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	len = oma_tlv_put(&tlv, out, b64, false);
   1da35:	e8 1e fe ff ff       	call   1d858 <oma_tlv_put>
   1da3a:	5a                   	pop    %edx
}
   1da3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1da3e:	5b                   	pop    %ebx
   1da3f:	5e                   	pop    %esi
   1da40:	5f                   	pop    %edi
   1da41:	5d                   	pop    %ebp
   1da42:	c3                   	ret    

0001da43 <put_string>:
{
   1da43:	55                   	push   %ebp
   1da44:	31 c0                	xor    %eax,%eax
   1da46:	89 e5                	mov    %esp,%ebp
   1da48:	83 ec 08             	sub    $0x8,%esp
   1da4b:	8b 55 08             	mov    0x8(%ebp),%edx
	fd = engine_get_out_user_data(out);
   1da4e:	8b 4a 08             	mov    0x8(%edx),%ecx
	if (!fd) {
   1da51:	85 c9                	test   %ecx,%ecx
   1da53:	74 30                	je     1da85 <put_string+0x42>
		  path->res_id, (u32_t)buflen);
   1da55:	8b 45 0c             	mov    0xc(%ebp),%eax
   1da58:	66 8b 40 04          	mov    0x4(%eax),%ax
   1da5c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1da60:	8a 41 06             	mov    0x6(%ecx),%al
   1da63:	83 e0 02             	and    $0x2,%eax
	len = oma_tlv_put(&tlv, out, (u8_t *)buf, false);
   1da66:	6a 00                	push   $0x0
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1da68:	3c 01                	cmp    $0x1,%al
	len = oma_tlv_put(&tlv, out, (u8_t *)buf, false);
   1da6a:	8b 4d 10             	mov    0x10(%ebp),%ecx
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1da6d:	19 c0                	sbb    %eax,%eax
   1da6f:	83 e0 02             	and    $0x2,%eax
   1da72:	40                   	inc    %eax
		tlv->type = type;
   1da73:	88 45 f8             	mov    %al,-0x8(%ebp)
		tlv->length = buflen;
   1da76:	8b 45 14             	mov    0x14(%ebp),%eax
   1da79:	89 45 fc             	mov    %eax,-0x4(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)buf, false);
   1da7c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1da7f:	e8 d4 fd ff ff       	call   1d858 <oma_tlv_put>
   1da84:	5a                   	pop    %edx
}
   1da85:	c9                   	leave  
   1da86:	c3                   	ret    

0001da87 <put_s64>:
{
   1da87:	55                   	push   %ebp
   1da88:	31 c0                	xor    %eax,%eax
   1da8a:	89 e5                	mov    %esp,%ebp
   1da8c:	57                   	push   %edi
   1da8d:	56                   	push   %esi
   1da8e:	53                   	push   %ebx
   1da8f:	83 ec 10             	sub    $0x10,%esp
   1da92:	8b 55 08             	mov    0x8(%ebp),%edx
   1da95:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1da98:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1da9b:	8b 7d 14             	mov    0x14(%ebp),%edi
	fd = engine_get_out_user_data(out);
   1da9e:	8b 72 08             	mov    0x8(%edx),%esi
	if (!fd) {
   1daa1:	85 f6                	test   %esi,%esi
   1daa3:	74 3c                	je     1dae1 <put_s64+0x5a>
	net_value = sys_cpu_to_be64(value);
   1daa5:	89 f8                	mov    %edi,%eax
   1daa7:	0f c9                	bswap  %ecx
   1daa9:	0f c8                	bswap  %eax
   1daab:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1daae:	89 4d f0             	mov    %ecx,-0x10(%ebp)
			path->res_inst_id : path->res_id;
   1dab1:	f6 46 06 02          	testb  $0x2,0x6(%esi)
   1dab5:	74 08                	je     1dabf <put_s64+0x38>
   1dab7:	66 8b 43 06          	mov    0x6(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dabb:	b1 01                	mov    $0x1,%cl
   1dabd:	eb 06                	jmp    1dac5 <put_s64+0x3e>
			path->res_inst_id : path->res_id;
   1dabf:	66 8b 43 04          	mov    0x4(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dac3:	b1 03                	mov    $0x3,%cl
		tlv->type = type;
   1dac5:	88 4d e4             	mov    %cl,-0x1c(%ebp)
		tlv->id = id;
   1dac8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1dacc:	6a 00                	push   $0x0
   1dace:	8d 4d ec             	lea    -0x14(%ebp),%ecx
   1dad1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		tlv->length = buflen;
   1dad4:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1dadb:	e8 78 fd ff ff       	call   1d858 <oma_tlv_put>
   1dae0:	5a                   	pop    %edx
}
   1dae1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1dae4:	5b                   	pop    %ebx
   1dae5:	5e                   	pop    %esi
   1dae6:	5f                   	pop    %edi
   1dae7:	5d                   	pop    %ebp
   1dae8:	c3                   	ret    

0001dae9 <put_s32>:
{
   1dae9:	55                   	push   %ebp
   1daea:	31 c0                	xor    %eax,%eax
   1daec:	89 e5                	mov    %esp,%ebp
   1daee:	53                   	push   %ebx
   1daef:	83 ec 0c             	sub    $0xc,%esp
   1daf2:	8b 55 08             	mov    0x8(%ebp),%edx
   1daf5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	fd = engine_get_out_user_data(out);
   1daf8:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!fd) {
   1dafb:	85 db                	test   %ebx,%ebx
   1dafd:	74 38                	je     1db37 <put_s32+0x4e>
	net_value = sys_cpu_to_be32(value);
   1daff:	8b 45 10             	mov    0x10(%ebp),%eax
			path->res_inst_id : path->res_id;
   1db02:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
   1db06:	0f c8                	bswap  %eax
	net_value = sys_cpu_to_be32(value);
   1db08:	89 45 f0             	mov    %eax,-0x10(%ebp)
			path->res_inst_id : path->res_id;
   1db0b:	74 08                	je     1db15 <put_s32+0x2c>
   1db0d:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1db11:	b1 01                	mov    $0x1,%cl
   1db13:	eb 06                	jmp    1db1b <put_s32+0x32>
			path->res_inst_id : path->res_id;
   1db15:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1db19:	b1 03                	mov    $0x3,%cl
		tlv->type = type;
   1db1b:	88 4d f4             	mov    %cl,-0xc(%ebp)
		tlv->id = id;
   1db1e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1db22:	6a 00                	push   $0x0
   1db24:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1db27:	8d 45 f4             	lea    -0xc(%ebp),%eax
		tlv->length = buflen;
   1db2a:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1db31:	e8 22 fd ff ff       	call   1d858 <oma_tlv_put>
   1db36:	5a                   	pop    %edx
}
   1db37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1db3a:	c9                   	leave  
   1db3b:	c3                   	ret    

0001db3c <put_s16>:
{
   1db3c:	55                   	push   %ebp
   1db3d:	31 c0                	xor    %eax,%eax
   1db3f:	89 e5                	mov    %esp,%ebp
   1db41:	56                   	push   %esi
   1db42:	53                   	push   %ebx
   1db43:	83 ec 0c             	sub    $0xc,%esp
   1db46:	8b 55 08             	mov    0x8(%ebp),%edx
   1db49:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1db4c:	8b 4d 10             	mov    0x10(%ebp),%ecx
	fd = engine_get_out_user_data(out);
   1db4f:	8b 72 08             	mov    0x8(%edx),%esi
	if (!fd) {
   1db52:	85 f6                	test   %esi,%esi
   1db54:	74 36                	je     1db8c <put_s16+0x50>
	net_value = sys_cpu_to_be16(value);
   1db56:	86 e9                	xchg   %ch,%cl
			path->res_inst_id : path->res_id;
   1db58:	f6 46 06 02          	testb  $0x2,0x6(%esi)
	net_value = sys_cpu_to_be16(value);
   1db5c:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
			path->res_inst_id : path->res_id;
   1db60:	74 08                	je     1db6a <put_s16+0x2e>
   1db62:	66 8b 43 06          	mov    0x6(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1db66:	b1 01                	mov    $0x1,%cl
   1db68:	eb 06                	jmp    1db70 <put_s16+0x34>
			path->res_inst_id : path->res_id;
   1db6a:	66 8b 43 04          	mov    0x4(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1db6e:	b1 03                	mov    $0x3,%cl
		tlv->type = type;
   1db70:	88 4d f0             	mov    %cl,-0x10(%ebp)
		tlv->id = id;
   1db73:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1db77:	6a 00                	push   $0x0
   1db79:	8d 4d ee             	lea    -0x12(%ebp),%ecx
   1db7c:	8d 45 f0             	lea    -0x10(%ebp),%eax
		tlv->length = buflen;
   1db7f:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&net_value, false);
   1db86:	e8 cd fc ff ff       	call   1d858 <oma_tlv_put>
   1db8b:	5a                   	pop    %edx
}
   1db8c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1db8f:	5b                   	pop    %ebx
   1db90:	5e                   	pop    %esi
   1db91:	5d                   	pop    %ebp
   1db92:	c3                   	ret    

0001db93 <put_s8>:
{
   1db93:	55                   	push   %ebp
   1db94:	89 e5                	mov    %esp,%ebp
   1db96:	53                   	push   %ebx
   1db97:	83 ec 0c             	sub    $0xc,%esp
   1db9a:	8b 55 08             	mov    0x8(%ebp),%edx
   1db9d:	8b 45 10             	mov    0x10(%ebp),%eax
   1dba0:	88 45 f0             	mov    %al,-0x10(%ebp)
   1dba3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	fd = engine_get_out_user_data(out);
   1dba6:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!fd) {
   1dba9:	31 c0                	xor    %eax,%eax
   1dbab:	85 db                	test   %ebx,%ebx
   1dbad:	74 30                	je     1dbdf <put_s8+0x4c>
			path->res_inst_id : path->res_id;
   1dbaf:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
   1dbb3:	74 08                	je     1dbbd <put_s8+0x2a>
   1dbb5:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dbb9:	b1 01                	mov    $0x1,%cl
   1dbbb:	eb 06                	jmp    1dbc3 <put_s8+0x30>
			path->res_inst_id : path->res_id;
   1dbbd:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dbc1:	b1 03                	mov    $0x3,%cl
		tlv->type = type;
   1dbc3:	88 4d f4             	mov    %cl,-0xc(%ebp)
		tlv->id = id;
   1dbc6:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&value, false);
   1dbca:	6a 00                	push   $0x0
   1dbcc:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1dbcf:	8d 45 f4             	lea    -0xc(%ebp),%eax
		tlv->length = buflen;
   1dbd2:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
	len = oma_tlv_put(&tlv, out, (u8_t *)&value, false);
   1dbd9:	e8 7a fc ff ff       	call   1d858 <oma_tlv_put>
   1dbde:	5a                   	pop    %edx
}
   1dbdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1dbe2:	c9                   	leave  
   1dbe3:	c3                   	ret    

0001dbe4 <put_bool>:
{
   1dbe4:	55                   	push   %ebp
   1dbe5:	89 e5                	mov    %esp,%ebp
	return put_s8(out, path, value_s8);
   1dbe7:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
   1dbeb:	89 45 10             	mov    %eax,0x10(%ebp)
}
   1dbee:	5d                   	pop    %ebp
	return put_s8(out, path, value_s8);
   1dbef:	e9 9f ff ff ff       	jmp    1db93 <put_s8>

0001dbf4 <put_end_ri>:
{
   1dbf4:	55                   	push   %ebp
   1dbf5:	89 e5                	mov    %esp,%ebp
   1dbf7:	57                   	push   %edi
   1dbf8:	56                   	push   %esi
   1dbf9:	53                   	push   %ebx
   1dbfa:	83 ec 08             	sub    $0x8,%esp
   1dbfd:	8b 55 08             	mov    0x8(%ebp),%edx
	fd = engine_get_out_user_data(out);
   1dc00:	8b 42 08             	mov    0x8(%edx),%eax
	if (!fd) {
   1dc03:	85 c0                	test   %eax,%eax
   1dc05:	74 33                	je     1dc3a <put_end_ri+0x46>
			   OMA_TLV_TYPE_MULTI_RESOURCE, path->res_id);
   1dc07:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return put_end_tlv(out, fd->mark_pos_ri, &fd->writer_flags,
   1dc0a:	0f b7 78 04          	movzwl 0x4(%eax),%edi
			   OMA_TLV_TYPE_MULTI_RESOURCE, path->res_id);
   1dc0e:	66 8b 71 04          	mov    0x4(%ecx),%si
	*writer_flags &= ~writer_flag;
   1dc12:	80 60 06 fd          	andb   $0xfd,0x6(%eax)
	len = out->out_cpkt->offset - mark_pos;
   1dc16:	8b 4a 04             	mov    0x4(%edx),%ecx
   1dc19:	0f b7 49 04          	movzwl 0x4(%ecx),%ecx
   1dc1d:	29 f9                	sub    %edi,%ecx
	fd->mark_pos = mark_pos;
   1dc1f:	66 89 38             	mov    %di,(%eax)
		tlv->length = buflen;
   1dc22:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
   1dc25:	6a 01                	push   $0x1
   1dc27:	31 c9                	xor    %ecx,%ecx
   1dc29:	8d 45 ec             	lea    -0x14(%ebp),%eax
		tlv->type = type;
   1dc2c:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
		tlv->id = id;
   1dc30:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
   1dc34:	e8 1f fc ff ff       	call   1d858 <oma_tlv_put>
   1dc39:	58                   	pop    %eax
}
   1dc3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1dc3d:	31 c0                	xor    %eax,%eax
   1dc3f:	5b                   	pop    %ebx
   1dc40:	5e                   	pop    %esi
   1dc41:	5f                   	pop    %edi
   1dc42:	5d                   	pop    %ebp
   1dc43:	c3                   	ret    

0001dc44 <put_float32fix>:
{
   1dc44:	55                   	push   %ebp
   1dc45:	89 e5                	mov    %esp,%ebp
   1dc47:	57                   	push   %edi
   1dc48:	56                   	push   %esi
   1dc49:	53                   	push   %ebx
   1dc4a:	83 ec 0c             	sub    $0xc,%esp
	fd = engine_get_out_user_data(out);
   1dc4d:	8b 45 08             	mov    0x8(%ebp),%eax
{
   1dc50:	8b 75 0c             	mov    0xc(%ebp),%esi
	fd = engine_get_out_user_data(out);
   1dc53:	8b 58 08             	mov    0x8(%eax),%ebx
	if (!fd) {
   1dc56:	85 db                	test   %ebx,%ebx
   1dc58:	74 41                	je     1dc9b <put_float32fix+0x57>
	ret = lwm2m_f32_to_b32(value, b32, sizeof(b32));
   1dc5a:	6a 04                	push   $0x4
   1dc5c:	8d 7d e8             	lea    -0x18(%ebp),%edi
   1dc5f:	57                   	push   %edi
   1dc60:	ff 75 10             	pushl  0x10(%ebp)
   1dc63:	e8 26 02 00 00       	call   1de8e <lwm2m_f32_to_b32>
   1dc68:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1dc6b:	85 c0                	test   %eax,%eax
   1dc6d:	79 30                	jns    1dc9f <put_float32fix+0x5b>
		LOG_ERR("float32 conversion error: %d", ret);
   1dc6f:	f6 05 c0 a8 40 00 07 	testb  $0x7,0x40a8c0
   1dc76:	74 23                	je     1dc9b <put_float32fix+0x57>
   1dc78:	ba 04 52 02 00       	mov    $0x25204,%edx
   1dc7d:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1dc83:	c1 ea 03             	shr    $0x3,%edx
   1dc86:	c1 e2 06             	shl    $0x6,%edx
   1dc89:	83 ca 01             	or     $0x1,%edx
   1dc8c:	52                   	push   %edx
   1dc8d:	50                   	push   %eax
   1dc8e:	68 e1 a0 02 00       	push   $0x2a0e1
   1dc93:	e8 17 58 fe ff       	call   34af <log_1>
   1dc98:	83 c4 0c             	add    $0xc,%esp
		return 0;
   1dc9b:	31 c0                	xor    %eax,%eax
   1dc9d:	eb 32                	jmp    1dcd1 <put_float32fix+0x8d>
			path->res_inst_id : path->res_id;
   1dc9f:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
   1dca3:	74 08                	je     1dcad <put_float32fix+0x69>
   1dca5:	66 8b 46 06          	mov    0x6(%esi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dca9:	b2 01                	mov    $0x1,%dl
   1dcab:	eb 06                	jmp    1dcb3 <put_float32fix+0x6f>
			path->res_inst_id : path->res_id;
   1dcad:	66 8b 46 04          	mov    0x4(%esi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
   1dcb1:	b2 03                	mov    $0x3,%dl
		tlv->type = type;
   1dcb3:	88 55 ec             	mov    %dl,-0x14(%ebp)
		tlv->id = id;
   1dcb6:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	len = oma_tlv_put(&tlv, out, b32, false);
   1dcba:	6a 00                	push   $0x0
   1dcbc:	8b 55 08             	mov    0x8(%ebp),%edx
   1dcbf:	89 f9                	mov    %edi,%ecx
   1dcc1:	8d 45 ec             	lea    -0x14(%ebp),%eax
		tlv->length = buflen;
   1dcc4:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	len = oma_tlv_put(&tlv, out, b32, false);
   1dccb:	e8 88 fb ff ff       	call   1d858 <oma_tlv_put>
   1dcd0:	5a                   	pop    %edx
}
   1dcd1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1dcd4:	5b                   	pop    %ebx
   1dcd5:	5e                   	pop    %esi
   1dcd6:	5f                   	pop    %edi
   1dcd7:	5d                   	pop    %ebp
   1dcd8:	c3                   	ret    

0001dcd9 <put_end_oi>:
{
   1dcd9:	55                   	push   %ebp
   1dcda:	89 e5                	mov    %esp,%ebp
   1dcdc:	57                   	push   %edi
   1dcdd:	56                   	push   %esi
   1dcde:	53                   	push   %ebx
   1dcdf:	83 ec 08             	sub    $0x8,%esp
   1dce2:	8b 55 08             	mov    0x8(%ebp),%edx
	fd = engine_get_out_user_data(out);
   1dce5:	8b 4a 08             	mov    0x8(%edx),%ecx
	if (!fd) {
   1dce8:	85 c9                	test   %ecx,%ecx
   1dcea:	74 2f                	je     1dd1b <put_end_oi+0x42>
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
   1dcec:	8b 45 0c             	mov    0xc(%ebp),%eax
	return put_end_tlv(out, fd->mark_pos_oi, &fd->writer_flags, 0,
   1dcef:	0f b7 79 02          	movzwl 0x2(%ecx),%edi
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
   1dcf3:	66 8b 70 02          	mov    0x2(%eax),%si
	len = out->out_cpkt->offset - mark_pos;
   1dcf7:	8b 42 04             	mov    0x4(%edx),%eax
   1dcfa:	0f b7 40 04          	movzwl 0x4(%eax),%eax
   1dcfe:	29 f8                	sub    %edi,%eax
	fd->mark_pos = mark_pos;
   1dd00:	66 89 39             	mov    %di,(%ecx)
		tlv->length = buflen;
   1dd03:	89 45 f0             	mov    %eax,-0x10(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
   1dd06:	6a 01                	push   $0x1
   1dd08:	31 c9                	xor    %ecx,%ecx
   1dd0a:	8d 45 ec             	lea    -0x14(%ebp),%eax
		tlv->type = type;
   1dd0d:	c6 45 ec 00          	movb   $0x0,-0x14(%ebp)
		tlv->id = id;
   1dd11:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
   1dd15:	e8 3e fb ff ff       	call   1d858 <oma_tlv_put>
   1dd1a:	58                   	pop    %eax
}
   1dd1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1dd1e:	31 c0                	xor    %eax,%eax
   1dd20:	5b                   	pop    %ebx
   1dd21:	5e                   	pop    %esi
   1dd22:	5f                   	pop    %edi
   1dd23:	5d                   	pop    %ebp
   1dd24:	c3                   	ret    

0001dd25 <do_read_op_tlv>:
{
   1dd25:	55                   	push   %ebp
   1dd26:	89 e5                	mov    %esp,%ebp
   1dd28:	56                   	push   %esi
   1dd29:	53                   	push   %ebx
   1dd2a:	83 ec 08             	sub    $0x8,%esp
	(void)memset(&fd, 0, sizeof(fd));
   1dd2d:	8d 75 f0             	lea    -0x10(%ebp),%esi
{
   1dd30:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	(void)memset(&fd, 0, sizeof(fd));
   1dd33:	6a 08                	push   $0x8
   1dd35:	6a 00                	push   $0x0
   1dd37:	56                   	push   %esi
   1dd38:	e8 63 cc fe ff       	call   a9a0 <memset>
   1dd3d:	83 c4 0c             	add    $0xc,%esp
	out->user_data = user_data;
   1dd40:	89 73 1c             	mov    %esi,0x1c(%ebx)
	ret = lwm2m_perform_read_op(obj, msg, content_format);
   1dd43:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
   1dd47:	50                   	push   %eax
   1dd48:	53                   	push   %ebx
   1dd49:	ff 75 08             	pushl  0x8(%ebp)
   1dd4c:	e8 83 d1 ff ff       	call   1aed4 <lwm2m_perform_read_op>
	out->user_data = NULL;
   1dd51:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
   1dd58:	83 c4 0c             	add    $0xc,%esp
}
   1dd5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1dd5e:	5b                   	pop    %ebx
   1dd5f:	5e                   	pop    %esi
   1dd60:	5d                   	pop    %ebp
   1dd61:	c3                   	ret    

0001dd62 <do_write_op_tlv>:

int do_write_op_tlv(struct lwm2m_engine_obj *obj, struct lwm2m_message *msg)
{
   1dd62:	55                   	push   %ebp
   1dd63:	89 e5                	mov    %esp,%ebp
   1dd65:	57                   	push   %edi
   1dd66:	56                   	push   %esi
   1dd67:	53                   	push   %ebx
   1dd68:	83 ec 18             	sub    $0x18,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1dd6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
{
   1dd72:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	while (true) {
		/*
		 * This initial read of TLV data won't advance frag/offset.
		 * We need tlv.type to determine how to proceed.
		 */
		len = oma_tlv_get(&tlv, &msg->in, true);
   1dd75:	8d 7b 04             	lea    0x4(%ebx),%edi
   1dd78:	b9 01 00 00 00       	mov    $0x1,%ecx
   1dd7d:	89 fa                	mov    %edi,%edx
   1dd7f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1dd82:	e8 c1 f3 ff ff       	call   1d148 <oma_tlv_get>
		if (len == 0) {
   1dd87:	85 c0                	test   %eax,%eax
   1dd89:	0f 84 f5 00 00 00    	je     1de84 <do_write_op_tlv+0x122>
			break;
		}

		if (tlv.type == OMA_TLV_TYPE_OBJECT_INSTANCE) {
   1dd8f:	8a 45 e4             	mov    -0x1c(%ebp),%al
   1dd92:	84 c0                	test   %al,%al
   1dd94:	0f 85 a4 00 00 00    	jne    1de3e <do_write_op_tlv+0xdc>
			struct oma_tlv tlv2;
			int len2;
			int pos = 0;

			oma_tlv_get(&tlv, &msg->in, false);
   1dd9a:	31 c9                	xor    %ecx,%ecx
   1dd9c:	89 fa                	mov    %edi,%edx
   1dd9e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1dda1:	e8 a2 f3 ff ff       	call   1d148 <oma_tlv_get>
			msg->path.obj_inst_id = tlv.id;
   1dda6:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
			if (tlv.length == 0) {
   1ddaa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
			msg->path.obj_inst_id = tlv.id;
   1ddae:	66 89 43 22          	mov    %ax,0x22(%ebx)
			if (tlv.length == 0) {
   1ddb2:	75 2a                	jne    1ddde <do_write_op_tlv+0x7c>
				/* Create only - no data */
				ret = lwm2m_create_obj_inst(
   1ddb4:	8d 55 e0             	lea    -0x20(%ebp),%edx
   1ddb7:	52                   	push   %edx
   1ddb8:	50                   	push   %eax
   1ddb9:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
   1ddbd:	50                   	push   %eax
   1ddbe:	e8 2a 9f ff ff       	call   17ced <lwm2m_create_obj_inst>
   1ddc3:	83 c4 0c             	add    $0xc,%esp
						msg->path.obj_id,
						msg->path.obj_inst_id,
						&obj_inst);
				if (ret < 0) {
   1ddc6:	85 c0                	test   %eax,%eax
   1ddc8:	0f 88 b8 00 00 00    	js     1de86 <do_write_op_tlv+0x124>
					return ret;
				}

#ifdef CONFIG_LWM2M_RD_CLIENT_SUPPORT
				if (!msg->ctx->bootstrap_mode) {
   1ddce:	8b 03                	mov    (%ebx),%eax
   1ddd0:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
   1ddd7:	75 05                	jne    1ddde <do_write_op_tlv+0x7c>
					engine_trigger_update();
   1ddd9:	e8 6e 12 00 00       	call   1f04c <engine_trigger_update>
{
   1ddde:	31 f6                	xor    %esi,%esi
				}
#endif
			}

			while (pos < tlv.length &&
   1dde0:	39 75 e8             	cmp    %esi,-0x18(%ebp)
   1dde3:	76 90                	jbe    1dd75 <do_write_op_tlv+0x13>
			       (len2 = oma_tlv_get(&tlv2, &msg->in, true))) {
   1dde5:	89 fa                	mov    %edi,%edx
   1dde7:	b9 01 00 00 00       	mov    $0x1,%ecx
   1ddec:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1ddef:	e8 54 f3 ff ff       	call   1d148 <oma_tlv_get>
   1ddf4:	89 c2                	mov    %eax,%edx
			while (pos < tlv.length &&
   1ddf6:	85 c0                	test   %eax,%eax
   1ddf8:	0f 84 77 ff ff ff    	je     1dd75 <do_write_op_tlv+0x13>
				if (tlv2.type != OMA_TLV_TYPE_RESOURCE) {
   1ddfe:	80 7d ec 03          	cmpb   $0x3,-0x14(%ebp)
   1de02:	75 36                	jne    1de3a <do_write_op_tlv+0xd8>
					pos += len2;
					continue;
				}

				msg->path.res_id = tlv2.id;
   1de04:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
				msg->path.level = 3;
   1de08:	c6 43 28 03          	movb   $0x3,0x28(%ebx)
				msg->path.res_id = tlv2.id;
   1de0c:	66 89 43 24          	mov    %ax,0x24(%ebx)
				ret = do_write_op_tlv_item(msg);
   1de10:	89 d8                	mov    %ebx,%eax
   1de12:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1de15:	e8 b6 f4 ff ff       	call   1d2d0 <do_write_op_tlv_item>
				/*
				 * ignore errors for CREATE op
				 * for OP_CREATE and BOOTSTRAP WRITE: errors on
				 * optional resources are ignored (ENOTSUP)
				 */
				if (ret < 0 &&
   1de1a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1de1d:	85 c0                	test   %eax,%eax
   1de1f:	79 19                	jns    1de3a <do_write_op_tlv+0xd8>
   1de21:	83 f8 dd             	cmp    $0xffffffdd,%eax
   1de24:	75 60                	jne    1de86 <do_write_op_tlv+0x124>
				    !((ret == -ENOTSUP) &&
				      (msg->ctx->bootstrap_mode ||
   1de26:	8b 0b                	mov    (%ebx),%ecx
				    !((ret == -ENOTSUP) &&
   1de28:	80 b9 80 01 00 00 00 	cmpb   $0x0,0x180(%ecx)
   1de2f:	75 09                	jne    1de3a <do_write_op_tlv+0xd8>
				      (msg->ctx->bootstrap_mode ||
   1de31:	80 bb 85 01 00 00 02 	cmpb   $0x2,0x185(%ebx)
   1de38:	75 4c                	jne    1de86 <do_write_op_tlv+0x124>
				       msg->operation == LWM2M_OP_CREATE))) {
					return ret;
				}

				pos += len2;
   1de3a:	01 d6                	add    %edx,%esi
   1de3c:	eb a2                	jmp    1dde0 <do_write_op_tlv+0x7e>
			}
		} else if (tlv.type == OMA_TLV_TYPE_RESOURCE) {
   1de3e:	3c 03                	cmp    $0x3,%al
   1de40:	0f 85 2f ff ff ff    	jne    1dd75 <do_write_op_tlv+0x13>
			msg->path.res_id = tlv.id;
   1de46:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
			msg->path.level = 3;
   1de4a:	c6 43 28 03          	movb   $0x3,0x28(%ebx)
			msg->path.res_id = tlv.id;
   1de4e:	66 89 43 24          	mov    %ax,0x24(%ebx)
			ret = do_write_op_tlv_item(msg);
   1de52:	89 d8                	mov    %ebx,%eax
   1de54:	e8 77 f4 ff ff       	call   1d2d0 <do_write_op_tlv_item>
			/*
			 * ignore errors for CREATE op
			 * for OP_CREATE and BOOTSTRAP WRITE: errors on optional
			 * resources are ignored (ENOTSUP)
			 */
			if (ret < 0 &&
   1de59:	85 c0                	test   %eax,%eax
   1de5b:	0f 89 14 ff ff ff    	jns    1dd75 <do_write_op_tlv+0x13>
   1de61:	83 f8 dd             	cmp    $0xffffffdd,%eax
   1de64:	75 20                	jne    1de86 <do_write_op_tlv+0x124>
			    !((ret == -ENOTSUP) &&
			      (msg->ctx->bootstrap_mode ||
   1de66:	8b 13                	mov    (%ebx),%edx
			    !((ret == -ENOTSUP) &&
   1de68:	80 ba 80 01 00 00 00 	cmpb   $0x0,0x180(%edx)
   1de6f:	0f 85 00 ff ff ff    	jne    1dd75 <do_write_op_tlv+0x13>
			      (msg->ctx->bootstrap_mode ||
   1de75:	80 bb 85 01 00 00 02 	cmpb   $0x2,0x185(%ebx)
   1de7c:	0f 84 f3 fe ff ff    	je     1dd75 <do_write_op_tlv+0x13>
   1de82:	eb 02                	jmp    1de86 <do_write_op_tlv+0x124>
				return ret;
			}
		}
	}

	return 0;
   1de84:	31 c0                	xor    %eax,%eax
}
   1de86:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1de89:	5b                   	pop    %ebx
   1de8a:	5e                   	pop    %esi
   1de8b:	5f                   	pop    %edi
   1de8c:	5d                   	pop    %ebp
   1de8d:	c3                   	ret    

0001de8e <lwm2m_f32_to_b32>:
#define SHIFT_LEFT(v, o, m) (((v) << (o)) & (m))
#define SHIFT_RIGHT(v, o, m) (((v) >> (o)) & (m))

/* convert from float32 to binary32 */
int lwm2m_f32_to_b32(float32_value_t *f32, u8_t *b32, size_t len)
{
   1de8e:	55                   	push   %ebp
   1de8f:	89 e5                	mov    %esp,%ebp
   1de91:	57                   	push   %edi
   1de92:	56                   	push   %esi
	s32_t e = -1, v, f = 0;
	int i;

	if (len != 4) {
		return -EINVAL;
   1de93:	bf ea ff ff ff       	mov    $0xffffffea,%edi
{
   1de98:	53                   	push   %ebx
   1de99:	50                   	push   %eax
   1de9a:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (len != 4) {
   1de9d:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   1dea1:	0f 85 e1 00 00 00    	jne    1df88 <lwm2m_f32_to_b32+0xfa>
	}

	/* handle zero value special case */
	if (f32->val1 == 0 && f32->val2 == 0) {
   1dea7:	8b 45 08             	mov    0x8(%ebp),%eax
   1deaa:	8b 18                	mov    (%eax),%ebx
   1deac:	8b 78 04             	mov    0x4(%eax),%edi
   1deaf:	85 db                	test   %ebx,%ebx
   1deb1:	75 19                	jne    1decc <lwm2m_f32_to_b32+0x3e>
   1deb3:	83 ca ff             	or     $0xffffffff,%edx
   1deb6:	85 ff                	test   %edi,%edi
   1deb8:	75 37                	jne    1def1 <lwm2m_f32_to_b32+0x63>
		memset(b32, 0, len);
   1deba:	6a 04                	push   $0x4
   1debc:	6a 00                	push   $0x0
   1debe:	56                   	push   %esi
   1debf:	e8 dc ca fe ff       	call   a9a0 <memset>
   1dec4:	83 c4 0c             	add    $0xc,%esp
		return 0;
   1dec7:	e9 bc 00 00 00       	jmp    1df88 <lwm2m_f32_to_b32+0xfa>
	}

	v = f32->val1;
	/* sign handled later */
	if (v < 0) {
   1decc:	89 da                	mov    %ebx,%edx
   1dece:	89 d8                	mov    %ebx,%eax
   1ded0:	c1 fa 1f             	sar    $0x1f,%edx
	if (f32->val1 == 0 && f32->val2 == 0) {
   1ded3:	31 db                	xor    %ebx,%ebx
   1ded5:	31 d0                	xor    %edx,%eax
   1ded7:	29 d0                	sub    %edx,%eax
   1ded9:	83 ca ff             	or     $0xffffffff,%edx
		v = -v;
	}

	/* add whole value to fraction */
	while (v > 0) {
   1dedc:	85 c0                	test   %eax,%eax
   1dede:	7e 11                	jle    1def1 <lwm2m_f32_to_b32+0x63>
		f >>= 1;
   1dee0:	d1 fb                	sar    %ebx

		if (v & 1) {
   1dee2:	a8 01                	test   $0x1,%al
   1dee4:	74 06                	je     1deec <lwm2m_f32_to_b32+0x5e>
			f |= (1 << 23);
   1dee6:	81 cb 00 00 80 00    	or     $0x800000,%ebx
		}

		v >>= 1;
   1deec:	d1 f8                	sar    %eax
		e++;
   1deee:	42                   	inc    %edx
   1deef:	eb eb                	jmp    1dedc <lwm2m_f32_to_b32+0x4e>
	}

	v = f32->val2;
	/* sign handled later */
	if (v < 0) {
   1def1:	89 f8                	mov    %edi,%eax
   1def3:	89 f9                	mov    %edi,%ecx
   1def5:	c1 f8 1f             	sar    $0x1f,%eax
   1def8:	89 d7                	mov    %edx,%edi
   1defa:	31 c1                	xor    %eax,%ecx
   1defc:	29 c1                	sub    %eax,%ecx
		v = -v;
	}

	/* add decimal to fraction */
	i = e;
	while (v > 0 && i < 23) {
   1defe:	85 c9                	test   %ecx,%ecx
   1df00:	7e 47                	jle    1df49 <lwm2m_f32_to_b32+0xbb>
   1df02:	83 ff 16             	cmp    $0x16,%edi
   1df05:	7f 42                	jg     1df49 <lwm2m_f32_to_b32+0xbb>
		v *= 2;
   1df07:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
		if (!f && e < 0 && v < LWM2M_FLOAT32_DEC_MAX) {
   1df0a:	85 db                	test   %ebx,%ebx
		v *= 2;
   1df0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1df0f:	89 c1                	mov    %eax,%ecx
		if (!f && e < 0 && v < LWM2M_FLOAT32_DEC_MAX) {
   1df11:	75 0e                	jne    1df21 <lwm2m_f32_to_b32+0x93>
   1df13:	85 d2                	test   %edx,%edx
   1df15:	79 0a                	jns    1df21 <lwm2m_f32_to_b32+0x93>
   1df17:	3d 3f 42 0f 00       	cmp    $0xf423f,%eax
   1df1c:	7f 0c                	jg     1df2a <lwm2m_f32_to_b32+0x9c>
			/* handle -e */
			e--;
   1df1e:	4a                   	dec    %edx
			continue;
   1df1f:	eb dd                	jmp    1defe <lwm2m_f32_to_b32+0x70>
		} else if (v >= LWM2M_FLOAT32_DEC_MAX) {
   1df21:	81 7d f0 3f 42 0f 00 	cmpl   $0xf423f,-0x10(%ebp)
   1df28:	7e 1c                	jle    1df46 <lwm2m_f32_to_b32+0xb8>
			v -= LWM2M_FLOAT32_DEC_MAX;
			f |= 1 << (22 - i);
   1df2a:	b9 16 00 00 00       	mov    $0x16,%ecx
   1df2f:	b8 01 00 00 00       	mov    $0x1,%eax
   1df34:	29 f9                	sub    %edi,%ecx
   1df36:	d3 e0                	shl    %cl,%eax
   1df38:	09 c3                	or     %eax,%ebx
		}

		if (v == 0) {
   1df3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1df3d:	2d 40 42 0f 00       	sub    $0xf4240,%eax
   1df42:	89 c1                	mov    %eax,%ecx
   1df44:	74 03                	je     1df49 <lwm2m_f32_to_b32+0xbb>
			break;
		}

		i++;
   1df46:	47                   	inc    %edi
   1df47:	eb b5                	jmp    1defe <lwm2m_f32_to_b32+0x70>
	}

	/* adjust exponent for bias */
	e += 127;

	memset(b32, 0, len);
   1df49:	6a 04                	push   $0x4
	e += 127;
   1df4b:	8d 7a 7f             	lea    0x7f(%edx),%edi
	memset(b32, 0, len);
   1df4e:	6a 00                	push   $0x0
   1df50:	56                   	push   %esi
   1df51:	e8 4a ca fe ff       	call   a9a0 <memset>

	/* sign: bit 31 */
	b32[0] = f32->val1 < 0 ? 0x80 : 0;
   1df56:	8b 45 08             	mov    0x8(%ebp),%eax

	/* exponent: bits 30-23 */
	b32[0] |= e >> 1;
   1df59:	89 fa                	mov    %edi,%edx
   1df5b:	d1 fa                	sar    %edx
	memset(b32, 0, len);
   1df5d:	83 c4 0c             	add    $0xc,%esp
	b32[1] = (e & 1) << 7;
   1df60:	c1 e7 07             	shl    $0x7,%edi
	b32[0] = f32->val1 < 0 ? 0x80 : 0;
   1df63:	8b 00                	mov    (%eax),%eax
   1df65:	c1 f8 18             	sar    $0x18,%eax
   1df68:	83 e0 80             	and    $0xffffff80,%eax
	b32[0] |= e >> 1;
   1df6b:	09 d0                	or     %edx,%eax

	/* fraction: bits 22-0 */
	/* NOTE: ignore the "hidden" bit 23 in fraction */
	b32[1] |= (f >> 16) & 0x7F;
   1df6d:	89 da                	mov    %ebx,%edx
   1df6f:	c1 fa 10             	sar    $0x10,%edx
	b32[0] |= e >> 1;
   1df72:	88 06                	mov    %al,(%esi)
	b32[1] |= (f >> 16) & 0x7F;
   1df74:	88 d0                	mov    %dl,%al
	b32[1] = (e & 1) << 7;
   1df76:	89 fa                	mov    %edi,%edx
	b32[1] |= (f >> 16) & 0x7F;
   1df78:	83 e0 7f             	and    $0x7f,%eax
	b32[2] = (f >> 8) & 0xFF;
   1df7b:	86 fb                	xchg   %bh,%bl
	b32[1] |= (f >> 16) & 0x7F;
   1df7d:	09 c2                	or     %eax,%edx
	b32[2] = (f >> 8) & 0xFF;
   1df7f:	66 89 5e 02          	mov    %bx,0x2(%esi)
	b32[1] |= (f >> 16) & 0x7F;
   1df83:	88 56 01             	mov    %dl,0x1(%esi)
	b32[3] = f & 0xFF;

	return 0;
   1df86:	31 ff                	xor    %edi,%edi
}
   1df88:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1df8b:	89 f8                	mov    %edi,%eax
   1df8d:	5b                   	pop    %ebx
   1df8e:	5e                   	pop    %esi
   1df8f:	5f                   	pop    %edi
   1df90:	5d                   	pop    %ebp
   1df91:	c3                   	ret    

0001df92 <lwm2m_f64_to_b64>:

/* convert from float64 to binary64 */
int lwm2m_f64_to_b64(float64_value_t *f64, u8_t *b64, size_t len)
{
   1df92:	55                   	push   %ebp
	s64_t v, f = 0;
	s32_t e = -1;
	int i;

	if (len != 8) {
		return -EINVAL;
   1df93:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
   1df98:	89 e5                	mov    %esp,%ebp
   1df9a:	57                   	push   %edi
   1df9b:	56                   	push   %esi
   1df9c:	53                   	push   %ebx
   1df9d:	83 ec 14             	sub    $0x14,%esp
	if (len != 8) {
   1dfa0:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   1dfa4:	0f 85 d9 01 00 00    	jne    1e183 <lwm2m_f64_to_b64+0x1f1>
	}

	/* handle zero value special case */
	if (f64->val1 == 0LL && f64->val2 == 0LL) {
   1dfaa:	8b 45 08             	mov    0x8(%ebp),%eax
   1dfad:	8b 50 04             	mov    0x4(%eax),%edx
   1dfb0:	8b 00                	mov    (%eax),%eax
   1dfb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1dfb5:	8b 45 08             	mov    0x8(%ebp),%eax
   1dfb8:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1dfbb:	8b 40 08             	mov    0x8(%eax),%eax
   1dfbe:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1dfc1:	8b 45 08             	mov    0x8(%ebp),%eax
   1dfc4:	8b 40 0c             	mov    0xc(%eax),%eax
   1dfc7:	89 c6                	mov    %eax,%esi
   1dfc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1dfcc:	0b 45 ec             	or     -0x14(%ebp),%eax
   1dfcf:	75 26                	jne    1dff7 <lwm2m_f64_to_b64+0x65>
   1dfd1:	89 f0                	mov    %esi,%eax
   1dfd3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
   1dfda:	0b 45 e0             	or     -0x20(%ebp),%eax
   1dfdd:	0f 85 8a 00 00 00    	jne    1e06d <lwm2m_f64_to_b64+0xdb>
		memset(b64, 0, len);
   1dfe3:	6a 08                	push   $0x8
   1dfe5:	6a 00                	push   $0x0
   1dfe7:	ff 75 0c             	pushl  0xc(%ebp)
   1dfea:	e8 b1 c9 fe ff       	call   a9a0 <memset>
   1dfef:	83 c4 0c             	add    $0xc,%esp
		return 0;
   1dff2:	e9 8a 01 00 00       	jmp    1e181 <lwm2m_f64_to_b64+0x1ef>
	}

	v = f64->val1;
	/* sign handled later */
	if (v < 0) {
   1dff7:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1dffa:	8b 7d f0             	mov    -0x10(%ebp),%edi
   1dffd:	c1 fb 1f             	sar    $0x1f,%ebx
	if (f64->val1 == 0LL && f64->val2 == 0LL) {
   1e000:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1e007:	89 d9                	mov    %ebx,%ecx
   1e009:	89 5d e8             	mov    %ebx,-0x18(%ebp)
   1e00c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
   1e00f:	33 7d e8             	xor    -0x18(%ebp),%edi
   1e012:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1e015:	89 fa                	mov    %edi,%edx
   1e017:	33 5d ec             	xor    -0x14(%ebp),%ebx
   1e01a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1e021:	89 d8                	mov    %ebx,%eax
   1e023:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1e026:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
   1e02d:	1b 55 e8             	sbb    -0x18(%ebp),%edx
		v = -v;
	}

	/* add whole value to fraction */
	while (v > 0) {
   1e030:	31 db                	xor    %ebx,%ebx
   1e032:	bf 00 00 00 00       	mov    $0x0,%edi
   1e037:	39 c3                	cmp    %eax,%ebx
   1e039:	19 d7                	sbb    %edx,%edi
   1e03b:	7d 30                	jge    1e06d <lwm2m_f64_to_b64+0xdb>
		f >>= 1;
   1e03d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1e040:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1e043:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
   1e047:	d1 fb                	sar    %ebx
   1e049:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   1e04c:	89 5d f0             	mov    %ebx,-0x10(%ebp)

		if (v & 1) {
   1e04f:	89 c3                	mov    %eax,%ebx
   1e051:	83 e3 01             	and    $0x1,%ebx
   1e054:	74 0c                	je     1e062 <lwm2m_f64_to_b64+0xd0>
			f |= ((s64_t)1 << 52);
   1e056:	8b 7d f0             	mov    -0x10(%ebp),%edi
   1e059:	81 cf 00 00 10 00    	or     $0x100000,%edi
   1e05f:	89 7d f0             	mov    %edi,-0x10(%ebp)
		}

		v >>= 1;
   1e062:	0f ac d0 01          	shrd   $0x1,%edx,%eax
   1e066:	d1 fa                	sar    %edx
		e++;
   1e068:	ff 45 e4             	incl   -0x1c(%ebp)
   1e06b:	eb c3                	jmp    1e030 <lwm2m_f64_to_b64+0x9e>
	}

	v = f64->val2;
	/* sign handled later */
	if (v < 0) {
   1e06d:	89 f0                	mov    %esi,%eax
   1e06f:	8b 7d e0             	mov    -0x20(%ebp),%edi
   1e072:	c1 f8 1f             	sar    $0x1f,%eax
   1e075:	31 c7                	xor    %eax,%edi
   1e077:	89 c1                	mov    %eax,%ecx
   1e079:	89 f8                	mov    %edi,%eax
   1e07b:	89 f7                	mov    %esi,%edi
   1e07d:	31 cf                	xor    %ecx,%edi
   1e07f:	8b 75 e4             	mov    -0x1c(%ebp),%esi
   1e082:	89 fa                	mov    %edi,%edx
   1e084:	29 c8                	sub    %ecx,%eax
   1e086:	19 ca                	sbb    %ecx,%edx
   1e088:	89 75 e0             	mov    %esi,-0x20(%ebp)
		v = -v;
	}

	/* add decimal to fraction */
	i = e;
	while (v > 0 && i < 52) {
   1e08b:	89 d3                	mov    %edx,%ebx
   1e08d:	c1 fb 1f             	sar    $0x1f,%ebx
   1e090:	89 d9                	mov    %ebx,%ecx
   1e092:	39 c1                	cmp    %eax,%ecx
   1e094:	19 d3                	sbb    %edx,%ebx
   1e096:	85 db                	test   %ebx,%ebx
   1e098:	0f 89 93 00 00 00    	jns    1e131 <lwm2m_f64_to_b64+0x19f>
   1e09e:	83 7d e0 33          	cmpl   $0x33,-0x20(%ebp)
   1e0a2:	0f 8f 89 00 00 00    	jg     1e131 <lwm2m_f64_to_b64+0x19f>
		v *= 2;
   1e0a8:	01 c0                	add    %eax,%eax
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
   1e0aa:	8b 7d ec             	mov    -0x14(%ebp),%edi
		v *= 2;
   1e0ad:	11 d2                	adc    %edx,%edx
   1e0af:	89 c1                	mov    %eax,%ecx
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
   1e0b1:	0b 7d f0             	or     -0x10(%ebp),%edi
		v *= 2;
   1e0b4:	89 d3                	mov    %edx,%ebx
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
   1e0b6:	bf ff c9 9a 3b       	mov    $0x3b9ac9ff,%edi
   1e0bb:	75 24                	jne    1e0e1 <lwm2m_f64_to_b64+0x14f>
   1e0bd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1e0c1:	79 1e                	jns    1e0e1 <lwm2m_f64_to_b64+0x14f>
   1e0c3:	39 c7                	cmp    %eax,%edi
   1e0c5:	be 00 00 00 00       	mov    $0x0,%esi
   1e0ca:	19 d6                	sbb    %edx,%esi
   1e0cc:	7c 1e                	jl     1e0ec <lwm2m_f64_to_b64+0x15a>
			/* handle -e */
			e--;
   1e0ce:	ff 4d e4             	decl   -0x1c(%ebp)
			continue;
   1e0d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1e0d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1e0df:	eb aa                	jmp    1e08b <lwm2m_f64_to_b64+0xf9>
		} else if (v >= LWM2M_FLOAT64_DEC_MAX) {
   1e0e1:	39 cf                	cmp    %ecx,%edi
   1e0e3:	be 00 00 00 00       	mov    $0x0,%esi
   1e0e8:	19 de                	sbb    %ebx,%esi
   1e0ea:	7d 3d                	jge    1e129 <lwm2m_f64_to_b64+0x197>
			v -= LWM2M_FLOAT64_DEC_MAX;
   1e0ec:	89 c8                	mov    %ecx,%eax
   1e0ee:	89 da                	mov    %ebx,%edx
   1e0f0:	05 00 36 65 c4       	add    $0xc4653600,%eax
			f |= (s64_t)1 << (51 - i);
   1e0f5:	bf 33 00 00 00       	mov    $0x33,%edi
			v -= LWM2M_FLOAT64_DEC_MAX;
   1e0fa:	83 d2 ff             	adc    $0xffffffff,%edx
			f |= (s64_t)1 << (51 - i);
   1e0fd:	2b 7d e0             	sub    -0x20(%ebp),%edi
   1e100:	89 f9                	mov    %edi,%ecx
   1e102:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1e105:	89 cf                	mov    %ecx,%edi
   1e107:	c1 ef 05             	shr    $0x5,%edi
   1e10a:	83 e7 01             	and    $0x1,%edi
   1e10d:	89 fe                	mov    %edi,%esi
   1e10f:	83 f6 01             	xor    $0x1,%esi
   1e112:	d3 e7                	shl    %cl,%edi
   1e114:	d3 e6                	shl    %cl,%esi
   1e116:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1e119:	09 fb                	or     %edi,%ebx
   1e11b:	09 f1                	or     %esi,%ecx
		}

		if (v == 0) {
   1e11d:	89 d7                	mov    %edx,%edi
			f |= (s64_t)1 << (51 - i);
   1e11f:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   1e122:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		if (v == 0) {
   1e125:	09 c7                	or     %eax,%edi
   1e127:	74 08                	je     1e131 <lwm2m_f64_to_b64+0x19f>
			break;
		}

		i++;
   1e129:	ff 45 e0             	incl   -0x20(%ebp)
   1e12c:	e9 5a ff ff ff       	jmp    1e08b <lwm2m_f64_to_b64+0xf9>
	}

	/* adjust exponent for bias */
	e += 1023;

	memset(b64, 0, len);
   1e131:	6a 08                	push   $0x8
	e += 1023;
   1e133:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	memset(b64, 0, len);
   1e136:	6a 00                	push   $0x0
	e += 1023;
   1e138:	81 c3 ff 03 00 00    	add    $0x3ff,%ebx
	memset(b64, 0, len);
   1e13e:	ff 75 0c             	pushl  0xc(%ebp)
   1e141:	e8 5a c8 fe ff       	call   a9a0 <memset>

	/* sign: bit 63 */
	b64[0] = f64->val1 < 0 ? 0x80 : 0;
   1e146:	8b 45 08             	mov    0x8(%ebp),%eax
   1e149:	0f be 40 07          	movsbl 0x7(%eax),%eax

	/* exponent: bits 62-52 */
	b64[0] |= (e >> 4);
   1e14d:	89 da                	mov    %ebx,%edx
   1e14f:	8b 75 0c             	mov    0xc(%ebp),%esi
	b64[0] = f64->val1 < 0 ? 0x80 : 0;
   1e152:	83 e0 80             	and    $0xffffff80,%eax
	memset(b64, 0, len);
   1e155:	83 c4 0c             	add    $0xc,%esp
	b64[0] |= (e >> 4);
   1e158:	c1 fa 04             	sar    $0x4,%edx
	b64[1] = ((e & 0xF) << 4);
   1e15b:	c1 e3 04             	shl    $0x4,%ebx
	b64[0] |= (e >> 4);
   1e15e:	09 d0                	or     %edx,%eax
   1e160:	88 06                	mov    %al,(%esi)

	/* fraction: bits 51-0 */
	/* NOTE: ignore the "hidden" bit 52 in fraction */
	b64[1] |= ((f >> 48) & 0xF);
   1e162:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1e165:	c1 f8 10             	sar    $0x10,%eax
   1e168:	83 e0 0f             	and    $0xf,%eax
   1e16b:	09 c3                	or     %eax,%ebx
	b64[2] = (f >> 40) & 0xFF;
   1e16d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1e170:	88 66 02             	mov    %ah,0x2(%esi)
	b64[3] = (f >> 32) & 0xFF;
   1e173:	88 46 03             	mov    %al,0x3(%esi)
   1e176:	8b 45 ec             	mov    -0x14(%ebp),%eax
	b64[1] |= ((f >> 48) & 0xF);
   1e179:	88 5e 01             	mov    %bl,0x1(%esi)
	b64[4] = (f >> 24) & 0xFF;
	b64[5] = (f >> 16) & 0xFF;
	b64[6] = (f >> 8) & 0xFF;
	b64[7] = f & 0xFF;
   1e17c:	0f c8                	bswap  %eax
	b64[4] = (f >> 24) & 0xFF;
   1e17e:	89 46 04             	mov    %eax,0x4(%esi)

	return 0;
   1e181:	31 c0                	xor    %eax,%eax
}
   1e183:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1e186:	5b                   	pop    %ebx
   1e187:	5e                   	pop    %esi
   1e188:	5f                   	pop    %edi
   1e189:	5d                   	pop    %ebp
   1e18a:	c3                   	ret    

0001e18b <lwm2m_b32_to_f32>:

/* convert from binary32 to float32 */
int lwm2m_b32_to_f32(u8_t *b32, size_t len, float32_value_t *f32)
{
   1e18b:	55                   	push   %ebp
   1e18c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1e191:	89 e5                	mov    %esp,%ebp
   1e193:	57                   	push   %edi
   1e194:	56                   	push   %esi
   1e195:	53                   	push   %ebx
   1e196:	8b 7d 08             	mov    0x8(%ebp),%edi
   1e199:	8b 75 10             	mov    0x10(%ebp),%esi
	s32_t f, k, i, e;
	bool sign = false;

	if (len != 4) {
   1e19c:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
   1e1a0:	0f 85 ad 00 00 00    	jne    1e253 <lwm2m_b32_to_f32+0xc8>
		return -EINVAL;
	}

	f32->val1 = 0;
   1e1a6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	f32->val2 = 0;
   1e1ac:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
	/* calc sign: bit 31 */
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);

	/* calc exponent: bits 30-23 */
	e  = SHIFT_LEFT(b32[0], 1, 0xFF);
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
   1e1b3:	8a 47 01             	mov    0x1(%edi),%al
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);
   1e1b6:	8a 17                	mov    (%edi),%dl
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
   1e1b8:	88 c1                	mov    %al,%cl
   1e1ba:	c0 e9 07             	shr    $0x7,%cl
	e  = SHIFT_LEFT(b32[0], 1, 0xFF);
   1e1bd:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
   1e1c0:	81 e3 fe 00 00 00    	and    $0xfe,%ebx
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
   1e1c6:	0f b6 c9             	movzbl %cl,%ecx
	e -= 127;

	/* enable "hidden" fraction bit 23 which is always 1 */
	f  = ((s32_t)1 << 22);
	/* calc fraction: bits 22-0 */
	f += ((s32_t)(b32[1] & 0x7F) << 16);
   1e1c9:	c1 e0 10             	shl    $0x10,%eax
	e -= 127;
   1e1cc:	8d 5c 0b 81          	lea    -0x7f(%ebx,%ecx,1),%ebx
	f += ((s32_t)(b32[1] & 0x7F) << 16);
   1e1d0:	25 00 00 7f 00       	and    $0x7f0000,%eax
	f += ((s32_t)b32[2] << 8);
   1e1d5:	0f b6 4f 02          	movzbl 0x2(%edi),%ecx
	f += b32[3];
   1e1d9:	0f b6 7f 03          	movzbl 0x3(%edi),%edi
	f += ((s32_t)b32[2] << 8);
   1e1dd:	c1 e1 08             	shl    $0x8,%ecx

	/* handle whole number */
	if (e > -1) {
   1e1e0:	85 db                	test   %ebx,%ebx
	f += b32[3];
   1e1e2:	8d 8c 39 00 00 40 00 	lea    0x400000(%ecx,%edi,1),%ecx
   1e1e9:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
	if (e > -1) {
   1e1ec:	78 2f                	js     1e21d <lwm2m_b32_to_f32+0x92>
		/* precision overflow */
		if (e > 23) {
   1e1ee:	83 fb 17             	cmp    $0x17,%ebx
   1e1f1:	7e 05                	jle    1e1f8 <lwm2m_b32_to_f32+0x6d>
   1e1f3:	bb 17 00 00 00       	mov    $0x17,%ebx
			e = 23;
		}

		f32->val1 = (f >> (23 - e)) * (sign ? -1 : 1);
   1e1f8:	b9 17 00 00 00       	mov    $0x17,%ecx
   1e1fd:	89 f8                	mov    %edi,%eax
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);
   1e1ff:	c0 ea 07             	shr    $0x7,%dl
		f32->val1 = (f >> (23 - e)) * (sign ? -1 : 1);
   1e202:	29 d9                	sub    %ebx,%ecx
   1e204:	d3 f8                	sar    %cl,%eax
   1e206:	80 fa 01             	cmp    $0x1,%dl
   1e209:	89 c1                	mov    %eax,%ecx
   1e20b:	19 c0                	sbb    %eax,%eax
   1e20d:	83 e0 02             	and    $0x2,%eax
   1e210:	48                   	dec    %eax
   1e211:	0f af c1             	imul   %ecx,%eax
   1e214:	89 06                	mov    %eax,(%esi)
	}

	/* calculate the rest of the decimal */
	k = LWM2M_FLOAT32_DEC_MAX;
   1e216:	b8 40 42 0f 00       	mov    $0xf4240,%eax
   1e21b:	eb 15                	jmp    1e232 <lwm2m_b32_to_f32+0xa7>
   1e21d:	b8 40 42 0f 00       	mov    $0xf4240,%eax

	/* account for -e */
	while (e < -1) {
		k /= 2;
   1e222:	b9 02 00 00 00       	mov    $0x2,%ecx
	while (e < -1) {
   1e227:	83 fb ff             	cmp    $0xffffffff,%ebx
   1e22a:	74 06                	je     1e232 <lwm2m_b32_to_f32+0xa7>
		k /= 2;
   1e22c:	99                   	cltd   
   1e22d:	f7 f9                	idiv   %ecx
		e++;
   1e22f:	43                   	inc    %ebx
   1e230:	eb f5                	jmp    1e227 <lwm2m_b32_to_f32+0x9c>
	}

	for (i = 22 - e; i >= 0; i--) {
   1e232:	b9 16 00 00 00       	mov    $0x16,%ecx
   1e237:	29 d9                	sub    %ebx,%ecx
		k /= 2;
   1e239:	bb 02 00 00 00       	mov    $0x2,%ebx
	for (i = 22 - e; i >= 0; i--) {
   1e23e:	83 f9 ff             	cmp    $0xffffffff,%ecx
   1e241:	74 0e                	je     1e251 <lwm2m_b32_to_f32+0xc6>
		k /= 2;
   1e243:	99                   	cltd   
   1e244:	f7 fb                	idiv   %ebx
		if (f & (1 << i)) {
   1e246:	0f a3 cf             	bt     %ecx,%edi
   1e249:	73 03                	jae    1e24e <lwm2m_b32_to_f32+0xc3>
			f32->val2 += k;
   1e24b:	01 46 04             	add    %eax,0x4(%esi)
	for (i = 22 - e; i >= 0; i--) {
   1e24e:	49                   	dec    %ecx
   1e24f:	eb ed                	jmp    1e23e <lwm2m_b32_to_f32+0xb3>

		}
	}

	return 0;
   1e251:	31 c0                	xor    %eax,%eax
}
   1e253:	5b                   	pop    %ebx
   1e254:	5e                   	pop    %esi
   1e255:	5f                   	pop    %edi
   1e256:	5d                   	pop    %ebp
   1e257:	c3                   	ret    

0001e258 <lwm2m_b64_to_f64>:

/* convert from binary64 to float64 */
int lwm2m_b64_to_f64(u8_t *b64, size_t len, float64_value_t *f64)
{
   1e258:	55                   	push   %ebp
   1e259:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   1e25e:	89 e5                	mov    %esp,%ebp
   1e260:	57                   	push   %edi
   1e261:	56                   	push   %esi
   1e262:	53                   	push   %ebx
   1e263:	83 ec 10             	sub    $0x10,%esp
   1e266:	8b 55 08             	mov    0x8(%ebp),%edx
	s64_t f, k;
	int i, e;
	bool sign = false;

	if (len != 8) {
   1e269:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
   1e26d:	0f 85 98 01 00 00    	jne    1e40b <lwm2m_b64_to_f64+0x1b3>
		return -EINVAL;
	}

	f64->val1 = 0LL;
   1e273:	8b 45 10             	mov    0x10(%ebp),%eax
   1e276:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1e27c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	f64->val2 = 0LL;
   1e283:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   1e28a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* calc sign: bit 63 */
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
   1e291:	8a 02                	mov    (%edx),%al
   1e293:	88 45 ec             	mov    %al,-0x14(%ebp)

	/* get exponent: bits 62-52 */
	e  = SHIFT_LEFT((u16_t)b64[0], 4, 0x7F0);
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
   1e296:	8a 42 01             	mov    0x1(%edx),%al
   1e299:	88 c1                	mov    %al,%cl
	e  = SHIFT_LEFT((u16_t)b64[0], 4, 0x7F0);
   1e29b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   1e29e:	c1 e3 04             	shl    $0x4,%ebx
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
   1e2a1:	c0 e9 04             	shr    $0x4,%cl
	e  = SHIFT_LEFT((u16_t)b64[0], 4, 0x7F0);
   1e2a4:	81 e3 f0 07 00 00    	and    $0x7f0,%ebx
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
   1e2aa:	0f b6 c9             	movzbl %cl,%ecx
	f += ((s64_t)b64[2] << 40);
	f += ((s64_t)b64[3] << 32);
	f += ((s64_t)b64[4] << 24);
	f += ((s64_t)b64[5] << 16);
	f += ((s64_t)b64[6] << 8);
	f += b64[7];
   1e2ad:	0f b6 72 07          	movzbl 0x7(%edx),%esi
	e -= 1023;
   1e2b1:	8d bc 0b 01 fc ff ff 	lea    -0x3ff(%ebx,%ecx,1),%edi
	f += ((s64_t)b64[2] << 40);
   1e2b8:	0f b6 4a 02          	movzbl 0x2(%edx),%ecx
	e -= 1023;
   1e2bc:	89 7d f0             	mov    %edi,-0x10(%ebp)
	f += ((s64_t)b64[2] << 40);
   1e2bf:	89 cb                	mov    %ecx,%ebx
	f += b64[7];
   1e2c1:	31 ff                	xor    %edi,%edi
	f += ((s64_t)b64[2] << 40);
   1e2c3:	b9 00 00 00 00       	mov    $0x0,%ecx
   1e2c8:	c1 e3 08             	shl    $0x8,%ebx
	f += b64[7];
   1e2cb:	81 c7 00 00 10 00    	add    $0x100000,%edi
   1e2d1:	01 f1                	add    %esi,%ecx
	f += ((s64_t)b64[3] << 32);
   1e2d3:	0f b6 72 03          	movzbl 0x3(%edx),%esi
	f += b64[7];
   1e2d7:	11 fb                	adc    %edi,%ebx
	f += ((s64_t)b64[3] << 32);
   1e2d9:	89 f7                	mov    %esi,%edi
   1e2db:	be 00 00 00 00       	mov    $0x0,%esi
	f += b64[7];
   1e2e0:	01 f1                	add    %esi,%ecx
	f += ((s64_t)b64[4] << 24);
   1e2e2:	0f b6 72 04          	movzbl 0x4(%edx),%esi
	f += b64[7];
   1e2e6:	11 fb                	adc    %edi,%ebx
	f += ((s64_t)b64[4] << 24);
   1e2e8:	31 ff                	xor    %edi,%edi
   1e2ea:	0f a4 f7 18          	shld   $0x18,%esi,%edi
   1e2ee:	c1 e6 18             	shl    $0x18,%esi
	f += b64[7];
   1e2f1:	01 f1                	add    %esi,%ecx
	f += ((s64_t)b64[5] << 16);
   1e2f3:	0f b6 72 05          	movzbl 0x5(%edx),%esi
	f += b64[7];
   1e2f7:	11 fb                	adc    %edi,%ebx
	f += ((s64_t)b64[5] << 16);
   1e2f9:	31 ff                	xor    %edi,%edi
   1e2fb:	0f a4 f7 10          	shld   $0x10,%esi,%edi
   1e2ff:	c1 e6 10             	shl    $0x10,%esi
	f += b64[7];
   1e302:	01 ce                	add    %ecx,%esi
	f += ((s64_t)b64[6] << 8);
   1e304:	0f b6 4a 06          	movzbl 0x6(%edx),%ecx
	f += b64[7];
   1e308:	11 df                	adc    %ebx,%edi
	f += ((s64_t)b64[6] << 8);
   1e30a:	89 ca                	mov    %ecx,%edx
   1e30c:	31 c9                	xor    %ecx,%ecx
   1e30e:	89 cb                	mov    %ecx,%ebx
   1e310:	89 d1                	mov    %edx,%ecx
   1e312:	0f a4 cb 08          	shld   $0x8,%ecx,%ebx
   1e316:	c1 e1 08             	shl    $0x8,%ecx
	f += b64[7];
   1e319:	01 ce                	add    %ecx,%esi
   1e31b:	11 df                	adc    %ebx,%edi
	f += ((s64_t)(b64[1] & 0xF) << 48);
   1e31d:	31 c9                	xor    %ecx,%ecx
   1e31f:	c1 e0 10             	shl    $0x10,%eax
   1e322:	25 00 00 0f 00       	and    $0xf0000,%eax
	f += b64[7];
   1e327:	01 ce                	add    %ecx,%esi
   1e329:	11 c7                	adc    %eax,%edi
   1e32b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
   1e32e:	89 7d e8             	mov    %edi,-0x18(%ebp)

	/* handle whole number */
	if (e > -1) {
   1e331:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1e335:	78 5e                	js     1e395 <lwm2m_b64_to_f64+0x13d>
		/* precision overflow */
		if (e > 52) {
   1e337:	83 7d f0 34          	cmpl   $0x34,-0x10(%ebp)
   1e33b:	7e 07                	jle    1e344 <lwm2m_b64_to_f64+0xec>
   1e33d:	c7 45 f0 34 00 00 00 	movl   $0x34,-0x10(%ebp)
			e = 52;
		}

		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
   1e344:	b9 34 00 00 00       	mov    $0x34,%ecx
   1e349:	8b 7d e8             	mov    -0x18(%ebp),%edi
   1e34c:	2b 4d f0             	sub    -0x10(%ebp),%ecx
   1e34f:	8b 75 e4             	mov    -0x1c(%ebp),%esi
   1e352:	0f ad fe             	shrd   %cl,%edi,%esi
   1e355:	d3 ff                	sar    %cl,%edi
   1e357:	f6 c1 20             	test   $0x20,%cl
   1e35a:	74 05                	je     1e361 <lwm2m_b64_to_f64+0x109>
   1e35c:	89 fe                	mov    %edi,%esi
   1e35e:	c1 ff 1f             	sar    $0x1f,%edi
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
   1e361:	8a 4d ec             	mov    -0x14(%ebp),%cl
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
   1e364:	89 fa                	mov    %edi,%edx
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
   1e366:	c0 e9 07             	shr    $0x7,%cl
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
   1e369:	8b 7d 10             	mov    0x10(%ebp),%edi
   1e36c:	80 f9 01             	cmp    $0x1,%cl
	}

	/* calculate the rest of the decimal */
	k = LWM2M_FLOAT64_DEC_MAX;
   1e36f:	bb 00 ca 9a 3b       	mov    $0x3b9aca00,%ebx
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
   1e374:	19 c0                	sbb    %eax,%eax
   1e376:	c1 e1 1f             	shl    $0x1f,%ecx
   1e379:	83 e0 02             	and    $0x2,%eax
   1e37c:	c1 f9 1f             	sar    $0x1f,%ecx
   1e37f:	48                   	dec    %eax
   1e380:	0f af d0             	imul   %eax,%edx
   1e383:	0f af ce             	imul   %esi,%ecx
   1e386:	01 d1                	add    %edx,%ecx
   1e388:	f7 e6                	mul    %esi
   1e38a:	01 ca                	add    %ecx,%edx
   1e38c:	89 07                	mov    %eax,(%edi)
   1e38e:	89 57 04             	mov    %edx,0x4(%edi)
	k = LWM2M_FLOAT64_DEC_MAX;
   1e391:	31 f6                	xor    %esi,%esi
   1e393:	eb 2b                	jmp    1e3c0 <lwm2m_b64_to_f64+0x168>
   1e395:	bb 00 ca 9a 3b       	mov    $0x3b9aca00,%ebx
   1e39a:	31 f6                	xor    %esi,%esi

	/* account for -e */
	while (e < -1) {
   1e39c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
   1e3a0:	74 1e                	je     1e3c0 <lwm2m_b64_to_f64+0x168>
		k /= 2;
   1e3a2:	89 f0                	mov    %esi,%eax
   1e3a4:	89 f7                	mov    %esi,%edi
   1e3a6:	c1 e8 1f             	shr    $0x1f,%eax
   1e3a9:	89 de                	mov    %ebx,%esi
   1e3ab:	31 d2                	xor    %edx,%edx
   1e3ad:	01 c6                	add    %eax,%esi
   1e3af:	11 d7                	adc    %edx,%edi
		e++;
   1e3b1:	ff 45 f0             	incl   -0x10(%ebp)
		k /= 2;
   1e3b4:	0f ac fe 01          	shrd   $0x1,%edi,%esi
   1e3b8:	d1 ff                	sar    %edi
   1e3ba:	89 f3                	mov    %esi,%ebx
   1e3bc:	89 fe                	mov    %edi,%esi
		e++;
   1e3be:	eb dc                	jmp    1e39c <lwm2m_b64_to_f64+0x144>
	}

	for (i = 51 - e; i >= 0; i--) {
   1e3c0:	b9 33 00 00 00       	mov    $0x33,%ecx
   1e3c5:	2b 4d f0             	sub    -0x10(%ebp),%ecx
   1e3c8:	83 f9 ff             	cmp    $0xffffffff,%ecx
   1e3cb:	74 3c                	je     1e409 <lwm2m_b64_to_f64+0x1b1>
		k /= 2;
   1e3cd:	89 f0                	mov    %esi,%eax
   1e3cf:	89 f7                	mov    %esi,%edi
   1e3d1:	c1 e8 1f             	shr    $0x1f,%eax
   1e3d4:	89 de                	mov    %ebx,%esi
   1e3d6:	31 d2                	xor    %edx,%edx
   1e3d8:	01 c6                	add    %eax,%esi
   1e3da:	11 d7                	adc    %edx,%edi
		if (f & ((s64_t)1 << i)) {
   1e3dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		k /= 2;
   1e3df:	0f ac fe 01          	shrd   $0x1,%edi,%esi
		if (f & ((s64_t)1 << i)) {
   1e3e3:	8b 55 e8             	mov    -0x18(%ebp),%edx
		k /= 2;
   1e3e6:	89 f3                	mov    %esi,%ebx
   1e3e8:	d1 ff                	sar    %edi
		if (f & ((s64_t)1 << i)) {
   1e3ea:	0f ad d0             	shrd   %cl,%edx,%eax
		k /= 2;
   1e3ed:	89 fe                	mov    %edi,%esi
		if (f & ((s64_t)1 << i)) {
   1e3ef:	d3 fa                	sar    %cl,%edx
   1e3f1:	f6 c1 20             	test   $0x20,%cl
   1e3f4:	74 02                	je     1e3f8 <lwm2m_b64_to_f64+0x1a0>
   1e3f6:	89 d0                	mov    %edx,%eax
   1e3f8:	83 e0 01             	and    $0x1,%eax
   1e3fb:	74 09                	je     1e406 <lwm2m_b64_to_f64+0x1ae>
			f64->val2 += k;
   1e3fd:	8b 45 10             	mov    0x10(%ebp),%eax
   1e400:	01 58 08             	add    %ebx,0x8(%eax)
   1e403:	11 78 0c             	adc    %edi,0xc(%eax)
	for (i = 51 - e; i >= 0; i--) {
   1e406:	49                   	dec    %ecx
   1e407:	eb bf                	jmp    1e3c8 <lwm2m_b64_to_f64+0x170>

		}
	}

	return 0;
   1e409:	31 c0                	xor    %eax,%eax
}
   1e40b:	83 c4 10             	add    $0x10,%esp
   1e40e:	5b                   	pop    %ebx
   1e40f:	5e                   	pop    %esi
   1e410:	5f                   	pop    %edi
   1e411:	5d                   	pop    %ebp
   1e412:	c3                   	ret    

0001e413 <set_sm_state>:
		event = LWM2M_RD_CLIENT_EVENT_BOOTSTRAP_REG_COMPLETE;
	} else if (sm_state == ENGINE_BOOTSTRAP_TRANS_DONE) {
		event = LWM2M_RD_CLIENT_EVENT_BOOTSTRAP_TRANSFER_COMPLETE;
	} else
#endif
	if (client.engine_state == ENGINE_UPDATE_SENT &&
   1e413:	8a 15 68 36 40 00    	mov    0x403668,%dl
   1e419:	80 fa 04             	cmp    $0x4,%dl
   1e41c:	75 12                	jne    1e430 <set_sm_state+0x1d>
   1e41e:	3c 03                	cmp    $0x3,%al
   1e420:	75 12                	jne    1e434 <set_sm_state+0x21>
		    client.engine_state < ENGINE_DEREGISTER)) {
		event = LWM2M_RD_CLIENT_EVENT_DISCONNECT;
	}

	/* TODO: add locking? */
	client.engine_state = sm_state;
   1e422:	c6 05 68 36 40 00 03 	movb   $0x3,0x403668
		event = LWM2M_RD_CLIENT_EVENT_REG_UPDATE_COMPLETE;
   1e429:	b8 07 00 00 00       	mov    $0x7,%eax
   1e42e:	eb 25                	jmp    1e455 <set_sm_state+0x42>
	} else if (sm_state == ENGINE_REGISTRATION_DONE) {
   1e430:	3c 03                	cmp    $0x3,%al
   1e432:	74 15                	je     1e449 <set_sm_state+0x36>
	client.engine_state = sm_state;
   1e434:	a2 68 36 40 00       	mov    %al,0x403668
	} else if ((sm_state == ENGINE_INIT ||
   1e439:	a8 f7                	test   $0xf7,%al
   1e43b:	75 0b                	jne    1e448 <set_sm_state+0x35>
		   (client.engine_state >= ENGINE_DO_REGISTRATION &&
   1e43d:	4a                   	dec    %edx
		event = LWM2M_RD_CLIENT_EVENT_DISCONNECT;
   1e43e:	b8 09 00 00 00       	mov    $0x9,%eax
		    sm_state == ENGINE_DEREGISTERED) &&
   1e443:	80 fa 03             	cmp    $0x3,%dl
   1e446:	76 0d                	jbe    1e455 <set_sm_state+0x42>

	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
   1e448:	c3                   	ret    
	client.engine_state = sm_state;
   1e449:	c6 05 68 36 40 00 03 	movb   $0x3,0x403668
		event = LWM2M_RD_CLIENT_EVENT_REGISTRATION_COMPLETE;
   1e450:	b8 05 00 00 00       	mov    $0x5,%eax
	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
   1e455:	8b 15 b8 36 40 00    	mov    0x4036b8,%edx
   1e45b:	85 d2                	test   %edx,%edx
   1e45d:	74 10                	je     1e46f <set_sm_state+0x5c>
{
   1e45f:	55                   	push   %ebp
   1e460:	89 e5                	mov    %esp,%ebp
		client.event_cb(client.ctx, event);
   1e462:	50                   	push   %eax
   1e463:	ff 35 64 36 40 00    	pushl  0x403664
   1e469:	ff d2                	call   *%edx
   1e46b:	58                   	pop    %eax
   1e46c:	5a                   	pop    %edx
	}
}
   1e46d:	c9                   	leave  
   1e46e:	c3                   	ret    
   1e46f:	c3                   	ret    

0001e470 <lwm2m_rd_client_init>:
	strncpy(client.ep_name, ep_name, CLIENT_EP_LEN - 1);
	LOG_INF("LWM2M Client: %s", client.ep_name);
}

static int lwm2m_rd_client_init(struct device *dev)
{
   1e470:	55                   	push   %ebp
   1e471:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_add_service(lwm2m_rd_client_service,
   1e473:	68 f4 01 00 00       	push   $0x1f4
   1e478:	68 b6 eb 01 00       	push   $0x1ebb6
   1e47d:	e8 a4 d0 ff ff       	call   1b526 <lwm2m_engine_add_service>
   1e482:	5a                   	pop    %edx
   1e483:	59                   	pop    %ecx
					STATE_MACHINE_UPDATE_INTERVAL);
}
   1e484:	c9                   	leave  
   1e485:	c3                   	ret    

0001e486 <do_update_reply_cb>:
{
   1e486:	55                   	push   %ebp
   1e487:	89 e5                	mov    %esp,%ebp
   1e489:	53                   	push   %ebx
	code = coap_header_get_code(response);
   1e48a:	ff 75 08             	pushl  0x8(%ebp)
   1e48d:	e8 46 a0 fe ff       	call   84d8 <coap_header_get_code>
   1e492:	88 c3                	mov    %al,%bl
	LOG_INF("Update callback (code:%u.%u)",
   1e494:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
   1e499:	83 e0 07             	and    $0x7,%eax
	code = coap_header_get_code(response);
   1e49c:	59                   	pop    %ecx
	LOG_INF("Update callback (code:%u.%u)",
   1e49d:	83 f8 02             	cmp    $0x2,%eax
   1e4a0:	76 30                	jbe    1e4d2 <do_update_reply_cb+0x4c>
   1e4a2:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e4a7:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e4ac:	c1 e8 03             	shr    $0x3,%eax
   1e4af:	c1 e0 06             	shl    $0x6,%eax
   1e4b2:	83 c8 03             	or     $0x3,%eax
   1e4b5:	50                   	push   %eax
   1e4b6:	89 d8                	mov    %ebx,%eax
   1e4b8:	83 e0 1f             	and    $0x1f,%eax
   1e4bb:	50                   	push   %eax
   1e4bc:	88 d8                	mov    %bl,%al
   1e4be:	c0 e8 05             	shr    $0x5,%al
   1e4c1:	0f b6 c0             	movzbl %al,%eax
   1e4c4:	50                   	push   %eax
   1e4c5:	68 10 a1 02 00       	push   $0x2a110
   1e4ca:	e8 1a 50 fe ff       	call   34e9 <log_2>
   1e4cf:	83 c4 10             	add    $0x10,%esp
	if ((code == COAP_RESPONSE_CODE_CHANGED) ||
   1e4d2:	80 fb 44             	cmp    $0x44,%bl
   1e4d5:	74 05                	je     1e4dc <do_update_reply_cb+0x56>
   1e4d7:	80 fb 41             	cmp    $0x41,%bl
   1e4da:	75 39                	jne    1e515 <do_update_reply_cb+0x8f>
		set_sm_state(ENGINE_REGISTRATION_DONE);
   1e4dc:	b8 03 00 00 00       	mov    $0x3,%eax
   1e4e1:	e8 2d ff ff ff       	call   1e413 <set_sm_state>
		LOG_INF("Update Done");
   1e4e6:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
   1e4eb:	83 e0 07             	and    $0x7,%eax
   1e4ee:	83 f8 02             	cmp    $0x2,%eax
   1e4f1:	76 63                	jbe    1e556 <do_update_reply_cb+0xd0>
   1e4f3:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e4f8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e4fd:	c1 e8 03             	shr    $0x3,%eax
   1e500:	c1 e0 06             	shl    $0x6,%eax
   1e503:	83 c8 03             	or     $0x3,%eax
   1e506:	50                   	push   %eax
   1e507:	68 2d a1 02 00       	push   $0x2a12d
   1e50c:	e8 79 4f fe ff       	call   348a <log_0>
   1e511:	58                   	pop    %eax
   1e512:	5a                   	pop    %edx
   1e513:	eb 41                	jmp    1e556 <do_update_reply_cb+0xd0>
	LOG_ERR("Failed with code %u.%u. Retrying registration",
   1e515:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1e51c:	74 2e                	je     1e54c <do_update_reply_cb+0xc6>
   1e51e:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e523:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e528:	c1 e8 03             	shr    $0x3,%eax
   1e52b:	c1 e0 06             	shl    $0x6,%eax
   1e52e:	83 c8 01             	or     $0x1,%eax
   1e531:	50                   	push   %eax
   1e532:	89 d8                	mov    %ebx,%eax
   1e534:	c0 eb 05             	shr    $0x5,%bl
   1e537:	83 e0 1f             	and    $0x1f,%eax
   1e53a:	50                   	push   %eax
   1e53b:	0f b6 db             	movzbl %bl,%ebx
   1e53e:	53                   	push   %ebx
   1e53f:	68 39 a1 02 00       	push   $0x2a139
   1e544:	e8 a0 4f fe ff       	call   34e9 <log_2>
   1e549:	83 c4 10             	add    $0x10,%esp
	set_sm_state(ENGINE_DO_REGISTRATION);
   1e54c:	b8 01 00 00 00       	mov    $0x1,%eax
   1e551:	e8 bd fe ff ff       	call   1e413 <set_sm_state>
}
   1e556:	31 c0                	xor    %eax,%eax
   1e558:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1e55b:	c9                   	leave  
   1e55c:	c3                   	ret    

0001e55d <do_deregister_reply_cb>:
{
   1e55d:	55                   	push   %ebp
   1e55e:	89 e5                	mov    %esp,%ebp
   1e560:	56                   	push   %esi
   1e561:	53                   	push   %ebx
	code = coap_header_get_code(response);
   1e562:	ff 75 08             	pushl  0x8(%ebp)
   1e565:	e8 6e 9f fe ff       	call   84d8 <coap_header_get_code>
	LOG_DBG("Deregister callback (code:%u.%u)",
   1e56a:	f6 05 c8 a8 40 00 04 	testb  $0x4,0x40a8c8
	code = coap_header_get_code(response);
   1e571:	5a                   	pop    %edx
   1e572:	88 c3                	mov    %al,%bl
	LOG_DBG("Deregister callback (code:%u.%u)",
   1e574:	74 63                	je     1e5d9 <do_deregister_reply_cb+0x7c>
   1e576:	be 14 52 02 00       	mov    $0x25214,%esi
   1e57b:	81 ee 3c 51 02 00    	sub    $0x2513c,%esi
   1e581:	c1 ee 03             	shr    $0x3,%esi
   1e584:	c1 e6 06             	shl    $0x6,%esi
   1e587:	89 f0                	mov    %esi,%eax
   1e589:	83 c8 04             	or     $0x4,%eax
   1e58c:	50                   	push   %eax
   1e58d:	89 d8                	mov    %ebx,%eax
   1e58f:	83 e0 1f             	and    $0x1f,%eax
   1e592:	50                   	push   %eax
   1e593:	88 d8                	mov    %bl,%al
   1e595:	c0 e8 05             	shr    $0x5,%al
   1e598:	0f b6 c0             	movzbl %al,%eax
   1e59b:	50                   	push   %eax
   1e59c:	68 30 64 02 00       	push   $0x26430
   1e5a1:	68 67 a1 02 00       	push   $0x2a167
   1e5a6:	e8 85 4f fe ff       	call   3530 <log_3>
   1e5ab:	83 c4 14             	add    $0x14,%esp
	if (code == COAP_RESPONSE_CODE_DELETED) {
   1e5ae:	80 fb 42             	cmp    $0x42,%bl
   1e5b1:	75 2a                	jne    1e5dd <do_deregister_reply_cb+0x80>
		LOG_DBG("Deregistration success");
   1e5b3:	f6 05 c8 a8 40 00 04 	testb  $0x4,0x40a8c8
   1e5ba:	74 16                	je     1e5d2 <do_deregister_reply_cb+0x75>
   1e5bc:	83 ce 04             	or     $0x4,%esi
   1e5bf:	56                   	push   %esi
   1e5c0:	68 30 64 02 00       	push   $0x26430
   1e5c5:	68 8c a1 02 00       	push   $0x2a18c
   1e5ca:	e8 e0 4e fe ff       	call   34af <log_1>
   1e5cf:	83 c4 0c             	add    $0xc,%esp
		set_sm_state(ENGINE_DEREGISTERED);
   1e5d2:	b8 08 00 00 00       	mov    $0x8,%eax
   1e5d7:	eb 49                	jmp    1e622 <do_deregister_reply_cb+0xc5>
	if (code == COAP_RESPONSE_CODE_DELETED) {
   1e5d9:	3c 42                	cmp    $0x42,%al
   1e5db:	74 f5                	je     1e5d2 <do_deregister_reply_cb+0x75>
		LOG_ERR("failed with code %u.%u",
   1e5dd:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1e5e4:	74 2e                	je     1e614 <do_deregister_reply_cb+0xb7>
   1e5e6:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e5eb:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e5f0:	c1 e8 03             	shr    $0x3,%eax
   1e5f3:	c1 e0 06             	shl    $0x6,%eax
   1e5f6:	83 c8 01             	or     $0x1,%eax
   1e5f9:	50                   	push   %eax
   1e5fa:	89 d8                	mov    %ebx,%eax
   1e5fc:	c0 eb 05             	shr    $0x5,%bl
   1e5ff:	83 e0 1f             	and    $0x1f,%eax
   1e602:	50                   	push   %eax
   1e603:	0f b6 db             	movzbl %bl,%ebx
   1e606:	53                   	push   %ebx
   1e607:	68 a7 a1 02 00       	push   $0x2a1a7
   1e60c:	e8 d8 4e fe ff       	call   34e9 <log_2>
   1e611:	83 c4 10             	add    $0x10,%esp
		if (get_sm_state() == ENGINE_DEREGISTER_SENT) {
   1e614:	80 3d 68 36 40 00 06 	cmpb   $0x6,0x403668
   1e61b:	75 0a                	jne    1e627 <do_deregister_reply_cb+0xca>
			set_sm_state(ENGINE_DEREGISTER_FAILED);
   1e61d:	b8 07 00 00 00       	mov    $0x7,%eax
   1e622:	e8 ec fd ff ff       	call   1e413 <set_sm_state>
}
   1e627:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1e62a:	31 c0                	xor    %eax,%eax
   1e62c:	5b                   	pop    %ebx
   1e62d:	5e                   	pop    %esi
   1e62e:	5d                   	pop    %ebp
   1e62f:	c3                   	ret    

0001e630 <do_registration_reply_cb>:
{
   1e630:	55                   	push   %ebp
   1e631:	89 e5                	mov    %esp,%ebp
   1e633:	53                   	push   %ebx
   1e634:	83 ec 24             	sub    $0x24,%esp
   1e637:	8b 5d 08             	mov    0x8(%ebp),%ebx
	code = coap_header_get_code(response);
   1e63a:	53                   	push   %ebx
   1e63b:	e8 98 9e fe ff       	call   84d8 <coap_header_get_code>
   1e640:	5a                   	pop    %edx
	LOG_DBG("Registration callback (code:%u.%u)",
   1e641:	f6 05 c8 a8 40 00 04 	testb  $0x4,0x40a8c8
   1e648:	74 3c                	je     1e686 <do_registration_reply_cb+0x56>
   1e64a:	ba 14 52 02 00       	mov    $0x25214,%edx
   1e64f:	88 45 db             	mov    %al,-0x25(%ebp)
   1e652:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1e658:	c1 ea 03             	shr    $0x3,%edx
   1e65b:	c1 e2 06             	shl    $0x6,%edx
   1e65e:	83 ca 04             	or     $0x4,%edx
   1e661:	52                   	push   %edx
   1e662:	89 c2                	mov    %eax,%edx
   1e664:	83 e2 1f             	and    $0x1f,%edx
   1e667:	52                   	push   %edx
   1e668:	88 c2                	mov    %al,%dl
   1e66a:	c0 ea 05             	shr    $0x5,%dl
   1e66d:	0f b6 d2             	movzbl %dl,%edx
   1e670:	52                   	push   %edx
   1e671:	68 78 64 02 00       	push   $0x26478
   1e676:	68 be a1 02 00       	push   $0x2a1be
   1e67b:	e8 b0 4e fe ff       	call   3530 <log_3>
   1e680:	83 c4 14             	add    $0x14,%esp
   1e683:	8a 45 db             	mov    -0x25(%ebp),%al
	if (code == COAP_RESPONSE_CODE_CREATED) {
   1e686:	3c 41                	cmp    $0x41,%al
   1e688:	0f 85 f8 00 00 00    	jne    1e786 <do_registration_reply_cb+0x156>
		ret = coap_find_options(response, COAP_OPTION_LOCATION_PATH,
   1e68e:	6a 02                	push   $0x2
   1e690:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1e693:	50                   	push   %eax
   1e694:	6a 08                	push   $0x8
   1e696:	53                   	push   %ebx
   1e697:	e8 f4 9c fe ff       	call   8390 <coap_find_options>
   1e69c:	83 c4 10             	add    $0x10,%esp
		if (ret < 2) {
   1e69f:	48                   	dec    %eax
   1e6a0:	7f 37                	jg     1e6d9 <do_registration_reply_cb+0xa9>
			return -EINVAL;
   1e6a2:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
			LOG_ERR("Unexpected endpoint data returned.");
   1e6a7:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1e6ae:	0f 84 69 01 00 00    	je     1e81d <do_registration_reply_cb+0x1ed>
   1e6b4:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e6b9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e6be:	c1 e8 03             	shr    $0x3,%eax
   1e6c1:	c1 e0 06             	shl    $0x6,%eax
   1e6c4:	83 c8 01             	or     $0x1,%eax
   1e6c7:	50                   	push   %eax
   1e6c8:	68 e5 a1 02 00       	push   $0x2a1e5
   1e6cd:	e8 b8 4d fe ff       	call   348a <log_0>
   1e6d2:	59                   	pop    %ecx
   1e6d3:	58                   	pop    %eax
   1e6d4:	e9 44 01 00 00       	jmp    1e81d <do_registration_reply_cb+0x1ed>
		if (options[1].len + 1 > sizeof(client.server_ep)) {
   1e6d9:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   1e6dd:	8d 42 01             	lea    0x1(%edx),%eax
   1e6e0:	83 f8 21             	cmp    $0x21,%eax
   1e6e3:	7e 3b                	jle    1e720 <do_registration_reply_cb+0xf0>
			return -EINVAL;
   1e6e5:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
			LOG_ERR("Unexpected length of query: "
   1e6ea:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1e6f1:	0f 84 26 01 00 00    	je     1e81d <do_registration_reply_cb+0x1ed>
   1e6f7:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e6fc:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e701:	c1 e8 03             	shr    $0x3,%eax
   1e704:	c1 e0 06             	shl    $0x6,%eax
   1e707:	83 c8 01             	or     $0x1,%eax
   1e70a:	50                   	push   %eax
   1e70b:	6a 21                	push   $0x21
   1e70d:	52                   	push   %edx
   1e70e:	68 08 a2 02 00       	push   $0x2a208
   1e713:	e8 d1 4d fe ff       	call   34e9 <log_2>
   1e718:	83 c4 10             	add    $0x10,%esp
   1e71b:	e9 fd 00 00 00       	jmp    1e81d <do_registration_reply_cb+0x1ed>
		memcpy(client.server_ep, options[1].value,
   1e720:	52                   	push   %edx
   1e721:	8d 45 ef             	lea    -0x11(%ebp),%eax
   1e724:	50                   	push   %eax
		return 0;
   1e725:	31 db                	xor    %ebx,%ebx
		memcpy(client.server_ep, options[1].value,
   1e727:	68 95 36 40 00       	push   $0x403695
   1e72c:	e8 00 c2 fe ff       	call   a931 <memcpy>
		client.server_ep[options[1].len] = '\0';
   1e731:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
		memcpy(client.server_ep, options[1].value,
   1e735:	83 c4 0c             	add    $0xc,%esp
		client.server_ep[options[1].len] = '\0';
   1e738:	c6 80 95 36 40 00 00 	movb   $0x0,0x403695(%eax)
		set_sm_state(ENGINE_REGISTRATION_DONE);
   1e73f:	b8 03 00 00 00       	mov    $0x3,%eax
   1e744:	e8 ca fc ff ff       	call   1e413 <set_sm_state>
		LOG_INF("Registration Done (EP='%s')",
   1e749:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
   1e74e:	83 e0 07             	and    $0x7,%eax
   1e751:	83 f8 02             	cmp    $0x2,%eax
   1e754:	0f 86 c3 00 00 00    	jbe    1e81d <do_registration_reply_cb+0x1ed>
   1e75a:	ba 14 52 02 00       	mov    $0x25214,%edx
   1e75f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1e765:	c1 ea 03             	shr    $0x3,%edx
   1e768:	c1 e2 06             	shl    $0x6,%edx
   1e76b:	83 ca 03             	or     $0x3,%edx
   1e76e:	52                   	push   %edx
   1e76f:	68 95 36 40 00       	push   $0x403695
   1e774:	68 37 a2 02 00       	push   $0x2a237
   1e779:	e8 31 4d fe ff       	call   34af <log_1>
   1e77e:	83 c4 0c             	add    $0xc,%esp
   1e781:	e9 97 00 00 00       	jmp    1e81d <do_registration_reply_cb+0x1ed>
	} else if (code == COAP_RESPONSE_CODE_NOT_FOUND) {
   1e786:	8b 15 c8 a8 40 00    	mov    0x40a8c8,%edx
   1e78c:	83 e2 07             	and    $0x7,%edx
   1e78f:	3c 84                	cmp    $0x84,%al
   1e791:	75 2b                	jne    1e7be <do_registration_reply_cb+0x18e>
		LOG_ERR("Failed: NOT_FOUND.  Not Retrying.");
   1e793:	85 d2                	test   %edx,%edx
   1e795:	74 20                	je     1e7b7 <do_registration_reply_cb+0x187>
   1e797:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e79c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e7a1:	c1 e8 03             	shr    $0x3,%eax
   1e7a4:	c1 e0 06             	shl    $0x6,%eax
   1e7a7:	83 c8 01             	or     $0x1,%eax
   1e7aa:	50                   	push   %eax
   1e7ab:	68 53 a2 02 00       	push   $0x2a253
   1e7b0:	e8 d5 4c fe ff       	call   348a <log_0>
   1e7b5:	58                   	pop    %eax
   1e7b6:	5a                   	pop    %edx
		set_sm_state(ENGINE_REGISTRATION_DONE);
   1e7b7:	b8 03 00 00 00       	mov    $0x3,%eax
   1e7bc:	eb 58                	jmp    1e816 <do_registration_reply_cb+0x1e6>
	} else if (code == COAP_RESPONSE_CODE_FORBIDDEN) {
   1e7be:	3c 83                	cmp    $0x83,%al
   1e7c0:	75 1f                	jne    1e7e1 <do_registration_reply_cb+0x1b1>
		LOG_ERR("Failed: 4.03 - Forbidden.  Not Retrying.");
   1e7c2:	85 d2                	test   %edx,%edx
   1e7c4:	74 f1                	je     1e7b7 <do_registration_reply_cb+0x187>
   1e7c6:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e7cb:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e7d0:	c1 e8 03             	shr    $0x3,%eax
   1e7d3:	c1 e0 06             	shl    $0x6,%eax
   1e7d6:	83 c8 01             	or     $0x1,%eax
   1e7d9:	50                   	push   %eax
   1e7da:	68 75 a2 02 00       	push   $0x2a275
   1e7df:	eb cf                	jmp    1e7b0 <do_registration_reply_cb+0x180>
	LOG_ERR("failed with code %u.%u. Re-init network",
   1e7e1:	85 d2                	test   %edx,%edx
   1e7e3:	74 2f                	je     1e814 <do_registration_reply_cb+0x1e4>
   1e7e5:	ba 14 52 02 00       	mov    $0x25214,%edx
   1e7ea:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1e7f0:	c1 ea 03             	shr    $0x3,%edx
   1e7f3:	c1 e2 06             	shl    $0x6,%edx
   1e7f6:	83 ca 01             	or     $0x1,%edx
   1e7f9:	52                   	push   %edx
   1e7fa:	89 c2                	mov    %eax,%edx
   1e7fc:	c0 e8 05             	shr    $0x5,%al
   1e7ff:	83 e2 1f             	and    $0x1f,%edx
   1e802:	52                   	push   %edx
   1e803:	0f b6 c0             	movzbl %al,%eax
   1e806:	50                   	push   %eax
   1e807:	68 9e a2 02 00       	push   $0x2a29e
   1e80c:	e8 d8 4c fe ff       	call   34e9 <log_2>
   1e811:	83 c4 10             	add    $0x10,%esp
	set_sm_state(ENGINE_INIT);
   1e814:	31 c0                	xor    %eax,%eax
   1e816:	e8 f8 fb ff ff       	call   1e413 <set_sm_state>
	return 0;
   1e81b:	31 db                	xor    %ebx,%ebx
}
   1e81d:	89 d8                	mov    %ebx,%eax
   1e81f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1e822:	c9                   	leave  
   1e823:	c3                   	ret    

0001e824 <sm_handle_timeout_state.isra.0>:
static void sm_handle_timeout_state(struct lwm2m_message *msg,
   1e824:	55                   	push   %ebp
	if (client.engine_state == ENGINE_REGISTRATION_SENT) {
   1e825:	8a 15 68 36 40 00    	mov    0x403668,%dl
static void sm_handle_timeout_state(struct lwm2m_message *msg,
   1e82b:	89 e5                	mov    %esp,%ebp
	if (client.engine_state == ENGINE_REGISTRATION_SENT) {
   1e82d:	80 fa 02             	cmp    $0x2,%dl
static void sm_handle_timeout_state(struct lwm2m_message *msg,
   1e830:	53                   	push   %ebx
		event = LWM2M_RD_CLIENT_EVENT_REGISTRATION_FAILURE;
   1e831:	bb 04 00 00 00       	mov    $0x4,%ebx
	if (client.engine_state == ENGINE_REGISTRATION_SENT) {
   1e836:	74 15                	je     1e84d <sm_handle_timeout_state.isra.0+0x29>
		event = LWM2M_RD_CLIENT_EVENT_REG_UPDATE_FAILURE;
   1e838:	bb 06 00 00 00       	mov    $0x6,%ebx
	} else if (client.engine_state == ENGINE_UPDATE_SENT) {
   1e83d:	80 fa 04             	cmp    $0x4,%dl
   1e840:	74 0b                	je     1e84d <sm_handle_timeout_state.isra.0+0x29>
		event = LWM2M_RD_CLIENT_EVENT_DEREGISTER_FAILURE;
   1e842:	31 db                	xor    %ebx,%ebx
   1e844:	80 fa 06             	cmp    $0x6,%dl
   1e847:	0f 94 c3             	sete   %bl
   1e84a:	c1 e3 03             	shl    $0x3,%ebx
	set_sm_state(sm_state);
   1e84d:	e8 c1 fb ff ff       	call   1e413 <set_sm_state>
	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
   1e852:	85 db                	test   %ebx,%ebx
   1e854:	74 14                	je     1e86a <sm_handle_timeout_state.isra.0+0x46>
   1e856:	a1 b8 36 40 00       	mov    0x4036b8,%eax
   1e85b:	85 c0                	test   %eax,%eax
   1e85d:	74 0b                	je     1e86a <sm_handle_timeout_state.isra.0+0x46>
		client.event_cb(client.ctx, event);
   1e85f:	53                   	push   %ebx
   1e860:	ff 35 64 36 40 00    	pushl  0x403664
   1e866:	ff d0                	call   *%eax
   1e868:	58                   	pop    %eax
   1e869:	5a                   	pop    %edx
}
   1e86a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1e86d:	c9                   	leave  
   1e86e:	c3                   	ret    

0001e86f <do_registration_timeout_cb>:
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e86f:	31 c0                	xor    %eax,%eax
	LOG_WRN("Registration Timeout");
   1e871:	f6 05 c8 a8 40 00 06 	testb  $0x6,0x40a8c8
   1e878:	74 26                	je     1e8a0 <do_registration_timeout_cb+0x31>
   1e87a:	b8 14 52 02 00       	mov    $0x25214,%eax
{
   1e87f:	55                   	push   %ebp
   1e880:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e885:	89 e5                	mov    %esp,%ebp
   1e887:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("Registration Timeout");
   1e88a:	c1 e0 06             	shl    $0x6,%eax
   1e88d:	83 c8 02             	or     $0x2,%eax
   1e890:	50                   	push   %eax
   1e891:	68 e5 a2 02 00       	push   $0x2a2e5
   1e896:	e8 ef 4b fe ff       	call   348a <log_0>
   1e89b:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e89c:	31 c0                	xor    %eax,%eax
	LOG_WRN("Registration Timeout");
   1e89e:	5a                   	pop    %edx
}
   1e89f:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e8a0:	e9 7f ff ff ff       	jmp    1e824 <sm_handle_timeout_state.isra.0>

0001e8a5 <do_update_timeout_cb>:
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
   1e8a5:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Registration Update Timeout");
   1e8aa:	f6 05 c8 a8 40 00 06 	testb  $0x6,0x40a8c8
   1e8b1:	74 29                	je     1e8dc <do_update_timeout_cb+0x37>
   1e8b3:	b8 14 52 02 00       	mov    $0x25214,%eax
{
   1e8b8:	55                   	push   %ebp
   1e8b9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e8be:	89 e5                	mov    %esp,%ebp
   1e8c0:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("Registration Update Timeout");
   1e8c3:	c1 e0 06             	shl    $0x6,%eax
   1e8c6:	83 c8 02             	or     $0x2,%eax
   1e8c9:	50                   	push   %eax
   1e8ca:	68 c6 a2 02 00       	push   $0x2a2c6
   1e8cf:	e8 b6 4b fe ff       	call   348a <log_0>
   1e8d4:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
   1e8d5:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Registration Update Timeout");
   1e8da:	5a                   	pop    %edx
}
   1e8db:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
   1e8dc:	e9 43 ff ff ff       	jmp    1e824 <sm_handle_timeout_state.isra.0>

0001e8e1 <do_deregister_timeout_cb>:
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e8e1:	31 c0                	xor    %eax,%eax
	LOG_WRN("De-Registration Timeout");
   1e8e3:	f6 05 c8 a8 40 00 06 	testb  $0x6,0x40a8c8
   1e8ea:	74 26                	je     1e912 <do_deregister_timeout_cb+0x31>
   1e8ec:	b8 14 52 02 00       	mov    $0x25214,%eax
{
   1e8f1:	55                   	push   %ebp
   1e8f2:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e8f7:	89 e5                	mov    %esp,%ebp
   1e8f9:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("De-Registration Timeout");
   1e8fc:	c1 e0 06             	shl    $0x6,%eax
   1e8ff:	83 c8 02             	or     $0x2,%eax
   1e902:	50                   	push   %eax
   1e903:	68 e2 a2 02 00       	push   $0x2a2e2
   1e908:	e8 7d 4b fe ff       	call   348a <log_0>
   1e90d:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e90e:	31 c0                	xor    %eax,%eax
	LOG_WRN("De-Registration Timeout");
   1e910:	5a                   	pop    %edx
}
   1e911:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_INIT);
   1e912:	e9 0d ff ff ff       	jmp    1e824 <sm_handle_timeout_state.isra.0>

0001e917 <sm_send_registration>:
{
   1e917:	55                   	push   %ebp
   1e918:	89 e5                	mov    %esp,%ebp
   1e91a:	57                   	push   %edi
   1e91b:	56                   	push   %esi
   1e91c:	89 d7                	mov    %edx,%edi
   1e91e:	53                   	push   %ebx
   1e91f:	89 ce                	mov    %ecx,%esi
   1e921:	83 ec 0c             	sub    $0xc,%esp
   1e924:	89 45 f0             	mov    %eax,-0x10(%ebp)
	msg = lwm2m_get_message(client.ctx);
   1e927:	ff 35 64 36 40 00    	pushl  0x403664
   1e92d:	e8 42 95 ff ff       	call   17e74 <lwm2m_get_message>
   1e932:	59                   	pop    %ecx
	if (!msg) {
   1e933:	85 c0                	test   %eax,%eax
   1e935:	75 37                	jne    1e96e <sm_send_registration+0x57>
		return -ENOMEM;
   1e937:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("Unable to get a lwm2m message!");
   1e93c:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1e943:	0f 84 63 02 00 00    	je     1ebac <sm_send_registration+0x295>
   1e949:	b8 14 52 02 00       	mov    $0x25214,%eax
   1e94e:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1e953:	c1 e8 03             	shr    $0x3,%eax
   1e956:	c1 e0 06             	shl    $0x6,%eax
   1e959:	83 c8 01             	or     $0x1,%eax
   1e95c:	50                   	push   %eax
   1e95d:	68 70 9a 02 00       	push   $0x29a70
   1e962:	e8 23 4b fe ff       	call   348a <log_0>
   1e967:	58                   	pop    %eax
   1e968:	5a                   	pop    %edx
   1e969:	e9 3e 02 00 00       	jmp    1ebac <sm_send_registration+0x295>
   1e96e:	89 c3                	mov    %eax,%ebx
   1e970:	e8 9c 5f 00 00       	call   24911 <z_impl_k_uptime_get>
	msg->reply_cb = reply_cb;
   1e975:	89 bb 78 01 00 00    	mov    %edi,0x178(%ebx)
	msg->message_timeout_cb = timeout_cb;
   1e97b:	89 b3 7c 01 00 00    	mov    %esi,0x17c(%ebx)
	msg->mid = 0U;
   1e981:	c7 83 80 01 00 00 00 	movl   $0x2000000,0x180(%ebx)
   1e988:	00 00 02 
	client.last_update = k_uptime_get();
   1e98b:	a3 6c 36 40 00       	mov    %eax,0x40366c
	ret = lwm2m_init_message(msg);
   1e990:	53                   	push   %ebx
	client.last_update = k_uptime_get();
   1e991:	89 15 70 36 40 00    	mov    %edx,0x403670
	ret = lwm2m_init_message(msg);
   1e997:	e8 91 96 ff ff       	call   1802d <lwm2m_init_message>
   1e99c:	5e                   	pop    %esi
   1e99d:	89 c7                	mov    %eax,%edi
	if (ret) {
   1e99f:	89 c6                	mov    %eax,%esi
   1e9a1:	85 c0                	test   %eax,%eax
   1e9a3:	0f 85 f7 01 00 00    	jne    1eba0 <sm_send_registration+0x289>
				  strlen(LWM2M_RD_CLIENT_URI));
   1e9a9:	68 fa a2 02 00       	push   $0x2a2fa
   1e9ae:	e8 b0 be fe ff       	call   a863 <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
   1e9b3:	0f b7 c0             	movzwl %ax,%eax
   1e9b6:	89 04 24             	mov    %eax,(%esp)
   1e9b9:	68 fa a2 02 00       	push   $0x2a2fa
   1e9be:	6a 0b                	push   $0xb
   1e9c0:	8d 73 2c             	lea    0x2c(%ebx),%esi
   1e9c3:	56                   	push   %esi
   1e9c4:	e8 3f 96 fe ff       	call   8008 <coap_packet_append_option>
	return (client.engine_state >= ENGINE_REGISTRATION_DONE &&
   1e9c9:	a0 68 36 40 00       	mov    0x403668,%al
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
   1e9ce:	83 c4 10             	add    $0x10,%esp
	return (client.engine_state >= ENGINE_REGISTRATION_DONE &&
   1e9d1:	83 e8 03             	sub    $0x3,%eax
	if (!sm_is_registered()) {
   1e9d4:	3c 04                	cmp    $0x4,%al
   1e9d6:	76 78                	jbe    1ea50 <sm_send_registration+0x139>
		coap_append_option_int(&msg->cpkt, COAP_OPTION_CONTENT_FORMAT,
   1e9d8:	6a 28                	push   $0x28
   1e9da:	6a 0c                	push   $0xc
   1e9dc:	56                   	push   %esi
   1e9dd:	e8 c6 97 fe ff       	call   81a8 <coap_append_option_int>
   1e9e2:	83 c4 0c             	add    $0xc,%esp
		snprintk(query_buffer, sizeof(query_buffer) - 1,
   1e9e5:	68 65 68 02 00       	push   $0x26865
   1e9ea:	68 fd a2 02 00       	push   $0x2a2fd
   1e9ef:	6a 3f                	push   $0x3f
   1e9f1:	68 20 36 40 00       	push   $0x403620
   1e9f6:	e8 e2 41 fe ff       	call   2bdd <snprintk>
   1e9fb:	83 c4 10             	add    $0x10,%esp
					  query_buffer, strlen(query_buffer));
   1e9fe:	68 20 36 40 00       	push   $0x403620
   1ea03:	e8 5b be fe ff       	call   a863 <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
   1ea08:	0f b7 c0             	movzwl %ax,%eax
   1ea0b:	89 04 24             	mov    %eax,(%esp)
   1ea0e:	68 20 36 40 00       	push   $0x403620
   1ea13:	6a 0f                	push   $0xf
   1ea15:	56                   	push   %esi
   1ea16:	e8 ed 95 fe ff       	call   8008 <coap_packet_append_option>
   1ea1b:	83 c4 10             	add    $0x10,%esp
		snprintk(query_buffer, sizeof(query_buffer) - 1,
   1ea1e:	68 74 36 40 00       	push   $0x403674
   1ea23:	68 06 a3 02 00       	push   $0x2a306
   1ea28:	6a 3f                	push   $0x3f
   1ea2a:	68 20 36 40 00       	push   $0x403620
   1ea2f:	e8 a9 41 fe ff       	call   2bdd <snprintk>
   1ea34:	83 c4 10             	add    $0x10,%esp
					  query_buffer, strlen(query_buffer));
   1ea37:	68 20 36 40 00       	push   $0x403620
   1ea3c:	e8 22 be fe ff       	call   a863 <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
   1ea41:	0f b7 c0             	movzwl %ax,%eax
   1ea44:	89 04 24             	mov    %eax,(%esp)
   1ea47:	68 20 36 40 00       	push   $0x403620
   1ea4c:	6a 0f                	push   $0xf
   1ea4e:	eb 17                	jmp    1ea67 <sm_send_registration+0x150>
					  strlen(client.server_ep));
   1ea50:	68 95 36 40 00       	push   $0x403695
   1ea55:	e8 09 be fe ff       	call   a863 <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
   1ea5a:	0f b7 c0             	movzwl %ax,%eax
   1ea5d:	89 04 24             	mov    %eax,(%esp)
   1ea60:	68 95 36 40 00       	push   $0x403695
   1ea65:	6a 0b                	push   $0xb
   1ea67:	56                   	push   %esi
   1ea68:	e8 9b 95 fe ff       	call   8008 <coap_packet_append_option>
   1ea6d:	83 c4 10             	add    $0x10,%esp
	snprintk(query_buffer, sizeof(query_buffer) - 1,
   1ea70:	ff 35 60 36 40 00    	pushl  0x403660
   1ea76:	68 0c a3 02 00       	push   $0x2a30c
   1ea7b:	6a 3f                	push   $0x3f
   1ea7d:	68 20 36 40 00       	push   $0x403620
   1ea82:	e8 56 41 fe ff       	call   2bdd <snprintk>
   1ea87:	83 c4 10             	add    $0x10,%esp
				  query_buffer, strlen(query_buffer));
   1ea8a:	68 20 36 40 00       	push   $0x403620
   1ea8f:	e8 cf bd fe ff       	call   a863 <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
   1ea94:	0f b7 c0             	movzwl %ax,%eax
   1ea97:	89 04 24             	mov    %eax,(%esp)
   1ea9a:	68 20 36 40 00       	push   $0x403620
   1ea9f:	6a 0f                	push   $0xf
   1eaa1:	56                   	push   %esi
   1eaa2:	e8 61 95 fe ff       	call   8008 <coap_packet_append_option>
   1eaa7:	83 c4 10             	add    $0x10,%esp
	if (send_obj_support_data) {
   1eaaa:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
   1eaae:	74 6d                	je     1eb1d <sm_send_registration+0x206>
		ret = coap_packet_append_payload_marker(&msg->cpkt);
   1eab0:	56                   	push   %esi
   1eab1:	e8 af 97 fe ff       	call   8265 <coap_packet_append_payload_marker>
   1eab6:	59                   	pop    %ecx
   1eab7:	89 c6                	mov    %eax,%esi
		if (ret < 0) {
   1eab9:	85 c0                	test   %eax,%eax
   1eabb:	0f 88 df 00 00 00    	js     1eba0 <sm_send_registration+0x289>
		client_data_len = lwm2m_get_rd_data(client_data,
   1eac1:	68 00 01 00 00       	push   $0x100
   1eac6:	68 20 35 40 00       	push   $0x403520
   1eacb:	e8 79 bb ff ff       	call   1a649 <lwm2m_get_rd_data>
   1ead0:	0f b7 c8             	movzwl %ax,%ecx
		ret = buf_append(CPKT_BUF_WRITE(&msg->cpkt), client_data,
   1ead3:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
		client_data_len = lwm2m_get_rd_data(client_data,
   1ead7:	5e                   	pop    %esi
   1ead8:	89 ce                	mov    %ecx,%esi
   1eada:	5a                   	pop    %edx
		ret = buf_append(CPKT_BUF_WRITE(&msg->cpkt), client_data,
   1eadb:	89 c2                	mov    %eax,%edx
   1eadd:	8b 43 2c             	mov    0x2c(%ebx),%eax
   1eae0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!dst || !src) {
   1eae3:	85 c0                	test   %eax,%eax
   1eae5:	0f 84 a9 00 00 00    	je     1eb94 <sm_send_registration+0x27d>
	if (*dst_len + src_len > dst_size) {
   1eaeb:	0f b7 43 30          	movzwl 0x30(%ebx),%eax
   1eaef:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1eaf2:	01 c8                	add    %ecx,%eax
   1eaf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1eaf7:	89 d0                	mov    %edx,%eax
   1eaf9:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1eafc:	39 d0                	cmp    %edx,%eax
   1eafe:	0f 8c 97 00 00 00    	jl     1eb9b <sm_send_registration+0x284>
	memcpy(dst + *dst_len, src, src_len);
   1eb04:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1eb07:	51                   	push   %ecx
   1eb08:	03 45 ec             	add    -0x14(%ebp),%eax
   1eb0b:	68 20 35 40 00       	push   $0x403520
   1eb10:	50                   	push   %eax
   1eb11:	e8 1b be fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   1eb16:	66 01 73 30          	add    %si,0x30(%ebx)
	memcpy(dst + *dst_len, src, src_len);
   1eb1a:	83 c4 0c             	add    $0xc,%esp
	ret = lwm2m_send_message(msg);
   1eb1d:	53                   	push   %ebx
   1eb1e:	e8 5e b3 ff ff       	call   19e81 <lwm2m_send_message>
   1eb23:	59                   	pop    %ecx
   1eb24:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1eb26:	85 c0                	test   %eax,%eax
   1eb28:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
   1eb2d:	79 29                	jns    1eb58 <sm_send_registration+0x241>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
   1eb2f:	a8 07                	test   $0x7,%al
   1eb31:	74 6d                	je     1eba0 <sm_send_registration+0x289>
   1eb33:	ba 14 52 02 00       	mov    $0x25214,%edx
   1eb38:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1eb3e:	c1 ea 03             	shr    $0x3,%edx
   1eb41:	c1 e2 06             	shl    $0x6,%edx
   1eb44:	83 ca 01             	or     $0x1,%edx
   1eb47:	52                   	push   %edx
   1eb48:	56                   	push   %esi
   1eb49:	68 47 9b 02 00       	push   $0x29b47
   1eb4e:	e8 5c 49 fe ff       	call   34af <log_1>
   1eb53:	83 c4 0c             	add    $0xc,%esp
   1eb56:	eb 48                	jmp    1eba0 <sm_send_registration+0x289>
	LOG_DBG("registration sent [%s]",
   1eb58:	a8 04                	test   $0x4,%al
   1eb5a:	74 50                	je     1ebac <sm_send_registration+0x295>
   1eb5c:	ff 35 64 36 40 00    	pushl  0x403664
   1eb62:	e8 61 88 ff ff       	call   173c8 <lwm2m_sprint_ip_addr>
   1eb67:	bb 14 52 02 00       	mov    $0x25214,%ebx
   1eb6c:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   1eb72:	c1 eb 03             	shr    $0x3,%ebx
   1eb75:	c1 e3 06             	shl    $0x6,%ebx
   1eb78:	83 cb 04             	or     $0x4,%ebx
   1eb7b:	66 89 1c 24          	mov    %bx,(%esp)
   1eb7f:	50                   	push   %eax
   1eb80:	68 48 64 02 00       	push   $0x26448
   1eb85:	68 12 a3 02 00       	push   $0x2a312
   1eb8a:	e8 5a 49 fe ff       	call   34e9 <log_2>
   1eb8f:	83 c4 10             	add    $0x10,%esp
   1eb92:	eb 18                	jmp    1ebac <sm_send_registration+0x295>
		return -EINVAL;
   1eb94:	be ea ff ff ff       	mov    $0xffffffea,%esi
   1eb99:	eb 05                	jmp    1eba0 <sm_send_registration+0x289>
		return -ENOMEM;
   1eb9b:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
	lwm2m_reset_message(msg, true);
   1eba0:	6a 01                	push   $0x1
	return ret;
   1eba2:	89 f7                	mov    %esi,%edi
	lwm2m_reset_message(msg, true);
   1eba4:	53                   	push   %ebx
   1eba5:	e8 f8 92 ff ff       	call   17ea2 <lwm2m_reset_message>
   1ebaa:	58                   	pop    %eax
   1ebab:	5a                   	pop    %edx
}
   1ebac:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1ebaf:	89 f8                	mov    %edi,%eax
   1ebb1:	5b                   	pop    %ebx
   1ebb2:	5e                   	pop    %esi
   1ebb3:	5f                   	pop    %edi
   1ebb4:	5d                   	pop    %ebp
   1ebb5:	c3                   	ret    

0001ebb6 <lwm2m_rd_client_service>:
	if (client.ctx) {
   1ebb6:	a1 64 36 40 00       	mov    0x403664,%eax
   1ebbb:	85 c0                	test   %eax,%eax
   1ebbd:	0f 84 88 04 00 00    	je     1f04b <lwm2m_rd_client_service+0x495>
{
   1ebc3:	55                   	push   %ebp
   1ebc4:	89 e5                	mov    %esp,%ebp
   1ebc6:	57                   	push   %edi
   1ebc7:	56                   	push   %esi
   1ebc8:	53                   	push   %ebx
   1ebc9:	83 ec 20             	sub    $0x20,%esp
	return client.engine_state;
   1ebcc:	0f b6 15 68 36 40 00 	movzbl 0x403668,%edx
		switch (get_sm_state()) {
   1ebd3:	80 fa 08             	cmp    $0x8,%dl
   1ebd6:	0f 87 3c 04 00 00    	ja     1f018 <lwm2m_rd_client_service+0x462>
   1ebdc:	ff 24 95 0c 64 02 00 	jmp    *0x2640c(,%edx,4)
	client.ctx->sec_obj_inst = -1;
   1ebe3:	c7 80 7c 01 00 00 ff 	movl   $0xffffffff,0x17c(%eax)
   1ebea:	ff ff ff 
	client.trigger_update = 0U;
   1ebed:	c6 05 6a 36 40 00 00 	movb   $0x0,0x40366a
	client.lifetime = 0U;
   1ebf4:	c7 05 60 36 40 00 00 	movl   $0x0,0x403660
   1ebfb:	00 00 00 
	set_sm_state(ENGINE_DO_REGISTRATION);
   1ebfe:	e9 ee 02 00 00       	jmp    1eef1 <lwm2m_rd_client_service+0x33b>
	if (client.ctx->sock_fd > -1) {
   1ec03:	83 b8 84 01 00 00 00 	cmpl   $0x0,0x184(%eax)
   1ec0a:	78 07                	js     1ec13 <lwm2m_rd_client_service+0x5d>
		lwm2m_engine_context_close(client.ctx);
   1ec0c:	50                   	push   %eax
   1ec0d:	e8 33 ca ff ff       	call   1b645 <lwm2m_engine_context_close>
   1ec12:	59                   	pop    %ecx
	client.ctx->bootstrap_mode = false;
   1ec13:	8b 35 64 36 40 00    	mov    0x403664,%esi
	i = lwm2m_security_inst_id_to_index(*sec_obj_inst);
   1ec19:	0f b7 86 7c 01 00 00 	movzwl 0x17c(%esi),%eax
	client.ctx->bootstrap_mode = false;
   1ec20:	c6 86 80 01 00 00 00 	movb   $0x0,0x180(%esi)
	i = lwm2m_security_inst_id_to_index(*sec_obj_inst);
   1ec27:	50                   	push   %eax
   1ec28:	e8 b0 d0 ff ff       	call   1bcdd <lwm2m_security_inst_id_to_index>
   1ec2d:	5a                   	pop    %edx
	if (i < 0) {
   1ec2e:	89 c3                	mov    %eax,%ebx
	i = lwm2m_security_inst_id_to_index(*sec_obj_inst);
   1ec30:	89 c2                	mov    %eax,%edx
	if (i < 0) {
   1ec32:	85 c0                	test   %eax,%eax
   1ec34:	79 2b                	jns    1ec61 <lwm2m_rd_client_service+0xab>
		*sec_obj_inst = -1;
   1ec36:	c7 86 7c 01 00 00 ff 	movl   $0xffffffff,0x17c(%esi)
   1ec3d:	ff ff ff 
   1ec40:	83 cb ff             	or     $0xffffffff,%ebx
	end = (i == -1 ? CONFIG_LWM2M_SECURITY_INSTANCE_COUNT : i);
   1ec43:	ba 01 00 00 00       	mov    $0x1,%edx
	for (i++; i < end; i++) {
   1ec48:	eb 17                	jmp    1ec61 <lwm2m_rd_client_service+0xab>
		if (i >= CONFIG_LWM2M_SECURITY_INSTANCE_COUNT) {
   1ec4a:	85 db                	test   %ebx,%ebx
   1ec4c:	7e 02                	jle    1ec50 <lwm2m_rd_client_service+0x9a>
   1ec4e:	31 db                	xor    %ebx,%ebx
   1ec50:	89 55 d8             	mov    %edx,-0x28(%ebp)
		obj_inst_id = lwm2m_security_index_to_inst_id(i);
   1ec53:	53                   	push   %ebx
   1ec54:	e8 aa d0 ff ff       	call   1bd03 <lwm2m_security_index_to_inst_id>
   1ec59:	5f                   	pop    %edi
		if (obj_inst_id < 0) {
   1ec5a:	85 c0                	test   %eax,%eax
   1ec5c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1ec5f:	79 0a                	jns    1ec6b <lwm2m_rd_client_service+0xb5>
	for (i++; i < end; i++) {
   1ec61:	43                   	inc    %ebx
   1ec62:	39 d3                	cmp    %edx,%ebx
   1ec64:	7c e4                	jl     1ec4a <lwm2m_rd_client_service+0x94>
   1ec66:	e9 99 00 00 00       	jmp    1ed04 <lwm2m_rd_client_service+0x14e>
		snprintk(pathstr, sizeof(pathstr), "0/%d/1",
   1ec6b:	50                   	push   %eax
   1ec6c:	8d 7d e0             	lea    -0x20(%ebp),%edi
   1ec6f:	68 2d a3 02 00       	push   $0x2a32d
   1ec74:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   1ec77:	6a 14                	push   $0x14
   1ec79:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1ec7c:	57                   	push   %edi
   1ec7d:	e8 5b 3f fe ff       	call   2bdd <snprintk>
   1ec82:	83 c4 10             	add    $0x10,%esp
		ret = lwm2m_engine_get_bool(pathstr, &temp);
   1ec85:	8d 45 df             	lea    -0x21(%ebp),%eax
   1ec88:	50                   	push   %eax
   1ec89:	57                   	push   %edi
   1ec8a:	e8 56 bd ff ff       	call   1a9e5 <lwm2m_engine_get_bool>
   1ec8f:	5a                   	pop    %edx
		if (ret < 0) {
   1ec90:	85 c0                	test   %eax,%eax
		ret = lwm2m_engine_get_bool(pathstr, &temp);
   1ec92:	59                   	pop    %ecx
		if (ret < 0) {
   1ec93:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1ec96:	78 c9                	js     1ec61 <lwm2m_rd_client_service+0xab>
		if (temp == false) {
   1ec98:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1ec9c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1ec9f:	75 c0                	jne    1ec61 <lwm2m_rd_client_service+0xab>
		*sec_obj_inst = found;
   1eca1:	89 8e 7c 01 00 00    	mov    %ecx,0x17c(%esi)
		snprintk(pathstr, sizeof(pathstr), "1/%d/1",
   1eca7:	51                   	push   %ecx
   1eca8:	68 5b a4 02 00       	push   $0x2a45b
   1ecad:	6a 14                	push   $0x14
   1ecaf:	57                   	push   %edi
   1ecb0:	e8 28 3f fe ff       	call   2bdd <snprintk>
   1ecb5:	83 c4 10             	add    $0x10,%esp
		if (lwm2m_engine_get_u32(pathstr, lifetime) < 0) {
   1ecb8:	68 60 36 40 00       	push   $0x403660
   1ecbd:	57                   	push   %edi
   1ecbe:	e8 fa bc ff ff       	call   1a9bd <lwm2m_engine_get_u32>
   1ecc3:	5a                   	pop    %edx
   1ecc4:	85 c0                	test   %eax,%eax
   1ecc6:	59                   	pop    %ecx
   1ecc7:	79 3b                	jns    1ed04 <lwm2m_rd_client_service+0x14e>
			*lifetime = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
   1ecc9:	c7 05 60 36 40 00 1e 	movl   $0x1e,0x403660
   1ecd0:	00 00 00 
			LOG_DBG("Using default lifetime: %u", *lifetime);
   1ecd3:	f6 05 c8 a8 40 00 04 	testb  $0x4,0x40a8c8
   1ecda:	74 28                	je     1ed04 <lwm2m_rd_client_service+0x14e>
   1ecdc:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ece1:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ece6:	c1 e8 03             	shr    $0x3,%eax
   1ece9:	c1 e0 06             	shl    $0x6,%eax
   1ecec:	83 c8 04             	or     $0x4,%eax
   1ecef:	50                   	push   %eax
   1ecf0:	6a 1e                	push   $0x1e
   1ecf2:	68 60 64 02 00       	push   $0x26460
   1ecf7:	68 34 a3 02 00       	push   $0x2a334
   1ecfc:	e8 e8 47 fe ff       	call   34e9 <log_2>
   1ed01:	83 c4 10             	add    $0x10,%esp
	if (*sec_obj_inst < 0) {
   1ed04:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
   1ed09:	83 be 7c 01 00 00 00 	cmpl   $0x0,0x17c(%esi)
   1ed10:	78 15                	js     1ed27 <lwm2m_rd_client_service+0x171>
	if (client.lifetime == 0U) {
   1ed12:	83 3d 60 36 40 00 00 	cmpl   $0x0,0x403660
   1ed19:	75 65                	jne    1ed80 <lwm2m_rd_client_service+0x1ca>
		client.lifetime = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
   1ed1b:	c7 05 60 36 40 00 1e 	movl   $0x1e,0x403660
   1ed22:	00 00 00 
   1ed25:	eb 59                	jmp    1ed80 <lwm2m_rd_client_service+0x1ca>
		LOG_WRN("sec_obj_inst: No matching servers found.");
   1ed27:	a8 06                	test   $0x6,%al
   1ed29:	74 20                	je     1ed4b <lwm2m_rd_client_service+0x195>
   1ed2b:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ed30:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ed35:	c1 e8 03             	shr    $0x3,%eax
   1ed38:	c1 e0 06             	shl    $0x6,%eax
   1ed3b:	83 c8 02             	or     $0x2,%eax
   1ed3e:	50                   	push   %eax
   1ed3f:	68 53 a3 02 00       	push   $0x2a353
   1ed44:	e8 41 47 fe ff       	call   348a <log_0>
   1ed49:	5e                   	pop    %esi
   1ed4a:	5f                   	pop    %edi
		LOG_ERR("Unable to find a valid security instance.");
   1ed4b:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1ed52:	74 20                	je     1ed74 <lwm2m_rd_client_service+0x1be>
   1ed54:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ed59:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ed5e:	c1 e8 03             	shr    $0x3,%eax
   1ed61:	c1 e0 06             	shl    $0x6,%eax
   1ed64:	83 c8 01             	or     $0x1,%eax
   1ed67:	50                   	push   %eax
   1ed68:	68 7c a3 02 00       	push   $0x2a37c
   1ed6d:	e8 18 47 fe ff       	call   348a <log_0>
   1ed72:	59                   	pop    %ecx
   1ed73:	5b                   	pop    %ebx
		set_sm_state(ENGINE_INIT);
   1ed74:	31 c0                	xor    %eax,%eax
   1ed76:	e8 98 f6 ff ff       	call   1e413 <set_sm_state>
		return -EINVAL;
   1ed7b:	e9 c3 02 00 00       	jmp    1f043 <lwm2m_rd_client_service+0x48d>
	LOG_INF("RD Client started with endpoint '%s' with client lifetime %d",
   1ed80:	83 e0 07             	and    $0x7,%eax
   1ed83:	83 f8 02             	cmp    $0x2,%eax
   1ed86:	76 2c                	jbe    1edb4 <lwm2m_rd_client_service+0x1fe>
   1ed88:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ed8d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ed92:	c1 e8 03             	shr    $0x3,%eax
   1ed95:	c1 e0 06             	shl    $0x6,%eax
   1ed98:	83 c8 03             	or     $0x3,%eax
   1ed9b:	50                   	push   %eax
   1ed9c:	ff 35 60 36 40 00    	pushl  0x403660
   1eda2:	68 74 36 40 00       	push   $0x403674
   1eda7:	68 a6 a3 02 00       	push   $0x2a3a6
   1edac:	e8 38 47 fe ff       	call   34e9 <log_2>
   1edb1:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_start(client.ctx);
   1edb4:	ff 35 64 36 40 00    	pushl  0x403664
   1edba:	e8 23 cb ff ff       	call   1b8e2 <lwm2m_engine_start>
   1edbf:	5a                   	pop    %edx
	if (ret < 0) {
   1edc0:	85 c0                	test   %eax,%eax
   1edc2:	79 2d                	jns    1edf1 <lwm2m_rd_client_service+0x23b>
		LOG_ERR("Cannot init LWM2M engine (%d)", ret);
   1edc4:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1edcb:	0f 84 72 02 00 00    	je     1f043 <lwm2m_rd_client_service+0x48d>
   1edd1:	ba 14 52 02 00       	mov    $0x25214,%edx
   1edd6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1eddc:	c1 ea 03             	shr    $0x3,%edx
   1eddf:	c1 e2 06             	shl    $0x6,%edx
   1ede2:	83 ca 01             	or     $0x1,%edx
   1ede5:	52                   	push   %edx
   1ede6:	50                   	push   %eax
   1ede7:	68 e3 a3 02 00       	push   $0x2a3e3
   1edec:	e9 4a 02 00 00       	jmp    1f03b <lwm2m_rd_client_service+0x485>
	ret = sm_send_registration(true,
   1edf1:	b9 6f e8 01 00       	mov    $0x1e86f,%ecx
   1edf6:	ba 30 e6 01 00       	mov    $0x1e630,%edx
   1edfb:	b8 01 00 00 00       	mov    $0x1,%eax
   1ee00:	e8 12 fb ff ff       	call   1e917 <sm_send_registration>
	if (!ret) {
   1ee05:	85 c0                	test   %eax,%eax
   1ee07:	75 0a                	jne    1ee13 <lwm2m_rd_client_service+0x25d>
		set_sm_state(ENGINE_REGISTRATION_SENT);
   1ee09:	b8 02 00 00 00       	mov    $0x2,%eax
   1ee0e:	e9 63 ff ff ff       	jmp    1ed76 <lwm2m_rd_client_service+0x1c0>
		LOG_ERR("Registration err: %d", ret);
   1ee13:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1ee1a:	0f 84 ea 01 00 00    	je     1f00a <lwm2m_rd_client_service+0x454>
   1ee20:	ba 14 52 02 00       	mov    $0x25214,%edx
   1ee25:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1ee2b:	c1 ea 03             	shr    $0x3,%edx
   1ee2e:	c1 e2 06             	shl    $0x6,%edx
   1ee31:	83 ca 01             	or     $0x1,%edx
   1ee34:	52                   	push   %edx
   1ee35:	50                   	push   %eax
   1ee36:	68 01 a4 02 00       	push   $0x2a401
   1ee3b:	e8 6f 46 fe ff       	call   34af <log_1>
   1ee40:	83 c4 0c             	add    $0xc,%esp
		lwm2m_engine_context_close(client.ctx);
   1ee43:	e9 c2 01 00 00       	jmp    1f00a <lwm2m_rd_client_service+0x454>
	if (sm_is_registered() &&
   1ee48:	80 3d 6a 36 40 00 00 	cmpb   $0x0,0x40366a
   1ee4f:	74 31                	je     1ee82 <lwm2m_rd_client_service+0x2cc>
		forced_update = client.trigger_update;
   1ee51:	80 3d 6a 36 40 00 00 	cmpb   $0x0,0x40366a
		ret = sm_send_registration(forced_update,
   1ee58:	0f 95 c0             	setne  %al
   1ee5b:	0f b6 c0             	movzbl %al,%eax
   1ee5e:	b9 a5 e8 01 00       	mov    $0x1e8a5,%ecx
   1ee63:	ba 86 e4 01 00       	mov    $0x1e486,%edx
		client.trigger_update = 0U;
   1ee68:	c6 05 6a 36 40 00 00 	movb   $0x0,0x40366a
		ret = sm_send_registration(forced_update,
   1ee6f:	e8 a3 fa ff ff       	call   1e917 <sm_send_registration>
		if (!ret) {
   1ee74:	85 c0                	test   %eax,%eax
   1ee76:	75 41                	jne    1eeb9 <lwm2m_rd_client_service+0x303>
			set_sm_state(ENGINE_UPDATE_SENT);
   1ee78:	b8 04 00 00 00       	mov    $0x4,%eax
   1ee7d:	e9 f4 fe ff ff       	jmp    1ed76 <lwm2m_rd_client_service+0x1c0>
	     ((client.lifetime - SECONDS_TO_UPDATE_EARLY) <=
   1ee82:	a1 60 36 40 00       	mov    0x403660,%eax
   1ee87:	31 ff                	xor    %edi,%edi
   1ee89:	8d 58 fa             	lea    -0x6(%eax),%ebx
   1ee8c:	e8 80 5a 00 00       	call   24911 <z_impl_k_uptime_get>
	      (k_uptime_get() - client.last_update) / 1000))) {
   1ee91:	2b 05 6c 36 40 00    	sub    0x40366c,%eax
   1ee97:	6a 00                	push   $0x0
   1ee99:	1b 15 70 36 40 00    	sbb    0x403670,%edx
   1ee9f:	68 e8 03 00 00       	push   $0x3e8
   1eea4:	52                   	push   %edx
   1eea5:	50                   	push   %eax
   1eea6:	e8 25 22 fe ff       	call   10d0 <__divdi3>
   1eeab:	83 c4 10             	add    $0x10,%esp
	    (client.trigger_update ||
   1eeae:	39 d8                	cmp    %ebx,%eax
   1eeb0:	19 fa                	sbb    %edi,%edx
   1eeb2:	7d 9d                	jge    1ee51 <lwm2m_rd_client_service+0x29b>
   1eeb4:	e9 8a 01 00 00       	jmp    1f043 <lwm2m_rd_client_service+0x48d>
			LOG_ERR("Registration update err: %d", ret);
   1eeb9:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1eec0:	74 23                	je     1eee5 <lwm2m_rd_client_service+0x32f>
   1eec2:	ba 14 52 02 00       	mov    $0x25214,%edx
   1eec7:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1eecd:	c1 ea 03             	shr    $0x3,%edx
   1eed0:	c1 e2 06             	shl    $0x6,%edx
   1eed3:	83 ca 01             	or     $0x1,%edx
   1eed6:	52                   	push   %edx
   1eed7:	50                   	push   %eax
   1eed8:	68 16 a4 02 00       	push   $0x2a416
   1eedd:	e8 cd 45 fe ff       	call   34af <log_1>
   1eee2:	83 c4 0c             	add    $0xc,%esp
			lwm2m_engine_context_close(client.ctx);
   1eee5:	ff 35 64 36 40 00    	pushl  0x403664
   1eeeb:	e8 55 c7 ff ff       	call   1b645 <lwm2m_engine_context_close>
   1eef0:	58                   	pop    %eax
			set_sm_state(ENGINE_DO_REGISTRATION);
   1eef1:	b8 01 00 00 00       	mov    $0x1,%eax
   1eef6:	e9 7b fe ff ff       	jmp    1ed76 <lwm2m_rd_client_service+0x1c0>
	msg = lwm2m_get_message(client.ctx);
   1eefb:	50                   	push   %eax
   1eefc:	e8 73 8f ff ff       	call   17e74 <lwm2m_get_message>
   1ef01:	5f                   	pop    %edi
   1ef02:	89 c3                	mov    %eax,%ebx
	if (!msg) {
   1ef04:	85 c0                	test   %eax,%eax
   1ef06:	75 32                	jne    1ef3a <lwm2m_rd_client_service+0x384>
		LOG_ERR("Unable to get a lwm2m message!");
   1ef08:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1ef0f:	0f 84 2e 01 00 00    	je     1f043 <lwm2m_rd_client_service+0x48d>
   1ef15:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ef1a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ef1f:	c1 e8 03             	shr    $0x3,%eax
   1ef22:	c1 e0 06             	shl    $0x6,%eax
   1ef25:	83 c8 01             	or     $0x1,%eax
   1ef28:	50                   	push   %eax
   1ef29:	68 70 9a 02 00       	push   $0x29a70
   1ef2e:	e8 57 45 fe ff       	call   348a <log_0>
   1ef33:	5b                   	pop    %ebx
   1ef34:	5e                   	pop    %esi
   1ef35:	e9 09 01 00 00       	jmp    1f043 <lwm2m_rd_client_service+0x48d>
	msg->mid = 0U;
   1ef3a:	c7 80 80 01 00 00 00 	movl   $0x4000000,0x180(%eax)
   1ef41:	00 00 04 
	msg->reply_cb = do_deregister_reply_cb;
   1ef44:	c7 80 78 01 00 00 5d 	movl   $0x1e55d,0x178(%eax)
   1ef4b:	e5 01 00 
	msg->message_timeout_cb = do_deregister_timeout_cb;
   1ef4e:	c7 80 7c 01 00 00 e1 	movl   $0x1e8e1,0x17c(%eax)
   1ef55:	e8 01 00 
	ret = lwm2m_init_message(msg);
   1ef58:	50                   	push   %eax
   1ef59:	e8 cf 90 ff ff       	call   1802d <lwm2m_init_message>
   1ef5e:	59                   	pop    %ecx
	if (ret) {
   1ef5f:	85 c0                	test   %eax,%eax
   1ef61:	0f 85 99 00 00 00    	jne    1f000 <lwm2m_rd_client_service+0x44a>
				  strlen(client.server_ep));
   1ef67:	68 95 36 40 00       	push   $0x403695
   1ef6c:	e8 f2 b8 fe ff       	call   a863 <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
   1ef71:	0f b7 c0             	movzwl %ax,%eax
   1ef74:	89 04 24             	mov    %eax,(%esp)
   1ef77:	68 95 36 40 00       	push   $0x403695
   1ef7c:	6a 0b                	push   $0xb
   1ef7e:	8d 43 2c             	lea    0x2c(%ebx),%eax
   1ef81:	50                   	push   %eax
   1ef82:	e8 81 90 fe ff       	call   8008 <coap_packet_append_option>
	LOG_INF("Deregister from '%s'", client.server_ep);
   1ef87:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
   1ef8c:	83 c4 10             	add    $0x10,%esp
	LOG_INF("Deregister from '%s'", client.server_ep);
   1ef8f:	83 e0 07             	and    $0x7,%eax
   1ef92:	83 f8 02             	cmp    $0x2,%eax
   1ef95:	76 26                	jbe    1efbd <lwm2m_rd_client_service+0x407>
   1ef97:	b8 14 52 02 00       	mov    $0x25214,%eax
   1ef9c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1efa1:	c1 e8 03             	shr    $0x3,%eax
   1efa4:	c1 e0 06             	shl    $0x6,%eax
   1efa7:	83 c8 03             	or     $0x3,%eax
   1efaa:	50                   	push   %eax
   1efab:	68 95 36 40 00       	push   $0x403695
   1efb0:	68 32 a4 02 00       	push   $0x2a432
   1efb5:	e8 f5 44 fe ff       	call   34af <log_1>
   1efba:	83 c4 0c             	add    $0xc,%esp
	ret = lwm2m_send_message(msg);
   1efbd:	53                   	push   %ebx
   1efbe:	e8 be ae ff ff       	call   19e81 <lwm2m_send_message>
   1efc3:	5a                   	pop    %edx
	if (ret < 0) {
   1efc4:	85 c0                	test   %eax,%eax
   1efc6:	79 2e                	jns    1eff6 <lwm2m_rd_client_service+0x440>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
   1efc8:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1efcf:	74 2f                	je     1f000 <lwm2m_rd_client_service+0x44a>
   1efd1:	ba 14 52 02 00       	mov    $0x25214,%edx
   1efd6:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1efdc:	c1 ea 03             	shr    $0x3,%edx
   1efdf:	c1 e2 06             	shl    $0x6,%edx
   1efe2:	83 ca 01             	or     $0x1,%edx
   1efe5:	52                   	push   %edx
   1efe6:	50                   	push   %eax
   1efe7:	68 47 9b 02 00       	push   $0x29b47
   1efec:	e8 be 44 fe ff       	call   34af <log_1>
   1eff1:	83 c4 0c             	add    $0xc,%esp
   1eff4:	eb 0a                	jmp    1f000 <lwm2m_rd_client_service+0x44a>
	set_sm_state(ENGINE_DEREGISTER_SENT);
   1eff6:	b8 06 00 00 00       	mov    $0x6,%eax
   1effb:	e9 76 fd ff ff       	jmp    1ed76 <lwm2m_rd_client_service+0x1c0>
	lwm2m_reset_message(msg, true);
   1f000:	6a 01                	push   $0x1
   1f002:	53                   	push   %ebx
   1f003:	e8 9a 8e ff ff       	call   17ea2 <lwm2m_reset_message>
   1f008:	5e                   	pop    %esi
   1f009:	5f                   	pop    %edi
	lwm2m_engine_context_close(client.ctx);
   1f00a:	ff 35 64 36 40 00    	pushl  0x403664
   1f010:	e8 30 c6 ff ff       	call   1b645 <lwm2m_engine_context_close>
   1f015:	5b                   	pop    %ebx
	return ret;
   1f016:	eb 2b                	jmp    1f043 <lwm2m_rd_client_service+0x48d>
			LOG_ERR("Unhandled state: %d", get_sm_state());
   1f018:	f6 05 c8 a8 40 00 07 	testb  $0x7,0x40a8c8
   1f01f:	74 22                	je     1f043 <lwm2m_rd_client_service+0x48d>
   1f021:	b8 14 52 02 00       	mov    $0x25214,%eax
   1f026:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f02b:	c1 e8 03             	shr    $0x3,%eax
   1f02e:	c1 e0 06             	shl    $0x6,%eax
   1f031:	83 c8 01             	or     $0x1,%eax
   1f034:	50                   	push   %eax
   1f035:	52                   	push   %edx
   1f036:	68 47 a4 02 00       	push   $0x2a447
   1f03b:	e8 6f 44 fe ff       	call   34af <log_1>
   1f040:	83 c4 0c             	add    $0xc,%esp
}
   1f043:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1f046:	5b                   	pop    %ebx
   1f047:	5e                   	pop    %esi
   1f048:	5f                   	pop    %edi
   1f049:	5d                   	pop    %ebp
   1f04a:	c3                   	ret    
   1f04b:	c3                   	ret    

0001f04c <engine_trigger_update>:
	client.trigger_update = 1U;
   1f04c:	c6 05 6a 36 40 00 01 	movb   $0x1,0x40366a
}
   1f053:	c3                   	ret    

0001f054 <lwm2m_rd_client_start>:
{
   1f054:	55                   	push   %ebp
   1f055:	89 e5                	mov    %esp,%ebp
   1f057:	53                   	push   %ebx
	client.ctx = client_ctx;
   1f058:	8b 45 08             	mov    0x8(%ebp),%eax
{
   1f05b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	client.ctx = client_ctx;
   1f05e:	a3 64 36 40 00       	mov    %eax,0x403664
	client.event_cb = event_cb;
   1f063:	8b 45 10             	mov    0x10(%ebp),%eax
   1f066:	a3 b8 36 40 00       	mov    %eax,0x4036b8
	set_sm_state(ENGINE_INIT);
   1f06b:	31 c0                	xor    %eax,%eax
   1f06d:	e8 a1 f3 ff ff       	call   1e413 <set_sm_state>
	strncpy(client.ep_name, ep_name, CLIENT_EP_LEN - 1);
   1f072:	6a 20                	push   $0x20
   1f074:	53                   	push   %ebx
   1f075:	68 74 36 40 00       	push   $0x403674
   1f07a:	e8 6e b7 fe ff       	call   a7ed <strncpy>
	LOG_INF("LWM2M Client: %s", client.ep_name);
   1f07f:	a1 c8 a8 40 00       	mov    0x40a8c8,%eax
	strncpy(client.ep_name, ep_name, CLIENT_EP_LEN - 1);
   1f084:	83 c4 0c             	add    $0xc,%esp
	LOG_INF("LWM2M Client: %s", client.ep_name);
   1f087:	83 e0 07             	and    $0x7,%eax
   1f08a:	83 f8 02             	cmp    $0x2,%eax
   1f08d:	76 2e                	jbe    1f0bd <lwm2m_rd_client_start+0x69>
   1f08f:	b8 14 52 02 00       	mov    $0x25214,%eax
}
   1f094:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1f097:	2d 3c 51 02 00       	sub    $0x2513c,%eax
	LOG_INF("LWM2M Client: %s", client.ep_name);
   1f09c:	c7 45 0c 74 36 40 00 	movl   $0x403674,0xc(%ebp)
   1f0a3:	c1 e8 03             	shr    $0x3,%eax
   1f0a6:	c7 45 08 62 a4 02 00 	movl   $0x2a462,0x8(%ebp)
   1f0ad:	c1 e0 06             	shl    $0x6,%eax
   1f0b0:	83 c8 03             	or     $0x3,%eax
   1f0b3:	66 89 45 10          	mov    %ax,0x10(%ebp)
}
   1f0b7:	c9                   	leave  
	LOG_INF("LWM2M Client: %s", client.ep_name);
   1f0b8:	e9 f2 43 fe ff       	jmp    34af <log_1>
}
   1f0bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1f0c0:	c9                   	leave  
   1f0c1:	c3                   	ret    

0001f0c2 <firmware_create>:

	return 0;
}

static struct lwm2m_engine_obj_inst *firmware_create(u16_t obj_inst_id)
{
   1f0c2:	55                   	push   %ebp
	int i = 0;

	/* initialize instance resource data */
	INIT_OBJ_RES(res, i, FIRMWARE_PACKAGE_ID, 0, NULL, 0,
   1f0c3:	c7 05 c0 36 40 00 00 	movl   $0x0,0x4036c0
   1f0ca:	00 00 00 
{
   1f0cd:	89 e5                	mov    %esp,%ebp
	INIT_OBJ_RES(res, i, FIRMWARE_PACKAGE_ID, 0, NULL, 0,
   1f0cf:	c7 05 c4 36 40 00 00 	movl   $0x0,0x4036c4
   1f0d6:	00 00 00 
   1f0d9:	c7 05 c8 36 40 00 f1 	movl   $0x1f5f1,0x4036c8
   1f0e0:	f5 01 00 
   1f0e3:	c7 05 cc 36 40 00 00 	movl   $0x0,0x4036cc
   1f0ea:	00 00 00 
{
   1f0ed:	8b 55 08             	mov    0x8(%ebp),%edx
	INIT_OBJ_RES(res, i, FIRMWARE_PACKAGE_ID, 0, NULL, 0,
   1f0f0:	c7 05 d0 36 40 00 00 	movl   $0x0,0x4036d0
   1f0f7:	00 00 00 
   1f0fa:	c7 05 d4 36 40 00 00 	movl   $0x0,0x4036d4
   1f101:	00 00 00 
   1f104:	c7 05 d8 36 40 00 00 	movl   $0x0,0x4036d8
   1f10b:	00 00 00 
		     NULL, NULL, package_write_cb, NULL);
	INIT_OBJ_RES(res, i, FIRMWARE_PACKAGE_URI_ID, 0,
   1f10e:	c7 05 f0 36 40 00 00 	movl   $0x0,0x4036f0
   1f115:	00 00 00 
   1f118:	c7 05 f4 36 40 00 20 	movl   $0x403820,0x4036f4
   1f11f:	38 40 00 
   1f122:	c7 05 f8 36 40 00 ff 	movl   $0x100ff,0x4036f8
   1f129:	00 01 00 
   1f12c:	c7 05 e0 36 40 00 00 	movl   $0x0,0x4036e0
   1f133:	00 00 00 
   1f136:	c7 05 e4 36 40 00 00 	movl   $0x0,0x4036e4
   1f13d:	00 00 00 
   1f140:	c7 05 e8 36 40 00 80 	movl   $0x1f580,0x4036e8
   1f147:	f5 01 00 
   1f14a:	c7 05 ec 36 40 00 00 	movl   $0x0,0x4036ec
   1f151:	00 00 00 
		     package_uri, PACKAGE_URI_LEN,
		     NULL, NULL, package_uri_write_cb, NULL);
	INIT_OBJ_RES_EXECUTE(res, i, FIRMWARE_UPDATE_ID,
   1f154:	c7 05 10 37 40 00 00 	movl   $0x0,0x403710
   1f15b:	00 00 00 
   1f15e:	c7 05 14 37 40 00 00 	movl   $0x0,0x403714
   1f165:	00 00 00 
   1f168:	c7 05 18 37 40 00 00 	movl   $0x20000,0x403718
   1f16f:	00 02 00 
   1f172:	c7 05 00 37 40 00 00 	movl   $0x0,0x403700
   1f179:	00 00 00 
   1f17c:	c7 05 04 37 40 00 00 	movl   $0x0,0x403704
   1f183:	00 00 00 
   1f186:	c7 05 08 37 40 00 00 	movl   $0x0,0x403708
   1f18d:	00 00 00 
   1f190:	c7 05 0c 37 40 00 dc 	movl   $0x1f6dc,0x40370c
   1f197:	f6 01 00 
			     firmware_update_cb);
	INIT_OBJ_RES_DATA(res, i, FIRMWARE_STATE_ID,
   1f19a:	c7 05 30 37 40 00 00 	movl   $0x0,0x403730
   1f1a1:	00 00 00 
   1f1a4:	c7 05 34 37 40 00 62 	movl   $0x404562,0x403734
   1f1ab:	45 40 00 
   1f1ae:	c7 05 38 37 40 00 01 	movl   $0x30001,0x403738
   1f1b5:	00 03 00 
   1f1b8:	c7 05 20 37 40 00 00 	movl   $0x0,0x403720
   1f1bf:	00 00 00 
   1f1c2:	c7 05 24 37 40 00 00 	movl   $0x0,0x403724
   1f1c9:	00 00 00 
   1f1cc:	c7 05 28 37 40 00 00 	movl   $0x0,0x403728
   1f1d3:	00 00 00 
   1f1d6:	c7 05 2c 37 40 00 00 	movl   $0x0,0x40372c
   1f1dd:	00 00 00 
			  &update_state, sizeof(update_state));
	INIT_OBJ_RES_DATA(res, i, FIRMWARE_UPDATE_RESULT_ID,
   1f1e0:	c7 05 50 37 40 00 00 	movl   $0x0,0x403750
   1f1e7:	00 00 00 
   1f1ea:	c7 05 54 37 40 00 61 	movl   $0x404561,0x403754
   1f1f1:	45 40 00 
   1f1f4:	c7 05 58 37 40 00 01 	movl   $0x50001,0x403758
   1f1fb:	00 05 00 
   1f1fe:	c7 05 40 37 40 00 00 	movl   $0x0,0x403740
   1f205:	00 00 00 
   1f208:	c7 05 44 37 40 00 00 	movl   $0x0,0x403744
   1f20f:	00 00 00 
   1f212:	c7 05 48 37 40 00 00 	movl   $0x0,0x403748
   1f219:	00 00 00 
   1f21c:	c7 05 4c 37 40 00 00 	movl   $0x0,0x40374c
   1f223:	00 00 00 
			  &update_result, sizeof(update_result));
	INIT_OBJ_RES_DATA(res, i, FIRMWARE_UPDATE_DELIV_METHOD_ID,
   1f226:	c7 05 70 37 40 00 00 	movl   $0x0,0x403770
   1f22d:	00 00 00 
   1f230:	c7 05 74 37 40 00 60 	movl   $0x404560,0x403774
   1f237:	45 40 00 
   1f23a:	c7 05 78 37 40 00 01 	movl   $0x90001,0x403778
   1f241:	00 09 00 
   1f244:	c7 05 60 37 40 00 00 	movl   $0x0,0x403760
   1f24b:	00 00 00 
   1f24e:	c7 05 64 37 40 00 00 	movl   $0x0,0x403764
   1f255:	00 00 00 
   1f258:	c7 05 68 37 40 00 00 	movl   $0x0,0x403768
   1f25f:	00 00 00 
   1f262:	c7 05 6c 37 40 00 00 	movl   $0x0,0x40376c
   1f269:	00 00 00 
			  &delivery_method, sizeof(delivery_method));

	inst.resources = res;
   1f26c:	c7 05 80 44 40 00 c0 	movl   $0x4036c0,0x404480
   1f273:	36 40 00 
	inst.resource_count = i;
   1f276:	66 c7 05 86 44 40 00 	movw   $0x6,0x404486
   1f27d:	06 00 
	LOG_DBG("Create LWM2M firmware instance: %d", obj_inst_id);
   1f27f:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
   1f286:	74 2a                	je     1f2b2 <firmware_create+0x1f0>
   1f288:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f28d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f292:	c1 e8 03             	shr    $0x3,%eax
   1f295:	c1 e0 06             	shl    $0x6,%eax
   1f298:	83 c8 04             	or     $0x4,%eax
   1f29b:	50                   	push   %eax
   1f29c:	0f b7 c2             	movzwl %dx,%eax
   1f29f:	50                   	push   %eax
   1f2a0:	68 e8 64 02 00       	push   $0x264e8
   1f2a5:	68 87 a4 02 00       	push   $0x2a487
   1f2aa:	e8 3a 42 fe ff       	call   34e9 <log_2>
   1f2af:	83 c4 10             	add    $0x10,%esp
	return &inst;
}
   1f2b2:	b8 78 44 40 00       	mov    $0x404478,%eax
   1f2b7:	c9                   	leave  
   1f2b8:	c3                   	ret    

0001f2b9 <lwm2m_firmware_init>:

static int lwm2m_firmware_init(struct device *dev)
{
   1f2b9:	55                   	push   %ebp
   1f2ba:	89 e5                	mov    %esp,%ebp
   1f2bc:	83 ec 08             	sub    $0x8,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	/* Set default values */
	package_uri[0] = '\0';
   1f2bf:	c6 05 20 38 40 00 00 	movb   $0x0,0x403820
	/* Initialize state machine */
	/* TODO: should be restored from the permanent storage */
	update_state = STATE_IDLE;
   1f2c6:	c6 05 62 45 40 00 00 	movb   $0x0,0x404562
	firmware.obj_id = LWM2M_OBJECT_FIRMWARE_ID;
	firmware.fields = fields;
	firmware.field_count = ARRAY_SIZE(fields);
	firmware.max_instance_count = 1U;
	firmware.create_cb = firmware_create;
	lwm2m_register_obj(&firmware);
   1f2cd:	68 00 38 40 00       	push   $0x403800
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   1f2d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	update_result = RESULT_DEFAULT;
   1f2d9:	c6 05 61 45 40 00 00 	movb   $0x0,0x404561
	delivery_method = DELIVERY_METHOD_BOTH;
   1f2e0:	c6 05 60 45 40 00 02 	movb   $0x2,0x404560
	firmware.fields = fields;
   1f2e7:	c7 05 04 38 40 00 20 	movl   $0x40a520,0x403804
   1f2ee:	a5 40 00 
	firmware.obj_id = LWM2M_OBJECT_FIRMWARE_ID;
   1f2f1:	c7 05 18 38 40 00 05 	movl   $0x90005,0x403818
   1f2f8:	00 09 00 
	firmware.max_instance_count = 1U;
   1f2fb:	66 c7 05 1e 38 40 00 	movw   $0x1,0x40381e
   1f302:	01 00 
	firmware.create_cb = firmware_create;
   1f304:	c7 05 08 38 40 00 c2 	movl   $0x1f0c2,0x403808
   1f30b:	f0 01 00 
	lwm2m_register_obj(&firmware);
   1f30e:	e8 03 82 ff ff       	call   17516 <lwm2m_register_obj>

	/* auto create the only instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_FIRMWARE_ID, 0, &obj_inst);
   1f313:	8d 45 fc             	lea    -0x4(%ebp),%eax
   1f316:	89 04 24             	mov    %eax,(%esp)
   1f319:	6a 00                	push   $0x0
   1f31b:	6a 05                	push   $0x5
   1f31d:	e8 cb 89 ff ff       	call   17ced <lwm2m_create_obj_inst>
   1f322:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
   1f325:	85 c0                	test   %eax,%eax
   1f327:	79 37                	jns    1f360 <lwm2m_firmware_init+0xa7>
		LOG_DBG("Create LWM2M instance 0 error: %d", ret);
   1f329:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
   1f330:	74 2e                	je     1f360 <lwm2m_firmware_init+0xa7>
   1f332:	ba e4 51 02 00       	mov    $0x251e4,%edx
   1f337:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1f33a:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f340:	c1 ea 03             	shr    $0x3,%edx
   1f343:	c1 e2 06             	shl    $0x6,%edx
   1f346:	83 ca 04             	or     $0x4,%edx
   1f349:	52                   	push   %edx
   1f34a:	50                   	push   %eax
   1f34b:	68 f8 64 02 00       	push   $0x264f8
   1f350:	68 2f 9f 02 00       	push   $0x29f2f
   1f355:	e8 8f 41 fe ff       	call   34e9 <log_2>
   1f35a:	83 c4 10             	add    $0x10,%esp
   1f35d:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
   1f360:	c9                   	leave  
   1f361:	c3                   	ret    

0001f362 <lwm2m_firmware_set_update_state>:
{
   1f362:	55                   	push   %ebp
   1f363:	89 e5                	mov    %esp,%ebp
   1f365:	53                   	push   %ebx
   1f366:	8b 5d 08             	mov    0x8(%ebp),%ebx
	switch (state) {
   1f369:	80 fb 01             	cmp    $0x1,%bl
   1f36c:	74 1b                	je     1f389 <lwm2m_firmware_set_update_state+0x27>
   1f36e:	84 db                	test   %bl,%bl
   1f370:	0f 84 97 00 00 00    	je     1f40d <lwm2m_firmware_set_update_state+0xab>
   1f376:	80 fb 02             	cmp    $0x2,%bl
   1f379:	74 17                	je     1f392 <lwm2m_firmware_set_update_state+0x30>
   1f37b:	80 fb 03             	cmp    $0x3,%bl
   1f37e:	75 20                	jne    1f3a0 <lwm2m_firmware_set_update_state+0x3e>
		if (update_state != STATE_DOWNLOADED) {
   1f380:	80 3d 62 45 40 00 02 	cmpb   $0x2,0x404562
   1f387:	eb 13                	jmp    1f39c <lwm2m_firmware_set_update_state+0x3a>
		if (update_state != STATE_IDLE) {
   1f389:	80 3d 62 45 40 00 00 	cmpb   $0x0,0x404562
   1f390:	eb 0a                	jmp    1f39c <lwm2m_firmware_set_update_state+0x3a>
		if (update_state != STATE_DOWNLOADING &&
   1f392:	a0 62 45 40 00       	mov    0x404562,%al
   1f397:	83 e0 fd             	and    $0xfffffffd,%eax
   1f39a:	fe c8                	dec    %al
		if (update_state != STATE_DOWNLOADED) {
   1f39c:	75 39                	jne    1f3d7 <lwm2m_firmware_set_update_state+0x75>
   1f39e:	eb 6d                	jmp    1f40d <lwm2m_firmware_set_update_state+0xab>
		LOG_ERR("Unhandled state: %u", state);
   1f3a0:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f3a7:	0f 84 ab 00 00 00    	je     1f458 <lwm2m_firmware_set_update_state+0xf6>
   1f3ad:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f3b2:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f3b7:	c1 e8 03             	shr    $0x3,%eax
   1f3ba:	c1 e0 06             	shl    $0x6,%eax
   1f3bd:	83 c8 01             	or     $0x1,%eax
   1f3c0:	50                   	push   %eax
   1f3c1:	0f b6 db             	movzbl %bl,%ebx
   1f3c4:	53                   	push   %ebx
   1f3c5:	68 ae a4 02 00       	push   $0x2a4ae
   1f3ca:	e8 e0 40 fe ff       	call   34af <log_1>
   1f3cf:	83 c4 0c             	add    $0xc,%esp
   1f3d2:	e9 81 00 00 00       	jmp    1f458 <lwm2m_firmware_set_update_state+0xf6>
		LOG_ERR("Invalid state transition: %u -> %u",
   1f3d7:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f3de:	74 2d                	je     1f40d <lwm2m_firmware_set_update_state+0xab>
   1f3e0:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f3e5:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f3ea:	c1 e8 03             	shr    $0x3,%eax
   1f3ed:	c1 e0 06             	shl    $0x6,%eax
   1f3f0:	83 c8 01             	or     $0x1,%eax
   1f3f3:	50                   	push   %eax
   1f3f4:	0f b6 c3             	movzbl %bl,%eax
   1f3f7:	50                   	push   %eax
   1f3f8:	0f b6 05 62 45 40 00 	movzbl 0x404562,%eax
   1f3ff:	50                   	push   %eax
   1f400:	68 c2 a4 02 00       	push   $0x2a4c2
   1f405:	e8 df 40 fe ff       	call   34e9 <log_2>
   1f40a:	83 c4 10             	add    $0x10,%esp
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_STATE_ID);
   1f40d:	6a 03                	push   $0x3
	update_state = state;
   1f40f:	88 1d 62 45 40 00    	mov    %bl,0x404562
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_STATE_ID);
   1f415:	6a 00                	push   $0x0
   1f417:	6a 05                	push   $0x5
   1f419:	e8 22 80 ff ff       	call   17440 <lwm2m_notify_observer>
   1f41e:	83 c4 0c             	add    $0xc,%esp
	LOG_DBG("Update state = %d", update_state);
   1f421:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
   1f428:	74 2e                	je     1f458 <lwm2m_firmware_set_update_state+0xf6>
   1f42a:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f42f:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f434:	c1 e8 03             	shr    $0x3,%eax
   1f437:	c1 e0 06             	shl    $0x6,%eax
   1f43a:	83 c8 04             	or     $0x4,%eax
   1f43d:	50                   	push   %eax
   1f43e:	0f b6 05 62 45 40 00 	movzbl 0x404562,%eax
   1f445:	50                   	push   %eax
   1f446:	68 40 5b 02 00       	push   $0x25b40
   1f44b:	68 e5 a4 02 00       	push   $0x2a4e5
   1f450:	e8 94 40 fe ff       	call   34e9 <log_2>
   1f455:	83 c4 10             	add    $0x10,%esp
}
   1f458:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1f45b:	c9                   	leave  
   1f45c:	c3                   	ret    

0001f45d <lwm2m_firmware_set_update_result>:
{
   1f45d:	55                   	push   %ebp
   1f45e:	89 e5                	mov    %esp,%ebp
   1f460:	57                   	push   %edi
   1f461:	56                   	push   %esi
   1f462:	53                   	push   %ebx
   1f463:	51                   	push   %ecx
   1f464:	8b 45 08             	mov    0x8(%ebp),%eax
   1f467:	89 45 f0             	mov    %eax,-0x10(%ebp)
	switch (result) {
   1f46a:	80 7d f0 09          	cmpb   $0x9,-0x10(%ebp)
   1f46e:	77 55                	ja     1f4c5 <lwm2m_firmware_set_update_result+0x68>
   1f470:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
   1f474:	ff 24 bd 94 64 02 00 	jmp    *0x26494(,%edi,4)
		lwm2m_firmware_set_update_state(STATE_IDLE);
   1f47b:	6a 00                	push   $0x0
   1f47d:	e8 e0 fe ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
   1f482:	5a                   	pop    %edx
	if (error) {
   1f483:	e9 a3 00 00 00       	jmp    1f52b <lwm2m_firmware_set_update_result+0xce>
		if (update_state != STATE_UPDATING) {
   1f488:	8a 15 62 45 40 00    	mov    0x404562,%dl
	bool error = false;
   1f48e:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_UPDATING) {
   1f490:	80 fa 03             	cmp    $0x3,%dl
   1f493:	eb 1c                	jmp    1f4b1 <lwm2m_firmware_set_update_result+0x54>
		if (update_state != STATE_DOWNLOADING) {
   1f495:	8a 15 62 45 40 00    	mov    0x404562,%dl
	bool error = false;
   1f49b:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_DOWNLOADING) {
   1f49d:	80 fa 01             	cmp    $0x1,%dl
   1f4a0:	eb 0f                	jmp    1f4b1 <lwm2m_firmware_set_update_result+0x54>
		if (update_state != STATE_DOWNLOADING &&
   1f4a2:	8a 15 62 45 40 00    	mov    0x404562,%dl
	bool error = false;
   1f4a8:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_DOWNLOADING &&
   1f4aa:	88 d1                	mov    %dl,%cl
   1f4ac:	83 e1 fd             	and    $0xfffffffd,%ecx
   1f4af:	fe c9                	dec    %cl
   1f4b1:	74 04                	je     1f4b7 <lwm2m_firmware_set_update_result+0x5a>
   1f4b3:	89 d6                	mov    %edx,%esi
			error = true;
   1f4b5:	b3 01                	mov    $0x1,%bl
		lwm2m_firmware_set_update_state(STATE_IDLE);
   1f4b7:	6a 00                	push   $0x0
   1f4b9:	e8 a4 fe ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
   1f4be:	58                   	pop    %eax
	if (error) {
   1f4bf:	84 db                	test   %bl,%bl
   1f4c1:	74 68                	je     1f52b <lwm2m_firmware_set_update_result+0xce>
   1f4c3:	eb 35                	jmp    1f4fa <lwm2m_firmware_set_update_result+0x9d>
		LOG_ERR("Unhandled result: %u", result);
   1f4c5:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f4cc:	0f 84 a6 00 00 00    	je     1f578 <lwm2m_firmware_set_update_result+0x11b>
   1f4d2:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f4d7:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f4dc:	c1 e8 03             	shr    $0x3,%eax
   1f4df:	c1 e0 06             	shl    $0x6,%eax
   1f4e2:	83 c8 01             	or     $0x1,%eax
   1f4e5:	0f b6 5d f0          	movzbl -0x10(%ebp),%ebx
   1f4e9:	50                   	push   %eax
   1f4ea:	53                   	push   %ebx
   1f4eb:	68 fb a4 02 00       	push   $0x2a4fb
   1f4f0:	e8 ba 3f fe ff       	call   34af <log_1>
   1f4f5:	83 c4 0c             	add    $0xc,%esp
   1f4f8:	eb 7e                	jmp    1f578 <lwm2m_firmware_set_update_result+0x11b>
		LOG_ERR("Unexpected result(%u) set while state is %u",
   1f4fa:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f501:	74 28                	je     1f52b <lwm2m_firmware_set_update_result+0xce>
   1f503:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f508:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f50d:	c1 e8 03             	shr    $0x3,%eax
   1f510:	c1 e0 06             	shl    $0x6,%eax
   1f513:	83 c8 01             	or     $0x1,%eax
   1f516:	50                   	push   %eax
   1f517:	89 f0                	mov    %esi,%eax
   1f519:	0f b6 f0             	movzbl %al,%esi
   1f51c:	56                   	push   %esi
   1f51d:	57                   	push   %edi
   1f51e:	68 10 a5 02 00       	push   $0x2a510
   1f523:	e8 c1 3f fe ff       	call   34e9 <log_2>
   1f528:	83 c4 10             	add    $0x10,%esp
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
   1f52b:	6a 05                	push   $0x5
	update_result = result;
   1f52d:	8a 45 f0             	mov    -0x10(%ebp),%al
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
   1f530:	6a 00                	push   $0x0
	update_result = result;
   1f532:	a2 61 45 40 00       	mov    %al,0x404561
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
   1f537:	6a 05                	push   $0x5
   1f539:	e8 02 7f ff ff       	call   17440 <lwm2m_notify_observer>
   1f53e:	83 c4 0c             	add    $0xc,%esp
	LOG_DBG("Update result = %d", update_result);
   1f541:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
   1f548:	74 2e                	je     1f578 <lwm2m_firmware_set_update_result+0x11b>
   1f54a:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f54f:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f554:	c1 e8 03             	shr    $0x3,%eax
   1f557:	c1 e0 06             	shl    $0x6,%eax
   1f55a:	83 c8 04             	or     $0x4,%eax
   1f55d:	50                   	push   %eax
   1f55e:	0f b6 05 61 45 40 00 	movzbl 0x404561,%eax
   1f565:	50                   	push   %eax
   1f566:	68 00 5b 02 00       	push   $0x25b00
   1f56b:	68 3c a5 02 00       	push   $0x2a53c
   1f570:	e8 74 3f fe ff       	call   34e9 <log_2>
   1f575:	83 c4 10             	add    $0x10,%esp
}
   1f578:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1f57b:	5b                   	pop    %ebx
   1f57c:	5e                   	pop    %esi
   1f57d:	5f                   	pop    %edi
   1f57e:	5d                   	pop    %ebp
   1f57f:	c3                   	ret    

0001f580 <package_uri_write_cb>:
{
   1f580:	55                   	push   %ebp
	LOG_DBG("PACKAGE_URI WRITE: %s", package_uri);
   1f581:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
{
   1f588:	89 e5                	mov    %esp,%ebp
   1f58a:	53                   	push   %ebx
   1f58b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	LOG_DBG("PACKAGE_URI WRITE: %s", package_uri);
   1f58e:	74 2b                	je     1f5bb <package_uri_write_cb+0x3b>
   1f590:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f595:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f59a:	c1 e8 03             	shr    $0x3,%eax
   1f59d:	c1 e0 06             	shl    $0x6,%eax
   1f5a0:	83 c8 04             	or     $0x4,%eax
   1f5a3:	50                   	push   %eax
   1f5a4:	68 20 38 40 00       	push   $0x403820
   1f5a9:	68 d0 64 02 00       	push   $0x264d0
   1f5ae:	68 53 a5 02 00       	push   $0x2a553
   1f5b3:	e8 31 3f fe ff       	call   34e9 <log_2>
   1f5b8:	83 c4 10             	add    $0x10,%esp
	return update_state;
   1f5bb:	a0 62 45 40 00       	mov    0x404562,%al
	if (state == STATE_IDLE) {
   1f5c0:	84 c0                	test   %al,%al
   1f5c2:	75 15                	jne    1f5d9 <package_uri_write_cb+0x59>
		lwm2m_firmware_set_update_result(RESULT_DEFAULT);
   1f5c4:	6a 00                	push   $0x0
   1f5c6:	e8 92 fe ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
		lwm2m_firmware_start_transfer(package_uri);
   1f5cb:	c7 04 24 20 38 40 00 	movl   $0x403820,(%esp)
   1f5d2:	e8 d7 09 00 00       	call   1ffae <lwm2m_firmware_start_transfer>
   1f5d7:	eb 10                	jmp    1f5e9 <package_uri_write_cb+0x69>
	} else if (state == STATE_DOWNLOADED && data_len == 0) {
   1f5d9:	3c 02                	cmp    $0x2,%al
   1f5db:	75 0d                	jne    1f5ea <package_uri_write_cb+0x6a>
   1f5dd:	66 85 db             	test   %bx,%bx
   1f5e0:	75 08                	jne    1f5ea <package_uri_write_cb+0x6a>
		lwm2m_firmware_set_update_result(RESULT_DEFAULT);
   1f5e2:	6a 00                	push   $0x0
   1f5e4:	e8 74 fe ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f5e9:	58                   	pop    %eax
}
   1f5ea:	31 c0                	xor    %eax,%eax
   1f5ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1f5ef:	c9                   	leave  
   1f5f0:	c3                   	ret    

0001f5f1 <package_write_cb>:
{
   1f5f1:	55                   	push   %ebp
   1f5f2:	89 e5                	mov    %esp,%ebp
   1f5f4:	57                   	push   %edi
	return update_state;
   1f5f5:	0f b6 15 62 45 40 00 	movzbl 0x404562,%edx
{
   1f5fc:	56                   	push   %esi
   1f5fd:	8b 7d 10             	mov    0x10(%ebp),%edi
   1f600:	53                   	push   %ebx
   1f601:	8b 75 14             	mov    0x14(%ebp),%esi
   1f604:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (state == STATE_IDLE) {
   1f607:	84 d2                	test   %dl,%dl
   1f609:	75 0a                	jne    1f615 <package_write_cb+0x24>
		lwm2m_firmware_set_update_state(STATE_DOWNLOADING);
   1f60b:	6a 01                	push   $0x1
   1f60d:	e8 50 fd ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
   1f612:	58                   	pop    %eax
   1f613:	eb 51                	jmp    1f666 <package_write_cb+0x75>
	} else if (state != STATE_DOWNLOADING) {
   1f615:	80 fa 01             	cmp    $0x1,%dl
   1f618:	74 4c                	je     1f666 <package_write_cb+0x75>
		if (data_len == 0 && state == STATE_DOWNLOADED) {
   1f61a:	66 85 ff             	test   %di,%di
   1f61d:	75 0e                	jne    1f62d <package_write_cb+0x3c>
   1f61f:	80 fa 02             	cmp    $0x2,%dl
   1f622:	75 09                	jne    1f62d <package_write_cb+0x3c>
			lwm2m_firmware_set_update_result(RESULT_DEFAULT);
   1f624:	6a 00                	push   $0x0
   1f626:	e8 32 fe ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f62b:	eb 72                	jmp    1f69f <package_write_cb+0xae>
		return -EPERM;
   1f62d:	83 cb ff             	or     $0xffffffff,%ebx
		LOG_DBG("Cannot download: state = %d", state);
   1f630:	f6 05 b0 a8 40 00 04 	testb  $0x4,0x40a8b0
   1f637:	0f 84 95 00 00 00    	je     1f6d2 <package_write_cb+0xe1>
   1f63d:	b8 e4 51 02 00       	mov    $0x251e4,%eax
   1f642:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1f647:	c1 e8 03             	shr    $0x3,%eax
   1f64a:	c1 e0 06             	shl    $0x6,%eax
   1f64d:	83 c8 04             	or     $0x4,%eax
   1f650:	50                   	push   %eax
   1f651:	52                   	push   %edx
   1f652:	68 bc 64 02 00       	push   $0x264bc
   1f657:	68 6d a5 02 00       	push   $0x2a56d
   1f65c:	e8 88 3e fe ff       	call   34e9 <log_2>
   1f661:	83 c4 10             	add    $0x10,%esp
   1f664:	eb 6c                	jmp    1f6d2 <package_write_cb+0xe1>
   1f666:	89 f0                	mov    %esi,%eax
   1f668:	0f b6 d0             	movzbl %al,%edx
	ret = write_cb ? write_cb(obj_inst_id, data, data_len,
   1f66b:	a1 74 44 40 00       	mov    0x404474,%eax
   1f670:	0f b7 db             	movzwl %bx,%ebx
   1f673:	0f b7 ff             	movzwl %di,%edi
				  last_block, total_size) : 0;
   1f676:	85 c0                	test   %eax,%eax
   1f678:	75 0f                	jne    1f689 <package_write_cb+0x98>
		if (last_block) {
   1f67a:	89 f0                	mov    %esi,%eax
   1f67c:	84 c0                	test   %al,%al
   1f67e:	74 20                	je     1f6a0 <package_write_cb+0xaf>
			lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
   1f680:	6a 02                	push   $0x2
   1f682:	e8 db fc ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
   1f687:	eb 16                	jmp    1f69f <package_write_cb+0xae>
	ret = write_cb ? write_cb(obj_inst_id, data, data_len,
   1f689:	ff 75 18             	pushl  0x18(%ebp)
   1f68c:	52                   	push   %edx
   1f68d:	57                   	push   %edi
   1f68e:	ff 75 0c             	pushl  0xc(%ebp)
   1f691:	53                   	push   %ebx
   1f692:	ff d0                	call   *%eax
   1f694:	83 c4 14             	add    $0x14,%esp
   1f697:	89 c3                	mov    %eax,%ebx
	if (ret >= 0) {
   1f699:	85 c0                	test   %eax,%eax
   1f69b:	78 07                	js     1f6a4 <package_write_cb+0xb3>
   1f69d:	eb db                	jmp    1f67a <package_write_cb+0x89>
			lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
   1f69f:	59                   	pop    %ecx
		return 0;
   1f6a0:	31 db                	xor    %ebx,%ebx
   1f6a2:	eb 2e                	jmp    1f6d2 <package_write_cb+0xe1>
	} else if (ret == -ENOMEM) {
   1f6a4:	83 f8 f4             	cmp    $0xfffffff4,%eax
   1f6a7:	75 04                	jne    1f6ad <package_write_cb+0xbc>
		lwm2m_firmware_set_update_result(RESULT_OUT_OF_MEM);
   1f6a9:	6a 03                	push   $0x3
   1f6ab:	eb 1f                	jmp    1f6cc <package_write_cb+0xdb>
	} else if (ret == -ENOSPC) {
   1f6ad:	83 f8 e4             	cmp    $0xffffffe4,%eax
   1f6b0:	75 0f                	jne    1f6c1 <package_write_cb+0xd0>
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
   1f6b2:	6a 02                	push   $0x2
		ret = -EFBIG;
   1f6b4:	bb e5 ff ff ff       	mov    $0xffffffe5,%ebx
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
   1f6b9:	e8 9f fd ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f6be:	5a                   	pop    %edx
		ret = -EFBIG;
   1f6bf:	eb 11                	jmp    1f6d2 <package_write_cb+0xe1>
	} else if (ret == -EFAULT) {
   1f6c1:	83 f8 f2             	cmp    $0xfffffff2,%eax
   1f6c4:	75 04                	jne    1f6ca <package_write_cb+0xd9>
		lwm2m_firmware_set_update_result(RESULT_INTEGRITY_FAILED);
   1f6c6:	6a 05                	push   $0x5
   1f6c8:	eb 02                	jmp    1f6cc <package_write_cb+0xdb>
		lwm2m_firmware_set_update_result(RESULT_UPDATE_FAILED);
   1f6ca:	6a 08                	push   $0x8
   1f6cc:	e8 8c fd ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f6d1:	58                   	pop    %eax
}
   1f6d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1f6d5:	89 d8                	mov    %ebx,%eax
   1f6d7:	5b                   	pop    %ebx
   1f6d8:	5e                   	pop    %esi
   1f6d9:	5f                   	pop    %edi
   1f6da:	5d                   	pop    %ebp
   1f6db:	c3                   	ret    

0001f6dc <firmware_update_cb>:
{
   1f6dc:	55                   	push   %ebp
   1f6dd:	89 e5                	mov    %esp,%ebp
   1f6df:	53                   	push   %ebx
	return update_state;
   1f6e0:	0f b6 0d 62 45 40 00 	movzbl 0x404562,%ecx
{
   1f6e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (state != STATE_DOWNLOADED) {
   1f6ea:	80 f9 02             	cmp    $0x2,%cl
   1f6ed:	74 35                	je     1f724 <firmware_update_cb+0x48>
		return -EPERM;
   1f6ef:	83 cb ff             	or     $0xffffffff,%ebx
		LOG_ERR("State other than downloaded: %d", state);
   1f6f2:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f6f9:	0f 84 84 00 00 00    	je     1f783 <firmware_update_cb+0xa7>
   1f6ff:	ba e4 51 02 00       	mov    $0x251e4,%edx
   1f704:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f70a:	c1 ea 03             	shr    $0x3,%edx
   1f70d:	c1 e2 06             	shl    $0x6,%edx
   1f710:	83 ca 01             	or     $0x1,%edx
   1f713:	52                   	push   %edx
   1f714:	51                   	push   %ecx
   1f715:	68 8d a5 02 00       	push   $0x2a58d
   1f71a:	e8 90 3d fe ff       	call   34af <log_1>
   1f71f:	83 c4 0c             	add    $0xc,%esp
   1f722:	eb 5f                	jmp    1f783 <firmware_update_cb+0xa7>
	lwm2m_firmware_set_update_state(STATE_UPDATING);
   1f724:	6a 03                	push   $0x3
   1f726:	e8 37 fc ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
	return update_cb;
   1f72b:	a1 70 44 40 00       	mov    0x404470,%eax
	lwm2m_firmware_set_update_state(STATE_UPDATING);
   1f730:	59                   	pop    %ecx
	if (callback) {
   1f731:	85 c0                	test   %eax,%eax
   1f733:	74 4c                	je     1f781 <firmware_update_cb+0xa5>
		ret = callback(obj_inst_id);
   1f735:	0f b7 db             	movzwl %bx,%ebx
   1f738:	53                   	push   %ebx
   1f739:	ff d0                	call   *%eax
   1f73b:	5a                   	pop    %edx
   1f73c:	89 c3                	mov    %eax,%ebx
		if (ret < 0) {
   1f73e:	85 c0                	test   %eax,%eax
   1f740:	79 3f                	jns    1f781 <firmware_update_cb+0xa5>
			LOG_ERR("Failed to update firmware: %d", ret);
   1f742:	f6 05 b0 a8 40 00 07 	testb  $0x7,0x40a8b0
   1f749:	74 23                	je     1f76e <firmware_update_cb+0x92>
   1f74b:	ba e4 51 02 00       	mov    $0x251e4,%edx
   1f750:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f756:	c1 ea 03             	shr    $0x3,%edx
   1f759:	c1 e2 06             	shl    $0x6,%edx
   1f75c:	83 ca 01             	or     $0x1,%edx
   1f75f:	52                   	push   %edx
   1f760:	50                   	push   %eax
   1f761:	68 ad a5 02 00       	push   $0x2a5ad
   1f766:	e8 44 3d fe ff       	call   34af <log_1>
   1f76b:	83 c4 0c             	add    $0xc,%esp
			lwm2m_firmware_set_update_result(
   1f76e:	31 c0                	xor    %eax,%eax
   1f770:	83 fb ea             	cmp    $0xffffffea,%ebx
   1f773:	0f 95 c0             	setne  %al
   1f776:	8d 44 40 05          	lea    0x5(%eax,%eax,2),%eax
   1f77a:	50                   	push   %eax
   1f77b:	e8 dd fc ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f780:	58                   	pop    %eax
			return 0;
   1f781:	31 db                	xor    %ebx,%ebx
}
   1f783:	89 d8                	mov    %ebx,%eax
   1f785:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1f788:	c9                   	leave  
   1f789:	c3                   	ret    

0001f78a <lwm2m_firmware_set_write_cb>:
{
   1f78a:	55                   	push   %ebp
   1f78b:	89 e5                	mov    %esp,%ebp
	write_cb = cb;
   1f78d:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1f790:	5d                   	pop    %ebp
	write_cb = cb;
   1f791:	a3 74 44 40 00       	mov    %eax,0x404474
}
   1f796:	c3                   	ret    

0001f797 <lwm2m_firmware_get_write_cb>:
}
   1f797:	a1 74 44 40 00       	mov    0x404474,%eax
   1f79c:	c3                   	ret    

0001f79d <lwm2m_firmware_set_update_cb>:
{
   1f79d:	55                   	push   %ebp
   1f79e:	89 e5                	mov    %esp,%ebp
	update_cb = cb;
   1f7a0:	8b 45 08             	mov    0x8(%ebp),%eax
}
   1f7a3:	5d                   	pop    %ebp
	update_cb = cb;
   1f7a4:	a3 70 44 40 00       	mov    %eax,0x404470
}
   1f7a9:	c3                   	ret    

0001f7aa <set_update_result_from_error>:
#endif

static void do_transmit_timeout_cb(struct lwm2m_message *msg);

static void set_update_result_from_error(int error_code)
{
   1f7aa:	55                   	push   %ebp
	if (error_code == -ENOMEM) {
   1f7ab:	83 f8 f4             	cmp    $0xfffffff4,%eax
{
   1f7ae:	89 e5                	mov    %esp,%ebp
	if (error_code == -ENOMEM) {
   1f7b0:	75 04                	jne    1f7b6 <set_update_result_from_error+0xc>
		lwm2m_firmware_set_update_result(RESULT_OUT_OF_MEM);
   1f7b2:	6a 03                	push   $0x3
   1f7b4:	eb 2f                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOSPC) {
   1f7b6:	83 f8 e4             	cmp    $0xffffffe4,%eax
   1f7b9:	75 04                	jne    1f7bf <set_update_result_from_error+0x15>
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
   1f7bb:	6a 02                	push   $0x2
   1f7bd:	eb 26                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else if (error_code == -EFAULT) {
   1f7bf:	83 f8 f2             	cmp    $0xfffffff2,%eax
   1f7c2:	75 04                	jne    1f7c8 <set_update_result_from_error+0x1e>
		lwm2m_firmware_set_update_result(RESULT_INTEGRITY_FAILED);
   1f7c4:	6a 05                	push   $0x5
   1f7c6:	eb 1d                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOMSG) {
   1f7c8:	83 f8 b0             	cmp    $0xffffffb0,%eax
   1f7cb:	75 04                	jne    1f7d1 <set_update_result_from_error+0x27>
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
   1f7cd:	6a 04                	push   $0x4
   1f7cf:	eb 14                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOTSUP) {
   1f7d1:	83 f8 dd             	cmp    $0xffffffdd,%eax
   1f7d4:	75 04                	jne    1f7da <set_update_result_from_error+0x30>
		lwm2m_firmware_set_update_result(RESULT_INVALID_URI);
   1f7d6:	6a 07                	push   $0x7
   1f7d8:	eb 0b                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else if (error_code == -EPROTONOSUPPORT) {
   1f7da:	83 f8 d5             	cmp    $0xffffffd5,%eax
   1f7dd:	75 04                	jne    1f7e3 <set_update_result_from_error+0x39>
		lwm2m_firmware_set_update_result(RESULT_UNSUP_PROTO);
   1f7df:	6a 09                	push   $0x9
   1f7e1:	eb 02                	jmp    1f7e5 <set_update_result_from_error+0x3b>
	} else {
		lwm2m_firmware_set_update_result(RESULT_UPDATE_FAILED);
   1f7e3:	6a 08                	push   $0x8
   1f7e5:	e8 73 fc ff ff       	call   1f45d <lwm2m_firmware_set_update_result>
   1f7ea:	58                   	pop    %eax
	}
}
   1f7eb:	c9                   	leave  
   1f7ec:	c3                   	ret    

0001f7ed <transfer_request.constprop.5>:

static int transfer_request(struct coap_block_context *ctx,
   1f7ed:	55                   	push   %ebp
   1f7ee:	89 e5                	mov    %esp,%ebp
   1f7f0:	57                   	push   %edi
   1f7f1:	56                   	push   %esi
   1f7f2:	89 c6                	mov    %eax,%esi
   1f7f4:	53                   	push   %ebx
   1f7f5:	83 ec 2c             	sub    $0x2c,%esp
   1f7f8:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct http_parser_url parser;
	u16_t off, len;
	char *next_slash;
#endif

	msg = lwm2m_get_message(&firmware_ctx);
   1f7fb:	68 20 39 40 00       	push   $0x403920
   1f800:	e8 6f 86 ff ff       	call   17e74 <lwm2m_get_message>
   1f805:	59                   	pop    %ecx
	if (!msg) {
   1f806:	85 c0                	test   %eax,%eax
   1f808:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1f80b:	75 36                	jne    1f843 <transfer_request.constprop.5+0x56>
		LOG_ERR("Unable to get a lwm2m message!");
		return -ENOMEM;
   1f80d:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
		LOG_ERR("Unable to get a lwm2m message!");
   1f812:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1f819:	0f 84 61 02 00 00    	je     1fa80 <transfer_request.constprop.5+0x293>
   1f81f:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1f824:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f82a:	c1 ea 03             	shr    $0x3,%edx
   1f82d:	c1 e2 06             	shl    $0x6,%edx
   1f830:	83 ca 01             	or     $0x1,%edx
   1f833:	52                   	push   %edx
   1f834:	68 70 9a 02 00       	push   $0x29a70
   1f839:	e8 4c 3c fe ff       	call   348a <log_0>
   1f83e:	e9 37 02 00 00       	jmp    1fa7a <transfer_request.constprop.5+0x28d>
	}

	msg->type = COAP_TYPE_CON;
	msg->code = COAP_METHOD_GET;
	msg->mid = 0U;
	msg->token = token;
   1f843:	89 b0 74 01 00 00    	mov    %esi,0x174(%eax)
	msg->tkl = tkl;
   1f849:	88 90 84 01 00 00    	mov    %dl,0x184(%eax)
	msg->mid = 0U;
   1f84f:	c7 80 80 01 00 00 00 	movl   $0x1000000,0x180(%eax)
   1f856:	00 00 01 
	msg->reply_cb = reply_cb;
   1f859:	c7 80 78 01 00 00 2b 	movl   $0x1fb2b,0x178(%eax)
   1f860:	fb 01 00 
	msg->message_timeout_cb = do_transmit_timeout_cb;
   1f863:	c7 80 7c 01 00 00 8a 	movl   $0x1fa8a,0x17c(%eax)
   1f86a:	fa 01 00 
   1f86d:	89 c3                	mov    %eax,%ebx

	ret = lwm2m_init_message(msg);
   1f86f:	50                   	push   %eax
   1f870:	e8 b8 87 ff ff       	call   1802d <lwm2m_init_message>
   1f875:	5a                   	pop    %edx
   1f876:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1f878:	85 c0                	test   %eax,%eax
   1f87a:	79 2c                	jns    1f8a8 <transfer_request.constprop.5+0xbb>
		LOG_ERR("Error setting up lwm2m message");
   1f87c:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1f883:	0f 84 e9 01 00 00    	je     1fa72 <transfer_request.constprop.5+0x285>
   1f889:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1f88e:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f894:	c1 ea 03             	shr    $0x3,%edx
   1f897:	c1 e2 06             	shl    $0x6,%edx
   1f89a:	83 ca 01             	or     $0x1,%edx
   1f89d:	52                   	push   %edx
   1f89e:	68 e2 a5 02 00       	push   $0x2a5e2
   1f8a3:	e9 f7 00 00 00       	jmp    1f99f <transfer_request.constprop.5+0x1b2>
	if (ret < 0) {
		LOG_ERR("Error adding URI_PATH '%s'", cursor);
		goto cleanup;
	}
#else
	http_parser_url_init(&parser);
   1f8a8:	8d 75 d4             	lea    -0x2c(%ebp),%esi
   1f8ab:	56                   	push   %esi
   1f8ac:	e8 f4 2c 00 00       	call   225a5 <http_parser_url_init>
	ret = http_parser_parse_url(firmware_uri, strlen(firmware_uri), 0,
   1f8b1:	c7 04 24 c0 3a 40 00 	movl   $0x403ac0,(%esp)
   1f8b8:	e8 a6 af fe ff       	call   a863 <strlen>
   1f8bd:	89 34 24             	mov    %esi,(%esp)
   1f8c0:	6a 00                	push   $0x0
   1f8c2:	50                   	push   %eax
   1f8c3:	68 c0 3a 40 00       	push   $0x403ac0
   1f8c8:	e8 ec 2c 00 00       	call   225b9 <http_parser_parse_url>
   1f8cd:	83 c4 10             	add    $0x10,%esp
				    &parser);
	if (ret < 0) {
   1f8d0:	85 c0                	test   %eax,%eax
   1f8d2:	79 36                	jns    1f90a <transfer_request.constprop.5+0x11d>
		LOG_ERR("Invalid firmware url: %s", firmware_uri);
		ret = -ENOTSUP;
   1f8d4:	be dd ff ff ff       	mov    $0xffffffdd,%esi
		LOG_ERR("Invalid firmware url: %s", firmware_uri);
   1f8d9:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1f8e0:	0f 84 8c 01 00 00    	je     1fa72 <transfer_request.constprop.5+0x285>
   1f8e6:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1f8eb:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f8f1:	c1 ea 03             	shr    $0x3,%edx
   1f8f4:	c1 e2 06             	shl    $0x6,%edx
   1f8f7:	83 ca 01             	or     $0x1,%edx
   1f8fa:	52                   	push   %edx
   1f8fb:	68 c0 3a 40 00       	push   $0x403ac0
   1f900:	68 01 a6 02 00       	push   $0x2a601
   1f905:	e9 60 01 00 00       	jmp    1fa6a <transfer_request.constprop.5+0x27d>
	}

	/* if path is not available, off/len will be zero */
	off = parser.field_data[UF_PATH].off;
	len = parser.field_data[UF_PATH].len;
	cursor = firmware_uri + off;
   1f90a:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
	len = parser.field_data[UF_PATH].len;
   1f90e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
	cursor = firmware_uri + off;
   1f912:	81 c2 c0 3a 40 00    	add    $0x403ac0,%edx
	len = parser.field_data[UF_PATH].len;
   1f918:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

	/* add path portions (separated by slashes) */
	while (len > 0 && (next_slash = strchr(cursor, '/')) != NULL) {
   1f91c:	eb 0e                	jmp    1f92c <transfer_request.constprop.5+0x13f>
				goto cleanup;
			}
		}

		/* skip slash */
		len -= (next_slash - cursor) + 1;
   1f91e:	8b 75 d0             	mov    -0x30(%ebp),%esi
		cursor = next_slash + 1;
   1f921:	8d 51 01             	lea    0x1(%ecx),%edx
		len -= (next_slash - cursor) + 1;
   1f924:	4e                   	dec    %esi
   1f925:	2b 75 cc             	sub    -0x34(%ebp),%esi
   1f928:	66 89 75 d0          	mov    %si,-0x30(%ebp)
		cursor = next_slash + 1;
   1f92c:	8d 7b 2c             	lea    0x2c(%ebx),%edi
	while (len > 0 && (next_slash = strchr(cursor, '/')) != NULL) {
   1f92f:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%ebp)
   1f934:	0f 84 88 00 00 00    	je     1f9c2 <transfer_request.constprop.5+0x1d5>
   1f93a:	6a 2f                	push   $0x2f
   1f93c:	89 55 cc             	mov    %edx,-0x34(%ebp)
   1f93f:	52                   	push   %edx
   1f940:	e8 e4 ae fe ff       	call   a829 <strchr>
   1f945:	59                   	pop    %ecx
   1f946:	85 c0                	test   %eax,%eax
   1f948:	5e                   	pop    %esi
   1f949:	89 c1                	mov    %eax,%ecx
   1f94b:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1f94e:	74 5b                	je     1f9ab <transfer_request.constprop.5+0x1be>
		if (next_slash != cursor) {
   1f950:	89 c8                	mov    %ecx,%eax
   1f952:	29 d0                	sub    %edx,%eax
   1f954:	39 ca                	cmp    %ecx,%edx
   1f956:	89 45 cc             	mov    %eax,-0x34(%ebp)
   1f959:	74 c3                	je     1f91e <transfer_request.constprop.5+0x131>
			ret = coap_packet_append_option(&msg->cpkt,
   1f95b:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
   1f95f:	50                   	push   %eax
   1f960:	89 4d c8             	mov    %ecx,-0x38(%ebp)
   1f963:	52                   	push   %edx
   1f964:	6a 0b                	push   $0xb
   1f966:	57                   	push   %edi
   1f967:	e8 9c 86 fe ff       	call   8008 <coap_packet_append_option>
   1f96c:	83 c4 10             	add    $0x10,%esp
   1f96f:	89 c6                	mov    %eax,%esi
			if (ret < 0) {
   1f971:	85 c0                	test   %eax,%eax
   1f973:	8b 4d c8             	mov    -0x38(%ebp),%ecx
   1f976:	79 a6                	jns    1f91e <transfer_request.constprop.5+0x131>
				LOG_ERR("Error adding URI_PATH");
   1f978:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1f97f:	0f 84 ed 00 00 00    	je     1fa72 <transfer_request.constprop.5+0x285>
   1f985:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1f98a:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f990:	c1 ea 03             	shr    $0x3,%edx
   1f993:	c1 e2 06             	shl    $0x6,%edx
   1f996:	83 ca 01             	or     $0x1,%edx
   1f999:	52                   	push   %edx
   1f99a:	68 1a a6 02 00       	push   $0x2a61a
   1f99f:	e8 e6 3a fe ff       	call   348a <log_0>
   1f9a4:	5f                   	pop    %edi
   1f9a5:	58                   	pop    %eax
   1f9a6:	e9 c7 00 00 00       	jmp    1fa72 <transfer_request.constprop.5+0x285>
	}

	if (len > 0) {
		/* flush the rest */
		ret = coap_packet_append_option(&msg->cpkt,
   1f9ab:	0f b7 75 d0          	movzwl -0x30(%ebp),%esi
   1f9af:	56                   	push   %esi
   1f9b0:	52                   	push   %edx
   1f9b1:	6a 0b                	push   $0xb
   1f9b3:	57                   	push   %edi
   1f9b4:	e8 4f 86 fe ff       	call   8008 <coap_packet_append_option>
   1f9b9:	83 c4 10             	add    $0x10,%esp
   1f9bc:	89 c6                	mov    %eax,%esi
						COAP_OPTION_URI_PATH,
						cursor, len);
		if (ret < 0) {
   1f9be:	85 c0                	test   %eax,%eax
   1f9c0:	78 b6                	js     1f978 <transfer_request.constprop.5+0x18b>
			goto cleanup;
		}
	}
#endif

	ret = coap_append_block2_option(&msg->cpkt, ctx);
   1f9c2:	68 88 44 40 00       	push   $0x404488
   1f9c7:	57                   	push   %edi
   1f9c8:	e8 51 8c fe ff       	call   861e <coap_append_block2_option>
   1f9cd:	5e                   	pop    %esi
	if (ret < 0) {
   1f9ce:	85 c0                	test   %eax,%eax
	ret = coap_append_block2_option(&msg->cpkt, ctx);
   1f9d0:	5a                   	pop    %edx
   1f9d1:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1f9d3:	79 29                	jns    1f9fe <transfer_request.constprop.5+0x211>
		LOG_ERR("Unable to add block2 option.");
   1f9d5:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1f9dc:	0f 84 90 00 00 00    	je     1fa72 <transfer_request.constprop.5+0x285>
   1f9e2:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1f9e7:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1f9ed:	c1 ea 03             	shr    $0x3,%edx
   1f9f0:	c1 e2 06             	shl    $0x6,%edx
   1f9f3:	83 ca 01             	or     $0x1,%edx
   1f9f6:	52                   	push   %edx
   1f9f7:	68 30 a6 02 00       	push   $0x2a630
   1f9fc:	eb a1                	jmp    1f99f <transfer_request.constprop.5+0x1b2>
		LOG_ERR("Error adding PROXY_URI '%s'", firmware_uri);
		goto cleanup;
	}
#else
	/* Ask the server to provide a size estimate */
	ret = coap_append_option_int(&msg->cpkt, COAP_OPTION_SIZE2, 0);
   1f9fe:	6a 00                	push   $0x0
   1fa00:	6a 1c                	push   $0x1c
   1fa02:	57                   	push   %edi
   1fa03:	e8 a0 87 fe ff       	call   81a8 <coap_append_option_int>
   1fa08:	83 c4 0c             	add    $0xc,%esp
   1fa0b:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1fa0d:	85 c0                	test   %eax,%eax
   1fa0f:	79 28                	jns    1fa39 <transfer_request.constprop.5+0x24c>
		LOG_ERR("Unable to add size2 option.");
   1fa11:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fa18:	74 58                	je     1fa72 <transfer_request.constprop.5+0x285>
   1fa1a:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1fa1f:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1fa25:	c1 ea 03             	shr    $0x3,%edx
   1fa28:	c1 e2 06             	shl    $0x6,%edx
   1fa2b:	83 ca 01             	or     $0x1,%edx
   1fa2e:	52                   	push   %edx
   1fa2f:	68 4d a6 02 00       	push   $0x2a64d
   1fa34:	e9 66 ff ff ff       	jmp    1f99f <transfer_request.constprop.5+0x1b2>
		goto cleanup;
	}
#endif

	/* send request */
	ret = lwm2m_send_message(msg);
   1fa39:	53                   	push   %ebx
   1fa3a:	e8 42 a4 ff ff       	call   19e81 <lwm2m_send_message>
   1fa3f:	59                   	pop    %ecx
   1fa40:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
   1fa42:	85 c0                	test   %eax,%eax
   1fa44:	79 38                	jns    1fa7e <transfer_request.constprop.5+0x291>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
   1fa46:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fa4d:	74 23                	je     1fa72 <transfer_request.constprop.5+0x285>
   1fa4f:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1fa54:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1fa5a:	c1 ea 03             	shr    $0x3,%edx
   1fa5d:	c1 e2 06             	shl    $0x6,%edx
   1fa60:	83 ca 01             	or     $0x1,%edx
   1fa63:	52                   	push   %edx
   1fa64:	50                   	push   %eax
   1fa65:	68 47 9b 02 00       	push   $0x29b47
   1fa6a:	e8 40 3a fe ff       	call   34af <log_1>
   1fa6f:	83 c4 0c             	add    $0xc,%esp
	}

	return 0;

cleanup:
	lwm2m_reset_message(msg, true);
   1fa72:	6a 01                	push   $0x1
   1fa74:	53                   	push   %ebx
   1fa75:	e8 28 84 ff ff       	call   17ea2 <lwm2m_reset_message>
   1fa7a:	58                   	pop    %eax
   1fa7b:	5a                   	pop    %edx
	return ret;
   1fa7c:	eb 02                	jmp    1fa80 <transfer_request.constprop.5+0x293>
	return 0;
   1fa7e:	31 f6                	xor    %esi,%esi
}
   1fa80:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1fa83:	89 f0                	mov    %esi,%eax
   1fa85:	5b                   	pop    %ebx
   1fa86:	5e                   	pop    %esi
   1fa87:	5f                   	pop    %edi
   1fa88:	5d                   	pop    %ebp
   1fa89:	c3                   	ret    

0001fa8a <do_transmit_timeout_cb>:
	set_update_result_from_error(ret);
	return ret;
}

static void do_transmit_timeout_cb(struct lwm2m_message *msg)
{
   1fa8a:	55                   	push   %ebp
   1fa8b:	a1 b4 a8 40 00       	mov    0x40a8b4,%eax
   1fa90:	89 e5                	mov    %esp,%ebp
   1fa92:	53                   	push   %ebx
	int ret;

	if (firmware_retry < PACKET_TRANSFER_RETRY_MAX) {
   1fa93:	83 3d 94 44 40 00 02 	cmpl   $0x2,0x404494
{
   1fa9a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (firmware_retry < PACKET_TRANSFER_RETRY_MAX) {
   1fa9d:	7f 53                	jg     1faf2 <do_transmit_timeout_cb+0x68>
		/* retry block */
		LOG_WRN("TIMEOUT - Sending a retry packet!");
   1fa9f:	a8 06                	test   $0x6,%al
   1faa1:	74 20                	je     1fac3 <do_transmit_timeout_cb+0x39>
   1faa3:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1faa8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1faad:	c1 e8 03             	shr    $0x3,%eax
   1fab0:	c1 e0 06             	shl    $0x6,%eax
   1fab3:	83 c8 02             	or     $0x2,%eax
   1fab6:	50                   	push   %eax
   1fab7:	68 69 a6 02 00       	push   $0x2a669
   1fabc:	e8 c9 39 fe ff       	call   348a <log_0>
   1fac1:	59                   	pop    %ecx
   1fac2:	58                   	pop    %eax

		ret = transfer_request(&firmware_block_ctx,
   1fac3:	0f b6 93 84 01 00 00 	movzbl 0x184(%ebx),%edx
   1faca:	8b 83 74 01 00 00    	mov    0x174(%ebx),%eax
   1fad0:	e8 18 fd ff ff       	call   1f7ed <transfer_request.constprop.5>
				       msg->token, msg->tkl,
				       do_firmware_transfer_reply_cb);
		if (ret < 0) {
   1fad5:	85 c0                	test   %eax,%eax
   1fad7:	79 11                	jns    1faea <do_transmit_timeout_cb+0x60>
			/* abort retries / transfer */
			set_update_result_from_error(ret);
   1fad9:	e8 cc fc ff ff       	call   1f7aa <set_update_result_from_error>
			firmware_retry = PACKET_TRANSFER_RETRY_MAX;
   1fade:	c7 05 94 44 40 00 03 	movl   $0x3,0x404494
   1fae5:	00 00 00 
			return;
   1fae8:	eb 3c                	jmp    1fb26 <do_transmit_timeout_cb+0x9c>
		}

		firmware_retry++;
   1faea:	ff 05 94 44 40 00    	incl   0x404494
   1faf0:	eb 34                	jmp    1fb26 <do_transmit_timeout_cb+0x9c>
	} else {
		LOG_ERR("TIMEOUT - Too many retry packet attempts! "
   1faf2:	a8 07                	test   $0x7,%al
   1faf4:	74 20                	je     1fb16 <do_transmit_timeout_cb+0x8c>
   1faf6:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fafb:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fb00:	c1 e8 03             	shr    $0x3,%eax
   1fb03:	c1 e0 06             	shl    $0x6,%eax
   1fb06:	83 c8 01             	or     $0x1,%eax
   1fb09:	50                   	push   %eax
   1fb0a:	68 8b a6 02 00       	push   $0x2a68b
   1fb0f:	e8 76 39 fe ff       	call   348a <log_0>
   1fb14:	58                   	pop    %eax
   1fb15:	5a                   	pop    %edx
			"Aborting firmware download.");
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
	}
}
   1fb16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
   1fb19:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
   1fb20:	c9                   	leave  
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
   1fb21:	e9 37 f9 ff ff       	jmp    1f45d <lwm2m_firmware_set_update_result>
}
   1fb26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1fb29:	c9                   	leave  
   1fb2a:	c3                   	ret    

0001fb2b <do_firmware_transfer_reply_cb>:
{
   1fb2b:	55                   	push   %ebp
   1fb2c:	89 e5                	mov    %esp,%ebp
   1fb2e:	57                   	push   %edi
   1fb2f:	56                   	push   %esi
   1fb30:	53                   	push   %ebx
	tkl = coap_header_get_token(check_response, token);
   1fb31:	8d 45 e0             	lea    -0x20(%ebp),%eax
{
   1fb34:	83 ec 34             	sub    $0x34,%esp
	struct lwm2m_engine_res_inst *res = NULL;
   1fb37:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
{
   1fb3e:	8b 75 08             	mov    0x8(%ebp),%esi
	tkl = coap_header_get_token(check_response, token);
   1fb41:	50                   	push   %eax
   1fb42:	56                   	push   %esi
   1fb43:	e8 5c 89 fe ff       	call   84a4 <coap_header_get_token>
   1fb48:	5a                   	pop    %edx
   1fb49:	88 45 cf             	mov    %al,-0x31(%ebp)
   1fb4c:	59                   	pop    %ecx
	if (!tkl && coap_header_get_type(response) == COAP_TYPE_ACK) {
   1fb4d:	84 c0                	test   %al,%al
   1fb4f:	74 10                	je     1fb61 <do_firmware_transfer_reply_cb+0x36>
	} else if (coap_header_get_type(response) == COAP_TYPE_CON) {
   1fb51:	56                   	push   %esi
   1fb52:	e8 30 89 fe ff       	call   8487 <coap_header_get_type>
   1fb57:	5f                   	pop    %edi
   1fb58:	84 c0                	test   %al,%al
   1fb5a:	74 15                	je     1fb71 <do_firmware_transfer_reply_cb+0x46>
   1fb5c:	e9 f4 00 00 00       	jmp    1fc55 <do_firmware_transfer_reply_cb+0x12a>
	if (!tkl && coap_header_get_type(response) == COAP_TYPE_ACK) {
   1fb61:	56                   	push   %esi
   1fb62:	e8 20 89 fe ff       	call   8487 <coap_header_get_type>
   1fb67:	5b                   	pop    %ebx
   1fb68:	3c 02                	cmp    $0x2,%al
   1fb6a:	75 e5                	jne    1fb51 <do_firmware_transfer_reply_cb+0x26>
   1fb6c:	e9 4b 03 00 00       	jmp    1febc <do_firmware_transfer_reply_cb+0x391>
		ret = transfer_empty_ack(coap_header_get_id(check_response));
   1fb71:	56                   	push   %esi
   1fb72:	e8 bf 89 fe ff       	call   8536 <coap_header_get_id>
	msg = lwm2m_get_message(&firmware_ctx);
   1fb77:	c7 04 24 20 39 40 00 	movl   $0x403920,(%esp)
		ret = transfer_empty_ack(coap_header_get_id(check_response));
   1fb7e:	89 c7                	mov    %eax,%edi
	msg = lwm2m_get_message(&firmware_ctx);
   1fb80:	e8 ef 82 ff ff       	call   17e74 <lwm2m_get_message>
   1fb85:	59                   	pop    %ecx
   1fb86:	89 c3                	mov    %eax,%ebx
	if (!msg) {
   1fb88:	85 c0                	test   %eax,%eax
   1fb8a:	75 34                	jne    1fbc0 <do_firmware_transfer_reply_cb+0x95>
		return -ENOMEM;
   1fb8c:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("Unable to get a lwm2m message!");
   1fb91:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fb98:	0f 84 85 00 00 00    	je     1fc23 <do_firmware_transfer_reply_cb+0xf8>
   1fb9e:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fba3:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fba8:	c1 e8 03             	shr    $0x3,%eax
   1fbab:	c1 e0 06             	shl    $0x6,%eax
   1fbae:	83 c8 01             	or     $0x1,%eax
   1fbb1:	50                   	push   %eax
   1fbb2:	68 70 9a 02 00       	push   $0x29a70
   1fbb7:	e8 ce 38 fe ff       	call   348a <log_0>
   1fbbc:	58                   	pop    %eax
   1fbbd:	5a                   	pop    %edx
		if (ret < 0) {
   1fbbe:	eb 63                	jmp    1fc23 <do_firmware_transfer_reply_cb+0xf8>
	msg->mid = mid;
   1fbc0:	66 89 b8 80 01 00 00 	mov    %di,0x180(%eax)
	msg->type = COAP_TYPE_ACK;
   1fbc7:	66 c7 80 82 01 00 00 	movw   $0x2,0x182(%eax)
   1fbce:	02 00 
	ret = lwm2m_init_message(msg);
   1fbd0:	50                   	push   %eax
   1fbd1:	e8 57 84 ff ff       	call   1802d <lwm2m_init_message>
   1fbd6:	5f                   	pop    %edi
	if (ret) {
   1fbd7:	85 c0                	test   %eax,%eax
	ret = lwm2m_init_message(msg);
   1fbd9:	89 c7                	mov    %eax,%edi
	if (ret) {
   1fbdb:	75 38                	jne    1fc15 <do_firmware_transfer_reply_cb+0xea>
	ret = lwm2m_send_message(msg);
   1fbdd:	53                   	push   %ebx
   1fbde:	e8 9e a2 ff ff       	call   19e81 <lwm2m_send_message>
   1fbe3:	59                   	pop    %ecx
   1fbe4:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
   1fbe6:	85 c0                	test   %eax,%eax
   1fbe8:	79 6b                	jns    1fc55 <do_firmware_transfer_reply_cb+0x12a>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
   1fbea:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fbf1:	74 22                	je     1fc15 <do_firmware_transfer_reply_cb+0xea>
   1fbf3:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fbf8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fbfd:	c1 e8 03             	shr    $0x3,%eax
   1fc00:	c1 e0 06             	shl    $0x6,%eax
   1fc03:	83 c8 01             	or     $0x1,%eax
   1fc06:	50                   	push   %eax
   1fc07:	57                   	push   %edi
   1fc08:	68 47 9b 02 00       	push   $0x29b47
   1fc0d:	e8 9d 38 fe ff       	call   34af <log_1>
   1fc12:	83 c4 0c             	add    $0xc,%esp
	lwm2m_reset_message(msg, true);
   1fc15:	6a 01                	push   $0x1
   1fc17:	53                   	push   %ebx
   1fc18:	e8 85 82 ff ff       	call   17ea2 <lwm2m_reset_message>
   1fc1d:	58                   	pop    %eax
		if (ret < 0) {
   1fc1e:	85 ff                	test   %edi,%edi
	lwm2m_reset_message(msg, true);
   1fc20:	5a                   	pop    %edx
		if (ret < 0) {
   1fc21:	79 32                	jns    1fc55 <do_firmware_transfer_reply_cb+0x12a>
			LOG_ERR("Error transmitting ACK");
   1fc23:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fc2a:	0f 84 90 02 00 00    	je     1fec0 <do_firmware_transfer_reply_cb+0x395>
   1fc30:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fc35:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fc3a:	c1 e8 03             	shr    $0x3,%eax
   1fc3d:	c1 e0 06             	shl    $0x6,%eax
   1fc40:	83 c8 01             	or     $0x1,%eax
   1fc43:	50                   	push   %eax
   1fc44:	68 d1 a6 02 00       	push   $0x2a6d1
   1fc49:	e8 3c 38 fe ff       	call   348a <log_0>
   1fc4e:	59                   	pop    %ecx
   1fc4f:	5b                   	pop    %ebx
   1fc50:	e9 6b 02 00 00       	jmp    1fec0 <do_firmware_transfer_reply_cb+0x395>
	resp_code = coap_header_get_code(check_response);
   1fc55:	56                   	push   %esi
   1fc56:	e8 7d 88 fe ff       	call   84d8 <coap_header_get_code>
   1fc5b:	5a                   	pop    %edx
	if (resp_code != COAP_RESPONSE_CODE_CONTENT) {
   1fc5c:	3c 45                	cmp    $0x45,%al
   1fc5e:	74 46                	je     1fca6 <do_firmware_transfer_reply_cb+0x17b>
		ret = -ENOMSG;
   1fc60:	bf b0 ff ff ff       	mov    $0xffffffb0,%edi
		LOG_ERR("Unexpected response from server: %d.%d",
   1fc65:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fc6c:	0f 84 4e 02 00 00    	je     1fec0 <do_firmware_transfer_reply_cb+0x395>
   1fc72:	b9 ec 51 02 00       	mov    $0x251ec,%ecx
   1fc77:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   1fc7d:	c1 e9 03             	shr    $0x3,%ecx
   1fc80:	c1 e1 06             	shl    $0x6,%ecx
   1fc83:	83 c9 01             	or     $0x1,%ecx
   1fc86:	51                   	push   %ecx
   1fc87:	89 c1                	mov    %eax,%ecx
   1fc89:	c0 e8 05             	shr    $0x5,%al
   1fc8c:	83 e1 1f             	and    $0x1f,%ecx
   1fc8f:	51                   	push   %ecx
   1fc90:	0f b6 c0             	movzbl %al,%eax
   1fc93:	50                   	push   %eax
   1fc94:	68 e8 a6 02 00       	push   $0x2a6e8
   1fc99:	e8 4b 38 fe ff       	call   34e9 <log_2>
   1fc9e:	83 c4 10             	add    $0x10,%esp
   1fca1:	e9 1a 02 00 00       	jmp    1fec0 <do_firmware_transfer_reply_cb+0x395>
	memcpy(&received_block_ctx, &firmware_block_ctx,
   1fca6:	6a 0c                	push   $0xc
   1fca8:	8d 5d e8             	lea    -0x18(%ebp),%ebx
   1fcab:	68 88 44 40 00       	push   $0x404488
   1fcb0:	53                   	push   %ebx
   1fcb1:	e8 7b ac fe ff       	call   a931 <memcpy>
   1fcb6:	83 c4 0c             	add    $0xc,%esp
	ret = coap_update_from_block(check_response, &firmware_block_ctx);
   1fcb9:	68 88 44 40 00       	push   $0x404488
   1fcbe:	56                   	push   %esi
   1fcbf:	e8 bd 89 fe ff       	call   8681 <coap_update_from_block>
   1fcc4:	59                   	pop    %ecx
	if (ret < 0) {
   1fcc5:	85 c0                	test   %eax,%eax
	ret = coap_update_from_block(check_response, &firmware_block_ctx);
   1fcc7:	5f                   	pop    %edi
	if (ret < 0) {
   1fcc8:	79 36                	jns    1fd00 <do_firmware_transfer_reply_cb+0x1d5>
		LOG_ERR("Error from block update: %d", ret);
   1fcca:	f6 05 b4 a8 40 00 07 	testb  $0x7,0x40a8b4
   1fcd1:	74 23                	je     1fcf6 <do_firmware_transfer_reply_cb+0x1cb>
   1fcd3:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1fcd8:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1fcde:	c1 ea 03             	shr    $0x3,%edx
   1fce1:	c1 e2 06             	shl    $0x6,%edx
   1fce4:	83 ca 01             	or     $0x1,%edx
   1fce7:	52                   	push   %edx
   1fce8:	50                   	push   %eax
   1fce9:	68 68 97 02 00       	push   $0x29768
   1fcee:	e8 bc 37 fe ff       	call   34af <log_1>
   1fcf3:	83 c4 0c             	add    $0xc,%esp
		ret = -EFAULT;
   1fcf6:	bf f2 ff ff ff       	mov    $0xfffffff2,%edi
   1fcfb:	e9 c0 01 00 00       	jmp    1fec0 <do_firmware_transfer_reply_cb+0x395>
	if (firmware_block_ctx.current < received_block_ctx.current) {
   1fd00:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1fd03:	39 05 8c 44 40 00    	cmp    %eax,0x40448c
   1fd09:	73 48                	jae    1fd53 <do_firmware_transfer_reply_cb+0x228>
		LOG_WRN("Duplicate packet ignored");
   1fd0b:	f6 05 b4 a8 40 00 06 	testb  $0x6,0x40a8b4
   1fd12:	74 20                	je     1fd34 <do_firmware_transfer_reply_cb+0x209>
   1fd14:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fd19:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fd1e:	c1 e8 03             	shr    $0x3,%eax
   1fd21:	c1 e0 06             	shl    $0x6,%eax
   1fd24:	83 c8 02             	or     $0x2,%eax
   1fd27:	50                   	push   %eax
   1fd28:	68 0f a7 02 00       	push   $0x2a70f
   1fd2d:	e8 58 37 fe ff       	call   348a <log_0>
   1fd32:	58                   	pop    %eax
   1fd33:	5a                   	pop    %edx
		memcpy(&firmware_block_ctx, &received_block_ctx,
   1fd34:	6a 0c                	push   $0xc
   1fd36:	53                   	push   %ebx
   1fd37:	68 88 44 40 00       	push   $0x404488
   1fd3c:	e8 f0 ab fe ff       	call   a931 <memcpy>
		reply->user_data = (void *)COAP_REPLY_STATUS_ERROR;
   1fd41:	8b 45 0c             	mov    0xc(%ebp),%eax
		memcpy(&firmware_block_ctx, &received_block_ctx,
   1fd44:	83 c4 0c             	add    $0xc,%esp
		reply->user_data = (void *)COAP_REPLY_STATUS_ERROR;
   1fd47:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		return 0;
   1fd4e:	e9 69 01 00 00       	jmp    1febc <do_firmware_transfer_reply_cb+0x391>
	last_block = !coap_next_block(check_response, &firmware_block_ctx);
   1fd53:	68 88 44 40 00       	push   $0x404488
   1fd58:	56                   	push   %esi
   1fd59:	e8 0e 8a fe ff       	call   876c <coap_next_block>
   1fd5e:	59                   	pop    %ecx
   1fd5f:	89 45 c8             	mov    %eax,-0x38(%ebp)
	payload_offset = response->hdr_len + response->opt_len;
   1fd62:	66 8b 46 0a          	mov    0xa(%esi),%ax
	last_block = !coap_next_block(check_response, &firmware_block_ctx);
   1fd66:	5b                   	pop    %ebx
	payload_offset = response->hdr_len + response->opt_len;
   1fd67:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
	coap_packet_get_payload(response, &payload_len);
   1fd6b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
	payload_offset = response->hdr_len + response->opt_len;
   1fd6e:	0f b6 5e 08          	movzbl 0x8(%esi),%ebx
	coap_packet_get_payload(response, &payload_len);
   1fd72:	50                   	push   %eax
   1fd73:	56                   	push   %esi
   1fd74:	e8 e0 87 fe ff       	call   8559 <coap_packet_get_payload>
   1fd79:	5f                   	pop    %edi
   1fd7a:	58                   	pop    %eax
	if (payload_len > 0) {
   1fd7b:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
   1fd80:	75 0f                	jne    1fd91 <do_firmware_transfer_reply_cb+0x266>
	if (!last_block) {
   1fd82:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   1fd86:	0f 85 14 01 00 00    	jne    1fea0 <do_firmware_transfer_reply_cb+0x375>
   1fd8c:	e9 23 01 00 00       	jmp    1feb4 <do_firmware_transfer_reply_cb+0x389>
		LOG_DBG("total: %zd, current: %zd",
   1fd91:	f6 05 b4 a8 40 00 04 	testb  $0x4,0x40a8b4
   1fd98:	74 32                	je     1fdcc <do_firmware_transfer_reply_cb+0x2a1>
   1fd9a:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1fd9f:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1fda4:	c1 e8 03             	shr    $0x3,%eax
   1fda7:	c1 e0 06             	shl    $0x6,%eax
   1fdaa:	83 c8 04             	or     $0x4,%eax
   1fdad:	50                   	push   %eax
   1fdae:	ff 35 8c 44 40 00    	pushl  0x40448c
   1fdb4:	ff 35 88 44 40 00    	pushl  0x404488
   1fdba:	68 0c 65 02 00       	push   $0x2650c
   1fdbf:	68 28 a7 02 00       	push   $0x2a728
   1fdc4:	e8 67 37 fe ff       	call   3530 <log_3>
   1fdc9:	83 c4 14             	add    $0x14,%esp
		ret = lwm2m_engine_get_resource("5/0/0", &res);
   1fdcc:	8d 45 d8             	lea    -0x28(%ebp),%eax
   1fdcf:	50                   	push   %eax
   1fdd0:	68 19 69 02 00       	push   $0x26919
   1fdd5:	e8 31 ac ff ff       	call   1aa0b <lwm2m_engine_get_resource>
   1fdda:	5f                   	pop    %edi
		if (ret < 0) {
   1fddb:	85 c0                	test   %eax,%eax
		ret = lwm2m_engine_get_resource("5/0/0", &res);
   1fddd:	5a                   	pop    %edx
   1fdde:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
   1fde0:	0f 88 da 00 00 00    	js     1fec0 <do_firmware_transfer_reply_cb+0x395>
		write_buf = res->data_ptr;
   1fde6:	8b 45 d8             	mov    -0x28(%ebp),%eax
		write_buflen = res->data_len;
   1fde9:	0f b7 50 18          	movzwl 0x18(%eax),%edx
		write_buf = res->data_ptr;
   1fded:	8b 48 14             	mov    0x14(%eax),%ecx
		if (res->pre_write_cb) {
   1fdf0:	8b 40 04             	mov    0x4(%eax),%eax
		write_buf = res->data_ptr;
   1fdf3:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		write_buflen = res->data_len;
   1fdf6:	89 55 dc             	mov    %edx,-0x24(%ebp)
		if (res->pre_write_cb) {
   1fdf9:	85 c0                	test   %eax,%eax
   1fdfb:	74 0d                	je     1fe0a <do_firmware_transfer_reply_cb+0x2df>
			write_buf = res->pre_write_cb(0, &write_buflen);
   1fdfd:	8d 55 dc             	lea    -0x24(%ebp),%edx
   1fe00:	52                   	push   %edx
   1fe01:	6a 00                	push   $0x0
   1fe03:	ff d0                	call   *%eax
   1fe05:	5a                   	pop    %edx
   1fe06:	89 45 d0             	mov    %eax,-0x30(%ebp)
   1fe09:	59                   	pop    %ecx
		write_cb = lwm2m_firmware_get_write_cb();
   1fe0a:	e8 88 f9 ff ff       	call   1f797 <lwm2m_firmware_get_write_cb>
   1fe0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (write_cb) {
   1fe12:	85 c0                	test   %eax,%eax
   1fe14:	0f 84 68 ff ff ff    	je     1fd82 <do_firmware_transfer_reply_cb+0x257>
	payload_offset = response->hdr_len + response->opt_len;
   1fe1a:	03 5d cc             	add    -0x34(%ebp),%ebx
   1fe1d:	66 89 5d cc          	mov    %bx,-0x34(%ebp)
			while (payload_len > 0) {
   1fe21:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
   1fe25:	66 85 c0             	test   %ax,%ax
   1fe28:	0f 84 54 ff ff ff    	je     1fd82 <do_firmware_transfer_reply_cb+0x257>
				       write_buflen : payload_len;
   1fe2e:	0f b7 d0             	movzwl %ax,%edx
   1fe31:	8b 5d dc             	mov    -0x24(%ebp),%ebx
   1fe34:	39 d3                	cmp    %edx,%ebx
   1fe36:	76 02                	jbe    1fe3a <do_firmware_transfer_reply_cb+0x30f>
   1fe38:	89 d3                	mov    %edx,%ebx
				payload_len -= len;
   1fe3a:	29 d8                	sub    %ebx,%eax
				len = (payload_len > write_buflen) ?
   1fe3c:	66 89 5d c2          	mov    %bx,-0x3e(%ebp)
				payload_len -= len;
   1fe40:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
				if (buf_read(write_buf, len,
   1fe44:	8b 06                	mov    (%esi),%eax
   1fe46:	0f b7 7e 06          	movzwl 0x6(%esi),%edi
	if (!src) {
   1fe4a:	85 c0                	test   %eax,%eax
   1fe4c:	0f 84 a4 fe ff ff    	je     1fcf6 <do_firmware_transfer_reply_cb+0x1cb>
	if (*offset + len > src_len) {
   1fe52:	0f b7 55 cc          	movzwl -0x34(%ebp),%edx
   1fe56:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
   1fe59:	39 cf                	cmp    %ecx,%edi
   1fe5b:	0f 8c 95 fe ff ff    	jl     1fcf6 <do_firmware_transfer_reply_cb+0x1cb>
	if (dst) {
   1fe61:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1fe65:	74 0f                	je     1fe76 <do_firmware_transfer_reply_cb+0x34b>
		memcpy(dst, src + *offset, len);
   1fe67:	53                   	push   %ebx
   1fe68:	01 d0                	add    %edx,%eax
   1fe6a:	50                   	push   %eax
   1fe6b:	ff 75 d0             	pushl  -0x30(%ebp)
   1fe6e:	e8 be aa fe ff       	call   a931 <memcpy>
   1fe73:	83 c4 0c             	add    $0xc,%esp
				ret = write_cb(0, write_buf, len, last_block,
   1fe76:	ff 35 88 44 40 00    	pushl  0x404488
	*offset += len;
   1fe7c:	66 01 5d cc          	add    %bx,-0x34(%ebp)
	last_block = !coap_next_block(check_response, &firmware_block_ctx);
   1fe80:	31 c0                	xor    %eax,%eax
   1fe82:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   1fe86:	0f 94 c0             	sete   %al
				ret = write_cb(0, write_buf, len, last_block,
   1fe89:	50                   	push   %eax
   1fe8a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1fe8d:	53                   	push   %ebx
   1fe8e:	ff 75 d0             	pushl  -0x30(%ebp)
   1fe91:	6a 00                	push   $0x0
   1fe93:	ff d0                	call   *%eax
   1fe95:	83 c4 14             	add    $0x14,%esp
   1fe98:	89 c7                	mov    %eax,%edi
				if (ret < 0) {
   1fe9a:	85 c0                	test   %eax,%eax
   1fe9c:	79 83                	jns    1fe21 <do_firmware_transfer_reply_cb+0x2f6>
   1fe9e:	eb 20                	jmp    1fec0 <do_firmware_transfer_reply_cb+0x395>
		ret = transfer_request(&firmware_block_ctx, token, tkl,
   1fea0:	0f b6 55 cf          	movzbl -0x31(%ebp),%edx
   1fea4:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1fea7:	e8 41 f9 ff ff       	call   1f7ed <transfer_request.constprop.5>
   1feac:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
   1feae:	85 c0                	test   %eax,%eax
   1feb0:	79 0a                	jns    1febc <do_firmware_transfer_reply_cb+0x391>
   1feb2:	eb 0c                	jmp    1fec0 <do_firmware_transfer_reply_cb+0x395>
		lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
   1feb4:	6a 02                	push   $0x2
   1feb6:	e8 a7 f4 ff ff       	call   1f362 <lwm2m_firmware_set_update_state>
   1febb:	58                   	pop    %eax
	return 0;
   1febc:	31 ff                	xor    %edi,%edi
   1febe:	eb 07                	jmp    1fec7 <do_firmware_transfer_reply_cb+0x39c>
	set_update_result_from_error(ret);
   1fec0:	89 f8                	mov    %edi,%eax
   1fec2:	e8 e3 f8 ff ff       	call   1f7aa <set_update_result_from_error>
}
   1fec7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1feca:	89 f8                	mov    %edi,%eax
   1fecc:	5b                   	pop    %ebx
   1fecd:	5e                   	pop    %esi
   1fece:	5f                   	pop    %edi
   1fecf:	5d                   	pop    %ebp
   1fed0:	c3                   	ret    

0001fed1 <firmware_transfer>:

static void firmware_transfer(struct k_work *work)
{
   1fed1:	55                   	push   %ebp
   1fed2:	89 e5                	mov    %esp,%ebp
   1fed4:	51                   	push   %ecx
	server_addr = proxy_uri;
#else
	server_addr = firmware_uri;
#endif

	ret = lwm2m_parse_peerinfo(server_addr, &firmware_ctx.remote_addr,
   1fed5:	68 98 3a 40 00       	push   $0x403a98
   1feda:	68 20 39 40 00       	push   $0x403920
   1fedf:	68 c0 3a 40 00       	push   $0x403ac0
   1fee4:	e8 a2 b8 ff ff       	call   1b78b <lwm2m_parse_peerinfo>
   1fee9:	83 c4 0c             	add    $0xc,%esp
				   &firmware_ctx.use_dtls);
	if (ret < 0) {
   1feec:	85 c0                	test   %eax,%eax
   1feee:	0f 88 b2 00 00 00    	js     1ffa6 <firmware_transfer+0xd5>
		goto error;
	}

	lwm2m_engine_context_init(&firmware_ctx);
   1fef4:	68 20 39 40 00       	push   $0x403920
   1fef9:	e8 81 b6 ff ff       	call   1b57f <lwm2m_engine_context_init>
	firmware_ctx.handle_separate_response = true;
	ret = lwm2m_socket_start(&firmware_ctx);
   1fefe:	c7 04 24 20 39 40 00 	movl   $0x403920,(%esp)
	firmware_ctx.handle_separate_response = true;
   1ff05:	c6 05 a1 3a 40 00 01 	movb   $0x1,0x403aa1
	ret = lwm2m_socket_start(&firmware_ctx);
   1ff0c:	e8 c0 b7 ff ff       	call   1b6d1 <lwm2m_socket_start>
   1ff11:	5a                   	pop    %edx
	if (ret < 0) {
   1ff12:	85 c0                	test   %eax,%eax
   1ff14:	8b 15 b4 a8 40 00    	mov    0x40a8b4,%edx
   1ff1a:	79 34                	jns    1ff50 <firmware_transfer+0x7f>
		LOG_ERR("Cannot start a firmware-pull connection:%d", ret);
   1ff1c:	80 e2 07             	and    $0x7,%dl
   1ff1f:	0f 84 81 00 00 00    	je     1ffa6 <firmware_transfer+0xd5>
   1ff25:	ba ec 51 02 00       	mov    $0x251ec,%edx
   1ff2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1ff2d:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   1ff33:	c1 ea 03             	shr    $0x3,%edx
   1ff36:	c1 e2 06             	shl    $0x6,%edx
   1ff39:	83 ca 01             	or     $0x1,%edx
   1ff3c:	52                   	push   %edx
   1ff3d:	50                   	push   %eax
   1ff3e:	68 45 a7 02 00       	push   $0x2a745
   1ff43:	e8 67 35 fe ff       	call   34af <log_1>
   1ff48:	83 c4 0c             	add    $0xc,%esp
   1ff4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1ff4e:	eb 56                	jmp    1ffa6 <firmware_transfer+0xd5>
		goto error;
	}

	LOG_INF("Connecting to server %s", firmware_uri);
   1ff50:	83 e2 07             	and    $0x7,%edx
   1ff53:	83 fa 02             	cmp    $0x2,%edx
   1ff56:	76 26                	jbe    1ff7e <firmware_transfer+0xad>
   1ff58:	b8 ec 51 02 00       	mov    $0x251ec,%eax
   1ff5d:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   1ff62:	c1 e8 03             	shr    $0x3,%eax
   1ff65:	c1 e0 06             	shl    $0x6,%eax
   1ff68:	83 c8 03             	or     $0x3,%eax
   1ff6b:	50                   	push   %eax
   1ff6c:	68 c0 3a 40 00       	push   $0x403ac0
   1ff71:	68 70 a7 02 00       	push   $0x2a770
   1ff76:	e8 34 35 fe ff       	call   34af <log_1>
   1ff7b:	83 c4 0c             	add    $0xc,%esp

	/* reset block transfer context */
	coap_block_transfer_init(&firmware_block_ctx,
   1ff7e:	e8 b7 74 ff ff       	call   1743a <lwm2m_default_block_size>
   1ff83:	6a 00                	push   $0x0
   1ff85:	50                   	push   %eax
   1ff86:	68 88 44 40 00       	push   $0x404488
   1ff8b:	e8 0d 86 fe ff       	call   859d <coap_block_transfer_init>
   1ff90:	83 c4 0c             	add    $0xc,%esp
				 lwm2m_default_block_size(), 0);
	ret = transfer_request(&firmware_block_ctx, coap_next_token(), 8,
   1ff93:	e8 e6 82 fe ff       	call   827e <coap_next_token>
   1ff98:	ba 08 00 00 00       	mov    $0x8,%edx
   1ff9d:	e8 4b f8 ff ff       	call   1f7ed <transfer_request.constprop.5>
			       do_firmware_transfer_reply_cb);
	if (ret < 0) {
   1ffa2:	85 c0                	test   %eax,%eax
   1ffa4:	79 06                	jns    1ffac <firmware_transfer+0xdb>

	return;

error:
	set_update_result_from_error(ret);
}
   1ffa6:	c9                   	leave  
	set_update_result_from_error(ret);
   1ffa7:	e9 fe f7 ff ff       	jmp    1f7aa <set_update_result_from_error>
}
   1ffac:	c9                   	leave  
   1ffad:	c3                   	ret    

0001ffae <lwm2m_firmware_start_transfer>:
{
	return 0;
}

int lwm2m_firmware_start_transfer(char *package_uri)
{
   1ffae:	55                   	push   %ebp
   1ffaf:	89 e5                	mov    %esp,%ebp
	/* close old socket */
	if (firmware_ctx.sock_fd > 0) {
   1ffb1:	83 3d a4 3a 40 00 00 	cmpl   $0x0,0x403aa4
   1ffb8:	7e 17                	jle    1ffd1 <lwm2m_firmware_start_transfer+0x23>
		lwm2m_socket_del(&firmware_ctx);
   1ffba:	68 20 39 40 00       	push   $0x403920
   1ffbf:	e8 42 b6 ff ff       	call   1b606 <lwm2m_socket_del>
   1ffc4:	59                   	pop    %ecx
K_SYSCALL_DECLARE1(K_SYSCALL_ZSOCK_CLOSE, zsock_close, int, int, sock)
   1ffc5:	ff 35 a4 3a 40 00    	pushl  0x403aa4
   1ffcb:	e8 5d 8d fe ff       	call   8d2d <z_impl_zsock_close>
   1ffd0:	58                   	pop    %eax
		close(firmware_ctx.sock_fd);
	}

	(void)memset(&firmware_ctx, 0, sizeof(struct lwm2m_ctx));
   1ffd1:	68 88 01 00 00       	push   $0x188
   1ffd6:	6a 00                	push   $0x0
   1ffd8:	68 20 39 40 00       	push   $0x403920
   1ffdd:	e8 be a9 fe ff       	call   a9a0 <memset>
   1ffe2:	83 c4 0c             	add    $0xc,%esp
	firmware_retry = 0;
   1ffe5:	c7 05 94 44 40 00 00 	movl   $0x0,0x404494
   1ffec:	00 00 00 
   1ffef:	c7 05 98 44 40 00 00 	movl   $0x0,0x404498
   1fff6:	00 00 00 
   1fff9:	c7 05 9c 44 40 00 d1 	movl   $0x1fed1,0x40449c
   20000:	fe 01 00 
	k_work_init(&firmware_work, firmware_transfer);
	lwm2m_firmware_set_update_state(STATE_DOWNLOADING);
   20003:	6a 01                	push   $0x1
   20005:	c7 05 a0 44 40 00 00 	movl   $0x0,0x4044a0
   2000c:	00 00 00 
   2000f:	e8 4e f3 ff ff       	call   1f362 <lwm2m_firmware_set_update_state>

	/* start file transfer work */
	strncpy(firmware_uri, package_uri, URI_LEN - 1);
   20014:	c7 04 24 fe 00 00 00 	movl   $0xfe,(%esp)
   2001b:	ff 75 08             	pushl  0x8(%ebp)
   2001e:	68 c0 3a 40 00       	push   $0x403ac0
   20023:	e8 c5 a7 fe ff       	call   a7ed <strncpy>
   20028:	83 c4 0c             	add    $0xc,%esp
   2002b:	a1 a0 44 40 00       	mov    0x4044a0,%eax
   20030:	89 c1                	mov    %eax,%ecx
   20032:	89 c2                	mov    %eax,%edx
   20034:	83 c9 01             	or     $0x1,%ecx
   20037:	f0 0f b1 0d a0 44 40 	lock cmpxchg %ecx,0x4044a0
   2003e:	00 
   2003f:	75 ef                	jne    20030 <lwm2m_firmware_start_transfer+0x82>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   20041:	80 e2 01             	and    $0x1,%dl
   20044:	75 11                	jne    20057 <lwm2m_firmware_start_transfer+0xa9>
		k_queue_append(&work_q->queue, work);
   20046:	68 98 44 40 00       	push   $0x404498
   2004b:	68 60 41 40 00       	push   $0x404160
   20050:	e8 51 36 00 00       	call   236a6 <k_queue_append>
   20055:	58                   	pop    %eax
   20056:	5a                   	pop    %edx
	k_work_submit(&firmware_work);

	return 0;
}
   20057:	31 c0                	xor    %eax,%eax
   20059:	c9                   	leave  
   2005a:	c3                   	ret    

0002005b <put_begin_ri>:
	return 2;
}

static size_t put_begin_ri(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
   2005b:	55                   	push   %ebp
   2005c:	89 e5                	mov    %esp,%ebp
	struct json_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
   2005e:	8b 45 08             	mov    0x8(%ebp),%eax
   20061:	8b 40 08             	mov    0x8(%eax),%eax
	if (!fd) {
   20064:	85 c0                	test   %eax,%eax
   20066:	74 04                	je     2006c <put_begin_ri+0x11>
		return 0;
	}

	fd->writer_flags |= WRITER_RESOURCE_INSTANCE;
   20068:	80 48 02 02          	orb    $0x2,0x2(%eax)
	return 0;
}
   2006c:	31 c0                	xor    %eax,%eax
   2006e:	5d                   	pop    %ebp
   2006f:	c3                   	ret    

00020070 <put_end_ri>:

static size_t put_end_ri(struct lwm2m_output_context *out,
			 struct lwm2m_obj_path *path)
{
   20070:	55                   	push   %ebp
   20071:	89 e5                	mov    %esp,%ebp
	struct json_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
   20073:	8b 45 08             	mov    0x8(%ebp),%eax
   20076:	8b 40 08             	mov    0x8(%eax),%eax
	if (!fd) {
   20079:	85 c0                	test   %eax,%eax
   2007b:	74 04                	je     20081 <put_end_ri+0x11>
		return 0;
	}

	fd->writer_flags &= ~WRITER_RESOURCE_INSTANCE;
   2007d:	80 60 02 fd          	andb   $0xfd,0x2(%eax)
	return 0;
}
   20081:	31 c0                	xor    %eax,%eax
   20083:	5d                   	pop    %ebp
   20084:	c3                   	ret    

00020085 <get_opaque>:
static size_t get_opaque(struct lwm2m_input_context *in,
			 u8_t *value, size_t buflen, bool *last_block)
{
	/* TODO */
	return 0;
}
   20085:	31 c0                	xor    %eax,%eax
   20087:	c3                   	ret    

00020088 <buf_append>:
{
   20088:	55                   	push   %ebp
   20089:	89 e5                	mov    %esp,%ebp
   2008b:	57                   	push   %edi
   2008c:	56                   	push   %esi
   2008d:	53                   	push   %ebx
   2008e:	89 c3                	mov    %eax,%ebx
   20090:	83 ec 08             	sub    $0x8,%esp
	if (!dst || !src) {
   20093:	85 db                	test   %ebx,%ebx
{
   20095:	8b 45 0c             	mov    0xc(%ebp),%eax
   20098:	89 45 f0             	mov    %eax,-0x10(%ebp)
		return -EINVAL;
   2009b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!dst || !src) {
   200a0:	74 37                	je     200d9 <buf_append+0x51>
	if (*dst_len + src_len > dst_size) {
   200a2:	0f b7 32             	movzwl (%edx),%esi
   200a5:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
   200a9:	0f b7 c9             	movzwl %cx,%ecx
   200ac:	8d 04 3e             	lea    (%esi,%edi,1),%eax
   200af:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
   200b2:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (*dst_len + src_len > dst_size) {
   200b7:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
   200ba:	7f 1d                	jg     200d9 <buf_append+0x51>
	memcpy(dst + *dst_len, src, src_len);
   200bc:	57                   	push   %edi
   200bd:	01 de                	add    %ebx,%esi
   200bf:	ff 75 08             	pushl  0x8(%ebp)
   200c2:	89 55 ec             	mov    %edx,-0x14(%ebp)
   200c5:	56                   	push   %esi
   200c6:	e8 66 a8 fe ff       	call   a931 <memcpy>
	*dst_len += src_len;
   200cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   200ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memcpy(dst + *dst_len, src, src_len);
   200d1:	83 c4 0c             	add    $0xc,%esp
	*dst_len += src_len;
   200d4:	66 01 02             	add    %ax,(%edx)
	return 0;
   200d7:	31 c0                	xor    %eax,%eax
}
   200d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   200dc:	5b                   	pop    %ebx
   200dd:	5e                   	pop    %esi
   200de:	5f                   	pop    %edi
   200df:	5d                   	pop    %ebp
   200e0:	c3                   	ret    

000200e1 <put_json_prefix>:
{
   200e1:	55                   	push   %ebp
   200e2:	89 e5                	mov    %esp,%ebp
   200e4:	57                   	push   %edi
   200e5:	56                   	push   %esi
   200e6:	53                   	push   %ebx
   200e7:	83 ec 08             	sub    $0x8,%esp
	fd = engine_get_out_user_data(out);
   200ea:	8b 78 08             	mov    0x8(%eax),%edi
	if (!fd) {
   200ed:	85 ff                	test   %edi,%edi
   200ef:	75 07                	jne    200f8 <put_json_prefix+0x17>
		return 0;
   200f1:	31 c0                	xor    %eax,%eax
   200f3:	e9 cd 00 00 00       	jmp    201c5 <put_json_prefix+0xe4>
	sep = SEPARATOR(fd->writer_flags);
   200f8:	0f b6 77 02          	movzbl 0x2(%edi),%esi
   200fc:	bb ec 96 02 00       	mov    $0x296ec,%ebx
   20101:	f7 c6 01 00 00 00    	test   $0x1,%esi
   20107:	75 05                	jne    2010e <put_json_prefix+0x2d>
   20109:	bb 7b 85 02 00       	mov    $0x2857b,%ebx
   2010e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (fd->path_level >= 2) {
   20111:	83 e6 02             	and    $0x2,%esi
   20114:	0f b7 42 04          	movzwl 0x4(%edx),%eax
   20118:	80 7f 03 01          	cmpb   $0x1,0x3(%edi)
   2011c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   2011f:	76 2c                	jbe    2014d <put_json_prefix+0x6c>
		if (fd->writer_flags & WRITER_RESOURCE_INSTANCE) {
   20121:	89 f0                	mov    %esi,%eax
   20123:	84 c0                	test   %al,%al
   20125:	74 0b                	je     20132 <put_json_prefix+0x51>
			len = snprintk(json_buffer, sizeof(json_buffer),
   20127:	0f b7 52 06          	movzwl 0x6(%edx),%edx
   2012b:	51                   	push   %ecx
   2012c:	52                   	push   %edx
   2012d:	ff 75 f0             	pushl  -0x10(%ebp)
   20130:	eb 4b                	jmp    2017d <put_json_prefix+0x9c>
			len = snprintk(json_buffer, sizeof(json_buffer),
   20132:	51                   	push   %ecx
   20133:	ff 75 f0             	pushl  -0x10(%ebp)
   20136:	53                   	push   %ebx
   20137:	68 b7 a7 02 00       	push   $0x2a7b7
   2013c:	6a 40                	push   $0x40
   2013e:	68 c0 3b 40 00       	push   $0x403bc0
   20143:	e8 95 2a fe ff       	call   2bdd <snprintk>
   20148:	83 c4 18             	add    $0x18,%esp
   2014b:	eb 45                	jmp    20192 <put_json_prefix+0xb1>
		if (fd->writer_flags & WRITER_RESOURCE_INSTANCE) {
   2014d:	89 f0                	mov    %esi,%eax
   2014f:	0f b7 7a 02          	movzwl 0x2(%edx),%edi
   20153:	84 c0                	test   %al,%al
   20155:	74 21                	je     20178 <put_json_prefix+0x97>
			len = snprintk(json_buffer, sizeof(json_buffer),
   20157:	0f b7 52 06          	movzwl 0x6(%edx),%edx
   2015b:	51                   	push   %ecx
   2015c:	52                   	push   %edx
   2015d:	ff 75 f0             	pushl  -0x10(%ebp)
   20160:	57                   	push   %edi
   20161:	53                   	push   %ebx
   20162:	68 c7 a7 02 00       	push   $0x2a7c7
   20167:	6a 40                	push   $0x40
   20169:	68 c0 3b 40 00       	push   $0x403bc0
   2016e:	e8 6a 2a fe ff       	call   2bdd <snprintk>
   20173:	83 c4 20             	add    $0x20,%esp
   20176:	eb 1a                	jmp    20192 <put_json_prefix+0xb1>
			len = snprintk(json_buffer, sizeof(json_buffer),
   20178:	51                   	push   %ecx
   20179:	ff 75 f0             	pushl  -0x10(%ebp)
   2017c:	57                   	push   %edi
   2017d:	53                   	push   %ebx
   2017e:	68 a4 a7 02 00       	push   $0x2a7a4
   20183:	6a 40                	push   $0x40
   20185:	68 c0 3b 40 00       	push   $0x403bc0
   2018a:	e8 4e 2a fe ff       	call   2bdd <snprintk>
   2018f:	83 c4 1c             	add    $0x1c,%esp
   20192:	89 c3                	mov    %eax,%ebx
	if (len < 0) {
   20194:	85 c0                	test   %eax,%eax
   20196:	0f 88 55 ff ff ff    	js     200f1 <put_json_prefix+0x10>
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), json_buffer, len) < 0) {
   2019c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   2019f:	0f b7 f3             	movzwl %bx,%esi
   201a2:	8b 40 04             	mov    0x4(%eax),%eax
   201a5:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   201a9:	8d 50 04             	lea    0x4(%eax),%edx
   201ac:	56                   	push   %esi
   201ad:	8b 00                	mov    (%eax),%eax
   201af:	68 c0 3b 40 00       	push   $0x403bc0
   201b4:	e8 cf fe ff ff       	call   20088 <buf_append>
   201b9:	5a                   	pop    %edx
   201ba:	59                   	pop    %ecx
   201bb:	85 c0                	test   %eax,%eax
   201bd:	0f 88 2e ff ff ff    	js     200f1 <put_json_prefix+0x10>
	return len;
   201c3:	89 d8                	mov    %ebx,%eax
}
   201c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
   201c8:	5b                   	pop    %ebx
   201c9:	5e                   	pop    %esi
   201ca:	5f                   	pop    %edi
   201cb:	5d                   	pop    %ebp
   201cc:	c3                   	ret    

000201cd <put_char>:
{
   201cd:	55                   	push   %ebp
   201ce:	89 e5                	mov    %esp,%ebp
   201d0:	53                   	push   %ebx
   201d1:	51                   	push   %ecx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
   201d2:	8b 40 04             	mov    0x4(%eax),%eax
{
   201d5:	88 55 f8             	mov    %dl,-0x8(%ebp)
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
   201d8:	8d 5d f8             	lea    -0x8(%ebp),%ebx
   201db:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   201df:	8d 50 04             	lea    0x4(%eax),%edx
   201e2:	6a 01                	push   $0x1
   201e4:	8b 00                	mov    (%eax),%eax
   201e6:	53                   	push   %ebx
   201e7:	e8 9c fe ff ff       	call   20088 <buf_append>
   201ec:	5b                   	pop    %ebx
   201ed:	f7 d0                	not    %eax
   201ef:	5a                   	pop    %edx
}
   201f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
   201f3:	c1 e8 1f             	shr    $0x1f,%eax
}
   201f6:	c9                   	leave  
   201f7:	c3                   	ret    

000201f8 <put_json_postfix>:
{
   201f8:	55                   	push   %ebp
   201f9:	89 e5                	mov    %esp,%ebp
   201fb:	53                   	push   %ebx
	fd = engine_get_out_user_data(out);
   201fc:	8b 58 08             	mov    0x8(%eax),%ebx
	if (!fd) {
   201ff:	85 db                	test   %ebx,%ebx
   20201:	75 04                	jne    20207 <put_json_postfix+0xf>
		return 0;
   20203:	31 c0                	xor    %eax,%eax
   20205:	eb 17                	jmp    2021e <put_json_postfix+0x26>
	if (put_char(out, '}') < 1) {
   20207:	ba 7d 00 00 00       	mov    $0x7d,%edx
   2020c:	e8 bc ff ff ff       	call   201cd <put_char>
   20211:	85 c0                	test   %eax,%eax
   20213:	74 ee                	je     20203 <put_json_postfix+0xb>
	fd->writer_flags |= WRITER_OUTPUT_VALUE;
   20215:	80 4b 02 01          	orb    $0x1,0x2(%ebx)
	return 1;
   20219:	b8 01 00 00 00       	mov    $0x1,%eax
}
   2021e:	5b                   	pop    %ebx
   2021f:	5d                   	pop    %ebp
   20220:	c3                   	ret    

00020221 <put_bool>:
{
   20221:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"bv\"");
   20222:	b9 e8 a7 02 00       	mov    $0x2a7e8,%ecx
{
   20227:	89 e5                	mov    %esp,%ebp
   20229:	57                   	push   %edi
   2022a:	56                   	push   %esi
   2022b:	8b 7d 08             	mov    0x8(%ebp),%edi
	len = put_json_prefix(out, path, "\"bv\"");
   2022e:	8b 55 0c             	mov    0xc(%ebp),%edx
   20231:	89 f8                	mov    %edi,%eax
{
   20233:	53                   	push   %ebx
   20234:	8b 5d 10             	mov    0x10(%ebp),%ebx
	len = put_json_prefix(out, path, "\"bv\"");
   20237:	e8 a5 fe ff ff       	call   200e1 <put_json_prefix>
	len += plain_text_put_format(out, "%s", value ? "true" : "false");
   2023c:	84 db                	test   %bl,%bl
	len = put_json_prefix(out, path, "\"bv\"");
   2023e:	89 c6                	mov    %eax,%esi
	len += plain_text_put_format(out, "%s", value ? "true" : "false");
   20240:	b8 e2 a7 02 00       	mov    $0x2a7e2,%eax
   20245:	74 05                	je     2024c <put_bool+0x2b>
   20247:	b8 dd a7 02 00       	mov    $0x2a7dd,%eax
   2024c:	50                   	push   %eax
   2024d:	68 6a a5 02 00       	push   $0x2a56a
   20252:	57                   	push   %edi
   20253:	e8 60 cc ff ff       	call   1ceb8 <plain_text_put_format>
   20258:	83 c4 0c             	add    $0xc,%esp
   2025b:	89 c3                	mov    %eax,%ebx
	len += put_json_postfix(out);
   2025d:	89 f8                	mov    %edi,%eax
   2025f:	e8 94 ff ff ff       	call   201f8 <put_json_postfix>
}
   20264:	8d 65 f4             	lea    -0xc(%ebp),%esp
	len += put_json_postfix(out);
   20267:	01 d8                	add    %ebx,%eax
}
   20269:	5b                   	pop    %ebx
	len += put_json_postfix(out);
   2026a:	01 f0                	add    %esi,%eax
}
   2026c:	5e                   	pop    %esi
   2026d:	5f                   	pop    %edi
   2026e:	5d                   	pop    %ebp
   2026f:	c3                   	ret    

00020270 <put_float64fix>:
{
   20270:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
   20271:	b9 ed a7 02 00       	mov    $0x2a7ed,%ecx
{
   20276:	89 e5                	mov    %esp,%ebp
   20278:	57                   	push   %edi
   20279:	56                   	push   %esi
   2027a:	8b 7d 10             	mov    0x10(%ebp),%edi
   2027d:	8b 75 08             	mov    0x8(%ebp),%esi
   20280:	53                   	push   %ebx
	len = put_json_prefix(out, path, "\"v\"");
   20281:	8b 55 0c             	mov    0xc(%ebp),%edx
   20284:	89 f0                	mov    %esi,%eax
   20286:	e8 56 fe ff ff       	call   200e1 <put_json_prefix>
	len += plain_text_put_format(out, "%lld.%lld",
   2028b:	ff 77 0c             	pushl  0xc(%edi)
   2028e:	ff 77 08             	pushl  0x8(%edi)
   20291:	ff 77 04             	pushl  0x4(%edi)
   20294:	ff 37                	pushl  (%edi)
	len = put_json_prefix(out, path, "\"v\"");
   20296:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%lld.%lld",
   20298:	68 20 a0 02 00       	push   $0x2a020
   2029d:	56                   	push   %esi
   2029e:	e8 15 cc ff ff       	call   1ceb8 <plain_text_put_format>
   202a3:	83 c4 18             	add    $0x18,%esp
   202a6:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
   202a8:	89 f0                	mov    %esi,%eax
   202aa:	e8 49 ff ff ff       	call   201f8 <put_json_postfix>
}
   202af:	8d 65 f4             	lea    -0xc(%ebp),%esp
	len += put_json_postfix(out);
   202b2:	01 d8                	add    %ebx,%eax
}
   202b4:	5b                   	pop    %ebx
   202b5:	5e                   	pop    %esi
   202b6:	5f                   	pop    %edi
   202b7:	5d                   	pop    %ebp
   202b8:	c3                   	ret    

000202b9 <put_float32fix>:
{
   202b9:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
   202ba:	b9 ed a7 02 00       	mov    $0x2a7ed,%ecx
{
   202bf:	89 e5                	mov    %esp,%ebp
   202c1:	57                   	push   %edi
   202c2:	56                   	push   %esi
   202c3:	8b 75 08             	mov    0x8(%ebp),%esi
	len = put_json_prefix(out, path, "\"v\"");
   202c6:	8b 55 0c             	mov    0xc(%ebp),%edx
   202c9:	89 f0                	mov    %esi,%eax
{
   202cb:	53                   	push   %ebx
   202cc:	8b 7d 10             	mov    0x10(%ebp),%edi
	len = put_json_prefix(out, path, "\"v\"");
   202cf:	e8 0d fe ff ff       	call   200e1 <put_json_prefix>
	len += plain_text_put_format(out, "%d.%d", value->val1, value->val2);
   202d4:	ff 77 04             	pushl  0x4(%edi)
   202d7:	ff 37                	pushl  (%edi)
	len = put_json_prefix(out, path, "\"v\"");
   202d9:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%d.%d", value->val1, value->val2);
   202db:	68 09 a7 02 00       	push   $0x2a709
   202e0:	56                   	push   %esi
   202e1:	e8 d2 cb ff ff       	call   1ceb8 <plain_text_put_format>
   202e6:	83 c4 10             	add    $0x10,%esp
   202e9:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
   202eb:	89 f0                	mov    %esi,%eax
   202ed:	e8 06 ff ff ff       	call   201f8 <put_json_postfix>
}
   202f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
	len += put_json_postfix(out);
   202f5:	01 d8                	add    %ebx,%eax
}
   202f7:	5b                   	pop    %ebx
   202f8:	5e                   	pop    %esi
   202f9:	5f                   	pop    %edi
   202fa:	5d                   	pop    %ebp
   202fb:	c3                   	ret    

000202fc <put_s64>:
{
   202fc:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
   202fd:	b9 ed a7 02 00       	mov    $0x2a7ed,%ecx
{
   20302:	89 e5                	mov    %esp,%ebp
   20304:	56                   	push   %esi
   20305:	53                   	push   %ebx
   20306:	8b 75 08             	mov    0x8(%ebp),%esi
	len = put_json_prefix(out, path, "\"v\"");
   20309:	8b 55 0c             	mov    0xc(%ebp),%edx
   2030c:	89 f0                	mov    %esi,%eax
   2030e:	e8 ce fd ff ff       	call   200e1 <put_json_prefix>
	len += plain_text_put_format(out, "%lld", value);
   20313:	ff 75 14             	pushl  0x14(%ebp)
   20316:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
   20319:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%lld", value);
   2031b:	68 d3 9a 02 00       	push   $0x29ad3
   20320:	56                   	push   %esi
   20321:	e8 92 cb ff ff       	call   1ceb8 <plain_text_put_format>
   20326:	83 c4 10             	add    $0x10,%esp
   20329:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
   2032b:	89 f0                	mov    %esi,%eax
   2032d:	e8 c6 fe ff ff       	call   201f8 <put_json_postfix>
}
   20332:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
   20335:	01 d8                	add    %ebx,%eax
}
   20337:	5b                   	pop    %ebx
   20338:	5e                   	pop    %esi
   20339:	5d                   	pop    %ebp
   2033a:	c3                   	ret    

0002033b <put_s32>:
{
   2033b:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
   2033c:	b9 ed a7 02 00       	mov    $0x2a7ed,%ecx
{
   20341:	89 e5                	mov    %esp,%ebp
   20343:	56                   	push   %esi
   20344:	53                   	push   %ebx
   20345:	8b 75 08             	mov    0x8(%ebp),%esi
	len = put_json_prefix(out, path, "\"v\"");
   20348:	8b 55 0c             	mov    0xc(%ebp),%edx
   2034b:	89 f0                	mov    %esi,%eax
   2034d:	e8 8f fd ff ff       	call   200e1 <put_json_prefix>
	len += plain_text_put_format(out, "%d", value);
   20352:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
   20355:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%d", value);
   20357:	68 4b 9d 02 00       	push   $0x29d4b
   2035c:	56                   	push   %esi
   2035d:	e8 56 cb ff ff       	call   1ceb8 <plain_text_put_format>
   20362:	83 c4 0c             	add    $0xc,%esp
   20365:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
   20367:	89 f0                	mov    %esi,%eax
   20369:	e8 8a fe ff ff       	call   201f8 <put_json_postfix>
}
   2036e:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
   20371:	01 d8                	add    %ebx,%eax
}
   20373:	5b                   	pop    %ebx
   20374:	5e                   	pop    %esi
   20375:	5d                   	pop    %ebp
   20376:	c3                   	ret    

00020377 <put_s16>:
{
   20377:	55                   	push   %ebp
   20378:	89 e5                	mov    %esp,%ebp
	return put_s32(out, path, (s32_t)value);
   2037a:	0f bf 45 10          	movswl 0x10(%ebp),%eax
   2037e:	89 45 10             	mov    %eax,0x10(%ebp)
}
   20381:	5d                   	pop    %ebp
	return put_s32(out, path, (s32_t)value);
   20382:	e9 b4 ff ff ff       	jmp    2033b <put_s32>

00020387 <put_s8>:
{
   20387:	55                   	push   %ebp
   20388:	89 e5                	mov    %esp,%ebp
	return put_s32(out, path, (s32_t)value);
   2038a:	0f be 45 10          	movsbl 0x10(%ebp),%eax
   2038e:	89 45 10             	mov    %eax,0x10(%ebp)
}
   20391:	5d                   	pop    %ebp
	return put_s32(out, path, (s32_t)value);
   20392:	e9 a4 ff ff ff       	jmp    2033b <put_s32>

00020397 <put_string>:
{
   20397:	55                   	push   %ebp
	res = put_json_prefix(out, path, "\"sv\"");
   20398:	b9 f1 a7 02 00       	mov    $0x2a7f1,%ecx
{
   2039d:	89 e5                	mov    %esp,%ebp
   2039f:	57                   	push   %edi
   203a0:	56                   	push   %esi
   203a1:	53                   	push   %ebx
   203a2:	83 ec 08             	sub    $0x8,%esp
   203a5:	8b 7d 08             	mov    0x8(%ebp),%edi
	res = put_json_prefix(out, path, "\"sv\"");
   203a8:	8b 55 0c             	mov    0xc(%ebp),%edx
   203ab:	89 f8                	mov    %edi,%eax
   203ad:	e8 2f fd ff ff       	call   200e1 <put_json_prefix>
	res += put_char(out, '"');
   203b2:	ba 22 00 00 00       	mov    $0x22,%edx
	res = put_json_prefix(out, path, "\"sv\"");
   203b7:	89 c3                	mov    %eax,%ebx
	res += put_char(out, '"');
   203b9:	89 f8                	mov    %edi,%eax
   203bb:	e8 0d fe ff ff       	call   201cd <put_char>
	if (res < 0) {
   203c0:	01 c3                	add    %eax,%ebx
   203c2:	79 07                	jns    203cb <put_string+0x34>
		return 0;
   203c4:	31 c0                	xor    %eax,%eax
   203c6:	e9 9d 00 00 00       	jmp    20468 <put_string+0xd1>
   203cb:	8b 75 10             	mov    0x10(%ebp),%esi
   203ce:	8b 45 14             	mov    0x14(%ebp),%eax
   203d1:	01 f0                	add    %esi,%eax
   203d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (i = 0; i < buflen; ++i) {
   203d6:	39 75 ec             	cmp    %esi,-0x14(%ebp)
   203d9:	74 6e                	je     20449 <put_string+0xb2>
		if (buf[i] < '\x20') {
   203db:	0f be 06             	movsbl (%esi),%eax
   203de:	3c 1f                	cmp    $0x1f,%al
   203e0:	7f 42                	jg     20424 <put_string+0x8d>
			res = snprintk(json_buffer, sizeof(json_buffer),
   203e2:	50                   	push   %eax
   203e3:	68 f6 a7 02 00       	push   $0x2a7f6
   203e8:	6a 40                	push   $0x40
   203ea:	68 c0 3b 40 00       	push   $0x403bc0
   203ef:	e8 e9 27 fe ff       	call   2bdd <snprintk>
   203f4:	83 c4 10             	add    $0x10,%esp
   203f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (res < 0) {
   203fa:	85 c0                	test   %eax,%eax
   203fc:	78 c6                	js     203c4 <put_string+0x2d>
			if (buf_append(CPKT_BUF_WRITE(out->out_cpkt),
   203fe:	8b 47 04             	mov    0x4(%edi),%eax
   20401:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
   20405:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   20409:	52                   	push   %edx
   2040a:	8d 50 04             	lea    0x4(%eax),%edx
   2040d:	8b 00                	mov    (%eax),%eax
   2040f:	68 c0 3b 40 00       	push   $0x403bc0
   20414:	e8 6f fc ff ff       	call   20088 <buf_append>
   20419:	5a                   	pop    %edx
   2041a:	59                   	pop    %ecx
   2041b:	85 c0                	test   %eax,%eax
   2041d:	78 a5                	js     203c4 <put_string+0x2d>
			len += res;
   2041f:	03 5d f0             	add    -0x10(%ebp),%ebx
			continue;
   20422:	eb 22                	jmp    20446 <put_string+0xaf>
		} else if (buf[i] == '"' || buf[i] == '\\') {
   20424:	3c 22                	cmp    $0x22,%al
   20426:	74 04                	je     2042c <put_string+0x95>
   20428:	3c 5c                	cmp    $0x5c,%al
   2042a:	75 0e                	jne    2043a <put_string+0xa3>
			len += put_char(out, '\\');
   2042c:	ba 5c 00 00 00       	mov    $0x5c,%edx
   20431:	89 f8                	mov    %edi,%eax
   20433:	e8 95 fd ff ff       	call   201cd <put_char>
   20438:	01 c3                	add    %eax,%ebx
		len += put_char(out, buf[i]);
   2043a:	0f be 16             	movsbl (%esi),%edx
   2043d:	89 f8                	mov    %edi,%eax
   2043f:	e8 89 fd ff ff       	call   201cd <put_char>
   20444:	01 c3                	add    %eax,%ebx
   20446:	46                   	inc    %esi
   20447:	eb 8d                	jmp    203d6 <put_string+0x3f>
	res = put_char(out, '"');
   20449:	ba 22 00 00 00       	mov    $0x22,%edx
   2044e:	89 f8                	mov    %edi,%eax
   20450:	e8 78 fd ff ff       	call   201cd <put_char>
	if (res < 0) {
   20455:	85 c0                	test   %eax,%eax
   20457:	0f 88 67 ff ff ff    	js     203c4 <put_string+0x2d>
	len += res;
   2045d:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
   2045f:	89 f8                	mov    %edi,%eax
   20461:	e8 92 fd ff ff       	call   201f8 <put_json_postfix>
   20466:	01 d8                	add    %ebx,%eax
}
   20468:	8d 65 f4             	lea    -0xc(%ebp),%esp
   2046b:	5b                   	pop    %ebx
   2046c:	5e                   	pop    %esi
   2046d:	5f                   	pop    %edi
   2046e:	5d                   	pop    %ebp
   2046f:	c3                   	ret    

00020470 <put_end>:
{
   20470:	55                   	push   %ebp
   20471:	89 e5                	mov    %esp,%ebp
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), "]}", 2) < 0) {
   20473:	8b 45 08             	mov    0x8(%ebp),%eax
   20476:	8b 40 04             	mov    0x4(%eax),%eax
   20479:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   2047d:	8d 50 04             	lea    0x4(%eax),%edx
   20480:	6a 02                	push   $0x2
   20482:	8b 00                	mov    (%eax),%eax
   20484:	68 fb a7 02 00       	push   $0x2a7fb
   20489:	e8 fa fb ff ff       	call   20088 <buf_append>
   2048e:	5a                   	pop    %edx
		return 0;
   2048f:	f7 d0                	not    %eax
   20491:	c1 e8 1f             	shr    $0x1f,%eax
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), "]}", 2) < 0) {
   20494:	59                   	pop    %ecx
		return 0;
   20495:	01 c0                	add    %eax,%eax
}
   20497:	c9                   	leave  
   20498:	c3                   	ret    

00020499 <put_begin>:
{
   20499:	55                   	push   %ebp
   2049a:	89 e5                	mov    %esp,%ebp
   2049c:	56                   	push   %esi
   2049d:	53                   	push   %ebx
   2049e:	8b 45 0c             	mov    0xc(%ebp),%eax
   204a1:	0f b7 10             	movzwl (%eax),%edx
	if (path->level >= 2) {
   204a4:	80 78 08 01          	cmpb   $0x1,0x8(%eax)
   204a8:	76 1c                	jbe    204c6 <put_begin+0x2d>
		len = snprintk(json_buffer, sizeof(json_buffer),
   204aa:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   204ae:	50                   	push   %eax
   204af:	52                   	push   %edx
   204b0:	68 fe a7 02 00       	push   $0x2a7fe
   204b5:	6a 40                	push   $0x40
   204b7:	68 c0 3b 40 00       	push   $0x403bc0
   204bc:	e8 1c 27 fe ff       	call   2bdd <snprintk>
   204c1:	83 c4 14             	add    $0x14,%esp
   204c4:	eb 15                	jmp    204db <put_begin+0x42>
		len = snprintk(json_buffer, sizeof(json_buffer),
   204c6:	52                   	push   %edx
   204c7:	68 14 a8 02 00       	push   $0x2a814
   204cc:	6a 40                	push   $0x40
   204ce:	68 c0 3b 40 00       	push   $0x403bc0
   204d3:	e8 05 27 fe ff       	call   2bdd <snprintk>
   204d8:	83 c4 10             	add    $0x10,%esp
   204db:	89 c3                	mov    %eax,%ebx
	if (len < 0) {
   204dd:	85 c0                	test   %eax,%eax
   204df:	79 04                	jns    204e5 <put_begin+0x4c>
		return 0;
   204e1:	31 c0                	xor    %eax,%eax
   204e3:	eb 25                	jmp    2050a <put_begin+0x71>
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), json_buffer, len) < 0) {
   204e5:	8b 45 08             	mov    0x8(%ebp),%eax
   204e8:	0f b7 f3             	movzwl %bx,%esi
   204eb:	8b 40 04             	mov    0x4(%eax),%eax
   204ee:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   204f2:	8d 50 04             	lea    0x4(%eax),%edx
   204f5:	56                   	push   %esi
   204f6:	8b 00                	mov    (%eax),%eax
   204f8:	68 c0 3b 40 00       	push   $0x403bc0
   204fd:	e8 86 fb ff ff       	call   20088 <buf_append>
   20502:	5a                   	pop    %edx
   20503:	59                   	pop    %ecx
   20504:	85 c0                	test   %eax,%eax
   20506:	78 d9                	js     204e1 <put_begin+0x48>
	return (size_t)len;
   20508:	89 d8                	mov    %ebx,%eax
}
   2050a:	8d 65 f8             	lea    -0x8(%ebp),%esp
   2050d:	5b                   	pop    %ebx
   2050e:	5e                   	pop    %esi
   2050f:	5d                   	pop    %ebp
   20510:	c3                   	ret    

00020511 <buf_read>:
{
   20511:	55                   	push   %ebp
   20512:	89 e5                	mov    %esp,%ebp
   20514:	57                   	push   %edi
   20515:	56                   	push   %esi
   20516:	53                   	push   %ebx
   20517:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
   2051a:	85 c9                	test   %ecx,%ecx
{
   2051c:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!src) {
   2051f:	74 3e                	je     2055f <buf_read+0x4e>
   20521:	89 c3                	mov    %eax,%ebx
	if (*offset + len > src_len) {
   20523:	8b 45 0c             	mov    0xc(%ebp),%eax
   20526:	0f b7 fa             	movzwl %dx,%edi
   20529:	0f b7 00             	movzwl (%eax),%eax
   2052c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   2052f:	01 f8                	add    %edi,%eax
   20531:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return -ENOMEM;
   20534:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (*offset + len > src_len) {
   20539:	0f b7 f6             	movzwl %si,%esi
   2053c:	39 75 ec             	cmp    %esi,-0x14(%ebp)
   2053f:	7f 23                	jg     20564 <buf_read+0x53>
   20541:	89 d6                	mov    %edx,%esi
	if (dst) {
   20543:	85 db                	test   %ebx,%ebx
   20545:	74 0e                	je     20555 <buf_read+0x44>
		memcpy(dst, src + *offset, len);
   20547:	03 4d f0             	add    -0x10(%ebp),%ecx
   2054a:	57                   	push   %edi
   2054b:	51                   	push   %ecx
   2054c:	53                   	push   %ebx
   2054d:	e8 df a3 fe ff       	call   a931 <memcpy>
   20552:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
   20555:	8b 45 0c             	mov    0xc(%ebp),%eax
   20558:	66 01 30             	add    %si,(%eax)
	return 0;
   2055b:	31 c0                	xor    %eax,%eax
   2055d:	eb 05                	jmp    20564 <buf_read+0x53>
		return -EINVAL;
   2055f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
   20564:	8d 65 f4             	lea    -0xc(%ebp),%esp
   20567:	5b                   	pop    %ebx
   20568:	5e                   	pop    %esi
   20569:	5f                   	pop    %edi
   2056a:	5d                   	pop    %ebp
   2056b:	c3                   	ret    

0002056c <get_string>:
{
   2056c:	55                   	push   %ebp
   2056d:	89 e5                	mov    %esp,%ebp
   2056f:	53                   	push   %ebx
   20570:	8b 55 08             	mov    0x8(%ebp),%edx
   20573:	8b 45 10             	mov    0x10(%ebp),%eax
	fd = engine_get_in_user_data(in);
   20576:	8b 5a 0c             	mov    0xc(%edx),%ebx
	if (!fd) {
   20579:	85 db                	test   %ebx,%ebx
   2057b:	75 04                	jne    20581 <get_string+0x15>
		return 0;
   2057d:	31 c0                	xor    %eax,%eax
   2057f:	eb 31                	jmp    205b2 <get_string+0x46>
	if (fd->value_len > buflen) {
   20581:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
   20585:	39 c1                	cmp    %eax,%ecx
   20587:	76 05                	jbe    2058e <get_string+0x22>
		fd->value_len = buflen - 1;
   20589:	48                   	dec    %eax
   2058a:	66 89 43 06          	mov    %ax,0x6(%ebx)
	ret = buf_read(buf, fd->value_len, CPKT_BUF_READ(in->in_cpkt),
   2058e:	8b 42 04             	mov    0x4(%edx),%eax
   20591:	8d 4b 04             	lea    0x4(%ebx),%ecx
   20594:	0f b7 53 06          	movzwl 0x6(%ebx),%edx
   20598:	51                   	push   %ecx
   20599:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   2059d:	51                   	push   %ecx
   2059e:	8b 08                	mov    (%eax),%ecx
   205a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   205a3:	e8 69 ff ff ff       	call   20511 <buf_read>
   205a8:	5a                   	pop    %edx
   205a9:	59                   	pop    %ecx
	if (ret < 0) {
   205aa:	85 c0                	test   %eax,%eax
   205ac:	78 cf                	js     2057d <get_string+0x11>
	return fd->value_len;
   205ae:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
}
   205b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   205b5:	c9                   	leave  
   205b6:	c3                   	ret    

000205b7 <get_bool>:
{
   205b7:	55                   	push   %ebp
   205b8:	31 c0                	xor    %eax,%eax
   205ba:	89 e5                	mov    %esp,%ebp
   205bc:	57                   	push   %edi
   205bd:	56                   	push   %esi
   205be:	8b 7d 08             	mov    0x8(%ebp),%edi
   205c1:	53                   	push   %ebx
   205c2:	8b 75 0c             	mov    0xc(%ebp),%esi
	fd = engine_get_in_user_data(in);
   205c5:	8b 5f 0c             	mov    0xc(%edi),%ebx
	if (!fd) {
   205c8:	85 db                	test   %ebx,%ebx
   205ca:	74 46                	je     20612 <get_bool+0x5b>
	if (strncmp(in->in_cpkt->data + fd->value_offset,
   205cc:	8b 57 04             	mov    0x4(%edi),%edx
   205cf:	6a 04                	push   $0x4
   205d1:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
   205d5:	03 02                	add    (%edx),%eax
   205d7:	68 dd a7 02 00       	push   $0x2a7dd
   205dc:	50                   	push   %eax
   205dd:	e8 b4 a2 fe ff       	call   a896 <strncmp>
   205e2:	83 c4 0c             	add    $0xc,%esp
   205e5:	85 c0                	test   %eax,%eax
   205e7:	75 05                	jne    205ee <get_bool+0x37>
		*value = true;
   205e9:	c6 06 01             	movb   $0x1,(%esi)
   205ec:	eb 20                	jmp    2060e <get_bool+0x57>
	} else if (strncmp(in->in_cpkt->data + fd->value_offset,
   205ee:	8b 57 04             	mov    0x4(%edi),%edx
   205f1:	6a 05                	push   $0x5
   205f3:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
   205f7:	03 02                	add    (%edx),%eax
   205f9:	68 e2 a7 02 00       	push   $0x2a7e2
   205fe:	50                   	push   %eax
   205ff:	e8 92 a2 fe ff       	call   a896 <strncmp>
   20604:	83 c4 0c             	add    $0xc,%esp
   20607:	85 c0                	test   %eax,%eax
   20609:	75 03                	jne    2060e <get_bool+0x57>
		*value = false;
   2060b:	c6 06 00             	movb   $0x0,(%esi)
	return fd->value_len;
   2060e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
}
   20612:	8d 65 f4             	lea    -0xc(%ebp),%esp
   20615:	5b                   	pop    %ebx
   20616:	5e                   	pop    %esi
   20617:	5f                   	pop    %edi
   20618:	5d                   	pop    %ebp
   20619:	c3                   	ret    

0002061a <json_add_char.isra.6>:
	if ((fd->json_flags & T_VALUE) ||
   2061a:	8a 50 0a             	mov    0xa(%eax),%dl
   2061d:	f6 c2 10             	test   $0x10,%dl
   20620:	75 0a                	jne    2062c <json_add_char.isra.6+0x12>
   20622:	83 e2 0c             	and    $0xc,%edx
   20625:	80 fa 04             	cmp    $0x4,%dl
   20628:	75 30                	jne    2065a <json_add_char.isra.6+0x40>
   2062a:	eb 18                	jmp    20644 <json_add_char.isra.6+0x2a>
			fd->value_len++;
   2062c:	66 8b 48 06          	mov    0x6(%eax),%cx
   20630:	8d 51 01             	lea    0x1(%ecx),%edx
   20633:	66 89 50 06          	mov    %dx,0x6(%eax)
			if (fd->value_len == 1) {
   20637:	66 4a                	dec    %dx
   20639:	75 1f                	jne    2065a <json_add_char.isra.6+0x40>
				fd->value_offset = fd->offset;
   2063b:	66 8b 50 08          	mov    0x8(%eax),%dx
   2063f:	66 89 50 04          	mov    %dx,0x4(%eax)
   20643:	c3                   	ret    
			fd->name_len++;
   20644:	66 8b 48 02          	mov    0x2(%eax),%cx
   20648:	8d 51 01             	lea    0x1(%ecx),%edx
   2064b:	66 89 50 02          	mov    %dx,0x2(%eax)
			if (fd->name_len == 1) {
   2064f:	66 4a                	dec    %dx
   20651:	75 07                	jne    2065a <json_add_char.isra.6+0x40>
				fd->name_offset = fd->offset;
   20653:	66 8b 50 08          	mov    0x8(%eax),%dx
   20657:	66 89 10             	mov    %dx,(%eax)
}
   2065a:	c3                   	ret    

0002065b <json_next_token>:
{
   2065b:	55                   	push   %ebp
   2065c:	89 e5                	mov    %esp,%ebp
   2065e:	57                   	push   %edi
   2065f:	56                   	push   %esi
	cont = 1U;
   20660:	bf 01 00 00 00       	mov    $0x1,%edi
{
   20665:	53                   	push   %ebx
	bool escape = false;
   20666:	31 f6                	xor    %esi,%esi
{
   20668:	83 ec 08             	sub    $0x8,%esp
   2066b:	89 d3                	mov    %edx,%ebx
   2066d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	(void)memset(fd, 0, sizeof(*fd));
   20670:	6a 0c                	push   $0xc
   20672:	6a 00                	push   $0x0
   20674:	52                   	push   %edx
   20675:	e8 26 a3 fe ff       	call   a9a0 <memset>
   2067a:	83 c4 0c             	add    $0xc,%esp
	while (in->offset < in->in_cpkt->offset && cont) {
   2067d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   20680:	8b 50 08             	mov    0x8(%eax),%edx
   20683:	8b 40 04             	mov    0x4(%eax),%eax
   20686:	66 3b 50 04          	cmp    0x4(%eax),%dx
   2068a:	0f 83 0d 01 00 00    	jae    2079d <json_next_token+0x142>
   20690:	89 f9                	mov    %edi,%ecx
   20692:	84 c9                	test   %cl,%cl
   20694:	0f 84 03 01 00 00    	je     2079d <json_next_token+0x142>
		if (buf_read_u8(&c, CPKT_BUF_READ(in->in_cpkt),
   2069a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		fd->offset = in->offset;
   2069d:	66 89 53 08          	mov    %dx,0x8(%ebx)
		if (buf_read_u8(&c, CPKT_BUF_READ(in->in_cpkt),
   206a1:	8d 51 08             	lea    0x8(%ecx),%edx
	return buf_read(value, sizeof(u8_t), src, src_len, offset);
   206a4:	8b 08                	mov    (%eax),%ecx
   206a6:	52                   	push   %edx
   206a7:	0f b7 50 06          	movzwl 0x6(%eax),%edx
   206ab:	8d 45 f3             	lea    -0xd(%ebp),%eax
   206ae:	52                   	push   %edx
   206af:	ba 01 00 00 00       	mov    $0x1,%edx
   206b4:	e8 58 fe ff ff       	call   20511 <buf_read>
   206b9:	5a                   	pop    %edx
   206ba:	59                   	pop    %ecx
   206bb:	85 c0                	test   %eax,%eax
   206bd:	0f 88 da 00 00 00    	js     2079d <json_next_token+0x142>
		if (c == '\\') {
   206c3:	8a 45 f3             	mov    -0xd(%ebp),%al
   206c6:	3c 5c                	cmp    $0x5c,%al
   206c8:	75 0e                	jne    206d8 <json_next_token+0x7d>
			json_add_char(in, fd);
   206ca:	89 d8                	mov    %ebx,%eax
			escape = true;
   206cc:	be 01 00 00 00       	mov    $0x1,%esi
			json_add_char(in, fd);
   206d1:	e8 44 ff ff ff       	call   2061a <json_add_char.isra.6>
			continue;
   206d6:	eb a5                	jmp    2067d <json_next_token+0x22>
		switch (c) {
   206d8:	3c 2c                	cmp    $0x2c,%al
   206da:	74 6b                	je     20747 <json_next_token+0xec>
   206dc:	77 23                	ja     20701 <json_next_token+0xa6>
   206de:	3c 20                	cmp    $0x20,%al
   206e0:	0f 84 9d 00 00 00    	je     20783 <json_next_token+0x128>
   206e6:	77 10                	ja     206f8 <json_next_token+0x9d>
   206e8:	83 e8 09             	sub    $0x9,%eax
   206eb:	3c 01                	cmp    $0x1,%al
   206ed:	0f 86 90 00 00 00    	jbe    20783 <json_next_token+0x128>
   206f3:	e9 97 00 00 00       	jmp    2078f <json_next_token+0x134>
   206f8:	3c 22                	cmp    $0x22,%al
   206fa:	74 53                	je     2074f <json_next_token+0xf4>
   206fc:	e9 8e 00 00 00       	jmp    2078f <json_next_token+0x134>
   20701:	3c 5d                	cmp    $0x5d,%al
   20703:	74 22                	je     20727 <json_next_token+0xcc>
   20705:	77 0a                	ja     20711 <json_next_token+0xb6>
   20707:	3c 3a                	cmp    $0x3a,%al
   20709:	74 61                	je     2076c <json_next_token+0x111>
   2070b:	3c 5b                	cmp    $0x5b,%al
   2070d:	74 0c                	je     2071b <json_next_token+0xc0>
   2070f:	eb 7e                	jmp    2078f <json_next_token+0x134>
   20711:	3c 7b                	cmp    $0x7b,%al
   20713:	74 23                	je     20738 <json_next_token+0xdd>
   20715:	3c 7d                	cmp    $0x7d,%al
   20717:	74 2e                	je     20747 <json_next_token+0xec>
   20719:	eb 74                	jmp    2078f <json_next_token+0x134>
			if (!escape) {
   2071b:	89 f0                	mov    %esi,%eax
   2071d:	84 c0                	test   %al,%al
   2071f:	75 6e                	jne    2078f <json_next_token+0x134>
				fd->json_flags |= T_OBJECT_BEGIN;
   20721:	80 4b 0a 01          	orb    $0x1,0xa(%ebx)
				cont = 0;
   20725:	eb 0a                	jmp    20731 <json_next_token+0xd6>
			if (!escape) {
   20727:	89 f0                	mov    %esi,%eax
   20729:	84 c0                	test   %al,%al
   2072b:	75 62                	jne    2078f <json_next_token+0x134>
				fd->json_flags |= T_OBJECT_END;
   2072d:	80 4b 0a 02          	orb    $0x2,0xa(%ebx)
				cont = 0;
   20731:	31 ff                	xor    %edi,%edi
   20733:	e9 45 ff ff ff       	jmp    2067d <json_next_token+0x22>
			if (!escape) {
   20738:	89 f0                	mov    %esi,%eax
   2073a:	84 c0                	test   %al,%al
   2073c:	75 51                	jne    2078f <json_next_token+0x134>
				fd->json_flags |= T_OBJECT_BEGIN;
   2073e:	80 4b 0a 01          	orb    $0x1,0xa(%ebx)
   20742:	e9 36 ff ff ff       	jmp    2067d <json_next_token+0x22>
			if (!escape) {
   20747:	89 f0                	mov    %esi,%eax
   20749:	84 c0                	test   %al,%al
   2074b:	74 e4                	je     20731 <json_next_token+0xd6>
   2074d:	eb 40                	jmp    2078f <json_next_token+0x134>
			if (!escape) {
   2074f:	89 f0                	mov    %esi,%eax
   20751:	84 c0                	test   %al,%al
   20753:	75 3a                	jne    2078f <json_next_token+0x134>
				if (fd->json_flags & T_STRING_BEGIN) {
   20755:	8a 43 0a             	mov    0xa(%ebx),%al
   20758:	a8 04                	test   $0x4,%al
   2075a:	74 08                	je     20764 <json_next_token+0x109>
					fd->json_flags &= ~T_STRING_BEGIN;
   2075c:	83 e0 fb             	and    $0xfffffffb,%eax
					fd->json_flags |= T_STRING_END;
   2075f:	83 c8 08             	or     $0x8,%eax
   20762:	eb 17                	jmp    2077b <json_next_token+0x120>
					fd->json_flags &= ~T_STRING_END;
   20764:	83 e0 f7             	and    $0xfffffff7,%eax
					fd->json_flags |= T_STRING_BEGIN;
   20767:	83 c8 04             	or     $0x4,%eax
   2076a:	eb 0f                	jmp    2077b <json_next_token+0x120>
			if (!escape) {
   2076c:	89 f0                	mov    %esi,%eax
   2076e:	84 c0                	test   %al,%al
   20770:	75 1d                	jne    2078f <json_next_token+0x134>
				fd->json_flags &= ~T_STRING_END;
   20772:	8a 43 0a             	mov    0xa(%ebx),%al
   20775:	83 e0 f7             	and    $0xfffffff7,%eax
				fd->json_flags |= T_VALUE;
   20778:	83 c8 10             	or     $0x10,%eax
   2077b:	88 43 0a             	mov    %al,0xa(%ebx)
   2077e:	e9 fa fe ff ff       	jmp    2067d <json_next_token+0x22>
			escape = false;
   20783:	31 f6                	xor    %esi,%esi
			if (!(fd->json_flags & T_STRING_BEGIN)) {
   20785:	f6 43 0a 04          	testb  $0x4,0xa(%ebx)
   20789:	0f 84 ee fe ff ff    	je     2067d <json_next_token+0x22>
			json_add_char(in, fd);
   2078f:	89 d8                	mov    %ebx,%eax
			escape = false;
   20791:	31 f6                	xor    %esi,%esi
			json_add_char(in, fd);
   20793:	e8 82 fe ff ff       	call   2061a <json_add_char.isra.6>
   20798:	e9 e0 fe ff ff       	jmp    2067d <json_next_token+0x22>
}
   2079d:	8d 65 f4             	lea    -0xc(%ebp),%esp
	return (cont == 0);
   207a0:	89 f8                	mov    %edi,%eax
   207a2:	83 f0 01             	xor    $0x1,%eax
}
   207a5:	5b                   	pop    %ebx
   207a6:	5e                   	pop    %esi
   207a7:	5f                   	pop    %edi
	return (cont == 0);
   207a8:	0f b6 c0             	movzbl %al,%eax
}
   207ab:	5d                   	pop    %ebp
   207ac:	c3                   	ret    

000207ad <read_number.constprop.8>:
static size_t read_number(struct lwm2m_input_context *in,
   207ad:	55                   	push   %ebp
   207ae:	89 e5                	mov    %esp,%ebp
   207b0:	57                   	push   %edi
   207b1:	56                   	push   %esi
   207b2:	89 d6                	mov    %edx,%esi
   207b4:	53                   	push   %ebx
   207b5:	83 ec 1c             	sub    $0x1c,%esp
   207b8:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	*value1 = 0;
   207bb:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   207c1:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	if (value2) {
   207c8:	85 c9                	test   %ecx,%ecx
   207ca:	74 0d                	je     207d9 <read_number.constprop.8+0x2c>
		*value2 = 0;
   207cc:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   207d2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	fd = engine_get_in_user_data(in);
   207d9:	8b 78 0c             	mov    0xc(%eax),%edi
   207dc:	89 7d ec             	mov    %edi,-0x14(%ebp)
		return 0;
   207df:	31 ff                	xor    %edi,%edi
	if (!fd) {
   207e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   207e5:	0f 84 b8 00 00 00    	je     208a3 <read_number.constprop.8+0xf6>
	buf = in->in_cpkt->data + fd->value_offset;
   207eb:	8b 50 04             	mov    0x4(%eax),%edx
   207ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   207f1:	89 f3                	mov    %esi,%ebx
	bool dot_found = false;
   207f3:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
	buf = in->in_cpkt->data + fd->value_offset;
   207f7:	0f b7 40 04          	movzwl 0x4(%eax),%eax
	while (*(buf + i) && i < fd->value_len) {
   207fb:	03 02                	add    (%edx),%eax
	bool neg = false;
   207fd:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
	while (*(buf + i) && i < fd->value_len) {
   20801:	89 45 d8             	mov    %eax,-0x28(%ebp)
   20804:	8b 45 d8             	mov    -0x28(%ebp),%eax
   20807:	0f be 04 38          	movsbl (%eax,%edi,1),%eax
   2080b:	84 c0                	test   %al,%al
   2080d:	75 15                	jne    20824 <read_number.constprop.8+0x77>
	if (neg) {
   2080f:	80 7d ea 00          	cmpb   $0x0,-0x16(%ebp)
   20813:	0f 84 8a 00 00 00    	je     208a3 <read_number.constprop.8+0xf6>
		*value1 = -*value1;
   20819:	f7 1e                	negl   (%esi)
   2081b:	83 56 04 00          	adcl   $0x0,0x4(%esi)
   2081f:	f7 5e 04             	negl   0x4(%esi)
   20822:	eb 7f                	jmp    208a3 <read_number.constprop.8+0xf6>
	while (*(buf + i) && i < fd->value_len) {
   20824:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   20827:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
   2082b:	39 d7                	cmp    %edx,%edi
   2082d:	73 e0                	jae    2080f <read_number.constprop.8+0x62>
		if (c == '-' && accept_sign && i == 0) {
   2082f:	3c 2d                	cmp    $0x2d,%al
   20831:	75 06                	jne    20839 <read_number.constprop.8+0x8c>
   20833:	85 ff                	test   %edi,%edi
   20835:	74 5a                	je     20891 <read_number.constprop.8+0xe4>
   20837:	eb 20                	jmp    20859 <read_number.constprop.8+0xac>
		} else if (c == '.' && i > 0 && accept_dot && !dot_found &&
   20839:	3c 2e                	cmp    $0x2e,%al
   2083b:	0f 94 c1             	sete   %cl
   2083e:	85 ff                	test   %edi,%edi
   20840:	0f 95 c2             	setne  %dl
   20843:	21 d1                	and    %edx,%ecx
   20845:	83 f1 01             	xor    $0x1,%ecx
   20848:	0a 4d eb             	or     -0x15(%ebp),%cl
   2084b:	83 f1 01             	xor    $0x1,%ecx
   2084e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   20852:	0f 95 c2             	setne  %dl
   20855:	20 ca                	and    %cl,%dl
   20857:	75 3e                	jne    20897 <read_number.constprop.8+0xea>
   20859:	8d 48 d0             	lea    -0x30(%eax),%ecx
		} else if (isdigit(c)) {
   2085c:	83 f9 09             	cmp    $0x9,%ecx
   2085f:	77 ae                	ja     2080f <read_number.constprop.8+0x62>
			*counter = *counter * 10 + (c - '0');
   20861:	6b 43 04 0a          	imul   $0xa,0x4(%ebx),%eax
   20865:	89 45 dc             	mov    %eax,-0x24(%ebp)
   20868:	b8 0a 00 00 00       	mov    $0xa,%eax
   2086d:	f7 23                	mull   (%ebx)
   2086f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   20872:	89 45 e0             	mov    %eax,-0x20(%ebp)
   20875:	89 ca                	mov    %ecx,%edx
   20877:	8b 45 dc             	mov    -0x24(%ebp),%eax
   2087a:	c1 f9 1f             	sar    $0x1f,%ecx
   2087d:	01 45 e4             	add    %eax,-0x1c(%ebp)
   20880:	89 d0                	mov    %edx,%eax
   20882:	89 ca                	mov    %ecx,%edx
   20884:	03 45 e0             	add    -0x20(%ebp),%eax
   20887:	13 55 e4             	adc    -0x1c(%ebp),%edx
   2088a:	89 03                	mov    %eax,(%ebx)
   2088c:	89 53 04             	mov    %edx,0x4(%ebx)
   2088f:	eb 0c                	jmp    2089d <read_number.constprop.8+0xf0>
			neg = true;
   20891:	c6 45 ea 01          	movb   $0x1,-0x16(%ebp)
   20895:	eb 06                	jmp    2089d <read_number.constprop.8+0xf0>
			dot_found = true;
   20897:	88 55 eb             	mov    %dl,-0x15(%ebp)
		} else if (c == '.' && i > 0 && accept_dot && !dot_found &&
   2089a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		i++;
   2089d:	47                   	inc    %edi
   2089e:	e9 61 ff ff ff       	jmp    20804 <read_number.constprop.8+0x57>
}
   208a3:	83 c4 1c             	add    $0x1c,%esp
   208a6:	89 f8                	mov    %edi,%eax
   208a8:	5b                   	pop    %ebx
   208a9:	5e                   	pop    %esi
   208aa:	5f                   	pop    %edi
   208ab:	5d                   	pop    %ebp
   208ac:	c3                   	ret    

000208ad <get_float64fix>:
{
   208ad:	55                   	push   %ebp
   208ae:	89 e5                	mov    %esp,%ebp
   208b0:	53                   	push   %ebx
   208b1:	83 ec 10             	sub    $0x10,%esp
	len = read_number(in, &tmp1, &tmp2, true, true);
   208b4:	8d 4d f4             	lea    -0xc(%ebp),%ecx
   208b7:	8d 55 ec             	lea    -0x14(%ebp),%edx
   208ba:	8b 45 08             	mov    0x8(%ebp),%eax
{
   208bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = read_number(in, &tmp1, &tmp2, true, true);
   208c0:	e8 e8 fe ff ff       	call   207ad <read_number.constprop.8>
	if (len > 0) {
   208c5:	85 c0                	test   %eax,%eax
   208c7:	74 17                	je     208e0 <get_float64fix+0x33>
		value->val1 = tmp1;
   208c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
   208cc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   208cf:	89 13                	mov    %edx,(%ebx)
   208d1:	89 4b 04             	mov    %ecx,0x4(%ebx)
		value->val2 = tmp2;
   208d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   208d7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   208da:	89 53 08             	mov    %edx,0x8(%ebx)
   208dd:	89 4b 0c             	mov    %ecx,0xc(%ebx)
}
   208e0:	83 c4 10             	add    $0x10,%esp
   208e3:	5b                   	pop    %ebx
   208e4:	5d                   	pop    %ebp
   208e5:	c3                   	ret    

000208e6 <get_float32fix>:
{
   208e6:	55                   	push   %ebp
   208e7:	89 e5                	mov    %esp,%ebp
   208e9:	53                   	push   %ebx
   208ea:	83 ec 10             	sub    $0x10,%esp
	len = read_number(in, &tmp1, &tmp2, true, true);
   208ed:	8d 4d f4             	lea    -0xc(%ebp),%ecx
   208f0:	8d 55 ec             	lea    -0x14(%ebp),%edx
   208f3:	8b 45 08             	mov    0x8(%ebp),%eax
{
   208f6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = read_number(in, &tmp1, &tmp2, true, true);
   208f9:	e8 af fe ff ff       	call   207ad <read_number.constprop.8>
	if (len > 0) {
   208fe:	85 c0                	test   %eax,%eax
   20900:	74 0b                	je     2090d <get_float32fix+0x27>
		value->val1 = (s32_t)tmp1;
   20902:	8b 55 ec             	mov    -0x14(%ebp),%edx
   20905:	89 13                	mov    %edx,(%ebx)
		value->val2 = (s32_t)tmp2;
   20907:	8b 55 f4             	mov    -0xc(%ebp),%edx
   2090a:	89 53 04             	mov    %edx,0x4(%ebx)
}
   2090d:	83 c4 10             	add    $0x10,%esp
   20910:	5b                   	pop    %ebx
   20911:	5d                   	pop    %ebp
   20912:	c3                   	ret    

00020913 <get_s32>:
{
   20913:	55                   	push   %ebp
	len = read_number(in, &tmp, NULL, true, true);
   20914:	31 c9                	xor    %ecx,%ecx
{
   20916:	89 e5                	mov    %esp,%ebp
   20918:	83 ec 08             	sub    $0x8,%esp
	len = read_number(in, &tmp, NULL, true, true);
   2091b:	8d 55 f8             	lea    -0x8(%ebp),%edx
   2091e:	8b 45 08             	mov    0x8(%ebp),%eax
	s64_t tmp = 0;
   20921:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   20928:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	len = read_number(in, &tmp, NULL, true, true);
   2092f:	e8 79 fe ff ff       	call   207ad <read_number.constprop.8>
	if (len > 0) {
   20934:	85 c0                	test   %eax,%eax
   20936:	74 08                	je     20940 <get_s32+0x2d>
		*value = (s32_t)tmp;
   20938:	8b 55 0c             	mov    0xc(%ebp),%edx
   2093b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   2093e:	89 0a                	mov    %ecx,(%edx)
}
   20940:	c9                   	leave  
   20941:	c3                   	ret    

00020942 <get_s64>:
{
   20942:	55                   	push   %ebp
	return read_number(in, value, NULL, true, true);
   20943:	31 c9                	xor    %ecx,%ecx
{
   20945:	89 e5                	mov    %esp,%ebp
	return read_number(in, value, NULL, true, true);
   20947:	8b 55 0c             	mov    0xc(%ebp),%edx
   2094a:	8b 45 08             	mov    0x8(%ebp),%eax
}
   2094d:	5d                   	pop    %ebp
	return read_number(in, value, NULL, true, true);
   2094e:	e9 5a fe ff ff       	jmp    207ad <read_number.constprop.8>

00020953 <do_read_op_json>:
	.get_opaque = get_opaque,
};

int do_read_op_json(struct lwm2m_engine_obj *obj, struct lwm2m_message *msg,
		    int content_format)
{
   20953:	55                   	push   %ebp
   20954:	89 e5                	mov    %esp,%ebp
   20956:	56                   	push   %esi
   20957:	53                   	push   %ebx
   20958:	50                   	push   %eax
	struct json_out_formatter_data fd;
	int ret;

	(void)memset(&fd, 0, sizeof(fd));
   20959:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
   2095c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	(void)memset(&fd, 0, sizeof(fd));
   2095f:	6a 04                	push   $0x4
   20961:	6a 00                	push   $0x0
   20963:	56                   	push   %esi
   20964:	e8 37 a0 fe ff       	call   a9a0 <memset>
	engine_set_out_user_data(&msg->out, &fd);
	/* save the level for output processing */
	fd.path_level = msg->path.level;
   20969:	8a 43 28             	mov    0x28(%ebx),%al
	(void)memset(&fd, 0, sizeof(fd));
   2096c:	83 c4 0c             	add    $0xc,%esp
	fd.path_level = msg->path.level;
   2096f:	88 45 f7             	mov    %al,-0x9(%ebp)
	out->user_data = user_data;
   20972:	89 73 1c             	mov    %esi,0x1c(%ebx)
	ret = lwm2m_perform_read_op(obj, msg, content_format);
   20975:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
   20979:	50                   	push   %eax
   2097a:	53                   	push   %ebx
   2097b:	ff 75 08             	pushl  0x8(%ebp)
   2097e:	e8 51 a5 ff ff       	call   1aed4 <lwm2m_perform_read_op>
	out->user_data = NULL;
   20983:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
   2098a:	83 c4 0c             	add    $0xc,%esp
	engine_clear_out_user_data(&msg->out);

	return ret;
}
   2098d:	8d 65 f8             	lea    -0x8(%ebp),%esp
   20990:	5b                   	pop    %ebx
   20991:	5e                   	pop    %esi
   20992:	5d                   	pop    %ebp
   20993:	c3                   	ret    

00020994 <do_write_op_json>:

	return ret;
}

int do_write_op_json(struct lwm2m_engine_obj *obj, struct lwm2m_message *msg)
{
   20994:	55                   	push   %ebp
   20995:	89 e5                	mov    %esp,%ebp
   20997:	57                   	push   %edi
   20998:	56                   	push   %esi
   20999:	53                   	push   %ebx
	u8_t value[TOKEN_BUF_LEN];
	u8_t base_name[MAX_RESOURCE_LEN];
	u8_t full_name[MAX_RESOURCE_LEN];
	u8_t created;

	(void)memset(&fd, 0, sizeof(fd));
   2099a:	8d 5d 80             	lea    -0x80(%ebp),%ebx
{
   2099d:	81 ec a4 00 00 00    	sub    $0xa4,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
   209a3:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
   209aa:	00 00 00 
{
   209ad:	8b 7d 0c             	mov    0xc(%ebp),%edi
	(void)memset(&fd, 0, sizeof(fd));
   209b0:	6a 0c                	push   $0xc
   209b2:	6a 00                	push   $0x0
   209b4:	53                   	push   %ebx
   209b5:	e8 e6 9f fe ff       	call   a9a0 <memset>
   209ba:	83 c4 0c             	add    $0xc,%esp
	in->user_data = user_data;
   209bd:	89 5f 10             	mov    %ebx,0x10(%edi)
	engine_set_in_user_data(&msg->in, &fd);

	/* store a copy of the original path */
	memcpy(&orig_path, &msg->path, sizeof(msg->path));
   209c0:	8d 47 20             	lea    0x20(%edi),%eax
   209c3:	6a 0a                	push   $0xa
   209c5:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
   209cb:	50                   	push   %eax
   209cc:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
   209d2:	50                   	push   %eax
   209d3:	e8 59 9f fe ff       	call   a931 <memcpy>
   209d8:	83 c4 0c             	add    $0xc,%esp

	/* PARSE base name "bn" */
	json_next_token(&msg->in, &fd);
   209db:	8d 47 04             	lea    0x4(%edi),%eax
   209de:	89 da                	mov    %ebx,%edx
   209e0:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
   209e6:	e8 70 fc ff ff       	call   2065b <json_next_token>
	/* TODO: validate name == "bn" */
	if (buf_read(base_name, fd.value_len,
		     CPKT_BUF_READ(msg->in.in_cpkt),
   209eb:	8b 47 08             	mov    0x8(%edi),%eax
	if (buf_read(base_name, fd.value_len,
   209ee:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
   209f1:	51                   	push   %ecx
   209f2:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   209f6:	0f b7 55 86          	movzwl -0x7a(%ebp),%edx
   209fa:	51                   	push   %ecx
   209fb:	8b 08                	mov    (%eax),%ecx
   209fd:	8d 45 8c             	lea    -0x74(%ebp),%eax
   20a00:	e8 0c fb ff ff       	call   20511 <buf_read>
   20a05:	5a                   	pop    %edx
   20a06:	59                   	pop    %ecx
   20a07:	85 c0                	test   %eax,%eax
   20a09:	79 37                	jns    20a42 <do_write_op_json+0xae>
		     &fd.value_offset) < 0) {
		LOG_ERR("Error parsing base name!");
		return -EINVAL;
   20a0b:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("Error parsing base name!");
   20a10:	f6 05 a8 a8 40 00 07 	testb  $0x7,0x40a8a8
   20a17:	0f 84 3a 03 00 00    	je     20d57 <do_write_op_json+0x3c3>
   20a1d:	b8 d4 51 02 00       	mov    $0x251d4,%eax
   20a22:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   20a27:	c1 e8 03             	shr    $0x3,%eax
   20a2a:	c1 e0 06             	shl    $0x6,%eax
   20a2d:	83 c8 01             	or     $0x1,%eax
   20a30:	50                   	push   %eax
   20a31:	68 27 a8 02 00       	push   $0x2a827
   20a36:	e8 4f 2a fe ff       	call   348a <log_0>
   20a3b:	5e                   	pop    %esi
   20a3c:	5f                   	pop    %edi
   20a3d:	e9 15 03 00 00       	jmp    20d57 <do_write_op_json+0x3c3>
	}

	/* skip to elements */
	json_next_token(&msg->in, &fd);
   20a42:	89 da                	mov    %ebx,%edx
   20a44:	8d 47 04             	lea    0x4(%edi),%eax
   20a47:	e8 0f fc ff ff       	call   2065b <json_next_token>
   20a4c:	b8 d4 51 02 00       	mov    $0x251d4,%eax
   20a51:	2d 3c 51 02 00       	sub    $0x2513c,%eax
	int ret = 0, index;
   20a56:	31 db                	xor    %ebx,%ebx
   20a58:	c1 e8 03             	shr    $0x3,%eax
	struct lwm2m_engine_res_inst *res = NULL;
   20a5b:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
   20a62:	00 00 00 
			LOG_DBG("Setting %u = %u", ret, val);
   20a65:	66 25 ff 03          	and    $0x3ff,%ax
   20a69:	66 89 85 60 ff ff ff 	mov    %ax,-0xa0(%ebp)
   20a70:	c1 e0 06             	shl    $0x6,%eax
   20a73:	66 89 85 62 ff ff ff 	mov    %ax,-0x9e(%ebp)
	/* TODO: validate name == "bv" */

	while (json_next_token(&msg->in, &fd)) {
   20a7a:	8d 4d 80             	lea    -0x80(%ebp),%ecx
   20a7d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
   20a83:	89 ca                	mov    %ecx,%edx
   20a85:	e8 d1 fb ff ff       	call   2065b <json_next_token>
   20a8a:	8d 4d 80             	lea    -0x80(%ebp),%ecx
   20a8d:	85 c0                	test   %eax,%eax
   20a8f:	0f 84 bb 02 00 00    	je     20d50 <do_write_op_json+0x3bc>

		if (!(fd.json_flags & T_VALUE)) {
   20a95:	f6 45 8a 10          	testb  $0x10,-0x76(%ebp)
   20a99:	74 df                	je     20a7a <do_write_op_json+0xe6>
			continue;
		}

		if (buf_read(value, fd.name_len,
			     CPKT_BUF_READ(msg->in.in_cpkt),
   20a9b:	8b 47 08             	mov    0x8(%edi),%eax
		if (buf_read(value, fd.name_len,
   20a9e:	51                   	push   %ecx
   20a9f:	0f b7 55 82          	movzwl -0x7e(%ebp),%edx
   20aa3:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   20aa7:	8d 75 b4             	lea    -0x4c(%ebp),%esi
   20aaa:	51                   	push   %ecx
   20aab:	8b 08                	mov    (%eax),%ecx
   20aad:	89 f0                	mov    %esi,%eax
   20aaf:	e8 5d fa ff ff       	call   20511 <buf_read>
   20ab4:	5a                   	pop    %edx
   20ab5:	59                   	pop    %ecx
   20ab6:	85 c0                	test   %eax,%eax
   20ab8:	79 1b                	jns    20ad5 <do_write_op_json+0x141>
			     &fd.name_offset) < 0) {
			LOG_ERR("Error parsing name!");
   20aba:	f6 05 a8 a8 40 00 07 	testb  $0x7,0x40a8a8
   20ac1:	74 b7                	je     20a7a <do_write_op_json+0xe6>
   20ac3:	66 8b 85 62 ff ff ff 	mov    -0x9e(%ebp),%ax
   20aca:	83 c8 01             	or     $0x1,%eax
   20acd:	50                   	push   %eax
   20ace:	68 40 a8 02 00       	push   $0x2a840
   20ad3:	eb 4d                	jmp    20b22 <do_write_op_json+0x18e>
			continue;
		}

		/* handle resource name */
		if (value[0] == 'n') {
   20ad5:	80 7d b4 6e          	cmpb   $0x6e,-0x4c(%ebp)
   20ad9:	0f 85 19 02 00 00    	jne    20cf8 <do_write_op_json+0x364>
			/* reset values */
			created = 0;

			/* get value for relative path */
			if (buf_read(value, fd.value_len,
				     CPKT_BUF_READ(msg->in.in_cpkt),
   20adf:	8b 47 08             	mov    0x8(%edi),%eax
			if (buf_read(value, fd.value_len,
   20ae2:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
   20ae5:	51                   	push   %ecx
			created = 0;
   20ae6:	c6 85 6f ff ff ff 00 	movb   $0x0,-0x91(%ebp)
			if (buf_read(value, fd.value_len,
   20aed:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
   20af1:	0f b7 55 86          	movzwl -0x7a(%ebp),%edx
   20af5:	51                   	push   %ecx
   20af6:	8b 08                	mov    (%eax),%ecx
   20af8:	89 f0                	mov    %esi,%eax
   20afa:	e8 12 fa ff ff       	call   20511 <buf_read>
   20aff:	5a                   	pop    %edx
   20b00:	59                   	pop    %ecx
   20b01:	85 c0                	test   %eax,%eax
   20b03:	79 29                	jns    20b2e <do_write_op_json+0x19a>
				     &fd.value_offset) < 0) {
				LOG_ERR("Error parsing relative path!");
   20b05:	f6 05 a8 a8 40 00 07 	testb  $0x7,0x40a8a8
   20b0c:	0f 84 68 ff ff ff    	je     20a7a <do_write_op_json+0xe6>
   20b12:	66 8b 85 62 ff ff ff 	mov    -0x9e(%ebp),%ax
   20b19:	83 c8 01             	or     $0x1,%eax
   20b1c:	50                   	push   %eax
   20b1d:	68 54 a8 02 00       	push   $0x2a854
   20b22:	e8 63 29 fe ff       	call   348a <log_0>
   20b27:	5e                   	pop    %esi
   20b28:	58                   	pop    %eax
   20b29:	e9 4c ff ff ff       	jmp    20a7a <do_write_op_json+0xe6>
				continue;
			}

			/* combine base_name + name */
			snprintf(full_name, TOKEN_BUF_LEN, "%s%s",
   20b2e:	56                   	push   %esi
   20b2f:	8d 45 8c             	lea    -0x74(%ebp),%eax
   20b32:	50                   	push   %eax
   20b33:	8d 5d a0             	lea    -0x60(%ebp),%ebx
   20b36:	68 b3 6d 02 00       	push   $0x26db3
	int pos = 0;
   20b3b:	31 f6                	xor    %esi,%esi
			snprintf(full_name, TOKEN_BUF_LEN, "%s%s",
   20b3d:	6a 40                	push   $0x40
   20b3f:	53                   	push   %ebx
   20b40:	e8 3d ac fe ff       	call   b782 <snprintf>
   20b45:	83 c4 14             	add    $0x14,%esp
				 base_name, value);

			/* parse full_name into path */
			ret = parse_path(full_name, strlen(full_name),
   20b48:	53                   	push   %ebx
   20b49:	e8 15 9d fe ff       	call   a863 <strlen>
	(void)memset(path, 0, sizeof(*path));
   20b4e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
   20b55:	6a 00                	push   $0x0
   20b57:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
			ret = parse_path(full_name, strlen(full_name),
   20b5d:	0f b7 c0             	movzwl %ax,%eax
   20b60:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
	int ret = 0;
   20b66:	31 db                	xor    %ebx,%ebx
	(void)memset(path, 0, sizeof(*path));
   20b68:	e8 33 9e fe ff       	call   a9a0 <memset>
   20b6d:	83 c4 0c             	add    $0xc,%esp
		c = buf[pos];
   20b70:	0f b6 44 35 a0       	movzbl -0x60(%ebp,%esi,1),%eax
		val = 0U;
   20b75:	31 c9                	xor    %ecx,%ecx
		while (pos < buflen && isdigit(c)) {
   20b77:	39 b5 64 ff ff ff    	cmp    %esi,-0x9c(%ebp)
   20b7d:	7e 1a                	jle    20b99 <do_write_op_json+0x205>
   20b7f:	0f b6 d0             	movzbl %al,%edx
   20b82:	83 ea 30             	sub    $0x30,%edx
   20b85:	83 fa 09             	cmp    $0x9,%edx
   20b88:	77 0f                	ja     20b99 <do_write_op_json+0x205>
			val = val * 10 + (c - '0');
   20b8a:	6b d1 0a             	imul   $0xa,%ecx,%edx
			c = buf[++pos];
   20b8d:	46                   	inc    %esi
			val = val * 10 + (c - '0');
   20b8e:	8d 4c 10 d0          	lea    -0x30(%eax,%edx,1),%ecx
			c = buf[++pos];
   20b92:	0f b6 44 35 a0       	movzbl -0x60(%ebp,%esi,1),%eax
   20b97:	eb de                	jmp    20b77 <do_write_op_json+0x1e3>
		if (pos == 0 && c == '/') {
   20b99:	3c 2f                	cmp    $0x2f,%al
   20b9b:	0f 94 85 57 ff ff ff 	sete   -0xa9(%ebp)
   20ba2:	85 f6                	test   %esi,%esi
   20ba4:	75 0d                	jne    20bb3 <do_write_op_json+0x21f>
   20ba6:	80 bd 57 ff ff ff 00 	cmpb   $0x0,-0xa9(%ebp)
   20bad:	0f 85 a3 00 00 00    	jne    20c56 <do_write_op_json+0x2c2>
		} else if (c == '/' || pos == buflen) {
   20bb3:	8b 15 a8 a8 40 00    	mov    0x40a8a8,%edx
   20bb9:	39 b5 64 ff ff ff    	cmp    %esi,-0x9c(%ebp)
   20bbf:	89 95 58 ff ff ff    	mov    %edx,-0xa8(%ebp)
   20bc5:	74 09                	je     20bd0 <do_write_op_json+0x23c>
   20bc7:	80 bd 57 ff ff ff 00 	cmpb   $0x0,-0xa9(%ebp)
   20bce:	74 59                	je     20c29 <do_write_op_json+0x295>
			LOG_DBG("Setting %u = %u", ret, val);
   20bd0:	f6 85 58 ff ff ff 04 	testb  $0x4,-0xa8(%ebp)
   20bd7:	74 2e                	je     20c07 <do_write_op_json+0x273>
   20bd9:	66 8b 85 62 ff ff ff 	mov    -0x9e(%ebp),%ax
   20be0:	89 8d 58 ff ff ff    	mov    %ecx,-0xa8(%ebp)
   20be6:	83 c8 04             	or     $0x4,%eax
   20be9:	50                   	push   %eax
   20bea:	0f b7 c1             	movzwl %cx,%eax
   20bed:	50                   	push   %eax
   20bee:	53                   	push   %ebx
   20bef:	68 2c 65 02 00       	push   $0x2652c
   20bf4:	68 71 a8 02 00       	push   $0x2a871
   20bf9:	e8 32 29 fe ff       	call   3530 <log_3>
   20bfe:	83 c4 14             	add    $0x14,%esp
   20c01:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
			if (ret == 0) {
   20c07:	85 db                	test   %ebx,%ebx
   20c09:	75 06                	jne    20c11 <do_write_op_json+0x27d>
				path->obj_id = val;
   20c0b:	66 89 4f 20          	mov    %cx,0x20(%edi)
   20c0f:	eb 14                	jmp    20c25 <do_write_op_json+0x291>
			} else if (ret == 1) {
   20c11:	83 fb 01             	cmp    $0x1,%ebx
   20c14:	75 06                	jne    20c1c <do_write_op_json+0x288>
				path->obj_inst_id = val;
   20c16:	66 89 4f 22          	mov    %cx,0x22(%edi)
   20c1a:	eb 09                	jmp    20c25 <do_write_op_json+0x291>
			} else if (ret == 2) {
   20c1c:	83 fb 02             	cmp    $0x2,%ebx
   20c1f:	75 04                	jne    20c25 <do_write_op_json+0x291>
				path->res_id = val;
   20c21:	66 89 4f 24          	mov    %cx,0x24(%edi)
			ret++;
   20c25:	43                   	inc    %ebx
			pos++;
   20c26:	46                   	inc    %esi
   20c27:	eb 32                	jmp    20c5b <do_write_op_json+0x2c7>
			LOG_ERR("Error: illegal char '%c' at pos:%d",
   20c29:	f6 85 58 ff ff ff 07 	testb  $0x7,-0xa8(%ebp)
   20c30:	74 1c                	je     20c4e <do_write_op_json+0x2ba>
   20c32:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
   20c38:	c1 e2 06             	shl    $0x6,%edx
   20c3b:	83 ca 01             	or     $0x1,%edx
   20c3e:	52                   	push   %edx
   20c3f:	56                   	push   %esi
   20c40:	50                   	push   %eax
   20c41:	68 85 a8 02 00       	push   $0x2a885
   20c46:	e8 9e 28 fe ff       	call   34e9 <log_2>
   20c4b:	83 c4 10             	add    $0x10,%esp
			return -1;
   20c4e:	83 cb ff             	or     $0xffffffff,%ebx
   20c51:	e9 fa 00 00 00       	jmp    20d50 <do_write_op_json+0x3bc>
			pos++;
   20c56:	be 01 00 00 00       	mov    $0x1,%esi
	} while (pos < buflen);
   20c5b:	39 b5 64 ff ff ff    	cmp    %esi,-0x9c(%ebp)
   20c61:	0f 8f 09 ff ff ff    	jg     20b70 <do_write_op_json+0x1dc>
					 &msg->path);
			if (ret < 0) {
   20c67:	85 db                	test   %ebx,%ebx
   20c69:	0f 88 e1 00 00 00    	js     20d50 <do_write_op_json+0x3bc>
			}

			/* if valid, use the return value as level */
			msg->path.level = ret;

			ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst,
   20c6f:	8d 85 6f ff ff ff    	lea    -0x91(%ebp),%eax
			msg->path.level = ret;
   20c75:	88 5f 28             	mov    %bl,0x28(%edi)
			ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst,
   20c78:	50                   	push   %eax
   20c79:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
   20c7f:	50                   	push   %eax
   20c80:	57                   	push   %edi
   20c81:	e8 a7 a6 ff ff       	call   1b32d <lwm2m_get_or_create_engine_obj>
   20c86:	83 c4 0c             	add    $0xc,%esp
   20c89:	89 c3                	mov    %eax,%ebx
							     &created);
			if (ret < 0) {
   20c8b:	85 c0                	test   %eax,%eax
   20c8d:	0f 88 bd 00 00 00    	js     20d50 <do_write_op_json+0x3bc>
				break;
			}

			obj_field = lwm2m_get_engine_obj_field(
   20c93:	0f b7 47 24          	movzwl 0x24(%edi),%eax
   20c97:	50                   	push   %eax
   20c98:	ff 75 08             	pushl  0x8(%ebp)
   20c9b:	e8 87 68 ff ff       	call   17527 <lwm2m_get_engine_obj_field>
   20ca0:	5a                   	pop    %edx
   20ca1:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
   20ca7:	59                   	pop    %ecx
							obj, msg->path.res_id);
			/*
			 * if obj_field is not found,
			 * treat as an optional resource
			 */
			if (!obj_field) {
   20ca8:	85 c0                	test   %eax,%eax
   20caa:	0f 84 9b 00 00 00    	je     20d4b <do_write_op_json+0x3b7>
			/*
			 * TODO: support BOOTSTRAP WRITE where optional
			 * resources are ignored
			 */

			if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
   20cb0:	8a 40 02             	mov    0x2(%eax),%al
   20cb3:	88 85 58 ff ff ff    	mov    %al,-0xa8(%ebp)
   20cb9:	83 e0 06             	and    $0x6,%eax
   20cbc:	3c 06                	cmp    $0x6,%al
   20cbe:	75 8e                	jne    20c4e <do_write_op_json+0x2ba>
				ret = -EPERM;
				break;
			}

			if (!obj_inst->resources ||
   20cc0:	8b 95 70 ff ff ff    	mov    -0x90(%ebp),%edx
   20cc6:	8b 42 08             	mov    0x8(%edx),%eax
   20cc9:	85 c0                	test   %eax,%eax
   20ccb:	74 77                	je     20d44 <do_write_op_json+0x3b0>
			    obj_inst->resource_count == 0) {
   20ccd:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
			if (!obj_inst->resources ||
   20cd1:	66 85 d2             	test   %dx,%dx
   20cd4:	74 6e                	je     20d44 <do_write_op_json+0x3b0>
			}

			for (index = 0; index < obj_inst->resource_count;
			     index++) {
				if (obj_inst->resources[index].res_id ==
				    msg->path.res_id) {
   20cd6:	8b 77 24             	mov    0x24(%edi),%esi
			for (index = 0; index < obj_inst->resource_count;
   20cd9:	31 c9                	xor    %ecx,%ecx
				if (obj_inst->resources[index].res_id ==
   20cdb:	66 39 70 1a          	cmp    %si,0x1a(%eax)
   20cdf:	74 58                	je     20d39 <do_write_op_json+0x3a5>
			     index++) {
   20ce1:	41                   	inc    %ecx
   20ce2:	83 c0 20             	add    $0x20,%eax
			for (index = 0; index < obj_inst->resource_count;
   20ce5:	39 ca                	cmp    %ecx,%edx
   20ce7:	7f f2                	jg     20cdb <do_write_op_json+0x347>
					res = &obj_inst->resources[index];
					break;
				}
			}

			if (!res) {
   20ce9:	83 bd 68 ff ff ff 00 	cmpl   $0x0,-0x98(%ebp)
   20cf0:	0f 85 84 fd ff ff    	jne    20a7a <do_write_op_json+0xe6>
   20cf6:	eb 53                	jmp    20d4b <do_write_op_json+0x3b7>
				ret = -ENOENT;
				break;
			}
		} else if (res) {
   20cf8:	83 bd 68 ff ff ff 00 	cmpl   $0x0,-0x98(%ebp)
   20cff:	0f 84 75 fd ff ff    	je     20a7a <do_write_op_json+0xe6>
			/* handle value assignment */
			ret = lwm2m_write_handler(obj_inst, res, obj_field,
   20d05:	57                   	push   %edi
   20d06:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
   20d0c:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
   20d12:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
   20d18:	e8 4a 9e ff ff       	call   1ab67 <lwm2m_write_handler>
   20d1d:	83 c4 10             	add    $0x10,%esp
   20d20:	89 c3                	mov    %eax,%ebx
						  msg);
			if (orig_path.level == 3 && ret < 0) {
   20d22:	80 bd 7e ff ff ff 03 	cmpb   $0x3,-0x82(%ebp)
   20d29:	0f 85 4b fd ff ff    	jne    20a7a <do_write_op_json+0xe6>
   20d2f:	85 c0                	test   %eax,%eax
   20d31:	0f 89 43 fd ff ff    	jns    20a7a <do_write_op_json+0xe6>
   20d37:	eb 17                	jmp    20d50 <do_write_op_json+0x3bc>
				if (obj_inst->resources[index].res_id ==
   20d39:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
   20d3f:	e9 36 fd ff ff       	jmp    20a7a <do_write_op_json+0xe6>
				ret = -EINVAL;
   20d44:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   20d49:	eb 05                	jmp    20d50 <do_write_op_json+0x3bc>
				ret = -ENOENT;
   20d4b:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	in->user_data = NULL;
   20d50:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	}

	engine_clear_in_user_data(&msg->in);

	return ret;
}
   20d57:	8d 65 f4             	lea    -0xc(%ebp),%esp
   20d5a:	89 d8                	mov    %ebx,%eax
   20d5c:	5b                   	pop    %ebx
   20d5d:	5e                   	pop    %esi
   20d5e:	5f                   	pop    %edi
   20d5f:	5d                   	pop    %ebp
   20d60:	c3                   	ret    

00020d61 <ipso_temp_sensor_init>:
	LOG_DBG("Create IPSO Temperature Sensor instance: %d", obj_inst_id);
	return &inst[index];
}

static int ipso_temp_sensor_init(struct device *dev)
{
   20d61:	55                   	push   %ebp
   20d62:	89 e5                	mov    %esp,%ebp
	/* Set default values */
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   20d64:	6a 10                	push   $0x10
   20d66:	6a 00                	push   $0x0
   20d68:	68 a4 44 40 00       	push   $0x4044a4
   20d6d:	e8 2e 9c fe ff       	call   a9a0 <memset>
   20d72:	83 c4 0c             	add    $0xc,%esp
	(void)memset(res, 0, sizeof(struct lwm2m_engine_res_inst) *
   20d75:	68 e0 00 00 00       	push   $0xe0
   20d7a:	6a 00                	push   $0x0
   20d7c:	68 00 3c 40 00       	push   $0x403c00
   20d81:	e8 1a 9c fe ff       	call   a9a0 <memset>
   20d86:	83 c4 0c             	add    $0xc,%esp
			MAX_INSTANCE_COUNT * TEMP_MAX_ID);

	temp_sensor.obj_id = IPSO_OBJECT_TEMP_SENSOR_ID;
	temp_sensor.fields = fields;
   20d89:	c7 05 e4 3c 40 00 60 	movl   $0x40a560,0x403ce4
   20d90:	a5 40 00 
	temp_sensor.obj_id = IPSO_OBJECT_TEMP_SENSOR_ID;
   20d93:	c7 05 f8 3c 40 00 e7 	movl   $0x70ce7,0x403cf8
   20d9a:	0c 07 00 
	temp_sensor.field_count = ARRAY_SIZE(fields);
	temp_sensor.max_instance_count = MAX_INSTANCE_COUNT;
   20d9d:	66 c7 05 fe 3c 40 00 	movw   $0x1,0x403cfe
   20da4:	01 00 
	temp_sensor.create_cb = temp_sensor_create;
	lwm2m_register_obj(&temp_sensor);
   20da6:	68 e0 3c 40 00       	push   $0x403ce0
	temp_sensor.create_cb = temp_sensor_create;
   20dab:	c7 05 e8 3c 40 00 bf 	movl   $0x20dbf,0x403ce8
   20db2:	0d 02 00 
	lwm2m_register_obj(&temp_sensor);
   20db5:	e8 5c 67 ff ff       	call   17516 <lwm2m_register_obj>
   20dba:	58                   	pop    %eax

	return 0;
}
   20dbb:	31 c0                	xor    %eax,%eax
   20dbd:	c9                   	leave  
   20dbe:	c3                   	ret    

00020dbf <temp_sensor_create>:
{
   20dbf:	55                   	push   %ebp
   20dc0:	a1 90 a8 40 00       	mov    0x40a890,%eax
   20dc5:	89 e5                	mov    %esp,%ebp
   20dc7:	53                   	push   %ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   20dc8:	83 3d a8 44 40 00 00 	cmpl   $0x0,0x4044a8
{
   20dcf:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   20dd2:	74 68                	je     20e3c <temp_sensor_create+0x7d>
   20dd4:	83 e0 07             	and    $0x7,%eax
			return NULL;
   20dd7:	31 db                	xor    %ebx,%ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   20dd9:	66 39 15 b0 44 40 00 	cmp    %dx,0x4044b0
   20de0:	75 27                	jne    20e09 <temp_sensor_create+0x4a>
			LOG_ERR("Can not create instance - "
   20de2:	85 c0                	test   %eax,%eax
   20de4:	0f 84 ed 02 00 00    	je     210d7 <temp_sensor_create+0x318>
   20dea:	b8 a4 51 02 00       	mov    $0x251a4,%eax
   20def:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   20df4:	c1 e8 03             	shr    $0x3,%eax
   20df7:	c1 e0 06             	shl    $0x6,%eax
   20dfa:	83 c8 01             	or     $0x1,%eax
   20dfd:	50                   	push   %eax
   20dfe:	0f b7 d2             	movzwl %dx,%edx
   20e01:	52                   	push   %edx
   20e02:	68 fe 9d 02 00       	push   $0x29dfe
   20e07:	eb 26                	jmp    20e2f <temp_sensor_create+0x70>
		LOG_ERR("Can not create instance - no more room: %u",
   20e09:	85 c0                	test   %eax,%eax
   20e0b:	0f 84 c6 02 00 00    	je     210d7 <temp_sensor_create+0x318>
   20e11:	b9 a4 51 02 00       	mov    $0x251a4,%ecx
   20e16:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   20e1c:	c1 e9 03             	shr    $0x3,%ecx
   20e1f:	c1 e1 06             	shl    $0x6,%ecx
   20e22:	83 c9 01             	or     $0x1,%ecx
   20e25:	51                   	push   %ecx
   20e26:	0f b7 d2             	movzwl %dx,%edx
   20e29:	52                   	push   %edx
   20e2a:	68 2d 9e 02 00       	push   $0x29e2d
   20e2f:	e8 7b 26 fe ff       	call   34af <log_1>
   20e34:	83 c4 0c             	add    $0xc,%esp
   20e37:	e9 9b 02 00 00       	jmp    210d7 <temp_sensor_create+0x318>
	sensor_value[index].val1 = 0;
   20e3c:	c7 05 dc 44 40 00 00 	movl   $0x0,0x4044dc
   20e43:	00 00 00 
	sensor_value[index].val2 = 0;
   20e46:	c7 05 e0 44 40 00 00 	movl   $0x0,0x4044e0
   20e4d:	00 00 00 
	units[index][0] = '\0';
   20e50:	c6 05 d4 44 40 00 00 	movb   $0x0,0x4044d4
	min_measured_value[index].val1 = INT32_MAX;
   20e57:	c7 05 cc 44 40 00 ff 	movl   $0x7fffffff,0x4044cc
   20e5e:	ff ff 7f 
	min_measured_value[index].val2 = 0;
   20e61:	c7 05 d0 44 40 00 00 	movl   $0x0,0x4044d0
   20e68:	00 00 00 
	max_measured_value[index].val1 = -INT32_MAX;
   20e6b:	c7 05 c4 44 40 00 01 	movl   $0x80000001,0x4044c4
   20e72:	00 00 80 
	max_measured_value[index].val2 = 0;
   20e75:	c7 05 c8 44 40 00 00 	movl   $0x0,0x4044c8
   20e7c:	00 00 00 
	min_range_value[index].val1 = 0;
   20e7f:	c7 05 bc 44 40 00 00 	movl   $0x0,0x4044bc
   20e86:	00 00 00 
	min_range_value[index].val2 = 0;
   20e89:	c7 05 c0 44 40 00 00 	movl   $0x0,0x4044c0
   20e90:	00 00 00 
	max_range_value[index].val1 = 0;
   20e93:	c7 05 b4 44 40 00 00 	movl   $0x0,0x4044b4
   20e9a:	00 00 00 
	max_range_value[index].val2 = 0;
   20e9d:	c7 05 b8 44 40 00 00 	movl   $0x0,0x4044b8
   20ea4:	00 00 00 
	INIT_OBJ_RES(res[index], i, TEMP_SENSOR_VALUE_ID, 0,
   20ea7:	c7 05 10 3c 40 00 00 	movl   $0x0,0x403c10
   20eae:	00 00 00 
   20eb1:	c7 05 14 3c 40 00 dc 	movl   $0x4044dc,0x403c14
   20eb8:	44 40 00 
   20ebb:	c7 05 18 3c 40 00 08 	movl   $0x16440008,0x403c18
   20ec2:	00 44 16 
   20ec5:	c7 05 00 3c 40 00 00 	movl   $0x0,0x403c00
   20ecc:	00 00 00 
   20ecf:	c7 05 04 3c 40 00 00 	movl   $0x0,0x403c04
   20ed6:	00 00 00 
   20ed9:	c7 05 08 3c 40 00 de 	movl   $0x210de,0x403c08
   20ee0:	10 02 00 
   20ee3:	c7 05 0c 3c 40 00 00 	movl   $0x0,0x403c0c
   20eea:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, TEMP_UNITS_ID,
   20eed:	c7 05 30 3c 40 00 00 	movl   $0x0,0x403c30
   20ef4:	00 00 00 
   20ef7:	c7 05 34 3c 40 00 d4 	movl   $0x4044d4,0x403c34
   20efe:	44 40 00 
   20f01:	c7 05 38 3c 40 00 08 	movl   $0x16450008,0x403c38
   20f08:	00 45 16 
   20f0b:	c7 05 20 3c 40 00 00 	movl   $0x0,0x403c20
   20f12:	00 00 00 
   20f15:	c7 05 24 3c 40 00 00 	movl   $0x0,0x403c24
   20f1c:	00 00 00 
   20f1f:	c7 05 28 3c 40 00 00 	movl   $0x0,0x403c28
   20f26:	00 00 00 
   20f29:	c7 05 2c 3c 40 00 00 	movl   $0x0,0x403c2c
   20f30:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, TEMP_MIN_MEASURED_VALUE_ID,
   20f33:	c7 05 50 3c 40 00 00 	movl   $0x0,0x403c50
   20f3a:	00 00 00 
   20f3d:	c7 05 54 3c 40 00 cc 	movl   $0x4044cc,0x403c54
   20f44:	44 40 00 
   20f47:	c7 05 58 3c 40 00 08 	movl   $0x15e10008,0x403c58
   20f4e:	00 e1 15 
   20f51:	c7 05 40 3c 40 00 00 	movl   $0x0,0x403c40
   20f58:	00 00 00 
   20f5b:	c7 05 44 3c 40 00 00 	movl   $0x0,0x403c44
   20f62:	00 00 00 
   20f65:	c7 05 48 3c 40 00 00 	movl   $0x0,0x403c48
   20f6c:	00 00 00 
   20f6f:	c7 05 4c 3c 40 00 00 	movl   $0x0,0x403c4c
   20f76:	00 00 00 
	LOG_DBG("Create IPSO Temperature Sensor instance: %d", obj_inst_id);
   20f79:	a8 04                	test   $0x4,%al
	INIT_OBJ_RES_DATA(res[index], i, TEMP_MAX_MEASURED_VALUE_ID,
   20f7b:	c7 05 70 3c 40 00 00 	movl   $0x0,0x403c70
   20f82:	00 00 00 
   20f85:	c7 05 74 3c 40 00 c4 	movl   $0x4044c4,0x403c74
   20f8c:	44 40 00 
   20f8f:	c7 05 78 3c 40 00 08 	movl   $0x15e20008,0x403c78
   20f96:	00 e2 15 
   20f99:	c7 05 60 3c 40 00 00 	movl   $0x0,0x403c60
   20fa0:	00 00 00 
   20fa3:	c7 05 64 3c 40 00 00 	movl   $0x0,0x403c64
   20faa:	00 00 00 
   20fad:	c7 05 68 3c 40 00 00 	movl   $0x0,0x403c68
   20fb4:	00 00 00 
   20fb7:	c7 05 6c 3c 40 00 00 	movl   $0x0,0x403c6c
   20fbe:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, TEMP_MIN_RANGE_VALUE_ID,
   20fc1:	c7 05 90 3c 40 00 00 	movl   $0x0,0x403c90
   20fc8:	00 00 00 
   20fcb:	c7 05 94 3c 40 00 bc 	movl   $0x4044bc,0x403c94
   20fd2:	44 40 00 
   20fd5:	c7 05 98 3c 40 00 08 	movl   $0x15e30008,0x403c98
   20fdc:	00 e3 15 
   20fdf:	c7 05 80 3c 40 00 00 	movl   $0x0,0x403c80
   20fe6:	00 00 00 
   20fe9:	c7 05 84 3c 40 00 00 	movl   $0x0,0x403c84
   20ff0:	00 00 00 
   20ff3:	c7 05 88 3c 40 00 00 	movl   $0x0,0x403c88
   20ffa:	00 00 00 
   20ffd:	c7 05 8c 3c 40 00 00 	movl   $0x0,0x403c8c
   21004:	00 00 00 
	INIT_OBJ_RES_DATA(res[index], i, TEMP_MAX_RANGE_VALUE_ID,
   21007:	c7 05 b0 3c 40 00 00 	movl   $0x0,0x403cb0
   2100e:	00 00 00 
   21011:	c7 05 b4 3c 40 00 b4 	movl   $0x4044b4,0x403cb4
   21018:	44 40 00 
   2101b:	c7 05 b8 3c 40 00 08 	movl   $0x15e40008,0x403cb8
   21022:	00 e4 15 
   21025:	c7 05 a0 3c 40 00 00 	movl   $0x0,0x403ca0
   2102c:	00 00 00 
   2102f:	c7 05 a4 3c 40 00 00 	movl   $0x0,0x403ca4
   21036:	00 00 00 
   21039:	c7 05 a8 3c 40 00 00 	movl   $0x0,0x403ca8
   21040:	00 00 00 
   21043:	c7 05 ac 3c 40 00 00 	movl   $0x0,0x403cac
   2104a:	00 00 00 
	INIT_OBJ_RES_EXECUTE(res[index], i,
   2104d:	c7 05 d0 3c 40 00 00 	movl   $0x0,0x403cd0
   21054:	00 00 00 
   21057:	c7 05 d4 3c 40 00 00 	movl   $0x0,0x403cd4
   2105e:	00 00 00 
   21061:	c7 05 d8 3c 40 00 00 	movl   $0x15e50000,0x403cd8
   21068:	00 e5 15 
   2106b:	c7 05 c0 3c 40 00 00 	movl   $0x0,0x403cc0
   21072:	00 00 00 
   21075:	c7 05 c4 3c 40 00 00 	movl   $0x0,0x403cc4
   2107c:	00 00 00 
   2107f:	c7 05 c8 3c 40 00 00 	movl   $0x0,0x403cc8
   21086:	00 00 00 
   21089:	c7 05 cc 3c 40 00 c3 	movl   $0x211c3,0x403ccc
   21090:	11 02 00 
	inst[index].resources = res[index];
   21093:	c7 05 ac 44 40 00 00 	movl   $0x403c00,0x4044ac
   2109a:	3c 40 00 
	inst[index].resource_count = i;
   2109d:	66 c7 05 b2 44 40 00 	movw   $0x7,0x4044b2
   210a4:	07 00 
	LOG_DBG("Create IPSO Temperature Sensor instance: %d", obj_inst_id);
   210a6:	74 2a                	je     210d2 <temp_sensor_create+0x313>
   210a8:	b8 a4 51 02 00       	mov    $0x251a4,%eax
   210ad:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   210b2:	c1 e8 03             	shr    $0x3,%eax
   210b5:	c1 e0 06             	shl    $0x6,%eax
   210b8:	83 c8 04             	or     $0x4,%eax
   210bb:	50                   	push   %eax
   210bc:	0f b7 d2             	movzwl %dx,%edx
   210bf:	52                   	push   %edx
   210c0:	68 54 65 02 00       	push   $0x26554
   210c5:	68 b7 a8 02 00       	push   $0x2a8b7
   210ca:	e8 1a 24 fe ff       	call   34e9 <log_2>
   210cf:	83 c4 10             	add    $0x10,%esp
	return &inst[index];
   210d2:	bb a4 44 40 00       	mov    $0x4044a4,%ebx
}
   210d7:	89 d8                	mov    %ebx,%eax
   210d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   210dc:	c9                   	leave  
   210dd:	c3                   	ret    

000210de <sensor_value_write_cb>:
{
   210de:	55                   	push   %ebp
	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
   210df:	31 c0                	xor    %eax,%eax
{
   210e1:	89 e5                	mov    %esp,%ebp
   210e3:	57                   	push   %edi
   210e4:	56                   	push   %esi
	bool update_max = false;
   210e5:	31 ff                	xor    %edi,%edi
{
   210e7:	53                   	push   %ebx
   210e8:	8b 75 08             	mov    0x8(%ebp),%esi
	bool update_min = false;
   210eb:	31 db                	xor    %ebx,%ebx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   210ed:	8b 0d a8 44 40 00    	mov    0x4044a8,%ecx
   210f3:	8b 15 b0 44 40 00    	mov    0x4044b0,%edx
	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
   210f9:	85 c0                	test   %eax,%eax
   210fb:	0f 85 b8 00 00 00    	jne    211b9 <sensor_value_write_cb+0xdb>
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   21101:	85 c9                	test   %ecx,%ecx
   21103:	0f 84 b0 00 00 00    	je     211b9 <sensor_value_write_cb+0xdb>
   21109:	66 39 f2             	cmp    %si,%dx
   2110c:	0f 85 a7 00 00 00    	jne    211b9 <sensor_value_write_cb+0xdb>
			if (sensor_value[i].val1 < min_measured_value[i].val1) {
   21112:	a1 dc 44 40 00       	mov    0x4044dc,%eax
   21117:	3b 05 cc 44 40 00    	cmp    0x4044cc,%eax
   2111d:	7c 10                	jl     2112f <sensor_value_write_cb+0x51>
			} else if (sensor_value[i].val1 ==
   2111f:	75 10                	jne    21131 <sensor_value_write_cb+0x53>
					min_measured_value[i].val1 &&
   21121:	8b 15 d0 44 40 00    	mov    0x4044d0,%edx
   21127:	39 15 e0 44 40 00    	cmp    %edx,0x4044e0
   2112d:	7d 02                	jge    21131 <sensor_value_write_cb+0x53>
				update_min = true;
   2112f:	b3 01                	mov    $0x1,%bl
			if (sensor_value[i].val1 > max_measured_value[i].val1) {
   21131:	3b 05 c4 44 40 00    	cmp    0x4044c4,%eax
   21137:	7f 16                	jg     2114f <sensor_value_write_cb+0x71>
			} else if (sensor_value[i].val1 ==
   21139:	75 0e                	jne    21149 <sensor_value_write_cb+0x6b>
					max_measured_value[i].val1 &&
   2113b:	8b 0d c8 44 40 00    	mov    0x4044c8,%ecx
   21141:	39 0d e0 44 40 00    	cmp    %ecx,0x4044e0
   21147:	7f 06                	jg     2114f <sensor_value_write_cb+0x71>
			if (update_min) {
   21149:	84 db                	test   %bl,%bl
   2114b:	74 2d                	je     2117a <sensor_value_write_cb+0x9c>
   2114d:	eb 06                	jmp    21155 <sensor_value_write_cb+0x77>
   2114f:	84 db                	test   %bl,%bl
   21151:	74 2d                	je     21180 <sensor_value_write_cb+0xa2>
   21153:	89 df                	mov    %ebx,%edi
	min_measured_value[index].val1 = sensor_value[index].val1;
   21155:	a3 cc 44 40 00       	mov    %eax,0x4044cc
	min_measured_value[index].val2 = sensor_value[index].val2;
   2115a:	a1 e0 44 40 00       	mov    0x4044e0,%eax
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   2115f:	68 e1 15 00 00       	push   $0x15e1
	min_measured_value[index].val2 = sensor_value[index].val2;
   21164:	a3 d0 44 40 00       	mov    %eax,0x4044d0
				update_min_measured(obj_inst_id, i);
   21169:	0f b7 c6             	movzwl %si,%eax
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   2116c:	50                   	push   %eax
   2116d:	68 e7 0c 00 00       	push   $0xce7
   21172:	e8 c9 62 ff ff       	call   17440 <lwm2m_notify_observer>
   21177:	83 c4 0c             	add    $0xc,%esp
			if (update_max) {
   2117a:	89 f8                	mov    %edi,%eax
   2117c:	84 c0                	test   %al,%al
   2117e:	74 2f                	je     211af <sensor_value_write_cb+0xd1>
	max_measured_value[index].val1 = sensor_value[index].val1;
   21180:	a1 dc 44 40 00       	mov    0x4044dc,%eax
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21185:	68 e2 15 00 00       	push   $0x15e2
	max_measured_value[index].val1 = sensor_value[index].val1;
   2118a:	a3 c4 44 40 00       	mov    %eax,0x4044c4
	max_measured_value[index].val2 = sensor_value[index].val2;
   2118f:	a1 e0 44 40 00       	mov    0x4044e0,%eax
   21194:	a3 c8 44 40 00       	mov    %eax,0x4044c8
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21199:	bf 01 00 00 00       	mov    $0x1,%edi
				update_max_measured(obj_inst_id, i);
   2119e:	0f b7 c6             	movzwl %si,%eax
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   211a1:	50                   	push   %eax
   211a2:	68 e7 0c 00 00       	push   $0xce7
   211a7:	e8 94 62 ff ff       	call   17440 <lwm2m_notify_observer>
   211ac:	83 c4 0c             	add    $0xc,%esp
   211af:	b8 01 00 00 00       	mov    $0x1,%eax
   211b4:	e9 34 ff ff ff       	jmp    210ed <sensor_value_write_cb+0xf>
}
   211b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
   211bc:	31 c0                	xor    %eax,%eax
   211be:	5b                   	pop    %ebx
   211bf:	5e                   	pop    %esi
   211c0:	5f                   	pop    %edi
   211c1:	5d                   	pop    %ebp
   211c2:	c3                   	ret    

000211c3 <reset_min_max_measured_values_cb>:
{
   211c3:	55                   	push   %ebp
	LOG_DBG("RESET MIN/MAX %d", obj_inst_id);
   211c4:	f6 05 90 a8 40 00 04 	testb  $0x4,0x40a890
{
   211cb:	89 e5                	mov    %esp,%ebp
   211cd:	53                   	push   %ebx
   211ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	LOG_DBG("RESET MIN/MAX %d", obj_inst_id);
   211d1:	74 2a                	je     211fd <reset_min_max_measured_values_cb+0x3a>
   211d3:	b8 a4 51 02 00       	mov    $0x251a4,%eax
   211d8:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   211dd:	c1 e8 03             	shr    $0x3,%eax
   211e0:	c1 e0 06             	shl    $0x6,%eax
   211e3:	83 c8 04             	or     $0x4,%eax
   211e6:	50                   	push   %eax
   211e7:	0f b7 c3             	movzwl %bx,%eax
   211ea:	50                   	push   %eax
   211eb:	68 c0 5b 02 00       	push   $0x25bc0
   211f0:	68 e7 a8 02 00       	push   $0x2a8e7
   211f5:	e8 ef 22 fe ff       	call   34e9 <log_2>
   211fa:	83 c4 10             	add    $0x10,%esp
	return -ENOENT;
   211fd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
   21202:	83 3d a8 44 40 00 00 	cmpl   $0x0,0x4044a8
   21209:	74 5c                	je     21267 <reset_min_max_measured_values_cb+0xa4>
   2120b:	66 39 1d b0 44 40 00 	cmp    %bx,0x4044b0
   21212:	75 53                	jne    21267 <reset_min_max_measured_values_cb+0xa4>
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21214:	68 e1 15 00 00       	push   $0x15e1
	min_measured_value[index].val1 = sensor_value[index].val1;
   21219:	a1 dc 44 40 00       	mov    0x4044dc,%eax
   2121e:	0f b7 db             	movzwl %bx,%ebx
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21221:	53                   	push   %ebx
	min_measured_value[index].val1 = sensor_value[index].val1;
   21222:	a3 cc 44 40 00       	mov    %eax,0x4044cc
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21227:	68 e7 0c 00 00       	push   $0xce7
	min_measured_value[index].val2 = sensor_value[index].val2;
   2122c:	a1 e0 44 40 00       	mov    0x4044e0,%eax
   21231:	a3 d0 44 40 00       	mov    %eax,0x4044d0
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21236:	e8 05 62 ff ff       	call   17440 <lwm2m_notify_observer>
   2123b:	83 c4 0c             	add    $0xc,%esp
	max_measured_value[index].val1 = sensor_value[index].val1;
   2123e:	a1 dc 44 40 00       	mov    0x4044dc,%eax
   21243:	a3 c4 44 40 00       	mov    %eax,0x4044c4
	max_measured_value[index].val2 = sensor_value[index].val2;
   21248:	a1 e0 44 40 00       	mov    0x4044e0,%eax
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   2124d:	68 e2 15 00 00       	push   $0x15e2
	max_measured_value[index].val2 = sensor_value[index].val2;
   21252:	a3 c8 44 40 00       	mov    %eax,0x4044c8
	NOTIFY_OBSERVER(IPSO_OBJECT_TEMP_SENSOR_ID, obj_inst_id,
   21257:	53                   	push   %ebx
   21258:	68 e7 0c 00 00       	push   $0xce7
   2125d:	e8 de 61 ff ff       	call   17440 <lwm2m_notify_observer>
   21262:	83 c4 0c             	add    $0xc,%esp
   21265:	31 c0                	xor    %eax,%eax
}
   21267:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   2126a:	c9                   	leave  
   2126b:	c3                   	ret    

0002126c <ipso_light_control_init>:

	return &inst[avail];
}

static int ipso_light_control_init(struct device *dev)
{
   2126c:	55                   	push   %ebp
   2126d:	89 e5                	mov    %esp,%ebp
	/* Set default values */
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   2126f:	6a 10                	push   $0x10
   21271:	6a 00                	push   $0x0
   21273:	68 e4 44 40 00       	push   $0x4044e4
   21278:	e8 23 97 fe ff       	call   a9a0 <memset>
   2127d:	83 c4 0c             	add    $0xc,%esp
	(void)memset(res, 0, sizeof(struct lwm2m_engine_res_inst) *
   21280:	68 e0 00 00 00       	push   $0xe0
   21285:	6a 00                	push   $0x0
   21287:	68 00 3d 40 00       	push   $0x403d00
   2128c:	e8 0f 97 fe ff       	call   a9a0 <memset>
   21291:	83 c4 0c             	add    $0xc,%esp
			MAX_INSTANCE_COUNT * LIGHT_MAX_ID);

	light_control.obj_id = IPSO_OBJECT_LIGHT_CONTROL_ID;
	light_control.fields = fields;
   21294:	c7 05 e4 3d 40 00 a0 	movl   $0x40a5a0,0x403de4
   2129b:	a5 40 00 
	light_control.obj_id = IPSO_OBJECT_LIGHT_CONTROL_ID;
   2129e:	c7 05 f8 3d 40 00 ef 	movl   $0x70cef,0x403df8
   212a5:	0c 07 00 
	light_control.field_count = ARRAY_SIZE(fields);
	light_control.max_instance_count = MAX_INSTANCE_COUNT;
   212a8:	66 c7 05 fe 3d 40 00 	movw   $0x1,0x403dfe
   212af:	01 00 
	light_control.create_cb = light_control_create;
	lwm2m_register_obj(&light_control);
   212b1:	68 e0 3d 40 00       	push   $0x403de0
	light_control.create_cb = light_control_create;
   212b6:	c7 05 e8 3d 40 00 ca 	movl   $0x212ca,0x403de8
   212bd:	12 02 00 
	lwm2m_register_obj(&light_control);
   212c0:	e8 51 62 ff ff       	call   17516 <lwm2m_register_obj>
   212c5:	58                   	pop    %eax

	return 0;
}
   212c6:	31 c0                	xor    %eax,%eax
   212c8:	c9                   	leave  
   212c9:	c3                   	ret    

000212ca <light_control_create>:
{
   212ca:	55                   	push   %ebp
   212cb:	a1 8c a8 40 00       	mov    0x40a88c,%eax
   212d0:	89 e5                	mov    %esp,%ebp
   212d2:	53                   	push   %ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   212d3:	83 3d e8 44 40 00 00 	cmpl   $0x0,0x4044e8
{
   212da:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   212dd:	0f 85 89 02 00 00    	jne    2156c <light_control_create+0x2a2>
	on_off_value[avail] = false;
   212e3:	c6 05 64 45 40 00 00 	movb   $0x0,0x404564
	dimmer_value[avail] = 0U;
   212ea:	c6 05 63 45 40 00 00 	movb   $0x0,0x404563
	on_time_value[avail] = 0;
   212f1:	c7 05 10 45 40 00 00 	movl   $0x0,0x404510
   212f8:	00 00 00 
	on_time_offset[avail] = 0U;
   212fb:	c7 05 0c 45 40 00 00 	movl   $0x0,0x40450c
   21302:	00 00 00 
	cumulative_active_value[avail].val1 = 0;
   21305:	c7 05 04 45 40 00 00 	movl   $0x0,0x404504
   2130c:	00 00 00 
	cumulative_active_value[avail].val2 = 0;
   2130f:	c7 05 08 45 40 00 00 	movl   $0x0,0x404508
   21316:	00 00 00 
	power_factor_value[avail].val1 = 0;
   21319:	c7 05 fc 44 40 00 00 	movl   $0x0,0x4044fc
   21320:	00 00 00 
	power_factor_value[avail].val2 = 0;
   21323:	c7 05 00 45 40 00 00 	movl   $0x0,0x404500
   2132a:	00 00 00 
	colour[avail][0] = '\0';
   2132d:	c6 05 00 3e 40 00 00 	movb   $0x0,0x403e00
	units[avail][0] = '\0';
   21334:	c6 05 f4 44 40 00 00 	movb   $0x0,0x4044f4
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_ON_OFF_ID,
   2133b:	c7 05 10 3d 40 00 00 	movl   $0x0,0x403d10
   21342:	00 00 00 
   21345:	c7 05 14 3d 40 00 64 	movl   $0x404564,0x403d14
   2134c:	45 40 00 
   2134f:	c7 05 18 3d 40 00 01 	movl   $0x16da0001,0x403d18
   21356:	00 da 16 
   21359:	c7 05 00 3d 40 00 00 	movl   $0x0,0x403d00
   21360:	00 00 00 
   21363:	c7 05 04 3d 40 00 00 	movl   $0x0,0x403d04
   2136a:	00 00 00 
   2136d:	c7 05 08 3d 40 00 00 	movl   $0x0,0x403d08
   21374:	00 00 00 
   21377:	c7 05 0c 3d 40 00 00 	movl   $0x0,0x403d0c
   2137e:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_DIMMER_ID,
   21381:	c7 05 30 3d 40 00 00 	movl   $0x0,0x403d30
   21388:	00 00 00 
   2138b:	c7 05 34 3d 40 00 63 	movl   $0x404563,0x403d34
   21392:	45 40 00 
   21395:	c7 05 38 3d 40 00 01 	movl   $0x16db0001,0x403d38
   2139c:	00 db 16 
   2139f:	c7 05 20 3d 40 00 00 	movl   $0x0,0x403d20
   213a6:	00 00 00 
   213a9:	c7 05 24 3d 40 00 00 	movl   $0x0,0x403d24
   213b0:	00 00 00 
   213b3:	c7 05 28 3d 40 00 00 	movl   $0x0,0x403d28
   213ba:	00 00 00 
   213bd:	c7 05 2c 3d 40 00 00 	movl   $0x0,0x403d2c
   213c4:	00 00 00 
	INIT_OBJ_RES(res[avail], i, LIGHT_ON_TIME_ID, 0, &on_time_value[avail],
   213c7:	c7 05 50 3d 40 00 00 	movl   $0x0,0x403d50
   213ce:	00 00 00 
   213d1:	c7 05 54 3d 40 00 10 	movl   $0x404510,0x403d54
   213d8:	45 40 00 
   213db:	c7 05 58 3d 40 00 04 	movl   $0x16dc0004,0x403d58
   213e2:	00 dc 16 
   213e5:	c7 05 40 3d 40 00 5d 	movl   $0x2165d,0x403d40
   213ec:	16 02 00 
   213ef:	c7 05 44 3d 40 00 00 	movl   $0x0,0x403d44
   213f6:	00 00 00 
   213f9:	c7 05 48 3d 40 00 d2 	movl   $0x215d2,0x403d48
   21400:	15 02 00 
   21403:	c7 05 4c 3d 40 00 00 	movl   $0x0,0x403d4c
   2140a:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_CUMULATIVE_ACTIVE_POWER_ID,
   2140d:	c7 05 70 3d 40 00 00 	movl   $0x0,0x403d70
   21414:	00 00 00 
	LOG_DBG("Create IPSO Light Control instance: %d", obj_inst_id);
   21417:	a8 04                	test   $0x4,%al
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_CUMULATIVE_ACTIVE_POWER_ID,
   21419:	c7 05 74 3d 40 00 04 	movl   $0x404504,0x403d74
   21420:	45 40 00 
   21423:	c7 05 78 3d 40 00 08 	movl   $0x16ad0008,0x403d78
   2142a:	00 ad 16 
   2142d:	c7 05 60 3d 40 00 00 	movl   $0x0,0x403d60
   21434:	00 00 00 
   21437:	c7 05 64 3d 40 00 00 	movl   $0x0,0x403d64
   2143e:	00 00 00 
   21441:	c7 05 68 3d 40 00 00 	movl   $0x0,0x403d68
   21448:	00 00 00 
   2144b:	c7 05 6c 3d 40 00 00 	movl   $0x0,0x403d6c
   21452:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_POWER_FACTOR_ID,
   21455:	c7 05 90 3d 40 00 00 	movl   $0x0,0x403d90
   2145c:	00 00 00 
   2145f:	c7 05 94 3d 40 00 fc 	movl   $0x4044fc,0x403d94
   21466:	44 40 00 
   21469:	c7 05 98 3d 40 00 08 	movl   $0x16bc0008,0x403d98
   21470:	00 bc 16 
   21473:	c7 05 80 3d 40 00 00 	movl   $0x0,0x403d80
   2147a:	00 00 00 
   2147d:	c7 05 84 3d 40 00 00 	movl   $0x0,0x403d84
   21484:	00 00 00 
   21487:	c7 05 88 3d 40 00 00 	movl   $0x0,0x403d88
   2148e:	00 00 00 
   21491:	c7 05 8c 3d 40 00 00 	movl   $0x0,0x403d8c
   21498:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_COLOUR_ID,
   2149b:	c7 05 b0 3d 40 00 00 	movl   $0x0,0x403db0
   214a2:	00 00 00 
   214a5:	c7 05 b4 3d 40 00 00 	movl   $0x403e00,0x403db4
   214ac:	3e 40 00 
   214af:	c7 05 b8 3d 40 00 40 	movl   $0x164a0040,0x403db8
   214b6:	00 4a 16 
   214b9:	c7 05 a0 3d 40 00 00 	movl   $0x0,0x403da0
   214c0:	00 00 00 
   214c3:	c7 05 a4 3d 40 00 00 	movl   $0x0,0x403da4
   214ca:	00 00 00 
   214cd:	c7 05 a8 3d 40 00 00 	movl   $0x0,0x403da8
   214d4:	00 00 00 
   214d7:	c7 05 ac 3d 40 00 00 	movl   $0x0,0x403dac
   214de:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, LIGHT_SENSOR_UNITS_ID,
   214e1:	c7 05 d0 3d 40 00 00 	movl   $0x0,0x403dd0
   214e8:	00 00 00 
   214eb:	c7 05 d4 3d 40 00 f4 	movl   $0x4044f4,0x403dd4
   214f2:	44 40 00 
   214f5:	c7 05 d8 3d 40 00 08 	movl   $0x16450008,0x403dd8
   214fc:	00 45 16 
   214ff:	c7 05 c0 3d 40 00 00 	movl   $0x0,0x403dc0
   21506:	00 00 00 
   21509:	c7 05 c4 3d 40 00 00 	movl   $0x0,0x403dc4
   21510:	00 00 00 
   21513:	c7 05 c8 3d 40 00 00 	movl   $0x0,0x403dc8
   2151a:	00 00 00 
   2151d:	c7 05 cc 3d 40 00 00 	movl   $0x0,0x403dcc
   21524:	00 00 00 
	inst[avail].resources = res[avail];
   21527:	c7 05 ec 44 40 00 00 	movl   $0x403d00,0x4044ec
   2152e:	3d 40 00 
	inst[avail].resource_count = i;
   21531:	66 c7 05 f2 44 40 00 	movw   $0x7,0x4044f2
   21538:	07 00 
	LOG_DBG("Create IPSO Light Control instance: %d", obj_inst_id);
   2153a:	0f 84 86 00 00 00    	je     215c6 <light_control_create+0x2fc>
   21540:	b8 9c 51 02 00       	mov    $0x2519c,%eax
   21545:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   2154a:	c1 e8 03             	shr    $0x3,%eax
   2154d:	c1 e0 06             	shl    $0x6,%eax
   21550:	83 c8 04             	or     $0x4,%eax
   21553:	50                   	push   %eax
   21554:	0f b7 d2             	movzwl %dx,%edx
   21557:	52                   	push   %edx
   21558:	68 68 65 02 00       	push   $0x26568
   2155d:	68 11 a9 02 00       	push   $0x2a911
   21562:	e8 82 1f fe ff       	call   34e9 <log_2>
   21567:	83 c4 10             	add    $0x10,%esp
   2156a:	eb 5a                	jmp    215c6 <light_control_create+0x2fc>
			return NULL;
   2156c:	31 db                	xor    %ebx,%ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   2156e:	66 39 15 f0 44 40 00 	cmp    %dx,0x4044f0
   21575:	75 23                	jne    2159a <light_control_create+0x2d0>
			LOG_ERR("Can not create instance - "
   21577:	a8 07                	test   $0x7,%al
   21579:	74 50                	je     215cb <light_control_create+0x301>
   2157b:	b8 9c 51 02 00       	mov    $0x2519c,%eax
   21580:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   21585:	c1 e8 03             	shr    $0x3,%eax
   21588:	c1 e0 06             	shl    $0x6,%eax
   2158b:	83 c8 01             	or     $0x1,%eax
   2158e:	50                   	push   %eax
   2158f:	0f b7 d2             	movzwl %dx,%edx
   21592:	52                   	push   %edx
   21593:	68 fe 9d 02 00       	push   $0x29dfe
   21598:	eb 22                	jmp    215bc <light_control_create+0x2f2>
		LOG_ERR("Can not create instance - no more room: %u",
   2159a:	a8 07                	test   $0x7,%al
   2159c:	74 2d                	je     215cb <light_control_create+0x301>
   2159e:	b9 9c 51 02 00       	mov    $0x2519c,%ecx
   215a3:	81 e9 3c 51 02 00    	sub    $0x2513c,%ecx
   215a9:	c1 e9 03             	shr    $0x3,%ecx
   215ac:	c1 e1 06             	shl    $0x6,%ecx
   215af:	83 c9 01             	or     $0x1,%ecx
   215b2:	51                   	push   %ecx
   215b3:	0f b7 d2             	movzwl %dx,%edx
   215b6:	52                   	push   %edx
   215b7:	68 2d 9e 02 00       	push   $0x29e2d
   215bc:	e8 ee 1e fe ff       	call   34af <log_1>
   215c1:	83 c4 0c             	add    $0xc,%esp
   215c4:	eb 05                	jmp    215cb <light_control_create+0x301>
	return &inst[avail];
   215c6:	bb e4 44 40 00       	mov    $0x4044e4,%ebx
}
   215cb:	89 d8                	mov    %ebx,%eax
   215cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   215d0:	c9                   	leave  
   215d1:	c3                   	ret    

000215d2 <on_time_post_write_cb>:
{
   215d2:	55                   	push   %ebp
   215d3:	89 e5                	mov    %esp,%ebp
   215d5:	53                   	push   %ebx
   215d6:	8b 55 10             	mov    0x10(%ebp),%edx
   215d9:	8b 45 08             	mov    0x8(%ebp),%eax
	if (data_len != 4) {
   215dc:	66 83 fa 04          	cmp    $0x4,%dx
   215e0:	74 35                	je     21617 <on_time_post_write_cb+0x45>
		return -EINVAL;
   215e2:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("unknown size %u", data_len);
   215e7:	f6 05 8c a8 40 00 07 	testb  $0x7,0x40a88c
   215ee:	74 66                	je     21656 <on_time_post_write_cb+0x84>
   215f0:	b8 9c 51 02 00       	mov    $0x2519c,%eax
   215f5:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   215fa:	c1 e8 03             	shr    $0x3,%eax
   215fd:	c1 e0 06             	shl    $0x6,%eax
   21600:	83 c8 01             	or     $0x1,%eax
   21603:	50                   	push   %eax
   21604:	0f b7 d2             	movzwl %dx,%edx
   21607:	52                   	push   %edx
   21608:	68 74 9f 02 00       	push   $0x29f74
   2160d:	e8 9d 1e fe ff       	call   34af <log_1>
   21612:	83 c4 0c             	add    $0xc,%esp
   21615:	eb 3f                	jmp    21656 <on_time_post_write_cb+0x84>
	return -ENOENT;
   21617:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   2161c:	83 3d e8 44 40 00 00 	cmpl   $0x0,0x4044e8
   21623:	74 31                	je     21656 <on_time_post_write_cb+0x84>
   21625:	66 39 05 f0 44 40 00 	cmp    %ax,0x4044f0
   2162c:	75 28                	jne    21656 <on_time_post_write_cb+0x84>
	s32_t counter = *(s32_t *) data;
   2162e:	8b 45 0c             	mov    0xc(%ebp),%eax
   21631:	8b 18                	mov    (%eax),%ebx
		if (counter == 0) {
   21633:	85 db                	test   %ebx,%ebx
   21635:	75 1d                	jne    21654 <on_time_post_write_cb+0x82>
   21637:	e8 d5 32 00 00       	call   24911 <z_impl_k_uptime_get>
				(s32_t)(k_uptime_get() / MSEC_PER_SEC);
   2163c:	6a 00                	push   $0x0
   2163e:	68 e8 03 00 00       	push   $0x3e8
   21643:	52                   	push   %edx
   21644:	50                   	push   %eax
   21645:	e8 86 fa fd ff       	call   10d0 <__divdi3>
   2164a:	83 c4 10             	add    $0x10,%esp
   2164d:	a3 0c 45 40 00       	mov    %eax,0x40450c
   21652:	eb 02                	jmp    21656 <on_time_post_write_cb+0x84>
		return 0;
   21654:	31 db                	xor    %ebx,%ebx
}
   21656:	89 d8                	mov    %ebx,%eax
   21658:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   2165b:	c9                   	leave  
   2165c:	c3                   	ret    

0002165d <on_time_read_cb>:
{
   2165d:	55                   	push   %ebp
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   2165e:	a1 e8 44 40 00       	mov    0x4044e8,%eax
{
   21663:	89 e5                	mov    %esp,%ebp
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   21665:	85 c0                	test   %eax,%eax
{
   21667:	8b 55 08             	mov    0x8(%ebp),%edx
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   2166a:	74 43                	je     216af <on_time_read_cb+0x52>
	return NULL;
   2166c:	31 c0                	xor    %eax,%eax
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   2166e:	66 39 15 f0 44 40 00 	cmp    %dx,0x4044f0
   21675:	75 38                	jne    216af <on_time_read_cb+0x52>
		if (on_off_value[i]) {
   21677:	80 3d 64 45 40 00 00 	cmpb   $0x0,0x404564
   2167e:	74 21                	je     216a1 <on_time_read_cb+0x44>
   21680:	e8 8c 32 00 00       	call   24911 <z_impl_k_uptime_get>
			on_time_value[i] = (k_uptime_get() / MSEC_PER_SEC) -
   21685:	6a 00                	push   $0x0
   21687:	68 e8 03 00 00       	push   $0x3e8
   2168c:	52                   	push   %edx
   2168d:	50                   	push   %eax
   2168e:	e8 3d fa fd ff       	call   10d0 <__divdi3>
   21693:	2b 05 0c 45 40 00    	sub    0x40450c,%eax
   21699:	83 c4 10             	add    $0x10,%esp
   2169c:	a3 10 45 40 00       	mov    %eax,0x404510
		*data_len = sizeof(on_time_value[i]);
   216a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   216a4:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   216aa:	b8 10 45 40 00       	mov    $0x404510,%eax
}
   216af:	c9                   	leave  
   216b0:	c3                   	ret    

000216b1 <get_timer_index>:
static int get_timer_index(u16_t obj_inst_id)
{
	int i, ret = -ENOENT;

	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
		if (!inst[i].obj || inst[i].obj_inst_id != obj_inst_id) {
   216b1:	83 3d 18 45 40 00 00 	cmpl   $0x0,0x404518
   216b8:	74 12                	je     216cc <get_timer_index+0x1b>
			continue;
		}

		ret = i;
   216ba:	66 39 05 20 45 40 00 	cmp    %ax,0x404520
   216c1:	0f 94 c0             	sete   %al
   216c4:	0f b6 c0             	movzbl %al,%eax
   216c7:	8d 44 00 fe          	lea    -0x2(%eax,%eax,1),%eax
   216cb:	c3                   	ret    
	int i, ret = -ENOENT;
   216cc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		break;
	}

	return ret;
}
   216d1:	c3                   	ret    

000216d2 <cumulative_time_post_write_cb>:
}

static int cumulative_time_post_write_cb(u16_t obj_inst_id,
					 u8_t *data, u16_t data_len,
					 bool last_block, size_t total_size)
{
   216d2:	55                   	push   %ebp
   216d3:	89 e5                	mov    %esp,%ebp
	int i;

	i = get_timer_index(obj_inst_id);
   216d5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   216d9:	e8 d3 ff ff ff       	call   216b1 <get_timer_index>
	if (i < 0) {
   216de:	85 c0                	test   %eax,%eax
   216e0:	78 12                	js     216f4 <cumulative_time_post_write_cb+0x22>
		return i;
	}

	timer_data[i].cumulative_time_ms = 0U;
   216e2:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
   216e8:	c7 80 0c 40 40 00 00 	movl   $0x0,0x40400c(%eax)
   216ef:	00 00 00 
	return 0;
   216f2:	31 c0                	xor    %eax,%eax
}
   216f4:	5d                   	pop    %ebp
   216f5:	c3                   	ret    

000216f6 <trigger_counter_post_write_cb>:
}

static int trigger_counter_post_write_cb(u16_t obj_inst_id,
					 u8_t *data, u16_t data_len,
					 bool last_block, size_t total_size)
{
   216f6:	55                   	push   %ebp
   216f7:	89 e5                	mov    %esp,%ebp
	int i;

	i = get_timer_index(obj_inst_id);
   216f9:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   216fd:	e8 af ff ff ff       	call   216b1 <get_timer_index>
	if (i < 0) {
   21702:	85 c0                	test   %eax,%eax
   21704:	78 12                	js     21718 <trigger_counter_post_write_cb+0x22>
		return i;
	}

	timer_data[i].trigger_counter = 0U;
   21706:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
   2170c:	c7 80 08 40 40 00 00 	movl   $0x0,0x404008(%eax)
   21713:	00 00 00 
	return 0;
   21716:	31 c0                	xor    %eax,%eax
}
   21718:	5d                   	pop    %ebp
   21719:	c3                   	ret    

0002171a <ipso_timer_init>:

	return &inst[avail];
}

static int ipso_timer_init(struct device *dev)
{
   2171a:	55                   	push   %ebp
   2171b:	89 e5                	mov    %esp,%ebp
	/* Set default values */
	(void)memset(inst, 0, sizeof(*inst) * MAX_INSTANCE_COUNT);
   2171d:	6a 10                	push   $0x10
   2171f:	6a 00                	push   $0x0
   21721:	68 14 45 40 00       	push   $0x404514
   21726:	e8 75 92 fe ff       	call   a9a0 <memset>
   2172b:	83 c4 0c             	add    $0xc,%esp
	(void)memset(res, 0, sizeof(struct lwm2m_engine_res_inst) *
   2172e:	68 60 01 00 00       	push   $0x160
   21733:	6a 00                	push   $0x0
   21735:	68 40 3e 40 00       	push   $0x403e40
   2173a:	e8 61 92 fe ff       	call   a9a0 <memset>
   2173f:	83 c4 0c             	add    $0xc,%esp
			MAX_INSTANCE_COUNT * TIMER_MAX_ID);

	timer.obj_id = IPSO_OBJECT_TIMER_ID;
	timer.fields = fields;
   21742:	c7 05 a4 3f 40 00 e0 	movl   $0x40a5e0,0x403fa4
   21749:	a5 40 00 
	timer.obj_id = IPSO_OBJECT_TIMER_ID;
   2174c:	c7 05 b8 3f 40 00 0c 	movl   $0xb0d0c,0x403fb8
   21753:	0d 0b 00 
	timer.field_count = ARRAY_SIZE(fields);
	timer.max_instance_count = MAX_INSTANCE_COUNT;
   21756:	66 c7 05 be 3f 40 00 	movw   $0x1,0x403fbe
   2175d:	01 00 
	timer.create_cb = timer_create;
	lwm2m_register_obj(&timer);
   2175f:	68 a0 3f 40 00       	push   $0x403fa0
	timer.create_cb = timer_create;
   21764:	c7 05 a8 3f 40 00 78 	movl   $0x21778,0x403fa8
   2176b:	17 02 00 
	lwm2m_register_obj(&timer);
   2176e:	e8 a3 5d ff ff       	call   17516 <lwm2m_register_obj>
   21773:	58                   	pop    %eax

	return 0;
}
   21774:	31 c0                	xor    %eax,%eax
   21776:	c9                   	leave  
   21777:	c3                   	ret    

00021778 <timer_create>:
{
   21778:	55                   	push   %ebp
   21779:	89 e5                	mov    %esp,%ebp
   2177b:	56                   	push   %esi
   2177c:	53                   	push   %ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   2177d:	83 3d 18 45 40 00 00 	cmpl   $0x0,0x404518
{
   21784:	8b 5d 08             	mov    0x8(%ebp),%ebx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   21787:	0f 85 e4 03 00 00    	jne    21b71 <timer_create+0x3f9>
	k_delayed_work_init(&timer_data[avail].timer_work, timer_work_cb);
   2178d:	68 49 1d 02 00       	push   $0x21d49
   21792:	68 10 40 40 00       	push   $0x404010
   21797:	e8 09 2d 00 00       	call   244a5 <k_delayed_work_init>
   2179c:	58                   	pop    %eax
	timer_data[avail].trigger_offset = 0U;
   2179d:	c7 05 00 40 40 00 00 	movl   $0x0,0x404000
   217a4:	00 00 00 
	k_delayed_work_init(&timer_data[avail].timer_work, timer_work_cb);
   217a7:	5a                   	pop    %edx
	timer_data[avail].trigger_offset = 0U;
   217a8:	c7 05 04 40 40 00 00 	movl   $0x0,0x404004
   217af:	00 00 00 
	timer_data[avail].delay_duration.val1 = 5; /* 5 seconds */
   217b2:	c7 05 c0 3f 40 00 05 	movl   $0x5,0x403fc0
   217b9:	00 00 00 
   217bc:	c7 05 c4 3f 40 00 00 	movl   $0x0,0x403fc4
   217c3:	00 00 00 
	timer_data[avail].delay_duration.val2 = 0;
   217c6:	c7 05 c8 3f 40 00 00 	movl   $0x0,0x403fc8
   217cd:	00 00 00 
   217d0:	c7 05 cc 3f 40 00 00 	movl   $0x0,0x403fcc
   217d7:	00 00 00 
	timer_data[avail].remaining_time.val1 = 0;
   217da:	c7 05 d0 3f 40 00 00 	movl   $0x0,0x403fd0
   217e1:	00 00 00 
   217e4:	c7 05 d4 3f 40 00 00 	movl   $0x0,0x403fd4
   217eb:	00 00 00 
	timer_data[avail].remaining_time.val2 = 0;
   217ee:	c7 05 d8 3f 40 00 00 	movl   $0x0,0x403fd8
   217f5:	00 00 00 
   217f8:	c7 05 dc 3f 40 00 00 	movl   $0x0,0x403fdc
   217ff:	00 00 00 
	timer_data[avail].min_off_time.val1 = 0;
   21802:	c7 05 e0 3f 40 00 00 	movl   $0x0,0x403fe0
   21809:	00 00 00 
   2180c:	c7 05 e4 3f 40 00 00 	movl   $0x0,0x403fe4
   21813:	00 00 00 
	timer_data[avail].min_off_time.val2 = 0;
   21816:	c7 05 e8 3f 40 00 00 	movl   $0x0,0x403fe8
   2181d:	00 00 00 
   21820:	c7 05 ec 3f 40 00 00 	movl   $0x0,0x403fec
   21827:	00 00 00 
	timer_data[avail].cumulative_time.val1 = 0;
   2182a:	c7 05 f0 3f 40 00 00 	movl   $0x0,0x403ff0
   21831:	00 00 00 
   21834:	c7 05 f4 3f 40 00 00 	movl   $0x0,0x403ff4
   2183b:	00 00 00 
	timer_data[avail].cumulative_time.val2 = 0;
   2183e:	c7 05 f8 3f 40 00 00 	movl   $0x0,0x403ff8
   21845:	00 00 00 
   21848:	c7 05 fc 3f 40 00 00 	movl   $0x0,0x403ffc
   2184f:	00 00 00 
	timer_data[avail].timer_mode = TIMER_MODE_ONE_SHOT;
   21852:	66 c7 05 72 40 40 00 	movw   $0x101,0x404072
   21859:	01 01 
	timer_data[avail].active = false;
   2185b:	c6 05 74 40 40 00 00 	movb   $0x0,0x404074
	timer_data[avail].obj_inst_id = obj_inst_id;
   21862:	66 89 1d 70 40 40 00 	mov    %bx,0x404070
	INIT_OBJ_RES_DATA(res[avail], i, TIMER_DELAY_DURATION_ID,
   21869:	c7 05 50 3e 40 00 00 	movl   $0x0,0x403e50
   21870:	00 00 00 
   21873:	c7 05 54 3e 40 00 c0 	movl   $0x403fc0,0x403e54
   2187a:	3f 40 00 
   2187d:	c7 05 58 3e 40 00 10 	movl   $0x15910010,0x403e58
   21884:	00 91 15 
   21887:	c7 05 40 3e 40 00 00 	movl   $0x0,0x403e40
   2188e:	00 00 00 
   21891:	c7 05 44 3e 40 00 00 	movl   $0x0,0x403e44
   21898:	00 00 00 
   2189b:	c7 05 48 3e 40 00 00 	movl   $0x0,0x403e48
   218a2:	00 00 00 
   218a5:	c7 05 4c 3e 40 00 00 	movl   $0x0,0x403e4c
   218ac:	00 00 00 
	INIT_OBJ_RES(res[avail], i, TIMER_REMAINING_TIME_ID, 0,
   218af:	c7 05 70 3e 40 00 00 	movl   $0x0,0x403e70
   218b6:	00 00 00 
   218b9:	c7 05 74 3e 40 00 d0 	movl   $0x403fd0,0x403e74
   218c0:	3f 40 00 
   218c3:	c7 05 78 3e 40 00 10 	movl   $0x15a20010,0x403e78
   218ca:	00 a2 15 
   218cd:	c7 05 60 3e 40 00 de 	movl   $0x21bde,0x403e60
   218d4:	1b 02 00 
   218d7:	c7 05 64 3e 40 00 00 	movl   $0x0,0x403e64
   218de:	00 00 00 
   218e1:	c7 05 68 3e 40 00 00 	movl   $0x0,0x403e68
   218e8:	00 00 00 
   218eb:	c7 05 6c 3e 40 00 00 	movl   $0x0,0x403e6c
   218f2:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, TIMER_MINIMUM_OFF_TIME_ID,
   218f5:	c7 05 90 3e 40 00 00 	movl   $0x0,0x403e90
   218fc:	00 00 00 
   218ff:	c7 05 94 3e 40 00 e0 	movl   $0x403fe0,0x403e94
   21906:	3f 40 00 
   21909:	c7 05 98 3e 40 00 10 	movl   $0x15950010,0x403e98
   21910:	00 95 15 
   21913:	c7 05 80 3e 40 00 00 	movl   $0x0,0x403e80
   2191a:	00 00 00 
   2191d:	c7 05 84 3e 40 00 00 	movl   $0x0,0x403e84
   21924:	00 00 00 
   21927:	c7 05 88 3e 40 00 00 	movl   $0x0,0x403e88
   2192e:	00 00 00 
   21931:	c7 05 8c 3e 40 00 00 	movl   $0x0,0x403e8c
   21938:	00 00 00 
	INIT_OBJ_RES_EXECUTE(res[avail], i, TIMER_TRIGGER_ID,
   2193b:	c7 05 b0 3e 40 00 00 	movl   $0x0,0x403eb0
   21942:	00 00 00 
   21945:	c7 05 b4 3e 40 00 00 	movl   $0x0,0x403eb4
   2194c:	00 00 00 
   2194f:	c7 05 b8 3e 40 00 00 	movl   $0x15930000,0x403eb8
   21956:	00 93 15 
   21959:	c7 05 a0 3e 40 00 00 	movl   $0x0,0x403ea0
   21960:	00 00 00 
   21963:	c7 05 a4 3e 40 00 00 	movl   $0x0,0x403ea4
   2196a:	00 00 00 
   2196d:	c7 05 a8 3e 40 00 00 	movl   $0x0,0x403ea8
   21974:	00 00 00 
   21977:	c7 05 ac 3e 40 00 e0 	movl   $0x21de0,0x403eac
   2197e:	1d 02 00 
	INIT_OBJ_RES(res[avail], i, TIMER_ON_OFF_ID, 0,
   21981:	c7 05 d0 3e 40 00 00 	movl   $0x0,0x403ed0
   21988:	00 00 00 
   2198b:	c7 05 d4 3e 40 00 73 	movl   $0x404073,0x403ed4
   21992:	40 40 00 
   21995:	c7 05 d8 3e 40 00 01 	movl   $0x16da0001,0x403ed8
   2199c:	00 da 16 
   2199f:	c7 05 c0 3e 40 00 00 	movl   $0x0,0x403ec0
   219a6:	00 00 00 
   219a9:	c7 05 c4 3e 40 00 00 	movl   $0x0,0x403ec4
   219b0:	00 00 00 
   219b3:	c7 05 c8 3e 40 00 07 	movl   $0x21d07,0x403ec8
   219ba:	1d 02 00 
   219bd:	c7 05 cc 3e 40 00 00 	movl   $0x0,0x403ecc
   219c4:	00 00 00 
	INIT_OBJ_RES(res[avail], i, TIMER_CUMULATIVE_TIME_ID, 0,
   219c7:	c7 05 f0 3e 40 00 00 	movl   $0x0,0x403ef0
   219ce:	00 00 00 
   219d1:	c7 05 f4 3e 40 00 f0 	movl   $0x403ff0,0x403ef4
   219d8:	3f 40 00 
   219db:	c7 05 f8 3e 40 00 10 	movl   $0x15a80010,0x403ef8
   219e2:	00 a8 15 
   219e5:	c7 05 e0 3e 40 00 5a 	movl   $0x21d5a,0x403ee0
   219ec:	1d 02 00 
   219ef:	c7 05 e4 3e 40 00 00 	movl   $0x0,0x403ee4
   219f6:	00 00 00 
   219f9:	c7 05 e8 3e 40 00 d2 	movl   $0x216d2,0x403ee8
   21a00:	16 02 00 
   21a03:	c7 05 ec 3e 40 00 00 	movl   $0x0,0x403eec
   21a0a:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, TIMER_DIGITAL_STATE_ID,
   21a0d:	c7 05 10 3f 40 00 00 	movl   $0x0,0x403f10
   21a14:	00 00 00 
   21a17:	c7 05 14 3f 40 00 74 	movl   $0x404074,0x403f14
   21a1e:	40 40 00 
   21a21:	c7 05 18 3f 40 00 01 	movl   $0x15a70001,0x403f18
   21a28:	00 a7 15 
   21a2b:	c7 05 00 3f 40 00 00 	movl   $0x0,0x403f00
   21a32:	00 00 00 
   21a35:	c7 05 04 3f 40 00 00 	movl   $0x0,0x403f04
   21a3c:	00 00 00 
   21a3f:	c7 05 08 3f 40 00 00 	movl   $0x0,0x403f08
   21a46:	00 00 00 
   21a49:	c7 05 0c 3f 40 00 00 	movl   $0x0,0x403f0c
   21a50:	00 00 00 
	INIT_OBJ_RES(res[avail], i, TIMER_COUNTER_ID, 0,
   21a53:	c7 05 30 3f 40 00 00 	movl   $0x0,0x403f30
   21a5a:	00 00 00 
   21a5d:	c7 05 34 3f 40 00 08 	movl   $0x404008,0x403f34
   21a64:	40 40 00 
   21a67:	c7 05 38 3f 40 00 04 	movl   $0x159e0004,0x403f38
   21a6e:	00 9e 15 
   21a71:	c7 05 20 3f 40 00 00 	movl   $0x0,0x403f20
   21a78:	00 00 00 
   21a7b:	c7 05 24 3f 40 00 00 	movl   $0x0,0x403f24
   21a82:	00 00 00 
   21a85:	c7 05 28 3f 40 00 f6 	movl   $0x216f6,0x403f28
   21a8c:	16 02 00 
   21a8f:	c7 05 2c 3f 40 00 00 	movl   $0x0,0x403f2c
   21a96:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, TIMER_MODE_ID,
   21a99:	c7 05 50 3f 40 00 00 	movl   $0x0,0x403f50
   21aa0:	00 00 00 
   21aa3:	c7 05 54 3f 40 00 72 	movl   $0x404072,0x403f54
   21aaa:	40 40 00 
   21aad:	c7 05 58 3f 40 00 01 	movl   $0x15960001,0x403f58
   21ab4:	00 96 15 
   21ab7:	c7 05 40 3f 40 00 00 	movl   $0x0,0x403f40
   21abe:	00 00 00 
   21ac1:	c7 05 44 3f 40 00 00 	movl   $0x0,0x403f44
   21ac8:	00 00 00 
   21acb:	c7 05 48 3f 40 00 00 	movl   $0x0,0x403f48
   21ad2:	00 00 00 
   21ad5:	c7 05 4c 3f 40 00 00 	movl   $0x0,0x403f4c
   21adc:	00 00 00 
	INIT_OBJ_RES_DATA(res[avail], i, TIMER_APPLICATION_TYPE_ID,
   21adf:	c7 05 70 3f 40 00 00 	movl   $0x0,0x403f70
   21ae6:	00 00 00 
   21ae9:	c7 05 74 3f 40 00 30 	movl   $0x404030,0x403f74
   21af0:	40 40 00 
   21af3:	c7 05 78 3f 40 00 40 	movl   $0x16760040,0x403f78
   21afa:	00 76 16 
   21afd:	c7 05 60 3f 40 00 00 	movl   $0x0,0x403f60
   21b04:	00 00 00 
   21b07:	c7 05 64 3f 40 00 00 	movl   $0x0,0x403f64
   21b0e:	00 00 00 
   21b11:	c7 05 68 3f 40 00 00 	movl   $0x0,0x403f68
   21b18:	00 00 00 
   21b1b:	c7 05 6c 3f 40 00 00 	movl   $0x0,0x403f6c
   21b22:	00 00 00 
	inst[avail].resources = res[avail];
   21b25:	c7 05 1c 45 40 00 40 	movl   $0x403e40,0x40451c
   21b2c:	3e 40 00 
	inst[avail].resource_count = i;
   21b2f:	66 c7 05 22 45 40 00 	movw   $0xa,0x404522
   21b36:	0a 00 
	LOG_DBG("Create IPSO Timer instance: %d", obj_inst_id);
   21b38:	f6 05 94 a8 40 00 04 	testb  $0x4,0x40a894
   21b3f:	0f 84 8b 00 00 00    	je     21bd0 <timer_create+0x458>
   21b45:	b8 ac 51 02 00       	mov    $0x251ac,%eax
   21b4a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   21b4f:	c1 e8 03             	shr    $0x3,%eax
   21b52:	c1 e0 06             	shl    $0x6,%eax
   21b55:	83 c8 04             	or     $0x4,%eax
   21b58:	50                   	push   %eax
   21b59:	0f b7 db             	movzwl %bx,%ebx
   21b5c:	53                   	push   %ebx
   21b5d:	68 80 65 02 00       	push   $0x26580
   21b62:	68 53 a9 02 00       	push   $0x2a953
   21b67:	e8 7d 19 fe ff       	call   34e9 <log_2>
   21b6c:	83 c4 10             	add    $0x10,%esp
   21b6f:	eb 5f                	jmp    21bd0 <timer_create+0x458>
			return NULL;
   21b71:	31 f6                	xor    %esi,%esi
   21b73:	a1 94 a8 40 00       	mov    0x40a894,%eax
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
   21b78:	66 39 1d 20 45 40 00 	cmp    %bx,0x404520
   21b7f:	75 23                	jne    21ba4 <timer_create+0x42c>
			LOG_ERR("Can not create instance - "
   21b81:	a8 07                	test   $0x7,%al
   21b83:	74 50                	je     21bd5 <timer_create+0x45d>
   21b85:	b8 ac 51 02 00       	mov    $0x251ac,%eax
   21b8a:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   21b8f:	c1 e8 03             	shr    $0x3,%eax
   21b92:	c1 e0 06             	shl    $0x6,%eax
   21b95:	83 c8 01             	or     $0x1,%eax
   21b98:	50                   	push   %eax
   21b99:	0f b7 db             	movzwl %bx,%ebx
   21b9c:	53                   	push   %ebx
   21b9d:	68 fe 9d 02 00       	push   $0x29dfe
   21ba2:	eb 22                	jmp    21bc6 <timer_create+0x44e>
		LOG_ERR("Can not create instance - no more room: %u",
   21ba4:	a8 07                	test   $0x7,%al
   21ba6:	74 2d                	je     21bd5 <timer_create+0x45d>
   21ba8:	ba ac 51 02 00       	mov    $0x251ac,%edx
   21bad:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   21bb3:	c1 ea 03             	shr    $0x3,%edx
   21bb6:	c1 e2 06             	shl    $0x6,%edx
   21bb9:	83 ca 01             	or     $0x1,%edx
   21bbc:	52                   	push   %edx
   21bbd:	0f b7 db             	movzwl %bx,%ebx
   21bc0:	53                   	push   %ebx
   21bc1:	68 2d 9e 02 00       	push   $0x29e2d
   21bc6:	e8 e4 18 fe ff       	call   34af <log_1>
   21bcb:	83 c4 0c             	add    $0xc,%esp
   21bce:	eb 05                	jmp    21bd5 <timer_create+0x45d>
	return &inst[avail];
   21bd0:	be 14 45 40 00       	mov    $0x404514,%esi
}
   21bd5:	8d 65 f8             	lea    -0x8(%ebp),%esp
   21bd8:	89 f0                	mov    %esi,%eax
   21bda:	5b                   	pop    %ebx
   21bdb:	5e                   	pop    %esi
   21bdc:	5d                   	pop    %ebp
   21bdd:	c3                   	ret    

00021bde <remaining_time_read_cb>:
{
   21bde:	55                   	push   %ebp
   21bdf:	89 e5                	mov    %esp,%ebp
   21be1:	57                   	push   %edi
   21be2:	56                   	push   %esi
	i = get_timer_index(obj_inst_id);
   21be3:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
{
   21be7:	53                   	push   %ebx
	i = get_timer_index(obj_inst_id);
   21be8:	e8 c4 fa ff ff       	call   216b1 <get_timer_index>
   21bed:	89 c7                	mov    %eax,%edi
	if (i < 0) {
   21bef:	31 c0                	xor    %eax,%eax
   21bf1:	85 ff                	test   %edi,%edi
   21bf3:	0f 88 95 00 00 00    	js     21c8e <remaining_time_read_cb+0xb0>
	if (timer_data[i].active) {
   21bf9:	69 c7 b8 00 00 00    	imul   $0xb8,%edi,%eax
   21bff:	8d b0 c0 3f 40 00    	lea    0x403fc0(%eax),%esi
   21c05:	80 be b4 00 00 00 00 	cmpb   $0x0,0xb4(%esi)
   21c0c:	74 4f                	je     21c5d <remaining_time_read_cb+0x7f>
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21c0e:	6a 00                	push   $0x0
   21c10:	68 40 42 0f 00       	push   $0xf4240
   21c15:	ff 76 0c             	pushl  0xc(%esi)
   21c18:	ff 76 08             	pushl  0x8(%esi)
	*ms = f->val1 * MSEC_PER_SEC;
   21c1b:	69 98 c0 3f 40 00 e8 	imul   $0x3e8,0x403fc0(%eax),%ebx
   21c22:	03 00 00 
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21c25:	e8 a6 f4 fd ff       	call   10d0 <__divdi3>
   21c2a:	83 c4 10             	add    $0x10,%esp
   21c2d:	01 c3                	add    %eax,%ebx
   21c2f:	e8 dd 2c 00 00       	call   24911 <z_impl_k_uptime_get>
		temp -= (k_uptime_get() - timer_data[i].trigger_offset);
   21c34:	2b 46 40             	sub    0x40(%esi),%eax
	f->val1 = ms / MSEC_PER_SEC;
   21c37:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
		temp -= (k_uptime_get() - timer_data[i].trigger_offset);
   21c3c:	29 c3                	sub    %eax,%ebx
	f->val1 = ms / MSEC_PER_SEC;
   21c3e:	31 d2                	xor    %edx,%edx
		temp -= (k_uptime_get() - timer_data[i].trigger_offset);
   21c40:	89 d8                	mov    %ebx,%eax
	f->val1 = ms / MSEC_PER_SEC;
   21c42:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
   21c49:	f7 f1                	div    %ecx
   21c4b:	89 46 10             	mov    %eax,0x10(%esi)
	f->val2 = (ms % MSEC_PER_SEC) * (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21c4e:	b8 40 42 0f 00       	mov    $0xf4240,%eax
   21c53:	f7 e2                	mul    %edx
   21c55:	89 46 18             	mov    %eax,0x18(%esi)
   21c58:	89 56 1c             	mov    %edx,0x1c(%esi)
	return 0;
   21c5b:	eb 1c                	jmp    21c79 <remaining_time_read_cb+0x9b>
		timer_data[i].remaining_time.val1 = 0;
   21c5d:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
   21c64:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
		timer_data[i].remaining_time.val2 = 0;
   21c6b:	c7 46 18 00 00 00 00 	movl   $0x0,0x18(%esi)
   21c72:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
	return &timer_data[i].remaining_time;
   21c79:	69 ff b8 00 00 00    	imul   $0xb8,%edi,%edi
	*data_len = sizeof(timer_data[i].remaining_time);
   21c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   21c82:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
	return &timer_data[i].remaining_time;
   21c88:	8d 87 d0 3f 40 00    	lea    0x403fd0(%edi),%eax
}
   21c8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   21c91:	5b                   	pop    %ebx
   21c92:	5e                   	pop    %esi
   21c93:	5f                   	pop    %edi
   21c94:	5d                   	pop    %ebp
   21c95:	c3                   	ret    

00021c96 <stop_timer>:
{
   21c96:	55                   	push   %ebp
   21c97:	89 e5                	mov    %esp,%ebp
   21c99:	57                   	push   %edi
   21c9a:	56                   	push   %esi
		return -EINVAL;
   21c9b:	bf ea ff ff ff       	mov    $0xffffffea,%edi
{
   21ca0:	53                   	push   %ebx
   21ca1:	83 ec 14             	sub    $0x14,%esp
	if (!timer->active) {
   21ca4:	80 b8 b4 00 00 00 00 	cmpb   $0x0,0xb4(%eax)
   21cab:	74 50                	je     21cfd <stop_timer+0x67>
   21cad:	89 c3                	mov    %eax,%ebx
   21caf:	89 d6                	mov    %edx,%esi
   21cb1:	e8 5b 2c 00 00       	call   24911 <z_impl_k_uptime_get>
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21cb6:	8d 7d e0             	lea    -0x20(%ebp),%edi
	timer->cumulative_time_ms += k_uptime_get() - timer->trigger_offset;
   21cb9:	2b 43 40             	sub    0x40(%ebx),%eax
   21cbc:	01 43 4c             	add    %eax,0x4c(%ebx)
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21cbf:	68 a7 15 00 00       	push   $0x15a7
   21cc4:	0f b7 83 b0 00 00 00 	movzwl 0xb0(%ebx),%eax
   21ccb:	50                   	push   %eax
   21ccc:	68 0c 0d 00 00       	push   $0xd0c
   21cd1:	68 76 a9 02 00       	push   $0x2a976
   21cd6:	6a 14                	push   $0x14
   21cd8:	57                   	push   %edi
   21cd9:	e8 ff 0e fe ff       	call   2bdd <snprintk>
   21cde:	83 c4 18             	add    $0x18,%esp
	lwm2m_engine_set_bool(path, false);
   21ce1:	6a 00                	push   $0x0
   21ce3:	57                   	push   %edi
   21ce4:	e8 16 8c ff ff       	call   1a8ff <lwm2m_engine_set_bool>
   21ce9:	5a                   	pop    %edx
	if (cancel) {
   21cea:	89 f0                	mov    %esi,%eax
	return 0;
   21cec:	31 ff                	xor    %edi,%edi
	lwm2m_engine_set_bool(path, false);
   21cee:	59                   	pop    %ecx
	if (cancel) {
   21cef:	84 c0                	test   %al,%al
   21cf1:	74 0a                	je     21cfd <stop_timer+0x67>
		k_delayed_work_cancel(&timer->timer_work);
   21cf3:	83 c3 50             	add    $0x50,%ebx
   21cf6:	53                   	push   %ebx
   21cf7:	e8 ab 28 00 00       	call   245a7 <k_delayed_work_cancel>
   21cfc:	58                   	pop    %eax
}
   21cfd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   21d00:	89 f8                	mov    %edi,%eax
   21d02:	5b                   	pop    %ebx
   21d03:	5e                   	pop    %esi
   21d04:	5f                   	pop    %edi
   21d05:	5d                   	pop    %ebp
   21d06:	c3                   	ret    

00021d07 <enabled_post_write_cb>:
{
   21d07:	55                   	push   %ebp
   21d08:	89 e5                	mov    %esp,%ebp
	i = get_timer_index(obj_inst_id);
   21d0a:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   21d0e:	e8 9e f9 ff ff       	call   216b1 <get_timer_index>
	if (i < 0) {
   21d13:	85 c0                	test   %eax,%eax
   21d15:	78 30                	js     21d47 <enabled_post_write_cb+0x40>
	if (!timer_data[i].enabled && timer_data[i].active) {
   21d17:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
   21d1d:	8d 88 c0 3f 40 00    	lea    0x403fc0(%eax),%ecx
   21d23:	80 b8 73 40 40 00 00 	cmpb   $0x0,0x404073(%eax)
	return 0;
   21d2a:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!timer_data[i].enabled && timer_data[i].active) {
   21d2f:	75 16                	jne    21d47 <enabled_post_write_cb+0x40>
   21d31:	80 b9 b4 00 00 00 00 	cmpb   $0x0,0xb4(%ecx)
   21d38:	74 0d                	je     21d47 <enabled_post_write_cb+0x40>
		return stop_timer(&timer_data[i], true);
   21d3a:	ba 01 00 00 00       	mov    $0x1,%edx
   21d3f:	89 c8                	mov    %ecx,%eax
}
   21d41:	5d                   	pop    %ebp
		return stop_timer(&timer_data[i], true);
   21d42:	e9 4f ff ff ff       	jmp    21c96 <stop_timer>
}
   21d47:	5d                   	pop    %ebp
   21d48:	c3                   	ret    

00021d49 <timer_work_cb>:
{
   21d49:	55                   	push   %ebp
	stop_timer(timer, false);
   21d4a:	31 d2                	xor    %edx,%edx
{
   21d4c:	89 e5                	mov    %esp,%ebp
	struct ipso_timer_data *timer = CONTAINER_OF(work,
   21d4e:	8b 45 08             	mov    0x8(%ebp),%eax
}
   21d51:	5d                   	pop    %ebp
	struct ipso_timer_data *timer = CONTAINER_OF(work,
   21d52:	83 e8 50             	sub    $0x50,%eax
	stop_timer(timer, false);
   21d55:	e9 3c ff ff ff       	jmp    21c96 <stop_timer>

00021d5a <cumulative_time_read_cb>:
{
   21d5a:	55                   	push   %ebp
   21d5b:	89 e5                	mov    %esp,%ebp
   21d5d:	57                   	push   %edi
   21d5e:	56                   	push   %esi
	i = get_timer_index(obj_inst_id);
   21d5f:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
{
   21d63:	53                   	push   %ebx
	i = get_timer_index(obj_inst_id);
   21d64:	e8 48 f9 ff ff       	call   216b1 <get_timer_index>
	if (i < 0) {
   21d69:	31 c9                	xor    %ecx,%ecx
   21d6b:	85 c0                	test   %eax,%eax
   21d6d:	78 6a                	js     21dd9 <cumulative_time_read_cb+0x7f>
	temp = timer_data[i].cumulative_time_ms;
   21d6f:	69 f8 b8 00 00 00    	imul   $0xb8,%eax,%edi
   21d75:	89 c3                	mov    %eax,%ebx
   21d77:	8b b7 0c 40 40 00    	mov    0x40400c(%edi),%esi
   21d7d:	81 c7 c0 3f 40 00    	add    $0x403fc0,%edi
	if (timer_data[i].active) {
   21d83:	80 bf b4 00 00 00 00 	cmpb   $0x0,0xb4(%edi)
   21d8a:	74 0a                	je     21d96 <cumulative_time_read_cb+0x3c>
   21d8c:	e8 80 2b 00 00       	call   24911 <z_impl_k_uptime_get>
		temp += k_uptime_get() - timer_data[i].trigger_offset;
   21d91:	2b 47 40             	sub    0x40(%edi),%eax
   21d94:	01 c6                	add    %eax,%esi
	ms2float(temp, &timer_data[i].cumulative_time);
   21d96:	69 db b8 00 00 00    	imul   $0xb8,%ebx,%ebx
	f->val1 = ms / MSEC_PER_SEC;
   21d9c:	bf e8 03 00 00       	mov    $0x3e8,%edi
   21da1:	89 f0                	mov    %esi,%eax
   21da3:	31 d2                	xor    %edx,%edx
   21da5:	c7 83 f4 3f 40 00 00 	movl   $0x0,0x403ff4(%ebx)
   21dac:	00 00 00 
   21daf:	f7 f7                	div    %edi
   21db1:	89 83 f0 3f 40 00    	mov    %eax,0x403ff0(%ebx)
	f->val2 = (ms % MSEC_PER_SEC) * (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21db7:	b8 40 42 0f 00       	mov    $0xf4240,%eax
   21dbc:	f7 e2                	mul    %edx
   21dbe:	89 83 f8 3f 40 00    	mov    %eax,0x403ff8(%ebx)
	*data_len = sizeof(timer_data[i].cumulative_time);
   21dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
	f->val2 = (ms % MSEC_PER_SEC) * (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21dc7:	89 93 fc 3f 40 00    	mov    %edx,0x403ffc(%ebx)
	ms2float(temp, &timer_data[i].cumulative_time);
   21dcd:	8d 8b f0 3f 40 00    	lea    0x403ff0(%ebx),%ecx
	*data_len = sizeof(timer_data[i].cumulative_time);
   21dd3:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
}
   21dd9:	5b                   	pop    %ebx
   21dda:	89 c8                	mov    %ecx,%eax
   21ddc:	5e                   	pop    %esi
   21ddd:	5f                   	pop    %edi
   21dde:	5d                   	pop    %ebp
   21ddf:	c3                   	ret    

00021de0 <timer_trigger_cb>:
{
   21de0:	55                   	push   %ebp
   21de1:	89 e5                	mov    %esp,%ebp
   21de3:	57                   	push   %edi
   21de4:	56                   	push   %esi
   21de5:	53                   	push   %ebx
   21de6:	83 ec 18             	sub    $0x18,%esp
	i = get_timer_index(obj_inst_id);
   21de9:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
   21ded:	e8 bf f8 ff ff       	call   216b1 <get_timer_index>
	if (i < 0) {
   21df2:	85 c0                	test   %eax,%eax
   21df4:	0f 88 e1 00 00 00    	js     21edb <timer_trigger_cb+0xfb>
	if (timer->timer_mode == TIMER_MODE_OFF || timer->active ||
   21dfa:	69 d8 b8 00 00 00    	imul   $0xb8,%eax,%ebx
   21e00:	8d b3 c0 3f 40 00    	lea    0x403fc0(%ebx),%esi
   21e06:	80 be b2 00 00 00 00 	cmpb   $0x0,0xb2(%esi)
   21e0d:	75 0a                	jne    21e19 <timer_trigger_cb+0x39>
		return -EINVAL;
   21e0f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   21e14:	e9 c2 00 00 00       	jmp    21edb <timer_trigger_cb+0xfb>
	if (timer->timer_mode == TIMER_MODE_OFF || timer->active ||
   21e19:	80 be b4 00 00 00 00 	cmpb   $0x0,0xb4(%esi)
   21e20:	75 ed                	jne    21e0f <timer_trigger_cb+0x2f>
   21e22:	80 be b3 00 00 00 00 	cmpb   $0x0,0xb3(%esi)
   21e29:	74 e4                	je     21e0f <timer_trigger_cb+0x2f>
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21e2b:	6a 00                	push   $0x0
   21e2d:	68 40 42 0f 00       	push   $0xf4240
   21e32:	ff 76 2c             	pushl  0x2c(%esi)
   21e35:	ff 76 28             	pushl  0x28(%esi)
	*ms = f->val1 * MSEC_PER_SEC;
   21e38:	69 7e 20 e8 03 00 00 	imul   $0x3e8,0x20(%esi),%edi
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21e3f:	e8 8c f2 fd ff       	call   10d0 <__divdi3>
   21e44:	83 c4 10             	add    $0x10,%esp
   21e47:	01 f8                	add    %edi,%eax
   21e49:	89 45 dc             	mov    %eax,-0x24(%ebp)
   21e4c:	e8 c0 2a 00 00       	call   24911 <z_impl_k_uptime_get>
   21e51:	89 c1                	mov    %eax,%ecx
	if (k_uptime_get() < timer->trigger_offset + temp) {
   21e53:	8b 45 dc             	mov    -0x24(%ebp),%eax
   21e56:	89 d7                	mov    %edx,%edi
   21e58:	31 d2                	xor    %edx,%edx
   21e5a:	03 46 40             	add    0x40(%esi),%eax
   21e5d:	13 56 44             	adc    0x44(%esi),%edx
   21e60:	39 c1                	cmp    %eax,%ecx
   21e62:	19 d7                	sbb    %edx,%edi
   21e64:	72 a9                	jb     21e0f <timer_trigger_cb+0x2f>
   21e66:	e8 a6 2a 00 00       	call   24911 <z_impl_k_uptime_get>
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21e6b:	68 a7 15 00 00       	push   $0x15a7
	timer->trigger_offset = k_uptime_get();
   21e70:	89 46 40             	mov    %eax,0x40(%esi)
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21e73:	8d 7d e0             	lea    -0x20(%ebp),%edi
   21e76:	0f b7 86 b0 00 00 00 	movzwl 0xb0(%esi),%eax
   21e7d:	50                   	push   %eax
	timer->trigger_offset = k_uptime_get();
   21e7e:	89 56 44             	mov    %edx,0x44(%esi)
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21e81:	68 0c 0d 00 00       	push   $0xd0c
	timer->trigger_counter += 1;
   21e86:	ff 46 48             	incl   0x48(%esi)
	snprintk(path, MAX_RESOURCE_LEN, "%d/%u/%d", IPSO_OBJECT_TIMER_ID,
   21e89:	68 76 a9 02 00       	push   $0x2a976
   21e8e:	6a 14                	push   $0x14
   21e90:	57                   	push   %edi
   21e91:	e8 47 0d fe ff       	call   2bdd <snprintk>
   21e96:	83 c4 18             	add    $0x18,%esp
	lwm2m_engine_set_bool(path, true);
   21e99:	6a 01                	push   $0x1
   21e9b:	57                   	push   %edi
   21e9c:	e8 5e 8a ff ff       	call   1a8ff <lwm2m_engine_set_bool>
   21ea1:	58                   	pop    %eax
   21ea2:	5a                   	pop    %edx
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21ea3:	6a 00                	push   $0x0
   21ea5:	68 40 42 0f 00       	push   $0xf4240
   21eaa:	ff 76 0c             	pushl  0xc(%esi)
   21ead:	ff 76 08             	pushl  0x8(%esi)
	*ms = f->val1 * MSEC_PER_SEC;
   21eb0:	69 bb c0 3f 40 00 e8 	imul   $0x3e8,0x403fc0(%ebx),%edi
   21eb7:	03 00 00 
	*ms += f->val2 / (LWM2M_FLOAT64_DEC_MAX / MSEC_PER_SEC);
   21eba:	e8 11 f2 fd ff       	call   10d0 <__divdi3>
   21ebf:	83 c4 10             	add    $0x10,%esp
   21ec2:	01 c7                	add    %eax,%edi
	k_delayed_work_submit(&timer->timer_work, temp);
   21ec4:	81 c3 10 40 40 00    	add    $0x404010,%ebx
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   21eca:	57                   	push   %edi
   21ecb:	53                   	push   %ebx
   21ecc:	68 60 41 40 00       	push   $0x404160
   21ed1:	e8 ff 25 00 00       	call   244d5 <k_delayed_work_submit_to_queue>
   21ed6:	83 c4 0c             	add    $0xc,%esp
	return 0;
   21ed9:	31 c0                	xor    %eax,%eax
}
   21edb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   21ede:	5b                   	pop    %ebx
   21edf:	5e                   	pop    %esi
   21ee0:	5f                   	pop    %edi
   21ee1:	5d                   	pop    %ebp
   21ee2:	c3                   	ret    

00021ee3 <ipv6_event_handler>:
static struct net_mgmt_event_callback mgmt6_cb;
static struct in6_addr laddr;

static void ipv6_event_handler(struct net_mgmt_event_callback *cb,
			       u32_t mgmt_event, struct net_if *iface)
{
   21ee3:	55                   	push   %ebp
   21ee4:	89 e5                	mov    %esp,%ebp
   21ee6:	56                   	push   %esi
   21ee7:	53                   	push   %ebx
   21ee8:	83 ec 28             	sub    $0x28,%esp
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
   21eeb:	8b 55 10             	mov    0x10(%ebp),%edx
{
   21eee:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
   21ef1:	8b 72 04             	mov    0x4(%edx),%esi
	int i;

	if (!ipv6) {
   21ef4:	85 f6                	test   %esi,%esi
   21ef6:	0f 84 e7 00 00 00    	je     21fe3 <ipv6_event_handler+0x100>
		return;
	}

	if (mgmt_event == NET_EVENT_IPV6_ADDR_ADD) {
   21efc:	3d 01 00 60 f0       	cmp    $0xf0600001,%eax
   21f01:	75 2e                	jne    21f31 <ipv6_event_handler+0x4e>
		/* save the last added IP address for this interface */
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
   21f03:	bb 02 00 00 00       	mov    $0x2,%ebx
			if (ipv6->unicast[i].is_used) {
   21f08:	6b c3 48             	imul   $0x48,%ebx,%eax
   21f0b:	f6 44 06 47 02       	testb  $0x2,0x47(%esi,%eax,1)
   21f10:	74 14                	je     21f26 <ipv6_event_handler+0x43>
				memcpy(&laddr,
   21f12:	6a 10                	push   $0x10
   21f14:	8d 44 06 04          	lea    0x4(%esi,%eax,1),%eax
   21f18:	50                   	push   %eax
   21f19:	68 24 45 40 00       	push   $0x404524
   21f1e:	e8 0e 8a fe ff       	call   a931 <memcpy>
   21f23:	83 c4 0c             	add    $0xc,%esp
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
   21f26:	4b                   	dec    %ebx
   21f27:	83 fb ff             	cmp    $0xffffffff,%ebx
   21f2a:	75 dc                	jne    21f08 <ipv6_event_handler+0x25>
   21f2c:	e9 b2 00 00 00       	jmp    21fe3 <ipv6_event_handler+0x100>
				       sizeof(laddr));
			}
		}
	}

	if (mgmt_event == NET_EVENT_IPV6_DAD_SUCCEED) {
   21f31:	3d 0d 00 60 f0       	cmp    $0xf060000d,%eax
   21f36:	0f 85 87 00 00 00    	jne    21fc3 <ipv6_event_handler+0xe0>
#if CONFIG_NET_CONFIG_LOG_LEVEL >= LOG_LEVEL_INF
		char hr_addr[NET_IPV6_ADDR_LEN];
#endif
		struct net_if_addr *ifaddr;

		ifaddr = net_if_ipv6_addr_lookup(&laddr, &iface);
   21f3c:	8d 45 10             	lea    0x10(%ebp),%eax
   21f3f:	50                   	push   %eax
   21f40:	68 24 45 40 00       	push   $0x404524
   21f45:	e8 f6 c0 fe ff       	call   e040 <net_if_ipv6_addr_lookup>
   21f4a:	5b                   	pop    %ebx
		if (!ifaddr ||
   21f4b:	85 c0                	test   %eax,%eax
		ifaddr = net_if_ipv6_addr_lookup(&laddr, &iface);
   21f4d:	5e                   	pop    %esi
   21f4e:	89 c3                	mov    %eax,%ebx
		if (!ifaddr ||
   21f50:	0f 84 8d 00 00 00    	je     21fe3 <ipv6_event_handler+0x100>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
   21f56:	6a 10                	push   $0x10
		    !(net_ipv6_addr_cmp(&ifaddr->address.in6_addr, &laddr) &&
   21f58:	8d 40 04             	lea    0x4(%eax),%eax
   21f5b:	68 24 45 40 00       	push   $0x404524
   21f60:	50                   	push   %eax
   21f61:	e8 60 89 fe ff       	call   a8c6 <memcmp>
   21f66:	83 c4 0c             	add    $0xc,%esp
		if (!ifaddr ||
   21f69:	85 c0                	test   %eax,%eax
   21f6b:	75 76                	jne    21fe3 <ipv6_event_handler+0x100>
		    !(net_ipv6_addr_cmp(&ifaddr->address.in6_addr, &laddr) &&
   21f6d:	80 7b 45 01          	cmpb   $0x1,0x45(%ebx)
   21f71:	75 70                	jne    21fe3 <ipv6_event_handler+0x100>
			/* Address is not yet properly setup */
			return;
		}

#if CONFIG_NET_CONFIG_LOG_LEVEL >= LOG_LEVEL_INF
		NET_INFO("IPv6 address: %s",
   21f73:	a1 6c a8 40 00       	mov    0x40a86c,%eax
   21f78:	83 e0 07             	and    $0x7,%eax
   21f7b:	83 f8 02             	cmp    $0x2,%eax
   21f7e:	76 4a                	jbe    21fca <ipv6_event_handler+0xe7>
   21f80:	6a 28                	push   $0x28
   21f82:	8d 45 d0             	lea    -0x30(%ebp),%eax
   21f85:	50                   	push   %eax
   21f86:	bb 5c 51 02 00       	mov    $0x2515c,%ebx
   21f8b:	68 24 45 40 00       	push   $0x404524
   21f90:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   21f96:	c1 eb 03             	shr    $0x3,%ebx
   21f99:	6a 02                	push   $0x2
   21f9b:	c1 e3 06             	shl    $0x6,%ebx
   21f9e:	e8 b8 e8 fe ff       	call   1085b <net_addr_ntop>
   21fa3:	83 c4 10             	add    $0x10,%esp
   21fa6:	83 cb 03             	or     $0x3,%ebx
   21fa9:	50                   	push   %eax
   21faa:	e8 ac 18 fe ff       	call   385b <log_strdup>
   21faf:	66 89 1c 24          	mov    %bx,(%esp)
   21fb3:	50                   	push   %eax
   21fb4:	68 8e a9 02 00       	push   $0x2a98e
   21fb9:	e8 f1 14 fe ff       	call   34af <log_1>
   21fbe:	83 c4 0c             	add    $0xc,%esp
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   21fc1:	eb 07                	jmp    21fca <ipv6_event_handler+0xe7>

		k_sem_take(&counter, K_NO_WAIT);
		k_sem_give(&waiter);
	}

	if (mgmt_event == NET_EVENT_IPV6_ROUTER_ADD) {
   21fc3:	3d 09 00 60 f0       	cmp    $0xf0600009,%eax
   21fc8:	75 19                	jne    21fe3 <ipv6_event_handler+0x100>
   21fca:	6a 00                	push   $0x0
   21fcc:	68 80 40 40 00       	push   $0x404080
   21fd1:	e8 6c 20 00 00       	call   24042 <z_impl_k_sem_take>
   21fd6:	58                   	pop    %eax
   21fd7:	5a                   	pop    %edx
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   21fd8:	68 e0 a9 40 00       	push   $0x40a9e0
   21fdd:	e8 f7 1f 00 00       	call   23fd9 <z_impl_k_sem_give>
   21fe2:	59                   	pop    %ecx
		k_sem_take(&counter, K_NO_WAIT);
		k_sem_give(&waiter);
	}
}
   21fe3:	8d 65 f8             	lea    -0x8(%ebp),%esp
   21fe6:	5b                   	pop    %ebx
   21fe7:	5e                   	pop    %esi
   21fe8:	5d                   	pop    %ebp
   21fe9:	c3                   	ret    

00021fea <net_config_init>:
#else
#define setup_ipv6(...)
#endif /* CONFIG_NET_IPV6 */

int net_config_init(const char *app_info, u32_t flags, s32_t timeout)
{
   21fea:	55                   	push   %ebp
   21feb:	89 e5                	mov    %esp,%ebp
   21fed:	57                   	push   %edi
   21fee:	56                   	push   %esi
   21fef:	53                   	push   %ebx
   21ff0:	83 ec 18             	sub    $0x18,%esp
   21ff3:	8b 7d 08             	mov    0x8(%ebp),%edi
#define LOOP_DIVIDER 10
	struct net_if *iface = net_if_get_default();
   21ff6:	e8 88 bf fe ff       	call   df83 <net_if_get_default>
   21ffb:	89 c6                	mov    %eax,%esi
	int loop = timeout / LOOP_DIVIDER;
   21ffd:	8b 45 10             	mov    0x10(%ebp),%eax
   22000:	99                   	cltd   
   22001:	b9 0a 00 00 00       	mov    $0xa,%ecx
   22006:	f7 f9                	idiv   %ecx
   22008:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int count = 0;

	if (app_info) {
   2200b:	85 ff                	test   %edi,%edi
   2200d:	74 39                	je     22048 <net_config_init+0x5e>
		NET_INFO("%s", log_strdup(app_info));
   2200f:	a1 6c a8 40 00       	mov    0x40a86c,%eax
   22014:	83 e0 07             	and    $0x7,%eax
   22017:	83 f8 02             	cmp    $0x2,%eax
   2201a:	76 2c                	jbe    22048 <net_config_init+0x5e>
   2201c:	57                   	push   %edi
   2201d:	e8 39 18 fe ff       	call   385b <log_strdup>
   22022:	bb 5c 51 02 00       	mov    $0x2515c,%ebx
   22027:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   2202d:	c1 eb 03             	shr    $0x3,%ebx
   22030:	c1 e3 06             	shl    $0x6,%ebx
   22033:	83 cb 03             	or     $0x3,%ebx
   22036:	66 89 1c 24          	mov    %bx,(%esp)
   2203a:	50                   	push   %eax
   2203b:	68 6a a5 02 00       	push   $0x2a56a
   22040:	e8 6a 14 fe ff       	call   34af <log_1>
   22045:	83 c4 0c             	add    $0xc,%esp
	}

	if (!iface) {
   22048:	85 f6                	test   %esi,%esi
   2204a:	75 30                	jne    2207c <net_config_init+0x92>
		NET_ERR("No network interfaces");
		return -ENODEV;
   2204c:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
		NET_ERR("No network interfaces");
   22051:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   22058:	0f 84 98 02 00 00    	je     222f6 <net_config_init+0x30c>
   2205e:	b8 5c 51 02 00       	mov    $0x2515c,%eax
   22063:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   22068:	c1 e8 03             	shr    $0x3,%eax
   2206b:	c1 e0 06             	shl    $0x6,%eax
   2206e:	83 c8 01             	or     $0x1,%eax
   22071:	50                   	push   %eax
   22072:	68 9f a9 02 00       	push   $0x2a99f
   22077:	e9 73 02 00 00       	jmp    222ef <net_config_init+0x305>
	}

	if (flags & NET_CONFIG_NEED_IPV6) {
   2207c:	8b 45 0c             	mov    0xc(%ebp),%eax
		count++;
	}

	if (flags & NET_CONFIG_NEED_IPV4) {
   2207f:	8b 55 0c             	mov    0xc(%ebp),%edx
   22082:	83 e2 04             	and    $0x4,%edx
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
   22085:	6a ff                	push   $0xffffffff
	if (flags & NET_CONFIG_NEED_IPV6) {
   22087:	d1 e8                	shr    %eax
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
   22089:	8d 7d e0             	lea    -0x20(%ebp),%edi
	if (flags & NET_CONFIG_NEED_IPV6) {
   2208c:	83 e0 01             	and    $0x1,%eax
		count++;
   2208f:	83 fa 01             	cmp    $0x1,%edx
   22092:	83 d8 ff             	sbb    $0xffffffff,%eax
   22095:	50                   	push   %eax
   22096:	68 80 40 40 00       	push   $0x404080
   2209b:	e8 08 1f 00 00       	call   23fa8 <z_impl_k_sem_init>
   220a0:	83 c4 0c             	add    $0xc,%esp
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
   220a3:	57                   	push   %edi
   220a4:	68 b5 a9 02 00       	push   $0x2a9b5
   220a9:	6a 01                	push   $0x1
   220ab:	e8 21 ea fe ff       	call   10ad1 <net_addr_pton>
   220b0:	83 c4 0c             	add    $0xc,%esp
   220b3:	85 c0                	test   %eax,%eax
   220b5:	74 38                	je     220ef <net_config_init+0x105>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV4_ADDR);
   220b7:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   220be:	0f 84 02 01 00 00    	je     221c6 <net_config_init+0x1dc>
   220c4:	b8 5c 51 02 00       	mov    $0x2515c,%eax
   220c9:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   220ce:	c1 e8 03             	shr    $0x3,%eax
   220d1:	c1 e0 06             	shl    $0x6,%eax
   220d4:	83 c8 01             	or     $0x1,%eax
   220d7:	50                   	push   %eax
   220d8:	68 b5 a9 02 00       	push   $0x2a9b5
   220dd:	68 bf a9 02 00       	push   $0x2a9bf
   220e2:	e8 c8 13 fe ff       	call   34af <log_1>
   220e7:	83 c4 0c             	add    $0xc,%esp
		return;
   220ea:	e9 d7 00 00 00       	jmp    221c6 <net_config_init+0x1dc>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
   220ef:	6a 00                	push   $0x0
   220f1:	6a 03                	push   $0x3
   220f3:	57                   	push   %edi
   220f4:	56                   	push   %esi
   220f5:	e8 43 d4 fe ff       	call   f53d <net_if_ipv4_addr_add>
	NET_INFO("IPv4 address: %s",
   220fa:	a1 6c a8 40 00       	mov    0x40a86c,%eax
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
   220ff:	83 c4 10             	add    $0x10,%esp
	NET_INFO("IPv4 address: %s",
   22102:	83 e0 07             	and    $0x7,%eax
   22105:	83 f8 02             	cmp    $0x2,%eax
   22108:	76 3d                	jbe    22147 <net_config_init+0x15d>
   2210a:	6a 10                	push   $0x10
   2210c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   2210f:	50                   	push   %eax
   22110:	bb 5c 51 02 00       	mov    $0x2515c,%ebx
   22115:	57                   	push   %edi
   22116:	81 eb 3c 51 02 00    	sub    $0x2513c,%ebx
   2211c:	c1 eb 03             	shr    $0x3,%ebx
   2211f:	6a 01                	push   $0x1
   22121:	c1 e3 06             	shl    $0x6,%ebx
   22124:	e8 32 e7 fe ff       	call   1085b <net_addr_ntop>
   22129:	83 c4 10             	add    $0x10,%esp
   2212c:	83 cb 03             	or     $0x3,%ebx
   2212f:	50                   	push   %eax
   22130:	e8 26 17 fe ff       	call   385b <log_strdup>
   22135:	66 89 1c 24          	mov    %bx,(%esp)
   22139:	50                   	push   %eax
   2213a:	68 d3 a9 02 00       	push   $0x2a9d3
   2213f:	e8 6b 13 fe ff       	call   34af <log_1>
   22144:	83 c4 0c             	add    $0xc,%esp
		if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_NETMASK,
   22147:	8d 45 e0             	lea    -0x20(%ebp),%eax
   2214a:	50                   	push   %eax
   2214b:	68 e4 a9 02 00       	push   $0x2a9e4
   22150:	6a 01                	push   $0x1
   22152:	e8 7a e9 fe ff       	call   10ad1 <net_addr_pton>
   22157:	83 c4 0c             	add    $0xc,%esp
   2215a:	85 c0                	test   %eax,%eax
   2215c:	74 31                	je     2218f <net_config_init+0x1a5>
			NET_ERR("Invalid netmask: %s",
   2215e:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   22165:	74 46                	je     221ad <net_config_init+0x1c3>
   22167:	b8 5c 51 02 00       	mov    $0x2515c,%eax
   2216c:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   22171:	c1 e8 03             	shr    $0x3,%eax
   22174:	c1 e0 06             	shl    $0x6,%eax
   22177:	83 c8 01             	or     $0x1,%eax
   2217a:	50                   	push   %eax
   2217b:	68 e4 a9 02 00       	push   $0x2a9e4
   22180:	68 f2 a9 02 00       	push   $0x2a9f2
   22185:	e8 25 13 fe ff       	call   34af <log_1>
   2218a:	83 c4 0c             	add    $0xc,%esp
   2218d:	eb 1e                	jmp    221ad <net_config_init+0x1c3>
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
   2218f:	6a 00                	push   $0x0
   22191:	56                   	push   %esi
   22192:	e8 01 d1 fe ff       	call   f298 <net_if_config_ipv4_get>
   22197:	5a                   	pop    %edx
   22198:	85 c0                	test   %eax,%eax
   2219a:	59                   	pop    %ecx
   2219b:	78 10                	js     221ad <net_config_init+0x1c3>
	if (!iface->config.ip.ipv4) {
   2219d:	8b 46 08             	mov    0x8(%esi),%eax
   221a0:	85 c0                	test   %eax,%eax
   221a2:	74 09                	je     221ad <net_config_init+0x1c3>
	net_ipaddr_copy(&iface->config.ip.ipv4->netmask, netmask);
   221a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
   221a7:	89 90 0c 01 00 00    	mov    %edx,0x10c(%eax)
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   221ad:	6a 00                	push   $0x0
   221af:	68 80 40 40 00       	push   $0x404080
   221b4:	e8 89 1e 00 00       	call   24042 <z_impl_k_sem_take>
   221b9:	5f                   	pop    %edi
   221ba:	58                   	pop    %eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   221bb:	68 e0 a9 40 00       	push   $0x40a9e0
   221c0:	e8 14 1e 00 00       	call   23fd9 <z_impl_k_sem_give>
   221c5:	58                   	pop    %eax
	if (net_addr_pton(AF_INET6, CONFIG_NET_CONFIG_MY_IPV6_ADDR, &laddr)) {
   221c6:	68 24 45 40 00       	push   $0x404524
   221cb:	68 06 aa 02 00       	push   $0x2aa06
   221d0:	6a 02                	push   $0x2
   221d2:	e8 fa e8 fe ff       	call   10ad1 <net_addr_pton>
   221d7:	83 c4 0c             	add    $0xc,%esp
   221da:	85 c0                	test   %eax,%eax
   221dc:	74 2f                	je     2220d <net_config_init+0x223>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV6_ADDR);
   221de:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   221e5:	74 26                	je     2220d <net_config_init+0x223>
   221e7:	b8 5c 51 02 00       	mov    $0x2515c,%eax
   221ec:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   221f1:	c1 e8 03             	shr    $0x3,%eax
   221f4:	c1 e0 06             	shl    $0x6,%eax
   221f7:	83 c8 01             	or     $0x1,%eax
   221fa:	50                   	push   %eax
   221fb:	68 06 aa 02 00       	push   $0x2aa06
   22200:	68 bf a9 02 00       	push   $0x2a9bf
   22205:	e8 a5 12 fe ff       	call   34af <log_1>
   2220a:	83 c4 0c             	add    $0xc,%esp
	net_mgmt_add_event_callback(&mgmt6_cb);
   2220d:	68 34 45 40 00       	push   $0x404534
	cb->handler = handler;
   22212:	c7 05 38 45 40 00 e3 	movl   $0x21ee3,0x404538
   22219:	1e 02 00 
	cb->event_mask = mgmt_event_mask;
   2221c:	c7 05 3c 45 40 00 0d 	movl   $0xf060000d,0x40453c
   22223:	00 60 f0 
   22226:	e8 4e 22 ff ff       	call   14479 <net_mgmt_add_event_callback>
		ifaddr = net_if_ipv6_addr_add(iface, &laddr,
   2222b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   22232:	6a 03                	push   $0x3
   22234:	68 24 45 40 00       	push   $0x404524
   22239:	56                   	push   %esi
   2223a:	e8 f1 bf fe ff       	call   e230 <net_if_ipv6_addr_add>
   2223f:	83 c4 10             	add    $0x10,%esp
		if (!ifaddr) {
   22242:	85 c0                	test   %eax,%eax
   22244:	75 2f                	jne    22275 <net_config_init+0x28b>
			NET_ERR("Cannot add %s to interface",
   22246:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   2224d:	74 26                	je     22275 <net_config_init+0x28b>
   2224f:	b8 5c 51 02 00       	mov    $0x2515c,%eax
   22254:	2d 3c 51 02 00       	sub    $0x2513c,%eax
   22259:	c1 e8 03             	shr    $0x3,%eax
   2225c:	c1 e0 06             	shl    $0x6,%eax
   2225f:	83 c8 01             	or     $0x1,%eax
   22262:	50                   	push   %eax
   22263:	68 06 aa 02 00       	push   $0x2aa06
   22268:	68 12 aa 02 00       	push   $0x2aa12
   2226d:	e8 3d 12 fe ff       	call   34af <log_1>
   22272:	83 c4 0c             	add    $0xc,%esp
	setup_dhcpv4(iface);

	setup_ipv6(iface, flags);

	if (timeout < 0) {
		count = -1;
   22275:	83 cb ff             	or     $0xffffffff,%ebx
	if (timeout < 0) {
   22278:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   2227c:	78 2a                	js     222a8 <net_config_init+0x2be>
	} else if (timeout == 0) {
		count = 0;
   2227e:	bb 00 00 00 00       	mov    $0x0,%ebx
	} else if (timeout == 0) {
   22283:	74 23                	je     222a8 <net_config_init+0x2be>
	} else {
		count = timeout / 1000 + 1;
   22285:	8b 45 10             	mov    0x10(%ebp),%eax
   22288:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
   2228d:	99                   	cltd   
   2228e:	f7 f9                	idiv   %ecx
   22290:	8d 58 01             	lea    0x1(%eax),%ebx
   22293:	eb 13                	jmp    222a8 <net_config_init+0x2be>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   22295:	ff 75 dc             	pushl  -0x24(%ebp)
   22298:	68 e0 a9 40 00       	push   $0x40a9e0
   2229d:	e8 a0 1d 00 00       	call   24042 <z_impl_k_sem_take>
   222a2:	59                   	pop    %ecx

	/* Loop here until we are ready to continue. As we might need
	 * to wait multiple events, sleep smaller amounts of data.
	 */
	while (count--) {
		if (k_sem_take(&waiter, loop)) {
   222a3:	85 c0                	test   %eax,%eax
   222a5:	5e                   	pop    %esi
   222a6:	75 08                	jne    222b0 <net_config_init+0x2c6>
   222a8:	4b                   	dec    %ebx
	while (count--) {
   222a9:	83 fb ff             	cmp    $0xffffffff,%ebx
   222ac:	75 e7                	jne    22295 <net_config_init+0x2ab>
   222ae:	eb 0d                	jmp    222bd <net_config_init+0x2d3>
			if (!k_sem_count_get(&counter)) {
   222b0:	83 3d 90 40 40 00 00 	cmpl   $0x0,0x404090
   222b7:	75 ef                	jne    222a8 <net_config_init+0x2be>
				break;
			}
		}
	}

	if (!count && timeout) {
   222b9:	85 db                	test   %ebx,%ebx
   222bb:	74 04                	je     222c1 <net_config_init+0x2d7>
		NET_ERR("Timeout while waiting setup");
		return -ETIMEDOUT;
	}

	return 0;
   222bd:	31 db                	xor    %ebx,%ebx
   222bf:	eb 35                	jmp    222f6 <net_config_init+0x30c>
	if (!count && timeout) {
   222c1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   222c5:	74 f6                	je     222bd <net_config_init+0x2d3>
		return -ETIMEDOUT;
   222c7:	bb c4 ff ff ff       	mov    $0xffffffc4,%ebx
		NET_ERR("Timeout while waiting setup");
   222cc:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   222d3:	74 21                	je     222f6 <net_config_init+0x30c>
   222d5:	ba 5c 51 02 00       	mov    $0x2515c,%edx
   222da:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   222e0:	c1 ea 03             	shr    $0x3,%edx
   222e3:	c1 e2 06             	shl    $0x6,%edx
   222e6:	83 ca 01             	or     $0x1,%edx
   222e9:	52                   	push   %edx
   222ea:	68 2d aa 02 00       	push   $0x2aa2d
   222ef:	e8 96 11 fe ff       	call   348a <log_0>
   222f4:	58                   	pop    %eax
   222f5:	5a                   	pop    %edx
}
   222f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   222f9:	89 d8                	mov    %ebx,%eax
   222fb:	5b                   	pop    %ebx
   222fc:	5e                   	pop    %esi
   222fd:	5f                   	pop    %edi
   222fe:	5d                   	pop    %ebp
   222ff:	c3                   	ret    

00022300 <init_app>:

#if defined(CONFIG_NET_CONFIG_AUTO_INIT)
static int init_app(struct device *device)
{
   22300:	55                   	push   %ebp
   22301:	89 e5                	mov    %esp,%ebp
   22303:	50                   	push   %eax
	if (IS_ENABLED(CONFIG_NET_CONFIG_NEED_IPV4)) {
		flags |= NET_CONFIG_NEED_IPV4;
	}

	/* Initialize the application automatically if needed */
	ret = net_config_init("Initializing network", flags,
   22304:	68 30 75 00 00       	push   $0x7530
   22309:	6a 06                	push   $0x6
   2230b:	68 49 aa 02 00       	push   $0x2aa49
   22310:	e8 d5 fc ff ff       	call   21fea <net_config_init>
   22315:	83 c4 0c             	add    $0xc,%esp
			      K_SECONDS(CONFIG_NET_CONFIG_INIT_TIMEOUT));
	if (ret < 0) {
   22318:	85 c0                	test   %eax,%eax
   2231a:	79 32                	jns    2234e <init_app+0x4e>
		NET_ERR("Network initialization failed (%d)", ret);
   2231c:	f6 05 6c a8 40 00 07 	testb  $0x7,0x40a86c
   22323:	74 29                	je     2234e <init_app+0x4e>
   22325:	ba 5c 51 02 00       	mov    $0x2515c,%edx
   2232a:	89 45 fc             	mov    %eax,-0x4(%ebp)
   2232d:	81 ea 3c 51 02 00    	sub    $0x2513c,%edx
   22333:	c1 ea 03             	shr    $0x3,%edx
   22336:	c1 e2 06             	shl    $0x6,%edx
   22339:	83 ca 01             	or     $0x1,%edx
   2233c:	52                   	push   %edx
   2233d:	50                   	push   %eax
   2233e:	68 5e aa 02 00       	push   $0x2aa5e
   22343:	e8 67 11 fe ff       	call   34af <log_1>
   22348:	83 c4 0c             	add    $0xc,%esp
   2234b:	8b 45 fc             	mov    -0x4(%ebp),%eax
			log_backend_activate(backend, NULL);
		}
	}

	return ret;
}
   2234e:	c9                   	leave  
   2234f:	c3                   	ret    

00022350 <parse_url_char>:
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
enum state parse_url_char(enum state s, const char ch)
{
   22350:	55                   	push   %ebp
   22351:	89 e5                	mov    %esp,%ebp
   22353:	53                   	push   %ebx
   22354:	8b 55 0c             	mov    0xc(%ebp),%edx
   22357:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ch == ' ' || ch == '\r' || ch == '\n') {
   2235a:	8d 4a f6             	lea    -0xa(%edx),%ecx
   2235d:	80 f9 16             	cmp    $0x16,%cl
   22360:	77 0e                	ja     22370 <parse_url_char+0x20>
   22362:	bb 09 00 40 00       	mov    $0x400009,%ebx
   22367:	0f a3 cb             	bt     %ecx,%ebx
   2236a:	0f 82 18 02 00 00    	jb     22588 <parse_url_char+0x238>
	if (ch == '\t' || ch == '\f') {
		return s_dead;
	}
#endif

	switch (s) {
   22370:	8d 48 ec             	lea    -0x14(%eax),%ecx
   22373:	83 f9 0b             	cmp    $0xb,%ecx
   22376:	0f 87 0c 02 00 00    	ja     22588 <parse_url_char+0x238>
   2237c:	ff 24 8d 90 65 02 00 	jmp    *0x26590(,%ecx,4)
		/* Proxied requests are followed by scheme of an absolute URI
		 * (alpha).
		 * All methods except CONNECT are followed by '/' or '*'.
		 */

		if (ch == '/' || ch == '*') {
   22383:	80 fa 2f             	cmp    $0x2f,%dl
   22386:	0f 84 03 02 00 00    	je     2258f <parse_url_char+0x23f>
   2238c:	80 fa 2a             	cmp    $0x2a,%dl
   2238f:	0f 84 fa 01 00 00    	je     2258f <parse_url_char+0x23f>
			return s_req_path;
		}

		if (IS_ALPHA(ch)) {
   22395:	83 ca 20             	or     $0x20,%edx
   22398:	83 ea 61             	sub    $0x61,%edx
			return s_req_schema;
   2239b:	80 fa 1a             	cmp    $0x1a,%dl
   2239e:	19 c0                	sbb    %eax,%eax
   223a0:	83 e0 14             	and    $0x14,%eax
   223a3:	40                   	inc    %eax
   223a4:	e9 f9 01 00 00       	jmp    225a2 <parse_url_char+0x252>
		}

		break;

	case s_req_schema:
		if (IS_ALPHA(ch)) {
   223a9:	88 d1                	mov    %dl,%cl
   223ab:	83 c9 20             	or     $0x20,%ecx
   223ae:	83 e9 61             	sub    $0x61,%ecx
   223b1:	80 f9 19             	cmp    $0x19,%cl
   223b4:	0f 86 e8 01 00 00    	jbe    225a2 <parse_url_char+0x252>
			return s;
		}

		if (ch == ':') {
			return s_req_schema_slash;
   223ba:	31 c0                	xor    %eax,%eax
   223bc:	80 fa 3a             	cmp    $0x3a,%dl
   223bf:	0f 94 c0             	sete   %al
   223c2:	48                   	dec    %eax
   223c3:	83 e0 eb             	and    $0xffffffeb,%eax
   223c6:	83 c0 16             	add    $0x16,%eax
   223c9:	e9 d4 01 00 00       	jmp    225a2 <parse_url_char+0x252>

		break;

	case s_req_schema_slash:
		if (ch == '/') {
			return s_req_schema_slash_slash;
   223ce:	31 c0                	xor    %eax,%eax
   223d0:	80 fa 2f             	cmp    $0x2f,%dl
   223d3:	0f 94 c0             	sete   %al
   223d6:	48                   	dec    %eax
   223d7:	83 e0 ea             	and    $0xffffffea,%eax
   223da:	83 c0 17             	add    $0x17,%eax
   223dd:	e9 c0 01 00 00       	jmp    225a2 <parse_url_char+0x252>

		break;

	case s_req_schema_slash_slash:
		if (ch == '/') {
			return s_req_server_start;
   223e2:	31 c0                	xor    %eax,%eax
   223e4:	80 fa 2f             	cmp    $0x2f,%dl
   223e7:	0f 94 c0             	sete   %al
   223ea:	48                   	dec    %eax
   223eb:	83 e0 e9             	and    $0xffffffe9,%eax
   223ee:	83 c0 18             	add    $0x18,%eax
   223f1:	e9 ac 01 00 00       	jmp    225a2 <parse_url_char+0x252>
		return s_dead;
   223f6:	b8 01 00 00 00       	mov    $0x1,%eax
		}

		break;

	case s_req_server_with_at:
		if (ch == '@') {
   223fb:	80 fa 40             	cmp    $0x40,%dl
   223fe:	0f 84 9e 01 00 00    	je     225a2 <parse_url_char+0x252>
			return s_req_path;
   22404:	b8 1b 00 00 00       	mov    $0x1b,%eax
		}

	/* FALLTHROUGH */
	case s_req_server_start:
	case s_req_server:
		if (ch == '/') {
   22409:	80 fa 2f             	cmp    $0x2f,%dl
   2240c:	0f 84 90 01 00 00    	je     225a2 <parse_url_char+0x252>
			return s_req_path;
		}

		if (ch == '?') {
			return s_req_query_string_start;
   22412:	b8 1c 00 00 00       	mov    $0x1c,%eax
		if (ch == '?') {
   22417:	80 fa 3f             	cmp    $0x3f,%dl
   2241a:	0f 84 82 01 00 00    	je     225a2 <parse_url_char+0x252>
		}

		if (ch == '@') {
			return s_req_server_with_at;
   22420:	b8 1a 00 00 00       	mov    $0x1a,%eax
		if (ch == '@') {
   22425:	80 fa 40             	cmp    $0x40,%dl
   22428:	0f 84 74 01 00 00    	je     225a2 <parse_url_char+0x252>
		}

		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
   2242e:	88 d1                	mov    %dl,%cl
			return s_req_server;
   22430:	b8 19 00 00 00       	mov    $0x19,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
   22435:	83 c9 20             	or     $0x20,%ecx
   22438:	83 e9 61             	sub    $0x61,%ecx
   2243b:	80 f9 19             	cmp    $0x19,%cl
   2243e:	0f 86 5e 01 00 00    	jbe    225a2 <parse_url_char+0x252>
   22444:	8d 4a d0             	lea    -0x30(%edx),%ecx
   22447:	80 f9 09             	cmp    $0x9,%cl
   2244a:	0f 86 52 01 00 00    	jbe    225a2 <parse_url_char+0x252>
   22450:	8d 4a df             	lea    -0x21(%edx),%ecx
   22453:	80 f9 1a             	cmp    $0x1a,%cl
   22456:	77 0e                	ja     22466 <parse_url_char+0x116>
   22458:	bb 39 3f 00 06       	mov    $0x6003f39,%ebx
   2245d:	0f a3 cb             	bt     %ecx,%ebx
   22460:	0f 82 3c 01 00 00    	jb     225a2 <parse_url_char+0x252>
			return s_req_server;
   22466:	b8 19 00 00 00       	mov    $0x19,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
   2246b:	80 fa 7e             	cmp    $0x7e,%dl
   2246e:	0f 84 2e 01 00 00    	je     225a2 <parse_url_char+0x252>
   22474:	8d 4a d9             	lea    -0x27(%edx),%ecx
   22477:	80 f9 01             	cmp    $0x1,%cl
   2247a:	0f 86 22 01 00 00    	jbe    225a2 <parse_url_char+0x252>
   22480:	8d 4a c3             	lea    -0x3d(%edx),%ecx
   22483:	80 e1 df             	and    $0xdf,%cl
   22486:	0f 84 16 01 00 00    	je     225a2 <parse_url_char+0x252>
			return s_req_server;
   2248c:	31 c0                	xor    %eax,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
   2248e:	83 e2 fb             	and    $0xfffffffb,%edx
			return s_req_server;
   22491:	80 fa 5b             	cmp    $0x5b,%dl
   22494:	0f 94 c0             	sete   %al
   22497:	48                   	dec    %eax
   22498:	83 e0 e8             	and    $0xffffffe8,%eax
   2249b:	83 c0 19             	add    $0x19,%eax
   2249e:	e9 ff 00 00 00       	jmp    225a2 <parse_url_char+0x252>
		}

		break;

	case s_req_path:
		if (IS_URL_CHAR(ch)) {
   224a3:	88 d1                	mov    %dl,%cl
   224a5:	c0 e9 03             	shr    $0x3,%cl
   224a8:	0f b6 c9             	movzbl %cl,%ecx
   224ab:	0f b6 99 00 5c 02 00 	movzbl 0x25c00(%ecx),%ebx
   224b2:	88 d1                	mov    %dl,%cl
   224b4:	83 e1 07             	and    $0x7,%ecx
   224b7:	0f a3 cb             	bt     %ecx,%ebx
   224ba:	0f 82 e2 00 00 00    	jb     225a2 <parse_url_char+0x252>
   224c0:	84 d2                	test   %dl,%dl
   224c2:	0f 88 da 00 00 00    	js     225a2 <parse_url_char+0x252>
		switch (ch) {
		case '?':
			return s_req_query_string_start;

		case '#':
			return s_req_fragment_start;
   224c8:	b8 1e 00 00 00       	mov    $0x1e,%eax
   224cd:	80 fa 23             	cmp    $0x23,%dl
   224d0:	0f 84 cc 00 00 00    	je     225a2 <parse_url_char+0x252>
	}

	/* We should never fall out of the switch above unless there's
	 * an error
	 */
	return s_dead;
   224d6:	31 c0                	xor    %eax,%eax
   224d8:	80 fa 3f             	cmp    $0x3f,%dl
   224db:	0f 94 c0             	sete   %al
   224de:	48                   	dec    %eax
   224df:	83 e0 e5             	and    $0xffffffe5,%eax
   224e2:	83 c0 1c             	add    $0x1c,%eax
   224e5:	e9 b8 00 00 00       	jmp    225a2 <parse_url_char+0x252>
		if (IS_URL_CHAR(ch)) {
   224ea:	88 d0                	mov    %dl,%al
   224ec:	c0 e8 03             	shr    $0x3,%al
   224ef:	0f b6 c0             	movzbl %al,%eax
   224f2:	0f b6 88 00 5c 02 00 	movzbl 0x25c00(%eax),%ecx
   224f9:	88 d0                	mov    %dl,%al
   224fb:	83 e0 07             	and    $0x7,%eax
   224fe:	0f a3 c1             	bt     %eax,%ecx
   22501:	0f 82 8f 00 00 00    	jb     22596 <parse_url_char+0x246>
   22507:	84 d2                	test   %dl,%dl
   22509:	0f 88 87 00 00 00    	js     22596 <parse_url_char+0x246>
			return s_req_fragment_start;
   2250f:	b8 1e 00 00 00       	mov    $0x1e,%eax
   22514:	80 fa 23             	cmp    $0x23,%dl
   22517:	0f 84 85 00 00 00    	je     225a2 <parse_url_char+0x252>
	return s_dead;
   2251d:	31 c0                	xor    %eax,%eax
   2251f:	80 fa 3f             	cmp    $0x3f,%dl
   22522:	0f 94 c0             	sete   %al
   22525:	48                   	dec    %eax
   22526:	83 e0 e4             	and    $0xffffffe4,%eax
   22529:	83 c0 1d             	add    $0x1d,%eax
   2252c:	eb 74                	jmp    225a2 <parse_url_char+0x252>
		if (IS_URL_CHAR(ch)) {
   2252e:	88 d1                	mov    %dl,%cl
   22530:	c0 e9 03             	shr    $0x3,%cl
   22533:	0f b6 c9             	movzbl %cl,%ecx
   22536:	0f b6 99 00 5c 02 00 	movzbl 0x25c00(%ecx),%ebx
   2253d:	88 d1                	mov    %dl,%cl
   2253f:	83 e1 07             	and    $0x7,%ecx
   22542:	0f a3 cb             	bt     %ecx,%ebx
   22545:	72 56                	jb     2259d <parse_url_char+0x24d>
   22547:	84 d2                	test   %dl,%dl
   22549:	78 52                	js     2259d <parse_url_char+0x24d>
		switch (ch) {
   2254b:	80 fa 23             	cmp    $0x23,%dl
   2254e:	74 52                	je     225a2 <parse_url_char+0x252>
	return s_dead;
   22550:	31 c0                	xor    %eax,%eax
   22552:	80 fa 3f             	cmp    $0x3f,%dl
   22555:	0f 94 c0             	sete   %al
   22558:	48                   	dec    %eax
   22559:	83 e0 e2             	and    $0xffffffe2,%eax
   2255c:	83 c0 1f             	add    $0x1f,%eax
   2255f:	eb 41                	jmp    225a2 <parse_url_char+0x252>
		if (IS_URL_CHAR(ch)) {
   22561:	88 d1                	mov    %dl,%cl
   22563:	c0 e9 03             	shr    $0x3,%cl
   22566:	0f b6 c9             	movzbl %cl,%ecx
   22569:	0f b6 99 00 5c 02 00 	movzbl 0x25c00(%ecx),%ebx
   22570:	88 d1                	mov    %dl,%cl
   22572:	83 e1 07             	and    $0x7,%ecx
   22575:	0f a3 cb             	bt     %ecx,%ebx
   22578:	72 28                	jb     225a2 <parse_url_char+0x252>
   2257a:	84 d2                	test   %dl,%dl
   2257c:	78 24                	js     225a2 <parse_url_char+0x252>
		switch (ch) {
   2257e:	80 fa 23             	cmp    $0x23,%dl
   22581:	74 1f                	je     225a2 <parse_url_char+0x252>
   22583:	80 fa 3f             	cmp    $0x3f,%dl
   22586:	74 1a                	je     225a2 <parse_url_char+0x252>
	return s_dead;
   22588:	b8 01 00 00 00       	mov    $0x1,%eax
   2258d:	eb 13                	jmp    225a2 <parse_url_char+0x252>
			return s_req_path;
   2258f:	b8 1b 00 00 00       	mov    $0x1b,%eax
   22594:	eb 0c                	jmp    225a2 <parse_url_char+0x252>
			return s_req_query_string;
   22596:	b8 1d 00 00 00       	mov    $0x1d,%eax
   2259b:	eb 05                	jmp    225a2 <parse_url_char+0x252>
			return s_req_fragment;
   2259d:	b8 1f 00 00 00       	mov    $0x1f,%eax
}
   225a2:	5b                   	pop    %ebx
   225a3:	5d                   	pop    %ebp
   225a4:	c3                   	ret    

000225a5 <http_parser_url_init>:
	return 0;
}

void
http_parser_url_init(struct http_parser_url *u)
{
   225a5:	55                   	push   %ebp
   225a6:	89 e5                	mov    %esp,%ebp
	(void)memset(u, 0, sizeof(*u));
   225a8:	6a 20                	push   $0x20
   225aa:	6a 00                	push   $0x0
   225ac:	ff 75 08             	pushl  0x8(%ebp)
   225af:	e8 ec 83 fe ff       	call   a9a0 <memset>
   225b4:	83 c4 0c             	add    $0xc,%esp
}
   225b7:	c9                   	leave  
   225b8:	c3                   	ret    

000225b9 <http_parser_parse_url>:

int
http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
		      struct http_parser_url *u)
{
   225b9:	55                   	push   %ebp
   225ba:	89 e5                	mov    %esp,%ebp
   225bc:	57                   	push   %edi
   225bd:	56                   	push   %esi
		}

		u->field_data[uf].off = p - buf;
		u->field_data[uf].len = 1;

		u->field_set |= (1 << uf);
   225be:	bf 07 00 00 00       	mov    $0x7,%edi
{
   225c3:	53                   	push   %ebx
   225c4:	83 ec 08             	sub    $0x8,%esp
		u->field_set |= (1 << uf);
   225c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
   225ce:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
{
   225d2:	8b 5d 14             	mov    0x14(%ebp),%ebx
		u->field_set |= (1 << uf);
   225d5:	8b 75 08             	mov    0x8(%ebp),%esi
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
   225d8:	19 c0                	sbb    %eax,%eax
	for (p = buf; p < buf + buflen; p++) {
   225da:	8b 55 0c             	mov    0xc(%ebp),%edx
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
   225dd:	83 e0 fc             	and    $0xfffffffc,%eax
	for (p = buf; p < buf + buflen; p++) {
   225e0:	01 f2                	add    %esi,%edx
	u->port = u->field_set = 0;
   225e2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
   225e8:	83 c0 18             	add    $0x18,%eax
	for (p = buf; p < buf + buflen; p++) {
   225eb:	89 55 ec             	mov    %edx,-0x14(%ebp)
   225ee:	3b 75 ec             	cmp    -0x14(%ebp),%esi
   225f1:	73 6c                	jae    2265f <http_parser_parse_url+0xa6>
		s = parse_url_char(s, *p);
   225f3:	0f be 16             	movsbl (%esi),%edx
   225f6:	52                   	push   %edx
   225f7:	50                   	push   %eax
   225f8:	e8 53 fd ff ff       	call   22350 <parse_url_char>
   225fd:	5a                   	pop    %edx
		switch (s) {
   225fe:	8d 50 eb             	lea    -0x15(%eax),%edx
		s = parse_url_char(s, *p);
   22601:	59                   	pop    %ecx
		switch (s) {
   22602:	83 fa 0a             	cmp    $0xa,%edx
   22605:	77 64                	ja     2266b <http_parser_parse_url+0xb2>
   22607:	ff 24 95 c0 65 02 00 	jmp    *0x265c0(,%edx,4)
			found_at = 1;
   2260e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			uf = UF_HOST;
   22615:	b9 01 00 00 00       	mov    $0x1,%ecx
   2261a:	eb 17                	jmp    22633 <http_parser_parse_url+0x7a>
			uf = UF_PATH;
   2261c:	b9 03 00 00 00       	mov    $0x3,%ecx
			break;
   22621:	eb 10                	jmp    22633 <http_parser_parse_url+0x7a>
			uf = UF_QUERY;
   22623:	b9 04 00 00 00       	mov    $0x4,%ecx
			break;
   22628:	eb 09                	jmp    22633 <http_parser_parse_url+0x7a>
			uf = UF_FRAGMENT;
   2262a:	b9 05 00 00 00       	mov    $0x5,%ecx
			break;
   2262f:	eb 02                	jmp    22633 <http_parser_parse_url+0x7a>
			uf = UF_SCHEMA;
   22631:	31 c9                	xor    %ecx,%ecx
		if (uf == old_uf) {
   22633:	39 cf                	cmp    %ecx,%edi
   22635:	75 07                	jne    2263e <http_parser_parse_url+0x85>
			u->field_data[uf].len++;
   22637:	66 ff 44 bb 06       	incw   0x6(%ebx,%edi,4)
			continue;
   2263c:	eb 1e                	jmp    2265c <http_parser_parse_url+0xa3>
		u->field_data[uf].off = p - buf;
   2263e:	89 f7                	mov    %esi,%edi
   22640:	8d 14 8b             	lea    (%ebx,%ecx,4),%edx
   22643:	2b 7d 08             	sub    0x8(%ebp),%edi
		u->field_data[uf].len = 1;
   22646:	66 c7 42 06 01 00    	movw   $0x1,0x6(%edx)
		u->field_data[uf].off = p - buf;
   2264c:	66 89 7a 04          	mov    %di,0x4(%edx)
		u->field_set |= (1 << uf);
   22650:	ba 01 00 00 00       	mov    $0x1,%edx
   22655:	89 cf                	mov    %ecx,%edi
   22657:	d3 e2                	shl    %cl,%edx
   22659:	66 09 13             	or     %dx,(%ebx)
	for (p = buf; p < buf + buflen; p++) {
   2265c:	46                   	inc    %esi
   2265d:	eb 8f                	jmp    225ee <http_parser_parse_url+0x35>
		old_uf = uf;
	}

	/* host must be present if there is a schema */
	/* parsing http:///toto will fail */
	if ((u->field_set & (1 << UF_SCHEMA)) &&
   2265f:	66 8b 03             	mov    (%ebx),%ax
   22662:	89 c2                	mov    %eax,%edx
   22664:	83 e2 03             	and    $0x3,%edx
   22667:	66 4a                	dec    %dx
   22669:	75 0c                	jne    22677 <http_parser_parse_url+0xbe>
			(u->field_set & (1 << UF_HOST)) == 0) {
		return 1;
   2266b:	c7 45 10 01 00 00 00 	movl   $0x1,0x10(%ebp)
   22672:	e9 eb 02 00 00       	jmp    22962 <http_parser_parse_url+0x3a9>
	}

	if (u->field_set & (1 << UF_HOST)) {
   22677:	a8 02                	test   $0x2,%al
   22679:	75 12                	jne    2268d <http_parser_parse_url+0xd4>
			return 1;
		}
	}

	/* CONNECT requests can only contain "hostname:port" */
	if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
   2267b:	66 8b 03             	mov    (%ebx),%ax
   2267e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   22682:	0f 85 24 02 00 00    	jne    228ac <http_parser_parse_url+0x2f3>
   22688:	e9 2b 02 00 00       	jmp    228b8 <http_parser_parse_url+0x2ff>
	buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;
   2268d:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
   22691:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
   22695:	01 f2                	add    %esi,%edx
	u->field_data[UF_HOST].len = 0;
   22697:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	s = found_at ? s_http_userinfo_start : s_http_host_start;
   2269d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
   226a1:	19 c0                	sbb    %eax,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
   226a3:	03 55 08             	add    0x8(%ebp),%edx
	s = found_at ? s_http_userinfo_start : s_http_host_start;
   226a6:	83 e0 02             	and    $0x2,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
   226a9:	03 75 08             	add    0x8(%ebp),%esi
	s = found_at ? s_http_userinfo_start : s_http_host_start;
   226ac:	83 c0 02             	add    $0x2,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
   226af:	89 55 f0             	mov    %edx,-0x10(%ebp)
		if (IS_USERINFO_CHAR(ch)) {
   226b2:	bf 39 3f 00 16       	mov    $0x16003f39,%edi
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
   226b7:	3b 75 f0             	cmp    -0x10(%ebp),%esi
   226ba:	0f 83 c9 01 00 00    	jae    22889 <http_parser_parse_url+0x2d0>
	switch (s) {
   226c0:	8d 50 fe             	lea    -0x2(%eax),%edx
		enum http_host_state new_s = http_parse_host_char(s, *p);
   226c3:	8a 0e                	mov    (%esi),%cl
	switch (s) {
   226c5:	83 fa 0a             	cmp    $0xa,%edx
   226c8:	77 a1                	ja     2266b <http_parser_parse_url+0xb2>
   226ca:	ff 24 95 ec 65 02 00 	jmp    *0x265ec(,%edx,4)
		if (ch == '@') {
   226d1:	80 f9 40             	cmp    $0x40,%cl
   226d4:	0f 84 96 01 00 00    	je     22870 <http_parser_parse_url+0x2b7>
		if (IS_USERINFO_CHAR(ch)) {
   226da:	88 ca                	mov    %cl,%dl
   226dc:	83 ca 20             	or     $0x20,%edx
   226df:	83 ea 61             	sub    $0x61,%edx
   226e2:	80 fa 19             	cmp    $0x19,%dl
   226e5:	0f 86 1d 02 00 00    	jbe    22908 <http_parser_parse_url+0x34f>
   226eb:	8d 51 d0             	lea    -0x30(%ecx),%edx
   226ee:	80 fa 09             	cmp    $0x9,%dl
   226f1:	0f 86 11 02 00 00    	jbe    22908 <http_parser_parse_url+0x34f>
   226f7:	80 f9 5f             	cmp    $0x5f,%cl
   226fa:	0f 84 08 02 00 00    	je     22908 <http_parser_parse_url+0x34f>
   22700:	8d 51 df             	lea    -0x21(%ecx),%edx
   22703:	80 fa 1c             	cmp    $0x1c,%dl
   22706:	77 09                	ja     22711 <http_parser_parse_url+0x158>
   22708:	0f a3 d7             	bt     %edx,%edi
   2270b:	0f 82 f7 01 00 00    	jb     22908 <http_parser_parse_url+0x34f>
   22711:	80 f9 7e             	cmp    $0x7e,%cl
   22714:	0f 84 ee 01 00 00    	je     22908 <http_parser_parse_url+0x34f>
   2271a:	83 e9 27             	sub    $0x27,%ecx
   2271d:	80 f9 01             	cmp    $0x1,%cl
   22720:	0f 87 45 ff ff ff    	ja     2266b <http_parser_parse_url+0xb2>
   22726:	e9 dd 01 00 00       	jmp    22908 <http_parser_parse_url+0x34f>
		if (ch == '[') {
   2272b:	80 f9 5b             	cmp    $0x5b,%cl
   2272e:	0f 84 43 01 00 00    	je     22877 <http_parser_parse_url+0x2be>
		if (IS_HOST_CHAR(ch)) {
   22734:	88 c8                	mov    %cl,%al
   22736:	83 c8 20             	or     $0x20,%eax
   22739:	83 e8 61             	sub    $0x61,%eax
   2273c:	3c 19                	cmp    $0x19,%al
   2273e:	0f 86 18 01 00 00    	jbe    2285c <http_parser_parse_url+0x2a3>
   22744:	8d 41 d0             	lea    -0x30(%ecx),%eax
   22747:	3c 09                	cmp    $0x9,%al
   22749:	0f 86 0d 01 00 00    	jbe    2285c <http_parser_parse_url+0x2a3>
   2274f:	8d 41 d3             	lea    -0x2d(%ecx),%eax
   22752:	3c 01                	cmp    $0x1,%al
   22754:	0f 86 02 01 00 00    	jbe    2285c <http_parser_parse_url+0x2a3>
   2275a:	80 f9 5f             	cmp    $0x5f,%cl
   2275d:	0f 85 08 ff ff ff    	jne    2266b <http_parser_parse_url+0xb2>
   22763:	e9 f4 00 00 00       	jmp    2285c <http_parser_parse_url+0x2a3>
		if (IS_HOST_CHAR(ch)) {
   22768:	88 c8                	mov    %cl,%al
   2276a:	83 c8 20             	or     $0x20,%eax
   2276d:	83 e8 61             	sub    $0x61,%eax
   22770:	3c 19                	cmp    $0x19,%al
   22772:	0f 86 ed 00 00 00    	jbe    22865 <http_parser_parse_url+0x2ac>
   22778:	8d 41 d0             	lea    -0x30(%ecx),%eax
   2277b:	3c 09                	cmp    $0x9,%al
   2277d:	0f 86 e2 00 00 00    	jbe    22865 <http_parser_parse_url+0x2ac>
   22783:	8d 41 d3             	lea    -0x2d(%ecx),%eax
   22786:	3c 01                	cmp    $0x1,%al
   22788:	0f 86 d7 00 00 00    	jbe    22865 <http_parser_parse_url+0x2ac>
   2278e:	80 f9 5f             	cmp    $0x5f,%cl
   22791:	0f 84 ce 00 00 00    	je     22865 <http_parser_parse_url+0x2ac>
		if (ch == ':') {
   22797:	80 f9 3a             	cmp    $0x3a,%cl
   2279a:	0f 85 cb fe ff ff    	jne    2266b <http_parser_parse_url+0xb2>
			return s_http_host_port_start;
   227a0:	b8 0b 00 00 00       	mov    $0xb,%eax
   227a5:	e9 d9 00 00 00       	jmp    22883 <http_parser_parse_url+0x2ca>
		if (ch == ']') {
   227aa:	80 f9 5d             	cmp    $0x5d,%cl
   227ad:	0f 84 cb 00 00 00    	je     2287e <http_parser_parse_url+0x2c5>
		if (IS_HEX(ch) || ch == ':' || ch == '.') {
   227b3:	8d 51 d0             	lea    -0x30(%ecx),%edx
   227b6:	80 fa 09             	cmp    $0x9,%dl
   227b9:	0f 86 2d 01 00 00    	jbe    228ec <http_parser_parse_url+0x333>
   227bf:	88 ca                	mov    %cl,%dl
   227c1:	83 ca 20             	or     $0x20,%edx
   227c4:	83 ea 61             	sub    $0x61,%edx
   227c7:	80 fa 05             	cmp    $0x5,%dl
   227ca:	0f 86 1c 01 00 00    	jbe    228ec <http_parser_parse_url+0x333>
   227d0:	80 f9 3a             	cmp    $0x3a,%cl
   227d3:	0f 84 13 01 00 00    	je     228ec <http_parser_parse_url+0x333>
   227d9:	80 f9 2e             	cmp    $0x2e,%cl
   227dc:	0f 84 0a 01 00 00    	je     228ec <http_parser_parse_url+0x333>
		if (s == s_http_host_v6 && ch == '%') {
   227e2:	83 f8 07             	cmp    $0x7,%eax
   227e5:	0f 85 80 fe ff ff    	jne    2266b <http_parser_parse_url+0xb2>
   227eb:	80 f9 25             	cmp    $0x25,%cl
   227ee:	0f 85 77 fe ff ff    	jne    2266b <http_parser_parse_url+0xb2>
			return s_http_host_v6_zone_start;
   227f4:	b8 09 00 00 00       	mov    $0x9,%eax
   227f9:	e9 35 01 00 00       	jmp    22933 <http_parser_parse_url+0x37a>
		if (ch == ']') {
   227fe:	80 f9 5d             	cmp    $0x5d,%cl
   22801:	74 7b                	je     2287e <http_parser_parse_url+0x2c5>
		if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' ||
   22803:	88 c8                	mov    %cl,%al
   22805:	83 c8 20             	or     $0x20,%eax
   22808:	83 e8 61             	sub    $0x61,%eax
   2280b:	3c 19                	cmp    $0x19,%al
   2280d:	0f 86 1b 01 00 00    	jbe    2292e <http_parser_parse_url+0x375>
   22813:	8d 41 d0             	lea    -0x30(%ecx),%eax
   22816:	3c 09                	cmp    $0x9,%al
   22818:	0f 86 10 01 00 00    	jbe    2292e <http_parser_parse_url+0x375>
   2281e:	80 f9 25             	cmp    $0x25,%cl
   22821:	0f 84 07 01 00 00    	je     2292e <http_parser_parse_url+0x375>
   22827:	8d 41 d3             	lea    -0x2d(%ecx),%eax
   2282a:	3c 01                	cmp    $0x1,%al
   2282c:	0f 96 c2             	setbe  %dl
				ch == '_' ||
   2282f:	80 f9 5f             	cmp    $0x5f,%cl
   22832:	0f 94 c0             	sete   %al
   22835:	08 c2                	or     %al,%dl
   22837:	0f 85 f1 00 00 00    	jne    2292e <http_parser_parse_url+0x375>
   2283d:	80 f9 7e             	cmp    $0x7e,%cl
   22840:	0f 85 25 fe ff ff    	jne    2266b <http_parser_parse_url+0xb2>
   22846:	e9 e3 00 00 00       	jmp    2292e <http_parser_parse_url+0x375>
		if (IS_NUM(ch)) {
   2284b:	83 e9 30             	sub    $0x30,%ecx
   2284e:	80 f9 09             	cmp    $0x9,%cl
   22851:	0f 87 14 fe ff ff    	ja     2266b <http_parser_parse_url+0xb2>
   22857:	e9 e0 00 00 00       	jmp    2293c <http_parser_parse_url+0x383>
				u->field_data[UF_HOST].off = p - buf;
   2285c:	89 f0                	mov    %esi,%eax
   2285e:	2b 45 08             	sub    0x8(%ebp),%eax
   22861:	66 89 43 08          	mov    %ax,0x8(%ebx)
			u->field_data[UF_HOST].len++;
   22865:	66 ff 43 0a          	incw   0xa(%ebx)
   22869:	b8 06 00 00 00       	mov    $0x6,%eax
   2286e:	eb 13                	jmp    22883 <http_parser_parse_url+0x2ca>
			return s_http_host_start;
   22870:	b8 04 00 00 00       	mov    $0x4,%eax
   22875:	eb 0c                	jmp    22883 <http_parser_parse_url+0x2ca>
			return s_http_host_v6_start;
   22877:	b8 05 00 00 00       	mov    $0x5,%eax
   2287c:	eb 05                	jmp    22883 <http_parser_parse_url+0x2ca>
			return s_http_host_v6_end;
   2287e:	b8 08 00 00 00       	mov    $0x8,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
   22883:	46                   	inc    %esi
   22884:	e9 2e fe ff ff       	jmp    226b7 <http_parser_parse_url+0xfe>
	switch (s) {
   22889:	83 f8 0b             	cmp    $0xb,%eax
   2288c:	0f 87 e9 fd ff ff    	ja     2267b <http_parser_parse_url+0xc2>
   22892:	ba 01 00 00 00       	mov    $0x1,%edx
   22897:	88 c1                	mov    %al,%cl
   22899:	d3 e2                	shl    %cl,%edx
   2289b:	81 e2 bc 0e 00 00    	and    $0xebc,%edx
   228a1:	0f 85 c4 fd ff ff    	jne    2266b <http_parser_parse_url+0xb2>
   228a7:	e9 cf fd ff ff       	jmp    2267b <http_parser_parse_url+0xc2>
	if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
   228ac:	66 83 f8 06          	cmp    $0x6,%ax
   228b0:	0f 85 b5 fd ff ff    	jne    2266b <http_parser_parse_url+0xb2>
   228b6:	eb 08                	jmp    228c0 <http_parser_parse_url+0x307>
		return 1;
	}

	if (u->field_set & (1 << UF_PORT)) {
   228b8:	a8 04                	test   $0x4,%al
   228ba:	0f 84 a2 00 00 00    	je     22962 <http_parser_parse_url+0x3a9>
		/* Don't bother with endp; we've already validated the string */
		unsigned long v;

		v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);
   228c0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
   228c4:	6a 0a                	push   $0xa
   228c6:	03 45 08             	add    0x8(%ebp),%eax
   228c9:	6a 00                	push   $0x0
   228cb:	50                   	push   %eax
   228cc:	e8 61 7d fe ff       	call   a632 <strtoul>
   228d1:	83 c4 0c             	add    $0xc,%esp

		/* Ports have a max value of 2^16 */
		if (v > 0xffff) {
   228d4:	3d ff ff 00 00       	cmp    $0xffff,%eax
   228d9:	0f 87 8c fd ff ff    	ja     2266b <http_parser_parse_url+0xb2>
			return 1;
		}

		u->port = (u16_t) v;
   228df:	66 89 43 02          	mov    %ax,0x2(%ebx)
	}

	return 0;
   228e3:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
   228ea:	eb 76                	jmp    22962 <http_parser_parse_url+0x3a9>
			if (s != s_http_host_v6) {
   228ec:	83 f8 07             	cmp    $0x7,%eax
   228ef:	74 09                	je     228fa <http_parser_parse_url+0x341>
				u->field_data[UF_HOST].off = p - buf;
   228f1:	89 f0                	mov    %esi,%eax
   228f3:	2b 45 08             	sub    0x8(%ebp),%eax
   228f6:	66 89 43 08          	mov    %ax,0x8(%ebx)
			u->field_data[UF_HOST].len++;
   228fa:	66 ff 43 0a          	incw   0xa(%ebx)
   228fe:	b8 07 00 00 00       	mov    $0x7,%eax
   22903:	e9 7b ff ff ff       	jmp    22883 <http_parser_parse_url+0x2ca>
			if (s != s_http_userinfo) {
   22908:	83 f8 03             	cmp    $0x3,%eax
   2290b:	74 13                	je     22920 <http_parser_parse_url+0x367>
				u->field_data[UF_USERINFO].off = p - buf;
   2290d:	89 f0                	mov    %esi,%eax
				u->field_data[UF_USERINFO].len = 0;
   2290f:	66 c7 43 1e 00 00    	movw   $0x0,0x1e(%ebx)
				u->field_data[UF_USERINFO].off = p - buf;
   22915:	2b 45 08             	sub    0x8(%ebp),%eax
				u->field_set |= (1 << UF_USERINFO);
   22918:	66 83 0b 40          	orw    $0x40,(%ebx)
				u->field_data[UF_USERINFO].off = p - buf;
   2291c:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
			u->field_data[UF_USERINFO].len++;
   22920:	66 ff 43 1e          	incw   0x1e(%ebx)
   22924:	b8 03 00 00 00       	mov    $0x3,%eax
   22929:	e9 55 ff ff ff       	jmp    22883 <http_parser_parse_url+0x2ca>
				ch == '_' ||
   2292e:	b8 0a 00 00 00       	mov    $0xa,%eax
			u->field_data[UF_HOST].len++;
   22933:	66 ff 43 0a          	incw   0xa(%ebx)
			break;
   22937:	e9 47 ff ff ff       	jmp    22883 <http_parser_parse_url+0x2ca>
			if (s != s_http_host_port) {
   2293c:	83 f8 0c             	cmp    $0xc,%eax
   2293f:	74 13                	je     22954 <http_parser_parse_url+0x39b>
				u->field_data[UF_PORT].off = p - buf;
   22941:	89 f0                	mov    %esi,%eax
				u->field_data[UF_PORT].len = 0;
   22943:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
				u->field_data[UF_PORT].off = p - buf;
   22949:	2b 45 08             	sub    0x8(%ebp),%eax
				u->field_set |= (1 << UF_PORT);
   2294c:	66 83 0b 04          	orw    $0x4,(%ebx)
				u->field_data[UF_PORT].off = p - buf;
   22950:	66 89 43 0c          	mov    %ax,0xc(%ebx)
			u->field_data[UF_PORT].len++;
   22954:	66 ff 43 0e          	incw   0xe(%ebx)
			return s_http_host_port;
   22958:	b8 0c 00 00 00       	mov    $0xc,%eax
   2295d:	e9 21 ff ff ff       	jmp    22883 <http_parser_parse_url+0x2ca>
}
   22962:	8b 45 10             	mov    0x10(%ebp),%eax
   22965:	8d 65 f4             	lea    -0xc(%ebp),%esp
   22968:	5b                   	pop    %ebx
   22969:	5e                   	pop    %esi
   2296a:	5f                   	pop    %edi
   2296b:	5d                   	pop    %ebp
   2296c:	c3                   	ret    

0002296d <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
   2296d:	55                   	push   %ebp
   2296e:	89 e5                	mov    %esp,%ebp
   22970:	57                   	push   %edi
   22971:	56                   	push   %esi
   22972:	53                   	push   %ebx
   22973:	83 ec 10             	sub    $0x10,%esp
   22976:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
   22979:	8b 79 08             	mov    0x8(%ecx),%edi
		dev->driver_api = NULL;
		return -ENOTSUP;
	}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0U;
   2297c:	c6 47 09 00          	movb   $0x0,0x9(%edi)
	__asm__ volatile (
   22980:	9c                   	pushf  
   22981:	fa                   	cli    
   22982:	8f 45 e4             	popl   -0x1c(%ebp)

#ifdef CONFIG_UART_NS16550_PCP
	set_pcp(dev);
#endif

	set_baud_rate(dev, dev_data->baud_rate);
   22985:	8b 5f 04             	mov    0x4(%edi),%ebx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
   22988:	8b 71 08             	mov    0x8(%ecx),%esi
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
   2298b:	85 db                	test   %ebx,%ebx
   2298d:	74 43                	je     229d2 <uart_ns16550_init+0x65>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
   2298f:	8b 01                	mov    (%ecx),%eax
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
   22991:	8b 40 08             	mov    0x8(%eax),%eax
   22994:	8b 00                	mov    (%eax),%eax
   22996:	85 c0                	test   %eax,%eax
   22998:	74 38                	je     229d2 <uart_ns16550_init+0x65>
   2299a:	8b 16                	mov    (%esi),%edx
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
   2299c:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
   2299f:	83 c2 03             	add    $0x3,%edx
   229a2:	89 55 f0             	mov    %edx,-0x10(%ebp)
					/ baud_rate) >> 4;
   229a5:	31 d2                	xor    %edx,%edx
   229a7:	f7 f3                	div    %ebx
   229a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	__asm__ volatile("inb	%w1, %b0;\n\t"
   229ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
   229af:	ec                   	in     (%dx),%al
   229b0:	88 45 eb             	mov    %al,-0x15(%ebp)
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
   229b3:	83 c8 80             	or     $0xffffff80,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
   229b6:	ee                   	out    %al,(%dx)
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
   229b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   229ba:	8b 16                	mov    (%esi),%edx
   229bc:	c1 e8 04             	shr    $0x4,%eax
   229bf:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
   229c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   229c3:	42                   	inc    %edx
   229c4:	c1 e8 0c             	shr    $0xc,%eax
   229c7:	ee                   	out    %al,(%dx)
   229c8:	8a 45 eb             	mov    -0x15(%ebp),%al
   229cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
   229ce:	ee                   	out    %al,(%dx)
		dev_data->baud_rate = baud_rate;
   229cf:	89 5e 04             	mov    %ebx,0x4(%esi)

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
   229d2:	8b 1e                	mov    (%esi),%ebx
   229d4:	b0 03                	mov    $0x3,%al
   229d6:	8d 53 03             	lea    0x3(%ebx),%edx
   229d9:	ee                   	out    %al,(%dx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
   229da:	8a 47 08             	mov    0x8(%edi),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
   229dd:	8d 53 04             	lea    0x4(%ebx),%edx
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
   229e0:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
   229e3:	3c 01                	cmp    $0x1,%al
   229e5:	19 c0                	sbb    %eax,%eax
   229e7:	83 e0 e0             	and    $0xffffffe0,%eax
   229ea:	83 c0 2b             	add    $0x2b,%eax
   229ed:	ee                   	out    %al,(%dx)
   229ee:	b0 87                	mov    $0x87,%al
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
   229f0:	8d 53 02             	lea    0x2(%ebx),%edx
   229f3:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb	%w1, %b0;\n\t"
   229f4:	89 da                	mov    %ebx,%edx
   229f6:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
   229f7:	31 c0                	xor    %eax,%eax

	/* clear the port */
	INBYTE(RDR(dev));

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
   229f9:	8d 53 01             	lea    0x1(%ebx),%edx
   229fc:	ee                   	out    %al,(%dx)
   229fd:	0f ba 65 e4 09       	btl    $0x9,-0x1c(%ebp)
   22a02:	73 01                	jae    22a05 <uart_ns16550_init+0x98>
	__asm__ volatile (
   22a04:	fb                   	sti    

	irq_unlock(old_level);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
   22a05:	8b 01                	mov    (%ecx),%eax
   22a07:	8b 40 08             	mov    0x8(%eax),%eax
   22a0a:	51                   	push   %ecx
   22a0b:	ff 50 04             	call   *0x4(%eax)
   22a0e:	58                   	pop    %eax
#endif

	return 0;
}
   22a0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
   22a12:	31 c0                	xor    %eax,%eax
   22a14:	5b                   	pop    %ebx
   22a15:	5e                   	pop    %esi
   22a16:	5f                   	pop    %edi
   22a17:	5d                   	pop    %ebp
   22a18:	c3                   	ret    

00022a19 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
   22a19:	55                   	push   %ebp
   22a1a:	89 e5                	mov    %esp,%ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
   22a1c:	8b 45 08             	mov    0x8(%ebp),%eax
   22a1f:	8b 40 08             	mov    0x8(%eax),%eax
   22a22:	8b 08                	mov    (%eax),%ecx
   22a24:	8d 51 05             	lea    0x5(%ecx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22a27:	ec                   	in     (%dx),%al
   22a28:	88 c2                	mov    %al,%dl
   22a2a:	80 e2 01             	and    $0x1,%dl
   22a2d:	74 0c                	je     22a3b <uart_ns16550_poll_in+0x22>
   22a2f:	89 ca                	mov    %ecx,%edx
   22a31:	ec                   	in     (%dx),%al
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
   22a32:	8b 55 0c             	mov    0xc(%ebp),%edx
   22a35:	88 02                	mov    %al,(%edx)

	return 0;
   22a37:	31 c0                	xor    %eax,%eax
   22a39:	eb 03                	jmp    22a3e <uart_ns16550_poll_in+0x25>
   22a3b:	83 c8 ff             	or     $0xffffffff,%eax
}
   22a3e:	5d                   	pop    %ebp
   22a3f:	c3                   	ret    

00022a40 <uart_ns16550_poll_out>:
 * @param dev UART device struct
 * @param c Character to send
 */
static void uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
   22a40:	55                   	push   %ebp
   22a41:	89 e5                	mov    %esp,%ebp
   22a43:	53                   	push   %ebx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0)
   22a44:	8b 45 08             	mov    0x8(%ebp),%eax
{
   22a47:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0)
   22a4a:	8b 40 08             	mov    0x8(%eax),%eax
   22a4d:	8b 08                	mov    (%eax),%ecx
   22a4f:	8d 51 05             	lea    0x5(%ecx),%edx
   22a52:	ec                   	in     (%dx),%al
   22a53:	a8 20                	test   $0x20,%al
   22a55:	74 fb                	je     22a52 <uart_ns16550_poll_out+0x12>
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22a57:	88 d8                	mov    %bl,%al
   22a59:	89 ca                	mov    %ecx,%edx
   22a5b:	ee                   	out    %al,(%dx)
		;

	OUTBYTE(THR(dev), c);
}
   22a5c:	5b                   	pop    %ebx
   22a5d:	5d                   	pop    %ebp
   22a5e:	c3                   	ret    

00022a5f <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
   22a5f:	55                   	push   %ebp
   22a60:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
   22a62:	8b 45 08             	mov    0x8(%ebp),%eax
   22a65:	8b 40 08             	mov    0x8(%eax),%eax
   22a68:	8b 00                	mov    (%eax),%eax
   22a6a:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22a6d:	ec                   	in     (%dx),%al
   22a6e:	d1 e8                	shr    %eax
}
   22a70:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
   22a71:	83 e0 0f             	and    $0xf,%eax
}
   22a74:	c3                   	ret    

00022a75 <uart_ns16550_fifo_fill>:
 *
 * @return Number of bytes sent
 */
static int uart_ns16550_fifo_fill(struct device *dev, const u8_t *tx_data,
				  int size)
{
   22a75:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
   22a76:	31 c9                	xor    %ecx,%ecx
{
   22a78:	89 e5                	mov    %esp,%ebp
   22a7a:	57                   	push   %edi
   22a7b:	56                   	push   %esi
   22a7c:	53                   	push   %ebx
   22a7d:	8b 75 08             	mov    0x8(%ebp),%esi
   22a80:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
   22a83:	3b 4d 10             	cmp    0x10(%ebp),%ecx
   22a86:	7d 16                	jge    22a9e <uart_ns16550_fifo_fill+0x29>
   22a88:	8b 46 08             	mov    0x8(%esi),%eax
   22a8b:	8b 18                	mov    (%eax),%ebx
   22a8d:	8d 53 05             	lea    0x5(%ebx),%edx
   22a90:	ec                   	in     (%dx),%al
   22a91:	a8 20                	test   $0x20,%al
   22a93:	74 09                	je     22a9e <uart_ns16550_fifo_fill+0x29>
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22a95:	8a 04 0f             	mov    (%edi,%ecx,1),%al
   22a98:	89 da                	mov    %ebx,%edx
   22a9a:	ee                   	out    %al,(%dx)
   22a9b:	41                   	inc    %ecx
   22a9c:	eb e5                	jmp    22a83 <uart_ns16550_fifo_fill+0xe>
		OUTBYTE(THR(dev), tx_data[i]);
	}
	return i;
}
   22a9e:	5b                   	pop    %ebx
   22a9f:	89 c8                	mov    %ecx,%eax
   22aa1:	5e                   	pop    %esi
   22aa2:	5f                   	pop    %edi
   22aa3:	5d                   	pop    %ebp
   22aa4:	c3                   	ret    

00022aa5 <uart_ns16550_fifo_read>:
 *
 * @return Number of bytes read
 */
static int uart_ns16550_fifo_read(struct device *dev, u8_t *rx_data,
				  const int size)
{
   22aa5:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
   22aa6:	31 c9                	xor    %ecx,%ecx
{
   22aa8:	89 e5                	mov    %esp,%ebp
   22aaa:	56                   	push   %esi
   22aab:	53                   	push   %ebx
   22aac:	8b 75 08             	mov    0x8(%ebp),%esi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
   22aaf:	3b 4d 10             	cmp    0x10(%ebp),%ecx
   22ab2:	7d 19                	jge    22acd <uart_ns16550_fifo_read+0x28>
   22ab4:	8b 46 08             	mov    0x8(%esi),%eax
   22ab7:	8b 18                	mov    (%eax),%ebx
   22ab9:	8d 53 05             	lea    0x5(%ebx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22abc:	ec                   	in     (%dx),%al
   22abd:	a8 01                	test   $0x1,%al
   22abf:	74 0c                	je     22acd <uart_ns16550_fifo_read+0x28>
   22ac1:	89 da                	mov    %ebx,%edx
   22ac3:	ec                   	in     (%dx),%al
		rx_data[i] = INBYTE(RDR(dev));
   22ac4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   22ac7:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
   22aca:	41                   	inc    %ecx
   22acb:	eb e2                	jmp    22aaf <uart_ns16550_fifo_read+0xa>
	}

	return i;
}
   22acd:	5b                   	pop    %ebx
   22ace:	89 c8                	mov    %ecx,%eax
   22ad0:	5e                   	pop    %esi
   22ad1:	5d                   	pop    %ebp
   22ad2:	c3                   	ret    

00022ad3 <uart_ns16550_irq_tx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(struct device *dev)
{
   22ad3:	55                   	push   %ebp
   22ad4:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
   22ad6:	8b 45 08             	mov    0x8(%ebp),%eax
   22ad9:	8b 40 08             	mov    0x8(%eax),%eax
   22adc:	8b 10                	mov    (%eax),%edx
   22ade:	42                   	inc    %edx
   22adf:	ec                   	in     (%dx),%al
   22ae0:	83 c8 02             	or     $0x2,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22ae3:	ee                   	out    %al,(%dx)
}
   22ae4:	5d                   	pop    %ebp
   22ae5:	c3                   	ret    

00022ae6 <uart_ns16550_irq_tx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(struct device *dev)
{
   22ae6:	55                   	push   %ebp
   22ae7:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
   22ae9:	8b 45 08             	mov    0x8(%ebp),%eax
   22aec:	8b 40 08             	mov    0x8(%eax),%eax
   22aef:	8b 10                	mov    (%eax),%edx
   22af1:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22af2:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22af3:	83 e0 fd             	and    $0xfffffffd,%eax
   22af6:	ee                   	out    %al,(%dx)
}
   22af7:	5d                   	pop    %ebp
   22af8:	c3                   	ret    

00022af9 <uart_ns16550_irq_tx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(struct device *dev)
{
   22af9:	55                   	push   %ebp
   22afa:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
   22afc:	8b 45 08             	mov    0x8(%ebp),%eax
}
   22aff:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
   22b00:	8b 40 08             	mov    0x8(%eax),%eax
   22b03:	8a 40 09             	mov    0x9(%eax),%al
   22b06:	83 e0 06             	and    $0x6,%eax
   22b09:	3c 02                	cmp    $0x2,%al
   22b0b:	0f 94 c0             	sete   %al
   22b0e:	0f b6 c0             	movzbl %al,%eax
}
   22b11:	c3                   	ret    

00022b12 <uart_ns16550_irq_tx_complete>:
 * @param dev UART device struct
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_complete(struct device *dev)
{
   22b12:	55                   	push   %ebp
   22b13:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
   22b15:	8b 45 08             	mov    0x8(%ebp),%eax
   22b18:	8b 40 08             	mov    0x8(%eax),%eax
   22b1b:	8b 00                	mov    (%eax),%eax
   22b1d:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22b20:	ec                   	in     (%dx),%al
   22b21:	83 e0 60             	and    $0x60,%eax
}
   22b24:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
   22b25:	3c 60                	cmp    $0x60,%al
   22b27:	0f 94 c0             	sete   %al
   22b2a:	0f b6 c0             	movzbl %al,%eax
}
   22b2d:	c3                   	ret    

00022b2e <uart_ns16550_irq_rx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(struct device *dev)
{
   22b2e:	55                   	push   %ebp
   22b2f:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
   22b31:	8b 45 08             	mov    0x8(%ebp),%eax
   22b34:	8b 40 08             	mov    0x8(%eax),%eax
   22b37:	8b 10                	mov    (%eax),%edx
   22b39:	42                   	inc    %edx
   22b3a:	ec                   	in     (%dx),%al
   22b3b:	83 c8 01             	or     $0x1,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22b3e:	ee                   	out    %al,(%dx)
}
   22b3f:	5d                   	pop    %ebp
   22b40:	c3                   	ret    

00022b41 <uart_ns16550_irq_rx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(struct device *dev)
{
   22b41:	55                   	push   %ebp
   22b42:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
   22b44:	8b 45 08             	mov    0x8(%ebp),%eax
   22b47:	8b 40 08             	mov    0x8(%eax),%eax
   22b4a:	8b 10                	mov    (%eax),%edx
   22b4c:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22b4d:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22b4e:	83 e0 fe             	and    $0xfffffffe,%eax
   22b51:	ee                   	out    %al,(%dx)
}
   22b52:	5d                   	pop    %ebp
   22b53:	c3                   	ret    

00022b54 <uart_ns16550_irq_rx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(struct device *dev)
{
   22b54:	55                   	push   %ebp
   22b55:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
   22b57:	8b 45 08             	mov    0x8(%ebp),%eax
}
   22b5a:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
   22b5b:	8b 40 08             	mov    0x8(%eax),%eax
   22b5e:	8a 40 09             	mov    0x9(%eax),%al
   22b61:	83 e0 06             	and    $0x6,%eax
   22b64:	3c 04                	cmp    $0x4,%al
   22b66:	0f 94 c0             	sete   %al
   22b69:	0f b6 c0             	movzbl %al,%eax
}
   22b6c:	c3                   	ret    

00022b6d <uart_ns16550_irq_err_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(struct device *dev)
{
   22b6d:	55                   	push   %ebp
   22b6e:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
   22b70:	8b 45 08             	mov    0x8(%ebp),%eax
   22b73:	8b 40 08             	mov    0x8(%eax),%eax
   22b76:	8b 10                	mov    (%eax),%edx
   22b78:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22b79:	ec                   	in     (%dx),%al
   22b7a:	83 c8 04             	or     $0x4,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22b7d:	ee                   	out    %al,(%dx)
}
   22b7e:	5d                   	pop    %ebp
   22b7f:	c3                   	ret    

00022b80 <uart_ns16550_irq_err_disable>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(struct device *dev)
{
   22b80:	55                   	push   %ebp
   22b81:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
   22b83:	8b 45 08             	mov    0x8(%ebp),%eax
   22b86:	8b 40 08             	mov    0x8(%eax),%eax
   22b89:	8b 10                	mov    (%eax),%edx
   22b8b:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22b8c:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
   22b8d:	83 e0 fb             	and    $0xfffffffb,%eax
   22b90:	ee                   	out    %al,(%dx)
}
   22b91:	5d                   	pop    %ebp
   22b92:	c3                   	ret    

00022b93 <uart_ns16550_irq_is_pending>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(struct device *dev)
{
   22b93:	55                   	push   %ebp
   22b94:	89 e5                	mov    %esp,%ebp
	return (!(IIRC(dev) & IIR_NIP));
   22b96:	8b 45 08             	mov    0x8(%ebp),%eax
}
   22b99:	5d                   	pop    %ebp
	return (!(IIRC(dev) & IIR_NIP));
   22b9a:	8b 40 08             	mov    0x8(%eax),%eax
   22b9d:	8a 40 09             	mov    0x9(%eax),%al
   22ba0:	f7 d0                	not    %eax
   22ba2:	83 e0 01             	and    $0x1,%eax
}
   22ba5:	c3                   	ret    

00022ba6 <uart_ns16550_irq_update>:
 * @param dev UART device struct
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(struct device *dev)
{
   22ba6:	55                   	push   %ebp
   22ba7:	89 e5                	mov    %esp,%ebp
	IIRC(dev) = INBYTE(IIR(dev));
   22ba9:	8b 45 08             	mov    0x8(%ebp),%eax
   22bac:	8b 48 08             	mov    0x8(%eax),%ecx
   22baf:	8b 01                	mov    (%ecx),%eax
   22bb1:	8d 50 02             	lea    0x2(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
   22bb4:	ec                   	in     (%dx),%al
   22bb5:	88 41 09             	mov    %al,0x9(%ecx)

	return 1;
}
   22bb8:	b8 01 00 00 00       	mov    $0x1,%eax
   22bbd:	5d                   	pop    %ebp
   22bbe:	c3                   	ret    

00022bbf <uart_ns16550_irq_callback_set>:
 * @return N/A
 */
static void uart_ns16550_irq_callback_set(struct device *dev,
					  uart_irq_callback_user_data_t cb,
					  void *cb_data)
{
   22bbf:	55                   	push   %ebp
   22bc0:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
   22bc2:	8b 45 08             	mov    0x8(%ebp),%eax

	dev_data->cb = cb;
   22bc5:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
   22bc8:	8b 40 08             	mov    0x8(%eax),%eax
	dev_data->cb = cb;
   22bcb:	89 50 0c             	mov    %edx,0xc(%eax)
	dev_data->cb_data = cb_data;
   22bce:	8b 55 10             	mov    0x10(%ebp),%edx
   22bd1:	89 50 10             	mov    %edx,0x10(%eax)
}
   22bd4:	5d                   	pop    %ebp
   22bd5:	c3                   	ret    

00022bd6 <uart_ns16550_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_ns16550_isr(void *arg)
{
   22bd6:	55                   	push   %ebp
   22bd7:	89 e5                	mov    %esp,%ebp
	struct device *dev = arg;
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
   22bd9:	8b 45 08             	mov    0x8(%ebp),%eax
   22bdc:	8b 50 08             	mov    0x8(%eax),%edx

	if (dev_data->cb) {
   22bdf:	8b 42 0c             	mov    0xc(%edx),%eax
   22be2:	85 c0                	test   %eax,%eax
   22be4:	74 09                	je     22bef <uart_ns16550_isr+0x19>
		dev_data->cb(dev_data->cb_data);
   22be6:	8b 52 10             	mov    0x10(%edx),%edx
   22be9:	89 55 08             	mov    %edx,0x8(%ebp)
	}
}
   22bec:	5d                   	pop    %ebp
		dev_data->cb(dev_data->cb_data);
   22bed:	ff e0                	jmp    *%eax
}
   22bef:	5d                   	pop    %ebp
   22bf0:	c3                   	ret    

00022bf1 <irq_config_func_0>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_0(struct device *dev)
{
   22bf1:	55                   	push   %ebp
   22bf2:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	IRQ_CONNECT(DT_UART_NS16550_PORT_0_IRQ,
   22bf4:	0f b6 05 f4 b2 02 00 	movzbl 0x2b2f4,%eax
	__irq_controller_irq_config(vector, irq, flags);
   22bfb:	6a 00                	push   $0x0
   22bfd:	6a 04                	push   $0x4
   22bff:	50                   	push   %eax
   22c00:	e8 87 6d fe ff       	call   998c <__irq_controller_irq_config>
   22c05:	83 c4 0c             	add    $0xc,%esp
		    DT_UART_NS16550_PORT_0_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_0),
		    DT_UART_NS16550_PORT_0_IRQ_FLAGS);
	irq_enable(DT_UART_NS16550_PORT_0_IRQ);
   22c08:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
   22c0f:	c9                   	leave  
	irq_enable(DT_UART_NS16550_PORT_0_IRQ);
   22c10:	e9 9d 6d fe ff       	jmp    99b2 <z_arch_irq_enable>

00022c15 <uart_ns16550_isr_irq4_stub>:
   22c15:	68 84 a7 40 00       	push   $0x40a784
   22c1a:	68 d6 2b 02 00       	push   $0x22bd6
   22c1f:	e9 51 73 fe ff       	jmp    9f75 <_interrupt_enter>

00022c24 <uart_ns16550_isr_irq3_stub>:
   22c24:	68 78 a7 40 00       	push   $0x40a778
   22c29:	68 d6 2b 02 00       	push   $0x22bd6
   22c2e:	e9 42 73 fe ff       	jmp    9f75 <_interrupt_enter>

00022c33 <irq_config_func_1>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_1(struct device *dev)
{
   22c33:	55                   	push   %ebp
   22c34:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	IRQ_CONNECT(DT_UART_NS16550_PORT_1_IRQ,
   22c36:	0f b6 05 f3 b2 02 00 	movzbl 0x2b2f3,%eax
   22c3d:	6a 00                	push   $0x0
   22c3f:	6a 03                	push   $0x3
   22c41:	50                   	push   %eax
   22c42:	e8 45 6d fe ff       	call   998c <__irq_controller_irq_config>
   22c47:	83 c4 0c             	add    $0xc,%esp
		    DT_UART_NS16550_PORT_1_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_1),
		    DT_UART_NS16550_PORT_1_IRQ_FLAGS);
	irq_enable(DT_UART_NS16550_PORT_1_IRQ);
   22c4a:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)
}
   22c51:	c9                   	leave  
	irq_enable(DT_UART_NS16550_PORT_1_IRQ);
   22c52:	e9 5b 6d fe ff       	jmp    99b2 <z_arch_irq_enable>

00022c57 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
   22c57:	55                   	push   %ebp
   22c58:	89 e5                	mov    %esp,%ebp
   22c5a:	56                   	push   %esi
   22c5b:	53                   	push   %ebx
   22c5c:	8b 75 08             	mov    0x8(%ebp),%esi
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   22c5f:	8b 1c b5 28 66 02 00 	mov    0x26628(,%esi,4),%ebx
   22c66:	39 1c b5 2c 66 02 00 	cmp    %ebx,0x2662c(,%esi,4)
   22c6d:	76 17                	jbe    22c86 <z_sys_device_do_config_level+0x2f>
								info++) {
		int retval;
		struct device_config *device_conf = info->config;

		retval = device_conf->init(info);
   22c6f:	8b 03                	mov    (%ebx),%eax
   22c71:	53                   	push   %ebx
   22c72:	ff 50 04             	call   *0x4(%eax)
   22c75:	5a                   	pop    %edx
		if (retval != 0) {
   22c76:	85 c0                	test   %eax,%eax
   22c78:	74 07                	je     22c81 <z_sys_device_do_config_level+0x2a>
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   22c7a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
								info++) {
   22c81:	83 c3 0c             	add    $0xc,%ebx
   22c84:	eb e0                	jmp    22c66 <z_sys_device_do_config_level+0xf>
		} else {
			z_object_init(info);
		}
	}
}
   22c86:	8d 65 f8             	lea    -0x8(%ebp),%esp
   22c89:	5b                   	pop    %ebx
   22c8a:	5e                   	pop    %esi
   22c8b:	5d                   	pop    %ebp
   22c8c:	c3                   	ret    

00022c8d <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
   22c8d:	55                   	push   %ebp
   22c8e:	89 e5                	mov    %esp,%ebp
   22c90:	56                   	push   %esi
   22c91:	53                   	push   %ebx
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   22c92:	bb 30 a7 40 00       	mov    $0x40a730,%ebx
{
   22c97:	8b 75 08             	mov    0x8(%ebp),%esi
	for (info = __device_init_start; info != __device_init_end; info++) {
   22c9a:	81 fb 5c a8 40 00    	cmp    $0x40a85c,%ebx
   22ca0:	74 11                	je     22cb3 <z_impl_device_get_binding+0x26>
		if ((info->driver_api != NULL) &&
   22ca2:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
   22ca6:	74 06                	je     22cae <z_impl_device_get_binding+0x21>
		    (info->config->name == name)) {
   22ca8:	8b 03                	mov    (%ebx),%eax
		if ((info->driver_api != NULL) &&
   22caa:	39 30                	cmp    %esi,(%eax)
   22cac:	74 31                	je     22cdf <z_impl_device_get_binding+0x52>
	for (info = __device_init_start; info != __device_init_end; info++) {
   22cae:	83 c3 0c             	add    $0xc,%ebx
   22cb1:	eb e7                	jmp    22c9a <z_impl_device_get_binding+0xd>
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   22cb3:	bb 30 a7 40 00       	mov    $0x40a730,%ebx
   22cb8:	81 fb 5c a8 40 00    	cmp    $0x40a85c,%ebx
   22cbe:	74 1d                	je     22cdd <z_impl_device_get_binding+0x50>
		if (info->driver_api == NULL) {
   22cc0:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
   22cc4:	75 05                	jne    22ccb <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   22cc6:	83 c3 0c             	add    $0xc,%ebx
   22cc9:	eb ed                	jmp    22cb8 <z_impl_device_get_binding+0x2b>
			continue;
		}

		if (strcmp(name, info->config->name) == 0) {
   22ccb:	8b 03                	mov    (%ebx),%eax
   22ccd:	ff 30                	pushl  (%eax)
   22ccf:	56                   	push   %esi
   22cd0:	e8 a1 7b fe ff       	call   a876 <strcmp>
   22cd5:	5a                   	pop    %edx
   22cd6:	85 c0                	test   %eax,%eax
   22cd8:	59                   	pop    %ecx
   22cd9:	75 eb                	jne    22cc6 <z_impl_device_get_binding+0x39>
   22cdb:	eb 02                	jmp    22cdf <z_impl_device_get_binding+0x52>
			return info;
		}
	}

	return NULL;
   22cdd:	31 db                	xor    %ebx,%ebx
}
   22cdf:	8d 65 f8             	lea    -0x8(%ebp),%esp
   22ce2:	89 d8                	mov    %ebx,%eax
   22ce4:	5b                   	pop    %ebx
   22ce5:	5e                   	pop    %esi
   22ce6:	5d                   	pop    %ebp
   22ce7:	c3                   	ret    

00022ce8 <z_impl_z_errno>:

Z_SYSCALL_HANDLER0_SIMPLE(z_errno);
#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   22ce8:	a1 28 41 40 00       	mov    0x404128,%eax
   22ced:	83 c0 34             	add    $0x34,%eax
}
   22cf0:	c3                   	ret    

00022cf1 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   22cf1:	55                   	push   %ebp
   22cf2:	89 e5                	mov    %esp,%ebp
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   22cf4:	6a 02                	push   $0x2
   22cf6:	e8 5c ff ff ff       	call   22c57 <z_sys_device_do_config_level>
	if (boot_delay > 0) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
   22cfb:	c7 04 24 8c aa 02 00 	movl   $0x2aa8c,(%esp)
   22d02:	e8 c3 fe fd ff       	call   2bca <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   22d07:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
   22d0e:	e8 44 ff ff ff       	call   22c57 <z_sys_device_do_config_level>
   22d13:	58                   	pop    %eax
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   22d14:	e8 9e 15 00 00       	call   242b7 <z_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
   22d19:	e8 69 e9 fd ff       	call   1687 <main>

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
   22d1e:	80 25 ec 40 40 00 fe 	andb   $0xfe,0x4040ec
}
   22d25:	c9                   	leave  
   22d26:	c3                   	ret    

00022d27 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   22d27:	55                   	push   %ebp
   22d28:	89 e5                	mov    %esp,%ebp
   22d2a:	57                   	push   %edi
   22d2b:	83 ec 3c             	sub    $0x3c,%esp
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	if (IS_ENABLED(CONFIG_LOG)) {
		log_core_init();
   22d2e:	e8 4d 05 fe ff       	call   3280 <log_core_init>

	/* perform any architecture-specific initialization */
	kernel_arch_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   22d33:	8d 7d c0             	lea    -0x40(%ebp),%edi
   22d36:	31 c0                	xor    %eax,%eax
   22d38:	b9 0f 00 00 00       	mov    $0xf,%ecx
   22d3d:	f3 ab                	rep stos %eax,%es:(%edi)
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   22d3f:	6a 00                	push   $0x0
	_current = &dummy_thread;
   22d41:	8d 45 c0             	lea    -0x40(%ebp),%eax
   22d44:	a3 28 41 40 00       	mov    %eax,0x404128
 *
 * @return N/A
 */
static inline void kernel_arch_init(void)
{
	_kernel.nested = 0;
   22d49:	c7 05 20 41 40 00 00 	movl   $0x0,0x404120
   22d50:	00 00 00 
	_kernel.irq_stack = K_THREAD_STACK_BUFFER(_interrupt_stack) +
   22d53:	c7 05 24 41 40 00 10 	movl   $0x409210,0x404124
   22d5a:	92 40 00 
	struct k_thread dummy_thread = {
   22d5d:	c6 45 cd 01          	movb   $0x1,-0x33(%ebp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   22d61:	e8 f1 fe ff ff       	call   22c57 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   22d66:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
   22d6d:	e8 e5 fe ff ff       	call   22c57 <z_sys_device_do_config_level>
   22d72:	59                   	pop    %ecx
	dummy_thread->base.user_options = K_ESSENTIAL;
   22d73:	66 c7 45 cc 01 01    	movw   $0x101,-0x34(%ebp)
	z_sched_init();
   22d79:	e8 96 10 00 00       	call   23e14 <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
   22d7e:	68 ca aa 02 00       	push   $0x2aaca
	_kernel.ready_q.cache = _main_thread;
   22d83:	c7 05 40 41 40 00 e0 	movl   $0x4040e0,0x404140
   22d8a:	40 40 00 
	z_setup_new_thread(_main_thread, _main_stack,
   22d8d:	6a 01                	push   $0x1
   22d8f:	6a 00                	push   $0x0
   22d91:	6a 00                	push   $0x0
   22d93:	6a 00                	push   $0x0
   22d95:	6a 00                	push   $0x0
   22d97:	68 f1 2c 02 00       	push   $0x22cf1
   22d9c:	68 00 04 00 00       	push   $0x400
   22da1:	68 10 86 40 00       	push   $0x408610
   22da6:	68 e0 40 40 00       	push   $0x4040e0
   22dab:	e8 34 14 00 00       	call   241e4 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   22db0:	a0 ed 40 40 00       	mov    0x4040ed,%al
   22db5:	83 c4 28             	add    $0x28,%esp
   22db8:	88 c2                	mov    %al,%dl
   22dba:	83 e2 fb             	and    $0xfffffffb,%edx
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   22dbd:	a8 1b                	test   $0x1b,%al
	thread->base.thread_state &= ~_THREAD_PRESTART;
   22dbf:	88 15 ed 40 40 00    	mov    %dl,0x4040ed
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   22dc5:	75 14                	jne    22ddb <z_cstart+0xb4>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   22dc7:	83 3d f8 40 40 00 00 	cmpl   $0x0,0x4040f8
   22dce:	75 0b                	jne    22ddb <z_cstart+0xb4>
		z_add_thread_to_ready_q(thread);
   22dd0:	68 e0 40 40 00       	push   $0x4040e0
   22dd5:	e8 ec 0c 00 00       	call   23ac6 <z_add_thread_to_ready_q>
   22dda:	5a                   	pop    %edx
	z_setup_new_thread(thr, stack,
   22ddb:	68 cf aa 02 00       	push   $0x2aacf
   22de0:	6a 01                	push   $0x1
   22de2:	6a 0f                	push   $0xf
   22de4:	6a 00                	push   $0x0
   22de6:	6a 00                	push   $0x0
   22de8:	6a 00                	push   $0x0
   22dea:	68 f9 4c 02 00       	push   $0x24cf9
   22def:	68 00 01 00 00       	push   $0x100
   22df4:	68 10 85 40 00       	push   $0x408510
   22df9:	68 a0 40 40 00       	push   $0x4040a0
   22dfe:	e8 e1 13 00 00       	call   241e4 <z_setup_new_thread>
   22e03:	83 c4 28             	add    $0x28,%esp
	_kernel.cpus[0].idle_thread = _idle_thread;
   22e06:	c7 05 2c 41 40 00 a0 	movl   $0x4040a0,0x40412c
   22e0d:	40 40 00 
	thread->base.thread_state &= ~_THREAD_PRESTART;
   22e10:	80 25 ad 40 40 00 fb 	andb   $0xfb,0x4040ad
	list->head = (sys_dnode_t *)list;
   22e17:	c7 05 38 41 40 00 38 	movl   $0x404138,0x404138
   22e1e:	41 40 00 
	list->tail = (sys_dnode_t *)list;
   22e21:	c7 05 3c 41 40 00 38 	movl   $0x404138,0x40413c
   22e28:	41 40 00 
	__asm__ volatile (
   22e2b:	9c                   	pushf  
   22e2c:	fa                   	cli    
   22e2d:	58                   	pop    %eax
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
   22e2e:	50                   	push   %eax
   22e2f:	e8 aa 71 fe ff       	call   9fde <__swap>
   22e34:	58                   	pop    %eax

00022e35 <init_mem_slab_module>:
{
	ARG_UNUSED(dev);

	struct k_mem_slab *slab;

	for (slab = _k_mem_slab_list_start;
   22e35:	b8 00 a9 40 00       	mov    $0x40a900,%eax
   22e3a:	3d 6c a9 40 00       	cmp    $0x40a96c,%eax
   22e3f:	72 03                	jb     22e44 <init_mem_slab_module+0xf>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
   22e41:	31 c0                	xor    %eax,%eax
   22e43:	c3                   	ret    
{
   22e44:	55                   	push   %ebp
   22e45:	89 e5                	mov    %esp,%ebp
   22e47:	56                   	push   %esi
   22e48:	53                   	push   %ebx
	slab->free_list = NULL;
   22e49:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	p = slab->buffer;
   22e50:	8b 50 18             	mov    0x18(%eax),%edx
	for (j = 0U; j < slab->num_blocks; j++) {
   22e53:	8b 58 10             	mov    0x10(%eax),%ebx
   22e56:	31 c9                	xor    %ecx,%ecx
   22e58:	39 d9                	cmp    %ebx,%ecx
   22e5a:	74 0e                	je     22e6a <init_mem_slab_module+0x35>
		*(char **)p = slab->free_list;
   22e5c:	8b 70 1c             	mov    0x1c(%eax),%esi
	for (j = 0U; j < slab->num_blocks; j++) {
   22e5f:	41                   	inc    %ecx
		*(char **)p = slab->free_list;
   22e60:	89 32                	mov    %esi,(%edx)
		slab->free_list = p;
   22e62:	89 50 1c             	mov    %edx,0x1c(%eax)
		p += slab->block_size;
   22e65:	03 50 14             	add    0x14(%eax),%edx
   22e68:	eb ee                	jmp    22e58 <init_mem_slab_module+0x23>
	     slab++) {
   22e6a:	83 c0 24             	add    $0x24,%eax
	for (slab = _k_mem_slab_list_start;
   22e6d:	3d 6c a9 40 00       	cmp    $0x40a96c,%eax
   22e72:	72 d5                	jb     22e49 <init_mem_slab_module+0x14>
}
   22e74:	5b                   	pop    %ebx
   22e75:	31 c0                	xor    %eax,%eax
   22e77:	5e                   	pop    %esi
   22e78:	5d                   	pop    %ebp
   22e79:	c3                   	ret    

00022e7a <k_mem_slab_init>:
SYS_INIT(init_mem_slab_module, PRE_KERNEL_1,
	 CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, u32_t num_blocks)
{
   22e7a:	55                   	push   %ebp
	for (j = 0U; j < slab->num_blocks; j++) {
   22e7b:	31 c9                	xor    %ecx,%ecx
{
   22e7d:	89 e5                	mov    %esp,%ebp
   22e7f:	57                   	push   %edi
   22e80:	56                   	push   %esi
   22e81:	8b 55 08             	mov    0x8(%ebp),%edx
   22e84:	53                   	push   %ebx
   22e85:	8b 45 0c             	mov    0xc(%ebp),%eax
   22e88:	8b 75 10             	mov    0x10(%ebp),%esi
   22e8b:	8b 5d 14             	mov    0x14(%ebp),%ebx
	/* block size must be word aligned */
	__ASSERT((slab->block_size & (sizeof(void *) - 1)) == 0,
		 "block size not word aligned");

	slab->num_blocks = num_blocks;
	slab->block_size = block_size;
   22e8e:	89 72 14             	mov    %esi,0x14(%edx)
	slab->num_blocks = num_blocks;
   22e91:	89 5a 10             	mov    %ebx,0x10(%edx)
	slab->buffer = buffer;
   22e94:	89 42 18             	mov    %eax,0x18(%edx)
	slab->num_used = 0;
   22e97:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
	slab->free_list = NULL;
   22e9e:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	for (j = 0U; j < slab->num_blocks; j++) {
   22ea5:	39 cb                	cmp    %ecx,%ebx
   22ea7:	74 0d                	je     22eb6 <k_mem_slab_init+0x3c>
		*(char **)p = slab->free_list;
   22ea9:	8b 7a 1c             	mov    0x1c(%edx),%edi
	for (j = 0U; j < slab->num_blocks; j++) {
   22eac:	41                   	inc    %ecx
		*(char **)p = slab->free_list;
   22ead:	89 38                	mov    %edi,(%eax)
		slab->free_list = p;
   22eaf:	89 42 1c             	mov    %eax,0x1c(%edx)
		p += slab->block_size;
   22eb2:	01 f0                	add    %esi,%eax
   22eb4:	eb ef                	jmp    22ea5 <k_mem_slab_init+0x2b>
#define _WAIT_Q_FOR_EACH(wq, thread_ptr) \
	RB_FOR_EACH_CONTAINER(&(wq)->waitq.tree, thread_ptr, base.qnode_rb)

static inline void z_waitq_init(_wait_q_t *w)
{
	w->waitq = (struct _priq_rb) {
   22eb6:	b9 04 00 00 00       	mov    $0x4,%ecx
   22ebb:	31 c0                	xor    %eax,%eax
   22ebd:	89 d7                	mov    %edx,%edi
   22ebf:	f3 ab                	rep stos %eax,%es:(%edi)
   22ec1:	c7 42 04 07 38 02 00 	movl   $0x23807,0x4(%edx)
	create_free_list(slab);
	z_waitq_init(&slab->wait_q);
	SYS_TRACING_OBJ_INIT(k_mem_slab, slab);

	z_object_init(slab);
}
   22ec8:	5b                   	pop    %ebx
   22ec9:	5e                   	pop    %esi
   22eca:	5f                   	pop    %edi
   22ecb:	5d                   	pop    %ebp
   22ecc:	c3                   	ret    

00022ecd <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   22ecd:	55                   	push   %ebp
   22ece:	89 e5                	mov    %esp,%ebp
   22ed0:	56                   	push   %esi
   22ed1:	53                   	push   %ebx
   22ed2:	8b 45 08             	mov    0x8(%ebp),%eax
   22ed5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   22ed8:	8b 75 10             	mov    0x10(%ebp),%esi
   22edb:	9c                   	pushf  
   22edc:	fa                   	cli    
   22edd:	59                   	pop    %ecx

	/* block size must be word aligned */
	__ASSERT((slab->block_size & (sizeof(void *) - 1)) == 0,
		 "block size not word aligned");

	if (slab->free_list != NULL) {
   22ede:	8b 50 1c             	mov    0x1c(%eax),%edx
   22ee1:	85 d2                	test   %edx,%edx
   22ee3:	74 0e                	je     22ef3 <k_mem_slab_alloc+0x26>
		/* take a free block */
		*mem = slab->free_list;
   22ee5:	89 13                	mov    %edx,(%ebx)
		slab->free_list = *(char **)(slab->free_list);
   22ee7:	8b 12                	mov    (%edx),%edx
		slab->num_used++;
   22ee9:	ff 40 20             	incl   0x20(%eax)
		slab->free_list = *(char **)(slab->free_list);
   22eec:	89 50 1c             	mov    %edx,0x1c(%eax)
		result = 0;
   22eef:	31 c0                	xor    %eax,%eax
   22ef1:	eb 32                	jmp    22f25 <k_mem_slab_alloc+0x58>
	} else if (timeout == K_NO_WAIT) {
   22ef3:	85 f6                	test   %esi,%esi
   22ef5:	75 0d                	jne    22f04 <k_mem_slab_alloc+0x37>
		/* don't wait for a free block to become available */
		*mem = NULL;
   22ef7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		result = -ENOMEM;
   22efd:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   22f02:	eb 21                	jmp    22f25 <k_mem_slab_alloc+0x58>
	} else {
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   22f04:	56                   	push   %esi
   22f05:	50                   	push   %eax
   22f06:	51                   	push   %ecx
   22f07:	68 65 45 40 00       	push   $0x404565
   22f0c:	e8 d2 0d 00 00       	call   23ce3 <z_pend_curr>
   22f11:	83 c4 10             	add    $0x10,%esp
		if (result == 0) {
   22f14:	85 c0                	test   %eax,%eax
   22f16:	75 14                	jne    22f2c <k_mem_slab_alloc+0x5f>
			*mem = _current->base.swap_data;
   22f18:	8b 15 28 41 40 00    	mov    0x404128,%edx
   22f1e:	8b 52 14             	mov    0x14(%edx),%edx
   22f21:	89 13                	mov    %edx,(%ebx)
   22f23:	eb 07                	jmp    22f2c <k_mem_slab_alloc+0x5f>
   22f25:	0f ba e1 09          	bt     $0x9,%ecx
   22f29:	73 01                	jae    22f2c <k_mem_slab_alloc+0x5f>
	__asm__ volatile (
   22f2b:	fb                   	sti    
	}

	k_spin_unlock(&lock, key);

	return result;
}
   22f2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   22f2f:	5b                   	pop    %ebx
   22f30:	5e                   	pop    %esi
   22f31:	5d                   	pop    %ebp
   22f32:	c3                   	ret    

00022f33 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   22f33:	55                   	push   %ebp
   22f34:	89 e5                	mov    %esp,%ebp
   22f36:	57                   	push   %edi
   22f37:	56                   	push   %esi
   22f38:	53                   	push   %ebx
   22f39:	8b 7d 0c             	mov    0xc(%ebp),%edi
   22f3c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   22f3f:	9c                   	pushf  
   22f40:	fa                   	cli    
   22f41:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   22f42:	53                   	push   %ebx
   22f43:	e8 39 0e 00 00       	call   23d81 <z_unpend_first_thread>
   22f48:	5a                   	pop    %edx

	if (pending_thread != NULL) {
   22f49:	85 c0                	test   %eax,%eax
   22f4b:	74 37                	je     22f84 <k_mem_slab_free+0x51>
static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in z_swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
   22f4d:	8b 48 28             	mov    0x28(%eax),%ecx
		z_set_thread_return_value_with_data(pending_thread, 0, *mem);
   22f50:	8b 17                	mov    (%edi),%edx
   22f52:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	thread->base.swap_data = data;
   22f58:	89 50 14             	mov    %edx,0x14(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   22f5b:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   22f5f:	75 0d                	jne    22f6e <k_mem_slab_free+0x3b>
	if (z_is_thread_ready(thread)) {
   22f61:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   22f65:	75 07                	jne    22f6e <k_mem_slab_free+0x3b>
		z_add_thread_to_ready_q(thread);
   22f67:	50                   	push   %eax
   22f68:	e8 59 0b 00 00       	call   23ac6 <z_add_thread_to_ready_q>
   22f6d:	58                   	pop    %eax
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   22f6e:	89 75 0c             	mov    %esi,0xc(%ebp)
   22f71:	c7 45 08 65 45 40 00 	movl   $0x404565,0x8(%ebp)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   22f78:	8d 65 f4             	lea    -0xc(%ebp),%esp
   22f7b:	5b                   	pop    %ebx
   22f7c:	5e                   	pop    %esi
   22f7d:	5f                   	pop    %edi
   22f7e:	5d                   	pop    %ebp
		z_reschedule(&lock, key);
   22f7f:	e9 81 09 00 00       	jmp    23905 <z_reschedule>
		**(char ***)mem = slab->free_list;
   22f84:	8b 07                	mov    (%edi),%eax
   22f86:	8b 53 1c             	mov    0x1c(%ebx),%edx
   22f89:	89 10                	mov    %edx,(%eax)
		slab->free_list = *(char **)mem;
   22f8b:	8b 07                	mov    (%edi),%eax
		slab->num_used--;
   22f8d:	ff 4b 20             	decl   0x20(%ebx)
   22f90:	0f ba e6 09          	bt     $0x9,%esi
		slab->free_list = *(char **)mem;
   22f94:	89 43 1c             	mov    %eax,0x1c(%ebx)
   22f97:	73 01                	jae    22f9a <k_mem_slab_free+0x67>
	__asm__ volatile (
   22f99:	fb                   	sti    
}
   22f9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   22f9d:	5b                   	pop    %ebx
   22f9e:	5e                   	pop    %esi
   22f9f:	5f                   	pop    %edi
   22fa0:	5d                   	pop    %ebp
   22fa1:	c3                   	ret    

00022fa2 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   22fa2:	55                   	push   %ebp
   22fa3:	89 e5                	mov    %esp,%ebp
   22fa5:	57                   	push   %edi
   22fa6:	53                   	push   %ebx
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
   22fa7:	bb 6c a9 40 00       	mov    $0x40a96c,%ebx
   22fac:	81 fb 6c a9 40 00    	cmp    $0x40a96c,%ebx
   22fb2:	73 1f                	jae    22fd3 <init_static_pools+0x31>
   22fb4:	31 c0                	xor    %eax,%eax
   22fb6:	8d 7b 14             	lea    0x14(%ebx),%edi
   22fb9:	b9 04 00 00 00       	mov    $0x4,%ecx
   22fbe:	f3 ab                	rep stos %eax,%es:(%edi)
	z_sys_mem_pool_base_init(&p->base);
   22fc0:	53                   	push   %ebx
   22fc1:	c7 43 18 07 38 02 00 	movl   $0x23807,0x18(%ebx)
   22fc8:	e8 d6 eb fd ff       	call   1ba3 <z_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
   22fcd:	83 c3 24             	add    $0x24,%ebx
	z_sys_mem_pool_base_init(&p->base);
   22fd0:	58                   	pop    %eax
   22fd1:	eb d9                	jmp    22fac <init_static_pools+0xa>
		k_mem_pool_init(p);
	}

	return 0;
}
   22fd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
   22fd6:	31 c0                	xor    %eax,%eax
   22fd8:	5b                   	pop    %ebx
   22fd9:	5f                   	pop    %edi
   22fda:	5d                   	pop    %ebp
   22fdb:	c3                   	ret    

00022fdc <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   22fdc:	55                   	push   %ebp
   22fdd:	89 e5                	mov    %esp,%ebp
   22fdf:	57                   	push   %edi
   22fe0:	56                   	push   %esi
   22fe1:	31 f6                	xor    %esi,%esi
   22fe3:	53                   	push   %ebx
   22fe4:	83 ec 10             	sub    $0x10,%esp
	int ret;
	s64_t end = 0;

	__ASSERT(!(z_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
   22fe7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   22feb:	7e 4e                	jle    2303b <k_mem_pool_alloc+0x5f>
		end = z_tick_get() + z_ms_to_ticks(timeout);
   22fed:	e8 cc 18 00 00       	call   248be <z_tick_get>
	return z_clock_hw_cycles_per_sec;
   22ff2:	8b 35 24 a7 40 00    	mov    0x40a724,%esi
   22ff8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return (s32_t)ceiling_fraction(
   22ffb:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   23000:	89 55 e8             	mov    %edx,-0x18(%ebp)
   23003:	6a 00                	push   $0x0
   23005:	f7 ee                	imul   %esi
   23007:	6a 64                	push   $0x64
   23009:	52                   	push   %edx
   2300a:	50                   	push   %eax
   2300b:	e8 c0 e0 fd ff       	call   10d0 <__divdi3>
   23010:	89 c1                	mov    %eax,%ecx
   23012:	89 f0                	mov    %esi,%eax
   23014:	89 d3                	mov    %edx,%ebx
   23016:	83 c4 10             	add    $0x10,%esp
   23019:	f7 6d 14             	imull  0x14(%ebp)
   2301c:	89 ce                	mov    %ecx,%esi
   2301e:	89 df                	mov    %ebx,%edi
   23020:	83 c6 ff             	add    $0xffffffff,%esi
   23023:	53                   	push   %ebx
   23024:	83 d7 ff             	adc    $0xffffffff,%edi
   23027:	01 f0                	add    %esi,%eax
   23029:	11 fa                	adc    %edi,%edx
   2302b:	51                   	push   %ecx
   2302c:	52                   	push   %edx
   2302d:	50                   	push   %eax
   2302e:	e8 9d e0 fd ff       	call   10d0 <__divdi3>
   23033:	89 c6                	mov    %eax,%esi
   23035:	83 c4 10             	add    $0x10,%esp
   23038:	03 75 e4             	add    -0x1c(%ebp),%esi
	return pool - &_k_mem_pool_list_start[0];
   2303b:	8b 5d 08             	mov    0x8(%ebp),%ebx
   2303e:	81 eb 6c a9 40 00    	sub    $0x40a96c,%ebx
   23044:	c1 fb 02             	sar    $0x2,%ebx
   23047:	69 db 39 8e e3 38    	imul   $0x38e38e39,%ebx,%ebx
		 * Retry exactly once before sleeping to resolve it.
		 * If we're so contended that it fails twice, then we
		 * clearly want to block.
		 */
		for (int i = 0; i < 2; i++) {
			ret = z_sys_mem_pool_block_alloc(&p->base, size,
   2304d:	ff 75 0c             	pushl  0xc(%ebp)
   23050:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   23053:	8d 55 ec             	lea    -0x14(%ebp),%edx
   23056:	51                   	push   %ecx
   23057:	52                   	push   %edx
   23058:	ff 75 10             	pushl  0x10(%ebp)
   2305b:	ff 75 08             	pushl  0x8(%ebp)
   2305e:	e8 f4 eb fd ff       	call   1c57 <z_sys_mem_pool_block_alloc>
   23063:	83 c4 14             	add    $0x14,%esp
							&level_num, &block_num,
							&block->data);
			if (ret != -EAGAIN) {
   23066:	83 f8 f5             	cmp    $0xfffffff5,%eax
   23069:	75 23                	jne    2308e <k_mem_pool_alloc+0xb2>
			ret = z_sys_mem_pool_block_alloc(&p->base, size,
   2306b:	ff 75 0c             	pushl  0xc(%ebp)
   2306e:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   23071:	8d 55 ec             	lea    -0x14(%ebp),%edx
   23074:	51                   	push   %ecx
   23075:	52                   	push   %edx
   23076:	ff 75 10             	pushl  0x10(%ebp)
   23079:	ff 75 08             	pushl  0x8(%ebp)
   2307c:	e8 d6 eb fd ff       	call   1c57 <z_sys_mem_pool_block_alloc>
   23081:	83 c4 14             	add    $0x14,%esp
			if (ret != -EAGAIN) {
   23084:	83 f8 f5             	cmp    $0xfffffff5,%eax
   23087:	75 05                	jne    2308e <k_mem_pool_alloc+0xb2>
				break;
			}
		}

		if (ret == -EAGAIN) {
			ret = -ENOMEM;
   23089:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		}

		block->id.pool = pool_id(p);
   2308e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		block->id.level = level_num;
   23091:	8b 55 0c             	mov    0xc(%ebp),%edx
		block->id.pool = pool_id(p);
   23094:	88 59 04             	mov    %bl,0x4(%ecx)
		block->id.level = level_num;
   23097:	8a 4d ec             	mov    -0x14(%ebp),%cl
   2309a:	8a 52 05             	mov    0x5(%edx),%dl
   2309d:	83 e1 0f             	and    $0xf,%ecx
   230a0:	88 55 e4             	mov    %dl,-0x1c(%ebp)
   230a3:	83 e2 f0             	and    $0xfffffff0,%edx
   230a6:	09 ca                	or     %ecx,%edx
   230a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   230ab:	88 51 05             	mov    %dl,0x5(%ecx)
		block->id.block = block_num;
   230ae:	8b 55 0c             	mov    0xc(%ebp),%edx
   230b1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   230b4:	c1 e1 0c             	shl    $0xc,%ecx
   230b7:	8b 52 04             	mov    0x4(%edx),%edx
   230ba:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   230bd:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
   230c3:	09 ca                	or     %ecx,%edx
   230c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   230c8:	89 51 04             	mov    %edx,0x4(%ecx)

		if (ret == 0 || timeout == K_NO_WAIT ||
   230cb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   230cf:	74 3c                	je     2310d <k_mem_pool_alloc+0x131>
   230d1:	83 f8 f4             	cmp    $0xfffffff4,%eax
   230d4:	75 37                	jne    2310d <k_mem_pool_alloc+0x131>
	__asm__ volatile (
   230d6:	9c                   	pushf  
   230d7:	fa                   	cli    
   230d8:	58                   	pop    %eax
	(void) z_pend_curr_irqlock(z_arch_irq_lock(), wait_q, timeout);
   230d9:	ff 75 14             	pushl  0x14(%ebp)
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   230dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
   230df:	8d 51 14             	lea    0x14(%ecx),%edx
   230e2:	52                   	push   %edx
   230e3:	50                   	push   %eax
   230e4:	e8 d9 0b 00 00       	call   23cc2 <z_pend_curr_irqlock>
   230e9:	83 c4 0c             	add    $0xc,%esp

		if (timeout != K_FOREVER) {
   230ec:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
   230f0:	0f 84 57 ff ff ff    	je     2304d <k_mem_pool_alloc+0x71>
			timeout = end - z_tick_get();
   230f6:	e8 c3 17 00 00       	call   248be <z_tick_get>

			if (timeout < 0) {
   230fb:	89 f1                	mov    %esi,%ecx
   230fd:	29 c1                	sub    %eax,%ecx
   230ff:	89 4d 14             	mov    %ecx,0x14(%ebp)
   23102:	0f 89 45 ff ff ff    	jns    2304d <k_mem_pool_alloc+0x71>
				break;
			}
		}
	}

	return -EAGAIN;
   23108:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
   2310d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23110:	5b                   	pop    %ebx
   23111:	5e                   	pop    %esi
   23112:	5f                   	pop    %edi
   23113:	5d                   	pop    %ebp
   23114:	c3                   	ret    

00023115 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   23115:	55                   	push   %ebp
   23116:	89 e5                	mov    %esp,%ebp
   23118:	56                   	push   %esi
   23119:	53                   	push   %ebx
   2311a:	8b 45 08             	mov    0x8(%ebp),%eax
   2311d:	0f b6 18             	movzbl (%eax),%ebx
   23120:	6b db 24             	imul   $0x24,%ebx,%ebx
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   23123:	8b 10                	mov    (%eax),%edx
   23125:	c1 ea 0c             	shr    $0xc,%edx
   23128:	52                   	push   %edx
   23129:	8a 40 01             	mov    0x1(%eax),%al
   2312c:	83 e0 0f             	and    $0xf,%eax
   2312f:	50                   	push   %eax
   23130:	8d 83 6c a9 40 00    	lea    0x40a96c(%ebx),%eax
   23136:	50                   	push   %eax
   23137:	e8 fb ec fd ff       	call   1e37 <z_sys_mem_pool_block_free>
   2313c:	83 c4 0c             	add    $0xc,%esp
   2313f:	9c                   	pushf  
   23140:	fa                   	cli    
   23141:	5e                   	pop    %esi
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   23142:	81 c3 80 a9 40 00    	add    $0x40a980,%ebx
   23148:	53                   	push   %ebx
   23149:	e8 84 0c 00 00       	call   23dd2 <z_unpend_all>
   2314e:	59                   	pop    %ecx

	if (need_sched) {
   2314f:	85 c0                	test   %eax,%eax
   23151:	74 0f                	je     23162 <k_mem_pool_free_id+0x4d>
		z_reschedule(&lock, key);
   23153:	56                   	push   %esi
   23154:	68 65 45 40 00       	push   $0x404565
   23159:	e8 a7 07 00 00       	call   23905 <z_reschedule>
   2315e:	58                   	pop    %eax
   2315f:	5a                   	pop    %edx
   23160:	eb 07                	jmp    23169 <k_mem_pool_free_id+0x54>
   23162:	0f ba e6 09          	bt     $0x9,%esi
   23166:	73 01                	jae    23169 <k_mem_pool_free_id+0x54>
	__asm__ volatile (
   23168:	fb                   	sti    
	} else {
		k_spin_unlock(&lock, key);
	}
}
   23169:	8d 65 f8             	lea    -0x8(%ebp),%esp
   2316c:	5b                   	pop    %ebx
   2316d:	5e                   	pop    %esi
   2316e:	5d                   	pop    %ebp
   2316f:	c3                   	ret    

00023170 <k_mem_pool_malloc>:
{
	k_mem_pool_free_id(&block->id);
}

void *k_mem_pool_malloc(struct k_mem_pool *pool, size_t size)
{
   23170:	55                   	push   %ebp
   23171:	89 e5                	mov    %esp,%ebp
   23173:	83 ec 08             	sub    $0x8,%esp

	/*
	 * get a block large enough to hold an initial (hidden) block
	 * descriptor, as well as the space the caller requested
	 */
	if (__builtin_add_overflow(size, sizeof(struct k_mem_block_id),
   23176:	8b 45 0c             	mov    0xc(%ebp),%eax
   23179:	83 c0 04             	add    $0x4,%eax
   2317c:	72 16                	jb     23194 <k_mem_pool_malloc+0x24>
				   &size)) {
		return NULL;
	}
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   2317e:	6a 00                	push   $0x0
   23180:	50                   	push   %eax
   23181:	8d 45 f8             	lea    -0x8(%ebp),%eax
   23184:	50                   	push   %eax
   23185:	ff 75 08             	pushl  0x8(%ebp)
   23188:	e8 4f fe ff ff       	call   22fdc <k_mem_pool_alloc>
   2318d:	83 c4 10             	add    $0x10,%esp
   23190:	85 c0                	test   %eax,%eax
   23192:	74 04                	je     23198 <k_mem_pool_malloc+0x28>
		return NULL;
   23194:	31 c0                	xor    %eax,%eax
   23196:	eb 17                	jmp    231af <k_mem_pool_malloc+0x3f>
		return NULL;
	}

	/* save the block descriptor info at the start of the actual block */
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   23198:	6a 04                	push   $0x4
   2319a:	8d 45 fc             	lea    -0x4(%ebp),%eax
   2319d:	50                   	push   %eax
   2319e:	ff 75 f8             	pushl  -0x8(%ebp)
   231a1:	e8 8b 77 fe ff       	call   a931 <memcpy>

	/* return address of the user area part of the block to the caller */
	return (char *)block.data + sizeof(struct k_mem_block_id);
   231a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   231a9:	83 c4 0c             	add    $0xc,%esp
	return (char *)block.data + sizeof(struct k_mem_block_id);
   231ac:	83 c0 04             	add    $0x4,%eax
}
   231af:	c9                   	leave  
   231b0:	c3                   	ret    

000231b1 <k_free>:

void k_free(void *ptr)
{
   231b1:	55                   	push   %ebp
   231b2:	89 e5                	mov    %esp,%ebp
   231b4:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ptr != NULL) {
   231b7:	85 c0                	test   %eax,%eax
   231b9:	74 0c                	je     231c7 <k_free+0x16>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - sizeof(struct k_mem_block_id);
   231bb:	83 e8 04             	sub    $0x4,%eax

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
   231be:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
   231c1:	5d                   	pop    %ebp
		k_mem_pool_free_id(ptr);
   231c2:	e9 4e ff ff ff       	jmp    23115 <k_mem_pool_free_id>
}
   231c7:	5d                   	pop    %ebp
   231c8:	c3                   	ret    

000231c9 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool != NULL) {
   231c9:	a1 28 41 40 00       	mov    0x404128,%eax
   231ce:	8b 40 38             	mov    0x38(%eax),%eax
   231d1:	85 c0                	test   %eax,%eax
   231d3:	74 10                	je     231e5 <z_thread_malloc+0x1c>
{
   231d5:	55                   	push   %ebp
   231d6:	89 e5                	mov    %esp,%ebp
		ret = k_mem_pool_malloc(_current->resource_pool, size);
   231d8:	ff 75 08             	pushl  0x8(%ebp)
   231db:	50                   	push   %eax
   231dc:	e8 8f ff ff ff       	call   23170 <k_mem_pool_malloc>
   231e1:	5a                   	pop    %edx
   231e2:	59                   	pop    %ecx
	} else {
		ret = NULL;
	}

	return ret;
}
   231e3:	c9                   	leave  
   231e4:	c3                   	ret    
   231e5:	c3                   	ret    

000231e6 <z_impl_k_msgq_put>:
	}
}


int z_impl_k_msgq_put(struct k_msgq *q, void *data, s32_t timeout)
{
   231e6:	55                   	push   %ebp
   231e7:	89 e5                	mov    %esp,%ebp
   231e9:	57                   	push   %edi
   231ea:	56                   	push   %esi
   231eb:	53                   	push   %ebx
   231ec:	51                   	push   %ecx
   231ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
   231f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   231f3:	8b 55 10             	mov    0x10(%ebp),%edx
	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, "");

	k_spinlock_key_t key = k_spin_lock(&q->lock);
   231f6:	8d 7b 10             	lea    0x10(%ebx),%edi
	__asm__ volatile (
   231f9:	9c                   	pushf  
   231fa:	fa                   	cli    
   231fb:	5e                   	pop    %esi
	struct k_thread *pending_thread;
	int result;

	if (q->used_msgs < q->max_msgs) {
   231fc:	8b 43 14             	mov    0x14(%ebx),%eax
   231ff:	39 43 28             	cmp    %eax,0x28(%ebx)
   23202:	73 79                	jae    2327d <z_impl_k_msgq_put+0x97>
   23204:	89 4d 0c             	mov    %ecx,0xc(%ebp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&q->wait_q);
   23207:	53                   	push   %ebx
   23208:	e8 74 0b 00 00       	call   23d81 <z_unpend_first_thread>
   2320d:	5a                   	pop    %edx
		if (pending_thread != NULL) {
   2320e:	85 c0                	test   %eax,%eax
   23210:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   23213:	74 3e                	je     23253 <z_impl_k_msgq_put+0x6d>
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
   23215:	ff 73 10             	pushl  0x10(%ebx)
   23218:	89 45 f0             	mov    %eax,-0x10(%ebp)
   2321b:	51                   	push   %ecx
   2321c:	ff 70 14             	pushl  0x14(%eax)
   2321f:	e8 0d 77 fe ff       	call   a931 <memcpy>
   23224:	8b 55 f0             	mov    -0x10(%ebp),%edx
   23227:	8b 42 28             	mov    0x28(%edx),%eax
   2322a:	83 c4 0c             	add    $0xc,%esp
   2322d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   23233:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
   23237:	75 0d                	jne    23246 <z_impl_k_msgq_put+0x60>
	if (z_is_thread_ready(thread)) {
   23239:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
   2323d:	75 07                	jne    23246 <z_impl_k_msgq_put+0x60>
		z_add_thread_to_ready_q(thread);
   2323f:	52                   	push   %edx
   23240:	e8 81 08 00 00       	call   23ac6 <z_add_thread_to_ready_q>
   23245:	59                   	pop    %ecx
			       q->msg_size);
			/* wake up waiting thread */
			z_set_thread_return_value(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&q->lock, key);
   23246:	56                   	push   %esi
   23247:	57                   	push   %edi
   23248:	e8 b8 06 00 00       	call   23905 <z_reschedule>
   2324d:	58                   	pop    %eax
			return 0;
   2324e:	31 c0                	xor    %eax,%eax
			z_reschedule(&q->lock, key);
   23250:	5a                   	pop    %edx
			return 0;
   23251:	eb 50                	jmp    232a3 <z_impl_k_msgq_put+0xbd>
		} else {
			/* put message in queue */
			(void)memcpy(q->write_ptr, data, q->msg_size);
   23253:	ff 73 10             	pushl  0x10(%ebx)
   23256:	51                   	push   %ecx
   23257:	ff 73 24             	pushl  0x24(%ebx)
   2325a:	e8 d2 76 fe ff       	call   a931 <memcpy>
			q->write_ptr += q->msg_size;
   2325f:	8b 43 10             	mov    0x10(%ebx),%eax
   23262:	03 43 24             	add    0x24(%ebx),%eax
			(void)memcpy(q->write_ptr, data, q->msg_size);
   23265:	83 c4 0c             	add    $0xc,%esp
			q->write_ptr += q->msg_size;
   23268:	89 43 24             	mov    %eax,0x24(%ebx)
			if (q->write_ptr == q->buffer_end) {
   2326b:	3b 43 1c             	cmp    0x1c(%ebx),%eax
   2326e:	75 06                	jne    23276 <z_impl_k_msgq_put+0x90>
				q->write_ptr = q->buffer_start;
   23270:	8b 43 18             	mov    0x18(%ebx),%eax
   23273:	89 43 24             	mov    %eax,0x24(%ebx)
			}
			q->used_msgs++;
   23276:	ff 43 28             	incl   0x28(%ebx)
		}
		result = 0;
   23279:	31 c0                	xor    %eax,%eax
   2327b:	eb 1f                	jmp    2329c <z_impl_k_msgq_put+0xb6>
	} else if (timeout == K_NO_WAIT) {
		/* don't wait for message space to become available */
		result = -ENOMSG;
   2327d:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (timeout == K_NO_WAIT) {
   23282:	85 d2                	test   %edx,%edx
   23284:	74 16                	je     2329c <z_impl_k_msgq_put+0xb6>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = data;
   23286:	a1 28 41 40 00       	mov    0x404128,%eax
   2328b:	89 48 14             	mov    %ecx,0x14(%eax)
		return z_pend_curr(&q->lock, key, &q->wait_q, timeout);
   2328e:	52                   	push   %edx
   2328f:	53                   	push   %ebx
   23290:	56                   	push   %esi
   23291:	57                   	push   %edi
   23292:	e8 4c 0a 00 00       	call   23ce3 <z_pend_curr>
   23297:	83 c4 10             	add    $0x10,%esp
   2329a:	eb 07                	jmp    232a3 <z_impl_k_msgq_put+0xbd>
   2329c:	0f ba e6 09          	bt     $0x9,%esi
   232a0:	73 01                	jae    232a3 <z_impl_k_msgq_put+0xbd>
	__asm__ volatile (
   232a2:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
   232a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
   232a6:	5b                   	pop    %ebx
   232a7:	5e                   	pop    %esi
   232a8:	5f                   	pop    %edi
   232a9:	5d                   	pop    %ebp
   232aa:	c3                   	ret    

000232ab <z_impl_k_msgq_get>:
	return 0;
}
#endif

int z_impl_k_msgq_get(struct k_msgq *q, void *data, s32_t timeout)
{
   232ab:	55                   	push   %ebp
   232ac:	89 e5                	mov    %esp,%ebp
   232ae:	57                   	push   %edi
   232af:	56                   	push   %esi
   232b0:	53                   	push   %ebx
   232b1:	51                   	push   %ecx
   232b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
   232b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   232b8:	8b 55 10             	mov    0x10(%ebp),%edx
	__ASSERT(!z_is_in_isr() || timeout == K_NO_WAIT, "");

	k_spinlock_key_t key = k_spin_lock(&q->lock);
   232bb:	8d 7b 10             	lea    0x10(%ebx),%edi
	__asm__ volatile (
   232be:	9c                   	pushf  
   232bf:	fa                   	cli    
   232c0:	5e                   	pop    %esi
	struct k_thread *pending_thread;
	int result;

	if (q->used_msgs > 0) {
   232c1:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
   232c5:	0f 84 8c 00 00 00    	je     23357 <z_impl_k_msgq_get+0xac>
		/* take first available message from queue */
		(void)memcpy(data, q->read_ptr, q->msg_size);
   232cb:	ff 73 10             	pushl  0x10(%ebx)
   232ce:	ff 73 20             	pushl  0x20(%ebx)
   232d1:	51                   	push   %ecx
   232d2:	e8 5a 76 fe ff       	call   a931 <memcpy>
		q->read_ptr += q->msg_size;
   232d7:	8b 43 10             	mov    0x10(%ebx),%eax
		(void)memcpy(data, q->read_ptr, q->msg_size);
   232da:	83 c4 0c             	add    $0xc,%esp
		q->read_ptr += q->msg_size;
   232dd:	03 43 20             	add    0x20(%ebx),%eax
   232e0:	89 43 20             	mov    %eax,0x20(%ebx)
		if (q->read_ptr == q->buffer_end) {
   232e3:	3b 43 1c             	cmp    0x1c(%ebx),%eax
   232e6:	75 06                	jne    232ee <z_impl_k_msgq_get+0x43>
			q->read_ptr = q->buffer_start;
   232e8:	8b 43 18             	mov    0x18(%ebx),%eax
   232eb:	89 43 20             	mov    %eax,0x20(%ebx)
		}
		q->used_msgs--;
   232ee:	ff 4b 28             	decl   0x28(%ebx)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&q->wait_q);
   232f1:	53                   	push   %ebx
   232f2:	e8 8a 0a 00 00       	call   23d81 <z_unpend_first_thread>
   232f7:	5a                   	pop    %edx
   232f8:	89 c2                	mov    %eax,%edx
			z_set_thread_return_value(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&q->lock, key);
			return 0;
		}
		result = 0;
   232fa:	31 c0                	xor    %eax,%eax
		if (pending_thread != NULL) {
   232fc:	85 d2                	test   %edx,%edx
   232fe:	74 76                	je     23376 <z_impl_k_msgq_get+0xcb>
			(void)memcpy(q->write_ptr, pending_thread->base.swap_data,
   23300:	ff 73 10             	pushl  0x10(%ebx)
   23303:	ff 72 14             	pushl  0x14(%edx)
   23306:	ff 73 24             	pushl  0x24(%ebx)
   23309:	89 55 f0             	mov    %edx,-0x10(%ebp)
   2330c:	e8 20 76 fe ff       	call   a931 <memcpy>
			q->write_ptr += q->msg_size;
   23311:	8b 43 10             	mov    0x10(%ebx),%eax
			(void)memcpy(q->write_ptr, pending_thread->base.swap_data,
   23314:	83 c4 0c             	add    $0xc,%esp
			q->write_ptr += q->msg_size;
   23317:	03 43 24             	add    0x24(%ebx),%eax
			if (q->write_ptr == q->buffer_end) {
   2331a:	8b 55 f0             	mov    -0x10(%ebp),%edx
			q->write_ptr += q->msg_size;
   2331d:	89 43 24             	mov    %eax,0x24(%ebx)
			if (q->write_ptr == q->buffer_end) {
   23320:	3b 43 1c             	cmp    0x1c(%ebx),%eax
   23323:	75 06                	jne    2332b <z_impl_k_msgq_get+0x80>
				q->write_ptr = q->buffer_start;
   23325:	8b 43 18             	mov    0x18(%ebx),%eax
   23328:	89 43 24             	mov    %eax,0x24(%ebx)
			q->used_msgs++;
   2332b:	ff 43 28             	incl   0x28(%ebx)
   2332e:	8b 42 28             	mov    0x28(%edx),%eax
   23331:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   23337:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
   2333b:	75 0d                	jne    2334a <z_impl_k_msgq_get+0x9f>
	if (z_is_thread_ready(thread)) {
   2333d:	83 7a 18 00          	cmpl   $0x0,0x18(%edx)
   23341:	75 07                	jne    2334a <z_impl_k_msgq_get+0x9f>
		z_add_thread_to_ready_q(thread);
   23343:	52                   	push   %edx
   23344:	e8 7d 07 00 00       	call   23ac6 <z_add_thread_to_ready_q>
   23349:	59                   	pop    %ecx
			z_reschedule(&q->lock, key);
   2334a:	56                   	push   %esi
   2334b:	57                   	push   %edi
   2334c:	e8 b4 05 00 00       	call   23905 <z_reschedule>
   23351:	58                   	pop    %eax
			return 0;
   23352:	31 c0                	xor    %eax,%eax
			z_reschedule(&q->lock, key);
   23354:	5a                   	pop    %edx
			return 0;
   23355:	eb 26                	jmp    2337d <z_impl_k_msgq_get+0xd2>
	} else if (timeout == K_NO_WAIT) {
		/* don't wait for a message to become available */
		result = -ENOMSG;
   23357:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (timeout == K_NO_WAIT) {
   2335c:	85 d2                	test   %edx,%edx
   2335e:	74 16                	je     23376 <z_impl_k_msgq_get+0xcb>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
   23360:	a1 28 41 40 00       	mov    0x404128,%eax
   23365:	89 48 14             	mov    %ecx,0x14(%eax)
		return z_pend_curr(&q->lock, key, &q->wait_q, timeout);
   23368:	52                   	push   %edx
   23369:	53                   	push   %ebx
   2336a:	56                   	push   %esi
   2336b:	57                   	push   %edi
   2336c:	e8 72 09 00 00       	call   23ce3 <z_pend_curr>
   23371:	83 c4 10             	add    $0x10,%esp
   23374:	eb 07                	jmp    2337d <z_impl_k_msgq_get+0xd2>
   23376:	0f ba e6 09          	bt     $0x9,%esi
   2337a:	73 01                	jae    2337d <z_impl_k_msgq_get+0xd2>
	__asm__ volatile (
   2337c:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
   2337d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23380:	5b                   	pop    %ebx
   23381:	5e                   	pop    %esi
   23382:	5f                   	pop    %edi
   23383:	5d                   	pop    %ebp
   23384:	c3                   	ret    

00023385 <z_impl_k_msgq_peek>:
	return z_impl_k_msgq_get(q, (void *)data, timeout);
}
#endif

int z_impl_k_msgq_peek(struct k_msgq *q, void *data)
{
   23385:	55                   	push   %ebp
   23386:	89 e5                	mov    %esp,%ebp
   23388:	53                   	push   %ebx
   23389:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
   2338c:	9c                   	pushf  
   2338d:	fa                   	cli    
   2338e:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&q->lock);
	int result;

	if (q->used_msgs > 0) {
   2338f:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
   23394:	83 7a 28 00          	cmpl   $0x0,0x28(%edx)
   23398:	74 13                	je     233ad <z_impl_k_msgq_peek+0x28>
		/* take first available message from queue */
		(void)memcpy(data, q->read_ptr, q->msg_size);
   2339a:	ff 72 10             	pushl  0x10(%edx)
   2339d:	ff 72 20             	pushl  0x20(%edx)
   233a0:	ff 75 0c             	pushl  0xc(%ebp)
   233a3:	e8 89 75 fe ff       	call   a931 <memcpy>
   233a8:	83 c4 0c             	add    $0xc,%esp
		result = 0;
   233ab:	31 c0                	xor    %eax,%eax
   233ad:	0f ba e3 09          	bt     $0x9,%ebx
   233b1:	73 01                	jae    233b4 <z_impl_k_msgq_peek+0x2f>
	__asm__ volatile (
   233b3:	fb                   	sti    
	}

	k_spin_unlock(&q->lock, key);

	return result;
}
   233b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   233b7:	c9                   	leave  
   233b8:	c3                   	ret    

000233b9 <z_impl_k_mutex_init>:
SYS_INIT(init_mutex_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_mutex_init(struct k_mutex *mutex)
{
   233b9:	55                   	push   %ebp
   233ba:	b9 04 00 00 00       	mov    $0x4,%ecx
   233bf:	89 e5                	mov    %esp,%ebp
   233c1:	31 c0                	xor    %eax,%eax
   233c3:	57                   	push   %edi
   233c4:	8b 55 08             	mov    0x8(%ebp),%edx
   233c7:	89 d7                	mov    %edx,%edi
	mutex->owner = NULL;
   233c9:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
	mutex->lock_count = 0;
   233d0:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
   233d7:	f3 ab                	rep stos %eax,%es:(%edi)
   233d9:	c7 42 04 07 38 02 00 	movl   $0x23807,0x4(%edx)
	z_waitq_init(&mutex->wait_q);

	SYS_TRACING_OBJ_INIT(k_mutex, mutex);
	z_object_init(mutex);
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_INIT);
}
   233e0:	5f                   	pop    %edi
   233e1:	5d                   	pop    %ebp
   233e2:	c3                   	ret    

000233e3 <z_impl_k_mutex_lock>:
		z_thread_priority_set(mutex->owner, new_prio);
	}
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   233e3:	55                   	push   %ebp
   233e4:	89 e5                	mov    %esp,%ebp
   233e6:	57                   	push   %edi
   233e7:	56                   	push   %esi
   233e8:	53                   	push   %ebx
   233e9:	51                   	push   %ecx
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   233ea:	a1 28 41 40 00       	mov    0x404128,%eax
   233ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
   233f2:	8b 75 0c             	mov    0xc(%ebp),%esi
   233f5:	fe 48 0f             	decb   0xf(%eax)
	k_spinlock_key_t key;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	z_sched_lock();

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   233f8:	8b 53 14             	mov    0x14(%ebx),%edx
   233fb:	a1 28 41 40 00       	mov    0x404128,%eax
   23400:	85 d2                	test   %edx,%edx
   23402:	74 0c                	je     23410 <z_impl_k_mutex_lock+0x2d>
   23404:	8b 4b 10             	mov    0x10(%ebx),%ecx
   23407:	39 c1                	cmp    %eax,%ecx
   23409:	75 1f                	jne    2342a <z_impl_k_mutex_lock+0x47>

		RECORD_STATE_CHANGE();

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
   2340b:	8b 4b 18             	mov    0x18(%ebx),%ecx
   2340e:	eb 04                	jmp    23414 <z_impl_k_mutex_lock+0x31>
   23410:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
					mutex->owner_orig_prio;

		mutex->lock_count++;
   23414:	42                   	inc    %edx
		mutex->owner = _current;
   23415:	89 43 10             	mov    %eax,0x10(%ebx)
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   23418:	89 4b 18             	mov    %ecx,0x18(%ebx)
		mutex->lock_count++;
   2341b:	89 53 14             	mov    %edx,0x14(%ebx)

		K_DEBUG("%p took mutex %p, count: %d, orig prio: %d\n",
			_current, mutex, mutex->lock_count,
			mutex->owner_orig_prio);

		k_sched_unlock();
   2341e:	e8 7c 06 00 00       	call   23a9f <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
   23423:	31 c0                	xor    %eax,%eax
   23425:	e9 a8 00 00 00       	jmp    234d2 <z_impl_k_mutex_lock+0xef>
	}

	RECORD_CONFLICT();

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   2342a:	85 f6                	test   %esi,%esi
   2342c:	75 0f                	jne    2343d <z_impl_k_mutex_lock+0x5a>
		k_sched_unlock();
   2342e:	e8 6c 06 00 00       	call   23a9f <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   23433:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   23438:	e9 95 00 00 00       	jmp    234d2 <z_impl_k_mutex_lock+0xef>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
   2343d:	0f be 50 0e          	movsbl 0xe(%eax),%edx
   23441:	0f be 41 0e          	movsbl 0xe(%ecx),%eax
   23445:	39 d0                	cmp    %edx,%eax
   23447:	7e 02                	jle    2344b <z_impl_k_mutex_lock+0x68>
   23449:	89 d0                	mov    %edx,%eax
   2344b:	85 c0                	test   %eax,%eax
   2344d:	79 02                	jns    23451 <z_impl_k_mutex_lock+0x6e>
   2344f:	31 c0                	xor    %eax,%eax
	__asm__ volatile (
   23451:	9c                   	pushf  
   23452:	fa                   	cli    
   23453:	5f                   	pop    %edi

	key = k_spin_lock(&lock);

	K_DEBUG("adjusting prio up on mutex %p\n", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   23454:	8b 53 10             	mov    0x10(%ebx),%edx
   23457:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
   2345b:	39 c8                	cmp    %ecx,%eax
   2345d:	7d 09                	jge    23468 <z_impl_k_mutex_lock+0x85>
		z_thread_priority_set(mutex->owner, new_prio);
   2345f:	50                   	push   %eax
   23460:	52                   	push   %edx
   23461:	e8 9e 08 00 00       	call   23d04 <z_thread_priority_set>
   23466:	58                   	pop    %eax
   23467:	5a                   	pop    %edx
		adjust_owner_prio(mutex, new_prio);
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   23468:	56                   	push   %esi
   23469:	53                   	push   %ebx
   2346a:	57                   	push   %edi
   2346b:	68 65 45 40 00       	push   $0x404565
   23470:	e8 6e 08 00 00       	call   23ce3 <z_pend_curr>
   23475:	83 c4 10             	add    $0x10,%esp
	K_DEBUG("on mutex %p got_mutex value: %d\n", mutex, got_mutex);

	K_DEBUG("%p got mutex %p (y/n): %c\n", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
   23478:	89 45 f0             	mov    %eax,-0x10(%ebp)
   2347b:	85 c0                	test   %eax,%eax
   2347d:	75 0a                	jne    23489 <z_impl_k_mutex_lock+0xa6>
		k_sched_unlock();
   2347f:	e8 1b 06 00 00       	call   23a9f <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return 0;
   23484:	8b 45 f0             	mov    -0x10(%ebp),%eax
   23487:	eb 49                	jmp    234d2 <z_impl_k_mutex_lock+0xef>
/**
 * @brief Returns the lowest-sorted member of the tree
 */
static inline struct rbnode *rb_get_min(struct rbtree *tree)
{
	return z_rb_get_minmax(tree, 0);
   23489:	6a 00                	push   $0x0
   2348b:	53                   	push   %ebx
   2348c:	e8 23 ee fd ff       	call   22b4 <z_rb_get_minmax>
   23491:	59                   	pop    %ecx

	K_DEBUG("%p timeout on mutex %p\n", _current, mutex);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = mutex->owner_orig_prio;
   23492:	8b 53 18             	mov    0x18(%ebx),%edx
   23495:	5e                   	pop    %esi
	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
   23496:	85 c0                	test   %eax,%eax
   23498:	74 10                	je     234aa <z_impl_k_mutex_lock+0xc7>
   2349a:	0f be 40 0e          	movsbl 0xe(%eax),%eax
   2349e:	39 c2                	cmp    %eax,%edx
   234a0:	7e 02                	jle    234a4 <z_impl_k_mutex_lock+0xc1>
   234a2:	89 c2                	mov    %eax,%edx
   234a4:	85 d2                	test   %edx,%edx
   234a6:	79 02                	jns    234aa <z_impl_k_mutex_lock+0xc7>
   234a8:	31 d2                	xor    %edx,%edx
   234aa:	9c                   	pushf  
   234ab:	fa                   	cli    
   234ac:	5e                   	pop    %esi
		new_prio;

	K_DEBUG("adjusting prio down on mutex %p\n", mutex);

	key = k_spin_lock(&lock);
	adjust_owner_prio(mutex, new_prio);
   234ad:	8b 43 10             	mov    0x10(%ebx),%eax
	if (mutex->owner->base.prio != new_prio) {
   234b0:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
   234b4:	39 ca                	cmp    %ecx,%edx
   234b6:	74 09                	je     234c1 <z_impl_k_mutex_lock+0xde>
		z_thread_priority_set(mutex->owner, new_prio);
   234b8:	52                   	push   %edx
   234b9:	50                   	push   %eax
   234ba:	e8 45 08 00 00       	call   23d04 <z_thread_priority_set>
   234bf:	58                   	pop    %eax
   234c0:	5a                   	pop    %edx
   234c1:	0f ba e6 09          	bt     $0x9,%esi
   234c5:	73 01                	jae    234c8 <z_impl_k_mutex_lock+0xe5>
	__asm__ volatile (
   234c7:	fb                   	sti    
	k_spin_unlock(&lock, key);

	k_sched_unlock();
   234c8:	e8 d2 05 00 00       	call   23a9f <k_sched_unlock>

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
   234cd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
   234d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
   234d5:	5b                   	pop    %ebx
   234d6:	5e                   	pop    %esi
   234d7:	5f                   	pop    %edi
   234d8:	5d                   	pop    %ebp
   234d9:	c3                   	ret    

000234da <z_impl_k_mutex_unlock>:
	return z_impl_k_mutex_lock((struct k_mutex *)mutex, (s32_t)timeout);
}
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   234da:	55                   	push   %ebp
   234db:	a1 28 41 40 00       	mov    0x404128,%eax
   234e0:	89 e5                	mov    %esp,%ebp
   234e2:	57                   	push   %edi
   234e3:	56                   	push   %esi
   234e4:	53                   	push   %ebx
   234e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
   234e8:	fe 48 0f             	decb   0xf(%eax)
	RECORD_STATE_CHANGE();


	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
   234eb:	8b 43 14             	mov    0x14(%ebx),%eax
   234ee:	83 f8 01             	cmp    $0x1,%eax
   234f1:	74 06                	je     234f9 <z_impl_k_mutex_unlock+0x1f>
		mutex->lock_count--;
   234f3:	48                   	dec    %eax
   234f4:	89 43 14             	mov    %eax,0x14(%ebx)
		goto k_mutex_unlock_return;
   234f7:	eb 66                	jmp    2355f <z_impl_k_mutex_unlock+0x85>
	__asm__ volatile (
   234f9:	9c                   	pushf  
   234fa:	fa                   	cli    
   234fb:	5f                   	pop    %edi
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   234fc:	8b 43 10             	mov    0x10(%ebx),%eax
   234ff:	8b 53 18             	mov    0x18(%ebx),%edx
	if (mutex->owner->base.prio != new_prio) {
   23502:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
   23506:	39 ca                	cmp    %ecx,%edx
   23508:	74 09                	je     23513 <z_impl_k_mutex_unlock+0x39>
		z_thread_priority_set(mutex->owner, new_prio);
   2350a:	52                   	push   %edx
   2350b:	50                   	push   %eax
   2350c:	e8 f3 07 00 00       	call   23d04 <z_thread_priority_set>
   23511:	59                   	pop    %ecx
   23512:	5e                   	pop    %esi

	new_owner = z_unpend_first_thread(&mutex->wait_q);
   23513:	53                   	push   %ebx
   23514:	e8 68 08 00 00       	call   23d81 <z_unpend_first_thread>
   23519:	81 e7 00 02 00 00    	and    $0x200,%edi
   2351f:	5a                   	pop    %edx
   23520:	89 c6                	mov    %eax,%esi

	mutex->owner = new_owner;
   23522:	89 43 10             	mov    %eax,0x10(%ebx)

	K_DEBUG("new owner of mutex %p: %p (prio: %d)\n",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
   23525:	85 c0                	test   %eax,%eax
   23527:	74 2a                	je     23553 <z_impl_k_mutex_unlock+0x79>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   23529:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   2352d:	75 0d                	jne    2353c <z_impl_k_mutex_unlock+0x62>
	if (z_is_thread_ready(thread)) {
   2352f:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   23533:	75 07                	jne    2353c <z_impl_k_mutex_unlock+0x62>
		z_add_thread_to_ready_q(thread);
   23535:	50                   	push   %eax
   23536:	e8 8b 05 00 00       	call   23ac6 <z_add_thread_to_ready_q>
   2353b:	58                   	pop    %eax
   2353c:	85 ff                	test   %edi,%edi
   2353e:	74 01                	je     23541 <z_impl_k_mutex_unlock+0x67>
	__asm__ volatile (
   23540:	fb                   	sti    
   23541:	8b 46 28             	mov    0x28(%esi),%eax
   23544:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
   2354a:	0f be 46 0e          	movsbl 0xe(%esi),%eax
   2354e:	89 43 18             	mov    %eax,0x18(%ebx)
   23551:	eb 0c                	jmp    2355f <z_impl_k_mutex_unlock+0x85>
	} else {
		mutex->lock_count = 0;
   23553:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
   2355a:	85 ff                	test   %edi,%edi
   2355c:	74 01                	je     2355f <z_impl_k_mutex_unlock+0x85>
   2355e:	fb                   	sti    
	}


k_mutex_unlock_return:
	k_sched_unlock();
}
   2355f:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23562:	5b                   	pop    %ebx
   23563:	5e                   	pop    %esi
   23564:	5f                   	pop    %edi
   23565:	5d                   	pop    %ebp
	k_sched_unlock();
   23566:	e9 34 05 00 00       	jmp    23a9f <k_sched_unlock>

0002356b <queue_insert>:
			       struct k_queue *);
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   2356b:	55                   	push   %ebp
   2356c:	89 e5                	mov    %esp,%ebp
   2356e:	57                   	push   %edi
   2356f:	56                   	push   %esi
   23570:	53                   	push   %ebx
   23571:	89 c3                	mov    %eax,%ebx
   23573:	83 ec 0c             	sub    $0xc,%esp
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   23576:	8d 7b 08             	lea    0x8(%ebx),%edi
{
   23579:	8b 45 08             	mov    0x8(%ebp),%eax
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2357c:	89 7d f0             	mov    %edi,-0x10(%ebp)
	__asm__ volatile (
   2357f:	9c                   	pushf  
   23580:	fa                   	cli    
   23581:	5f                   	pop    %edi
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   23582:	84 c0                	test   %al,%al
   23584:	74 31                	je     235b7 <queue_insert+0x4c>
   23586:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   23589:	89 55 ec             	mov    %edx,-0x14(%ebp)
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   2358c:	6a 08                	push   $0x8
   2358e:	e8 36 fc ff ff       	call   231c9 <z_thread_malloc>
   23593:	5e                   	pop    %esi
		if (anode == NULL) {
   23594:	85 c0                	test   %eax,%eax
   23596:	8b 55 ec             	mov    -0x14(%ebp),%edx
   23599:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   2359c:	75 0e                	jne    235ac <queue_insert+0x41>
   2359e:	0f ba e7 09          	bt     $0x9,%edi
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   235a2:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   235a7:	73 78                	jae    23621 <queue_insert+0xb6>
	__asm__ volatile (
   235a9:	fb                   	sti    
   235aa:	eb 75                	jmp    23621 <queue_insert+0xb6>
		}
		anode->data = data;
   235ac:	89 48 04             	mov    %ecx,0x4(%eax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0, "flags too large");
	node->next_and_flags = flags;
   235af:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		sys_sfnode_init(&anode->node, 0x1);
		data = anode;
   235b5:	eb 08                	jmp    235bf <queue_insert+0x54>
   235b7:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   235bd:	89 c8                	mov    %ecx,%eax
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   235bf:	8b 08                	mov    (%eax),%ecx
   235c1:	83 e1 03             	and    $0x3,%ecx
   235c4:	85 d2                	test   %edx,%edx
   235c6:	75 0e                	jne    235d6 <queue_insert+0x6b>
	parent->next_and_flags = cur_flags | (unative_t)child;
   235c8:	0b 0b                	or     (%ebx),%ecx
Z_GENLIST_PREPEND(sflist, sfnode)
   235ca:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
	parent->next_and_flags = cur_flags | (unative_t)child;
   235ce:	89 08                	mov    %ecx,(%eax)
	list->head = node;
   235d0:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(sflist, sfnode)
   235d2:	75 34                	jne    23608 <queue_insert+0x9d>
   235d4:	eb 20                	jmp    235f6 <queue_insert+0x8b>
Z_GENLIST_INSERT(sflist, sfnode)
   235d6:	8b 32                	mov    (%edx),%esi
   235d8:	83 e6 fc             	and    $0xfffffffc,%esi
   235db:	75 1e                	jne    235fb <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
   235dd:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_APPEND(sflist, sfnode)
   235df:	8b 4b 04             	mov    0x4(%ebx),%ecx
   235e2:	85 c9                	test   %ecx,%ecx
   235e4:	75 07                	jne    235ed <queue_insert+0x82>
	list->tail = node;
   235e6:	89 43 04             	mov    %eax,0x4(%ebx)
	list->head = node;
   235e9:	89 03                	mov    %eax,(%ebx)
   235eb:	eb 1b                	jmp    23608 <queue_insert+0x9d>
	parent->next_and_flags = cur_flags | (unative_t)child;
   235ed:	8b 11                	mov    (%ecx),%edx
   235ef:	83 e2 03             	and    $0x3,%edx
   235f2:	09 c2                	or     %eax,%edx
   235f4:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
   235f6:	89 43 04             	mov    %eax,0x4(%ebx)
   235f9:	eb 0d                	jmp    23608 <queue_insert+0x9d>
	parent->next_and_flags = cur_flags | (unative_t)child;
   235fb:	09 f1                	or     %esi,%ecx
   235fd:	89 08                	mov    %ecx,(%eax)
   235ff:	8b 0a                	mov    (%edx),%ecx
   23601:	83 e1 03             	and    $0x3,%ecx
   23604:	09 c8                	or     %ecx,%eax
   23606:	89 02                	mov    %eax,(%edx)
	z_handle_obj_poll_events(&queue->poll_events, state);
   23608:	6a 04                	push   $0x4
   2360a:	ff 75 f0             	pushl  -0x10(%ebp)
   2360d:	e8 26 16 00 00       	call   24c38 <z_handle_obj_poll_events>
   23612:	58                   	pop    %eax
   23613:	5a                   	pop    %edx

#if defined(CONFIG_POLL)
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   23614:	57                   	push   %edi
   23615:	ff 75 f0             	pushl  -0x10(%ebp)
   23618:	e8 e8 02 00 00       	call   23905 <z_reschedule>
	return 0;
   2361d:	31 c0                	xor    %eax,%eax
	z_reschedule(&queue->lock, key);
   2361f:	59                   	pop    %ecx
   23620:	5b                   	pop    %ebx
}
   23621:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23624:	5b                   	pop    %ebx
   23625:	5e                   	pop    %esi
   23626:	5f                   	pop    %edi
   23627:	5d                   	pop    %ebp
   23628:	c3                   	ret    

00023629 <z_queue_node_peek>:
{
   23629:	55                   	push   %ebp
   2362a:	89 e5                	mov    %esp,%ebp
   2362c:	53                   	push   %ebx
   2362d:	8b 45 08             	mov    0x8(%ebp),%eax
   23630:	8b 55 0c             	mov    0xc(%ebp),%edx
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   23633:	85 c0                	test   %eax,%eax
   23635:	74 15                	je     2364c <z_queue_node_peek+0x23>
   23637:	f6 00 03             	testb  $0x3,(%eax)
   2363a:	74 10                	je     2364c <z_queue_node_peek+0x23>
		ret = anode->data;
   2363c:	8b 58 04             	mov    0x4(%eax),%ebx
		if (needs_free) {
   2363f:	84 d2                	test   %dl,%dl
   23641:	74 07                	je     2364a <z_queue_node_peek+0x21>
			k_free(anode);
   23643:	50                   	push   %eax
   23644:	e8 68 fb ff ff       	call   231b1 <k_free>
   23649:	58                   	pop    %eax
		if (needs_free) {
   2364a:	89 d8                	mov    %ebx,%eax
}
   2364c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   2364f:	c9                   	leave  
   23650:	c3                   	ret    

00023651 <z_impl_k_queue_init>:
{
   23651:	55                   	push   %ebp
   23652:	b9 04 00 00 00       	mov    $0x4,%ecx
   23657:	89 e5                	mov    %esp,%ebp
   23659:	57                   	push   %edi
   2365a:	53                   	push   %ebx
   2365b:	31 c0                	xor    %eax,%eax
   2365d:	8b 55 08             	mov    0x8(%ebp),%edx
	z_waitq_init(&queue->wait_q);
   23660:	8d 5a 08             	lea    0x8(%edx),%ebx
	list->head = NULL;
   23663:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   23669:	89 df                	mov    %ebx,%edi
	list->tail = NULL;
   2366b:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   23672:	f3 ab                	rep stos %eax,%es:(%edi)
	list->head = (sys_dnode_t *)list;
   23674:	89 5a 08             	mov    %ebx,0x8(%edx)
	list->tail = (sys_dnode_t *)list;
   23677:	89 5a 0c             	mov    %ebx,0xc(%edx)
}
   2367a:	5b                   	pop    %ebx
   2367b:	5f                   	pop    %edi
   2367c:	5d                   	pop    %ebp
   2367d:	c3                   	ret    

0002367e <z_impl_k_queue_cancel_wait>:
{
   2367e:	55                   	push   %ebp
   2367f:	89 e5                	mov    %esp,%ebp
   23681:	56                   	push   %esi
   23682:	53                   	push   %ebx
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   23683:	8b 45 08             	mov    0x8(%ebp),%eax
   23686:	8d 58 08             	lea    0x8(%eax),%ebx
	__asm__ volatile (
   23689:	9c                   	pushf  
   2368a:	fa                   	cli    
   2368b:	5e                   	pop    %esi
	z_handle_obj_poll_events(&queue->poll_events, state);
   2368c:	6a 08                	push   $0x8
   2368e:	53                   	push   %ebx
   2368f:	e8 a4 15 00 00       	call   24c38 <z_handle_obj_poll_events>
   23694:	58                   	pop    %eax
   23695:	5a                   	pop    %edx
	z_reschedule(&queue->lock, key);
   23696:	56                   	push   %esi
   23697:	53                   	push   %ebx
   23698:	e8 68 02 00 00       	call   23905 <z_reschedule>
   2369d:	59                   	pop    %ecx
   2369e:	5b                   	pop    %ebx
}
   2369f:	8d 65 f8             	lea    -0x8(%ebp),%esp
   236a2:	5b                   	pop    %ebx
   236a3:	5e                   	pop    %esi
   236a4:	5d                   	pop    %ebp
   236a5:	c3                   	ret    

000236a6 <k_queue_append>:
{
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
   236a6:	55                   	push   %ebp
   236a7:	89 e5                	mov    %esp,%ebp
   236a9:	8b 45 08             	mov    0x8(%ebp),%eax
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   236ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   236af:	8b 50 04             	mov    0x4(%eax),%edx
   236b2:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
			   data, false);
}
   236b9:	5d                   	pop    %ebp
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   236ba:	e9 ac fe ff ff       	jmp    2356b <queue_insert>

000236bf <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
   236bf:	55                   	push   %ebp
	(void)queue_insert(queue, NULL, data, false);
   236c0:	31 d2                	xor    %edx,%edx
{
   236c2:	89 e5                	mov    %esp,%ebp
   236c4:	8b 45 08             	mov    0x8(%ebp),%eax
	(void)queue_insert(queue, NULL, data, false);
   236c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   236ca:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
   236d1:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false);
   236d2:	e9 94 fe ff ff       	jmp    2356b <queue_insert>

000236d7 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   236d7:	55                   	push   %ebp
   236d8:	89 e5                	mov    %esp,%ebp
   236da:	57                   	push   %edi
   236db:	56                   	push   %esi
   236dc:	53                   	push   %ebx
   236dd:	83 ec 20             	sub    $0x20,%esp
   236e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
   236e3:	9c                   	pushf  
   236e4:	fa                   	cli    
   236e5:	5f                   	pop    %edi
Z_GENLIST_IS_EMPTY(sflist)
   236e6:	8b 33                	mov    (%ebx),%esi
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   236e8:	85 f6                	test   %esi,%esi
   236ea:	74 26                	je     23712 <z_impl_k_queue_get+0x3b>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   236ec:	8b 06                	mov    (%esi),%eax
   236ee:	83 e0 fc             	and    $0xfffffffc,%eax
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   236f1:	3b 73 04             	cmp    0x4(%ebx),%esi
	list->head = node;
   236f4:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   236f6:	75 03                	jne    236fb <z_impl_k_queue_get+0x24>
	list->tail = node;
   236f8:	89 43 04             	mov    %eax,0x4(%ebx)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   236fb:	6a 01                	push   $0x1
   236fd:	56                   	push   %esi
   236fe:	e8 26 ff ff ff       	call   23629 <z_queue_node_peek>
   23703:	0f ba e7 09          	bt     $0x9,%edi
   23707:	5b                   	pop    %ebx
   23708:	5e                   	pop    %esi
   23709:	89 c6                	mov    %eax,%esi
   2370b:	72 19                	jb     23726 <z_impl_k_queue_get+0x4f>
   2370d:	e9 d3 00 00 00       	jmp    237e5 <z_impl_k_queue_get+0x10e>
		k_spin_unlock(&queue->lock, key);
		return data;
	}

	if (timeout == K_NO_WAIT) {
   23712:	81 e7 00 02 00 00    	and    $0x200,%edi
   23718:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   2371c:	75 0e                	jne    2372c <z_impl_k_queue_get+0x55>
   2371e:	85 ff                	test   %edi,%edi
   23720:	0f 84 bf 00 00 00    	je     237e5 <z_impl_k_queue_get+0x10e>
	__asm__ volatile (
   23726:	fb                   	sti    
   23727:	e9 b9 00 00 00       	jmp    237e5 <z_impl_k_queue_get+0x10e>
   2372c:	85 ff                	test   %edi,%edi
   2372e:	74 01                	je     23731 <z_impl_k_queue_get+0x5a>
   23730:	fb                   	sti    
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   23731:	53                   	push   %ebx
   23732:	8d 45 e0             	lea    -0x20(%ebp),%eax
   23735:	6a 00                	push   $0x0
   23737:	6a 04                	push   $0x4
   23739:	50                   	push   %eax
   2373a:	e8 63 13 00 00       	call   24aa2 <k_poll_event_init>
   2373f:	83 c4 10             	add    $0x10,%esp
	if (timeout != K_FOREVER) {
   23742:	83 7d 0c ff          	cmpl   $0xffffffff,0xc(%ebp)
   23746:	74 08                	je     23750 <z_impl_k_queue_get+0x79>
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
   23748:	e8 a5 11 00 00       	call   248f2 <z_impl_k_uptime_get_32>
   2374d:	89 45 d8             	mov    %eax,-0x28(%ebp)
{
   23750:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		err = k_poll(&event, 1, timeout - elapsed);
   23757:	8b 45 0c             	mov    0xc(%ebp),%eax
   2375a:	2b 45 dc             	sub    -0x24(%ebp),%eax
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
   2375d:	50                   	push   %eax
   2375e:	8d 45 e0             	lea    -0x20(%ebp),%eax
   23761:	6a 01                	push   $0x1
		event.state = K_POLL_STATE_NOT_READY;
   23763:	81 65 ec ff 0f fe ff 	andl   $0xfffe0fff,-0x14(%ebp)
   2376a:	50                   	push   %eax
   2376b:	e8 73 13 00 00       	call   24ae3 <z_impl_k_poll>
   23770:	83 c4 0c             	add    $0xc,%esp
		if (err && err != -EAGAIN) {
   23773:	85 c0                	test   %eax,%eax
   23775:	74 05                	je     2377c <z_impl_k_queue_get+0xa5>
   23777:	83 f8 f5             	cmp    $0xfffffff5,%eax
   2377a:	75 69                	jne    237e5 <z_impl_k_queue_get+0x10e>
	__asm__ volatile (
   2377c:	9c                   	pushf  
   2377d:	fa                   	cli    
   2377e:	8f 45 d4             	popl   -0x2c(%ebp)
Z_GENLIST_IS_EMPTY(sflist)
   23781:	8b 03                	mov    (%ebx),%eax
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   23783:	85 c0                	test   %eax,%eax
   23785:	74 0f                	je     23796 <z_impl_k_queue_get+0xbf>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   23787:	8b 10                	mov    (%eax),%edx
   23789:	83 e2 fc             	and    $0xfffffffc,%edx
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2378c:	3b 43 04             	cmp    0x4(%ebx),%eax
	list->head = node;
   2378f:	89 13                	mov    %edx,(%ebx)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   23791:	75 03                	jne    23796 <z_impl_k_queue_get+0xbf>
	list->tail = node;
   23793:	89 53 04             	mov    %edx,0x4(%ebx)
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   23796:	6a 01                	push   $0x1
   23798:	50                   	push   %eax
   23799:	e8 8b fe ff ff       	call   23629 <z_queue_node_peek>
   2379e:	0f ba 65 d4 09       	btl    $0x9,-0x2c(%ebp)
   237a3:	5a                   	pop    %edx
   237a4:	89 c7                	mov    %eax,%edi
   237a6:	59                   	pop    %ecx
   237a7:	73 01                	jae    237aa <z_impl_k_queue_get+0xd3>
	__asm__ volatile (
   237a9:	fb                   	sti    
		if ((val == NULL) && (timeout != K_FOREVER)) {
   237aa:	85 ff                	test   %edi,%edi
   237ac:	0f 94 c1             	sete   %cl
   237af:	83 7d 0c ff          	cmpl   $0xffffffff,0xc(%ebp)
   237b3:	74 20                	je     237d5 <z_impl_k_queue_get+0xfe>
   237b5:	84 c9                	test   %cl,%cl
   237b7:	74 1c                	je     237d5 <z_impl_k_queue_get+0xfe>
   237b9:	88 4d d4             	mov    %cl,-0x2c(%ebp)
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
   237bc:	e8 31 11 00 00       	call   248f2 <z_impl_k_uptime_get_32>
			elapsed = k_uptime_get_32() - start;
   237c1:	2b 45 d8             	sub    -0x28(%ebp),%eax
   237c4:	8a 4d d4             	mov    -0x2c(%ebp),%cl
   237c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
			done = elapsed > timeout;
   237ca:	39 45 0c             	cmp    %eax,0xc(%ebp)
   237cd:	0f 9c c0             	setl   %al
   237d0:	0f b6 c0             	movzbl %al,%eax
   237d3:	eb 02                	jmp    237d7 <z_impl_k_queue_get+0x100>
		if ((val == NULL) && (timeout != K_FOREVER)) {
   237d5:	31 c0                	xor    %eax,%eax
	} while (!val && !done);
   237d7:	85 c0                	test   %eax,%eax
   237d9:	75 08                	jne    237e3 <z_impl_k_queue_get+0x10c>
   237db:	84 c9                	test   %cl,%cl
   237dd:	0f 85 74 ff ff ff    	jne    23757 <z_impl_k_queue_get+0x80>
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   237e3:	89 fe                	mov    %edi,%esi
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   237e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
   237e8:	89 f0                	mov    %esi,%eax
   237ea:	5b                   	pop    %ebx
   237eb:	5e                   	pop    %esi
   237ec:	5f                   	pop    %edi
   237ed:	5d                   	pop    %ebp
   237ee:	c3                   	ret    

000237ef <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   237ef:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   237f3:	75 0c                	jne    23801 <z_is_thread_ready+0x12>
   237f5:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   237f9:	0f 94 c0             	sete   %al
   237fc:	0f b6 c0             	movzbl %al,%eax
   237ff:	eb 02                	jmp    23803 <z_is_thread_ready+0x14>
   23801:	31 c0                	xor    %eax,%eax
   23803:	83 e0 01             	and    $0x1,%eax
}
   23806:	c3                   	ret    

00023807 <z_priq_rb_lessthan>:
	}
	return t;
}

bool z_priq_rb_lessthan(struct rbnode *a, struct rbnode *b)
{
   23807:	55                   	push   %ebp

	ta = CONTAINER_OF(a, struct k_thread, base.qnode_rb);
	tb = CONTAINER_OF(b, struct k_thread, base.qnode_rb);

	if (z_is_t1_higher_prio_than_t2(ta, tb)) {
		return true;
   23808:	b0 01                	mov    $0x1,%al
{
   2380a:	89 e5                	mov    %esp,%ebp
   2380c:	53                   	push   %ebx
   2380d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   23810:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (t1->base.prio < t2->base.prio) {
   23813:	8a 59 0e             	mov    0xe(%ecx),%bl
   23816:	38 5a 0e             	cmp    %bl,0xe(%edx)
   23819:	7f 0d                	jg     23828 <z_priq_rb_lessthan+0x21>
	} else if (z_is_t1_higher_prio_than_t2(tb, ta)) {
		return false;
   2381b:	b0 00                	mov    $0x0,%al
	if (t1->base.prio < t2->base.prio) {
   2381d:	7c 09                	jl     23828 <z_priq_rb_lessthan+0x21>
	} else {
		return ta->base.order_key < tb->base.order_key ? 1 : 0;
   2381f:	8b 42 10             	mov    0x10(%edx),%eax
   23822:	39 41 10             	cmp    %eax,0x10(%ecx)
   23825:	0f 92 c0             	setb   %al
	}
}
   23828:	5b                   	pop    %ebx
   23829:	5d                   	pop    %ebp
   2382a:	c3                   	ret    

0002382b <reset_time_slice>:
{
   2382b:	55                   	push   %ebp
   2382c:	89 e5                	mov    %esp,%ebp
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   2382e:	e8 be 66 fe ff       	call   9ef1 <z_clock_elapsed>
	z_set_timeout_expiry(slice_time, false);
   23833:	6a 00                	push   $0x0
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   23835:	8b 15 44 45 40 00    	mov    0x404544,%edx
   2383b:	01 d0                	add    %edx,%eax
	z_set_timeout_expiry(slice_time, false);
   2383d:	52                   	push   %edx
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   2383e:	a3 30 41 40 00       	mov    %eax,0x404130
	z_set_timeout_expiry(slice_time, false);
   23843:	e8 5a 0f 00 00       	call   247a2 <z_set_timeout_expiry>
   23848:	58                   	pop    %eax
   23849:	5a                   	pop    %edx
}
   2384a:	c9                   	leave  
   2384b:	c3                   	ret    

0002384c <z_is_t1_higher_prio_than_t2>:
{
   2384c:	55                   	push   %ebp
   2384d:	89 e5                	mov    %esp,%ebp
	if (t1->base.prio < t2->base.prio) {
   2384f:	8b 45 0c             	mov    0xc(%ebp),%eax
   23852:	8b 55 08             	mov    0x8(%ebp),%edx
}
   23855:	5d                   	pop    %ebp
	if (t1->base.prio < t2->base.prio) {
   23856:	8a 40 0e             	mov    0xe(%eax),%al
   23859:	38 42 0e             	cmp    %al,0xe(%edx)
   2385c:	0f 9c c0             	setl   %al
}
   2385f:	c3                   	ret    

00023860 <k_sched_time_slice_set>:
{
   23860:	55                   	push   %ebp
   23861:	89 e5                	mov    %esp,%ebp
   23863:	57                   	push   %edi
   23864:	56                   	push   %esi
   23865:	53                   	push   %ebx
   23866:	50                   	push   %eax
	__asm__ volatile (
   23867:	9c                   	pushf  
   23868:	fa                   	cli    
   23869:	8f 45 f0             	popl   -0x10(%ebp)
	return z_clock_hw_cycles_per_sec;
   2386c:	8b 1d 24 a7 40 00    	mov    0x40a724,%ebx
	return (s32_t)ceiling_fraction(
   23872:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   23877:	f7 eb                	imul   %ebx
   23879:	6a 00                	push   $0x0
		_current_cpu->slice_ticks = 0;
   2387b:	c7 05 30 41 40 00 00 	movl   $0x0,0x404130
   23882:	00 00 00 
   23885:	6a 64                	push   $0x64
   23887:	52                   	push   %edx
   23888:	50                   	push   %eax
   23889:	e8 42 d8 fd ff       	call   10d0 <__divdi3>
   2388e:	89 c6                	mov    %eax,%esi
   23890:	89 d8                	mov    %ebx,%eax
   23892:	89 d7                	mov    %edx,%edi
   23894:	83 c4 10             	add    $0x10,%esp
   23897:	f7 6d 08             	imull  0x8(%ebp)
   2389a:	89 f1                	mov    %esi,%ecx
   2389c:	89 fb                	mov    %edi,%ebx
   2389e:	83 c1 ff             	add    $0xffffffff,%ecx
   238a1:	57                   	push   %edi
   238a2:	83 d3 ff             	adc    $0xffffffff,%ebx
   238a5:	01 c8                	add    %ecx,%eax
   238a7:	11 da                	adc    %ebx,%edx
   238a9:	56                   	push   %esi
   238aa:	52                   	push   %edx
   238ab:	50                   	push   %eax
   238ac:	e8 1f d8 fd ff       	call   10d0 <__divdi3>
   238b1:	83 c4 10             	add    $0x10,%esp
   238b4:	a3 44 45 40 00       	mov    %eax,0x404544
		slice_max_prio = prio;
   238b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   238bc:	a3 40 45 40 00       	mov    %eax,0x404540
		reset_time_slice();
   238c1:	e8 65 ff ff ff       	call   2382b <reset_time_slice>
   238c6:	0f ba 65 f0 09       	btl    $0x9,-0x10(%ebp)
   238cb:	73 01                	jae    238ce <k_sched_time_slice_set+0x6e>
	__asm__ volatile (
   238cd:	fb                   	sti    
}
   238ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
   238d1:	5b                   	pop    %ebx
   238d2:	5e                   	pop    %esi
   238d3:	5f                   	pop    %edi
   238d4:	5d                   	pop    %ebp
   238d5:	c3                   	ret    

000238d6 <z_unpend_thread_no_timeout>:
{
   238d6:	55                   	push   %ebp
   238d7:	89 e5                	mov    %esp,%ebp
   238d9:	56                   	push   %esi
   238da:	53                   	push   %ebx
   238db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   238de:	9c                   	pushf  
   238df:	fa                   	cli    
   238e0:	5e                   	pop    %esi
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   238e1:	53                   	push   %ebx
   238e2:	ff 73 08             	pushl  0x8(%ebx)
   238e5:	e8 f7 00 00 00       	call   239e1 <z_priq_rb_remove>
   238ea:	58                   	pop    %eax
   238eb:	5a                   	pop    %edx
	thread->base.thread_state &= ~_THREAD_PENDING;
   238ec:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
   238f0:	0f ba e6 09          	bt     $0x9,%esi
   238f4:	73 01                	jae    238f7 <z_unpend_thread_no_timeout+0x21>
	__asm__ volatile (
   238f6:	fb                   	sti    
	thread->base.pended_on = NULL;
   238f7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
   238fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23901:	5b                   	pop    %ebx
   23902:	5e                   	pop    %esi
   23903:	5d                   	pop    %ebp
   23904:	c3                   	ret    

00023905 <z_reschedule>:
{
   23905:	55                   	push   %ebp
   23906:	89 e5                	mov    %esp,%ebp
	if (resched()) {
   23908:	83 3d 20 41 40 00 00 	cmpl   $0x0,0x404120
{
   2390f:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched()) {
   23912:	75 09                	jne    2391d <z_reschedule+0x18>
   23914:	89 45 08             	mov    %eax,0x8(%ebp)
}
   23917:	5d                   	pop    %ebp
   23918:	e9 c1 66 fe ff       	jmp    9fde <__swap>
   2391d:	0f ba e0 09          	bt     $0x9,%eax
   23921:	73 01                	jae    23924 <z_reschedule+0x1f>
   23923:	fb                   	sti    
   23924:	5d                   	pop    %ebp
   23925:	c3                   	ret    

00023926 <z_reschedule_irqlock>:
{
   23926:	55                   	push   %ebp
   23927:	89 e5                	mov    %esp,%ebp
	if (resched()) {
   23929:	83 3d 20 41 40 00 00 	cmpl   $0x0,0x404120
{
   23930:	8b 45 08             	mov    0x8(%ebp),%eax
	if (resched()) {
   23933:	75 06                	jne    2393b <z_reschedule_irqlock+0x15>
}
   23935:	5d                   	pop    %ebp
   23936:	e9 a3 66 fe ff       	jmp    9fde <__swap>
   2393b:	0f ba e0 09          	bt     $0x9,%eax
   2393f:	73 01                	jae    23942 <z_reschedule_irqlock+0x1c>
   23941:	fb                   	sti    
   23942:	5d                   	pop    %ebp
   23943:	c3                   	ret    

00023944 <z_reschedule_unlocked>:
{
   23944:	55                   	push   %ebp
   23945:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
   23947:	9c                   	pushf  
   23948:	fa                   	cli    
   23949:	58                   	pop    %eax
	(void) z_reschedule_irqlock(z_arch_irq_lock());
   2394a:	50                   	push   %eax
   2394b:	e8 d6 ff ff ff       	call   23926 <z_reschedule_irqlock>
   23950:	58                   	pop    %eax
}
   23951:	c9                   	leave  
   23952:	c3                   	ret    

00023953 <k_sched_lock>:
   23953:	9c                   	pushf  
   23954:	fa                   	cli    
   23955:	5a                   	pop    %edx
	--_current->base.sched_locked;
   23956:	a1 28 41 40 00       	mov    0x404128,%eax
   2395b:	fe 48 0f             	decb   0xf(%eax)
   2395e:	0f ba e2 09          	bt     $0x9,%edx
   23962:	73 01                	jae    23965 <k_sched_lock+0x12>
	__asm__ volatile (
   23964:	fb                   	sti    
}
   23965:	c3                   	ret    

00023966 <z_priq_rb_add>:

void z_priq_rb_add(struct _priq_rb *pq, struct k_thread *thread)
{
   23966:	55                   	push   %ebp
   23967:	89 e5                	mov    %esp,%ebp
   23969:	56                   	push   %esi
   2396a:	53                   	push   %ebx
   2396b:	83 ec 0c             	sub    $0xc,%esp
   2396e:	8b 5d 08             	mov    0x8(%ebp),%ebx
   23971:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct k_thread *t;

	__ASSERT_NO_MSG(!is_idle(thread));

	thread->base.order_key = pq->next_order_key++;
   23974:	8b 53 0c             	mov    0xc(%ebx),%edx
   23977:	8d 42 01             	lea    0x1(%edx),%eax
   2397a:	89 43 0c             	mov    %eax,0xc(%ebx)
	 * will almost never be hit on real systems.  BUT on very
	 * long-running systems where a priq never completely empties
	 * AND that contains very large numbers of threads, it can be
	 * a latency glitch to loop over all the threads like this.
	 */
	if (!pq->next_order_key) {
   2397d:	85 c0                	test   %eax,%eax
	thread->base.order_key = pq->next_order_key++;
   2397f:	89 56 10             	mov    %edx,0x10(%esi)
	if (!pq->next_order_key) {
   23982:	75 4d                	jne    239d1 <z_priq_rb_add+0x6b>
		RB_FOR_EACH_CONTAINER(&pq->tree, t, base.qnode_rb) {
   23984:	8b 43 08             	mov    0x8(%ebx),%eax
   23987:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
   2398e:	8d 14 85 0c 00 00 00 	lea    0xc(,%eax,4),%edx
   23995:	83 c0 0f             	add    $0xf,%eax
   23998:	29 d4                	sub    %edx,%esp
   2399a:	83 e0 fc             	and    $0xfffffffc,%eax
   2399d:	8d 54 24 0f          	lea    0xf(%esp),%edx
   239a1:	29 c4                	sub    %eax,%esp
   239a3:	83 e2 f0             	and    $0xfffffff0,%edx
   239a6:	8d 44 24 0f          	lea    0xf(%esp),%eax
   239aa:	89 55 ec             	mov    %edx,-0x14(%ebp)
   239ad:	83 e0 f0             	and    $0xfffffff0,%eax
   239b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   239b3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   239b6:	50                   	push   %eax
   239b7:	53                   	push   %ebx
   239b8:	e8 3b ec fd ff       	call   25f8 <z_rb_foreach_next>
   239bd:	59                   	pop    %ecx
   239be:	85 c0                	test   %eax,%eax
   239c0:	5a                   	pop    %edx
   239c1:	74 0e                	je     239d1 <z_priq_rb_add+0x6b>
			t->base.order_key = pq->next_order_key++;
   239c3:	8b 53 0c             	mov    0xc(%ebx),%edx
   239c6:	8d 4a 01             	lea    0x1(%edx),%ecx
   239c9:	89 4b 0c             	mov    %ecx,0xc(%ebx)
   239cc:	89 50 10             	mov    %edx,0x10(%eax)
   239cf:	eb e2                	jmp    239b3 <z_priq_rb_add+0x4d>
		}
	}

	rb_insert(&pq->tree, &thread->base.qnode_rb);
   239d1:	56                   	push   %esi
   239d2:	53                   	push   %ebx
   239d3:	e8 03 e9 fd ff       	call   22db <rb_insert>
   239d8:	58                   	pop    %eax
   239d9:	5a                   	pop    %edx
}
   239da:	8d 65 f8             	lea    -0x8(%ebp),%esp
   239dd:	5b                   	pop    %ebx
   239de:	5e                   	pop    %esi
   239df:	5d                   	pop    %ebp
   239e0:	c3                   	ret    

000239e1 <z_priq_rb_remove>:

void z_priq_rb_remove(struct _priq_rb *pq, struct k_thread *thread)
{
   239e1:	55                   	push   %ebp
   239e2:	89 e5                	mov    %esp,%ebp
   239e4:	53                   	push   %ebx
		return;
	}
#endif
	__ASSERT_NO_MSG(!is_idle(thread));

	rb_remove(&pq->tree, &thread->base.qnode_rb);
   239e5:	ff 75 0c             	pushl  0xc(%ebp)
{
   239e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rb_remove(&pq->tree, &thread->base.qnode_rb);
   239eb:	53                   	push   %ebx
   239ec:	e8 2d ea fd ff       	call   241e <rb_remove>
   239f1:	58                   	pop    %eax

	if (!pq->tree.root) {
   239f2:	83 3b 00             	cmpl   $0x0,(%ebx)
	rb_remove(&pq->tree, &thread->base.qnode_rb);
   239f5:	5a                   	pop    %edx
	if (!pq->tree.root) {
   239f6:	75 07                	jne    239ff <z_priq_rb_remove+0x1e>
		pq->next_order_key = 0;
   239f8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	}
}
   239ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   23a02:	c9                   	leave  
   23a03:	c3                   	ret    

00023a04 <z_unpend_thread>:
{
   23a04:	55                   	push   %ebp
   23a05:	89 e5                	mov    %esp,%ebp
   23a07:	56                   	push   %esi
   23a08:	53                   	push   %ebx
   23a09:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   23a0c:	9c                   	pushf  
   23a0d:	fa                   	cli    
   23a0e:	5e                   	pop    %esi
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   23a0f:	53                   	push   %ebx
   23a10:	ff 73 08             	pushl  0x8(%ebx)
   23a13:	e8 c9 ff ff ff       	call   239e1 <z_priq_rb_remove>
   23a18:	58                   	pop    %eax
   23a19:	5a                   	pop    %edx
	thread->base.thread_state &= ~_THREAD_PENDING;
   23a1a:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
   23a1e:	0f ba e6 09          	bt     $0x9,%esi
   23a22:	73 01                	jae    23a25 <z_unpend_thread+0x21>
	__asm__ volatile (
   23a24:	fb                   	sti    
	thread->base.pended_on = NULL;
   23a25:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   23a2c:	83 c3 18             	add    $0x18,%ebx
   23a2f:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   23a32:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23a35:	5b                   	pop    %ebx
   23a36:	5e                   	pop    %esi
   23a37:	5d                   	pop    %ebp
   23a38:	e9 d5 0c 00 00       	jmp    24712 <z_abort_timeout>

00023a3d <z_priq_rb_best>:

struct k_thread *z_priq_rb_best(struct _priq_rb *pq)
{
   23a3d:	55                   	push   %ebp
   23a3e:	89 e5                	mov    %esp,%ebp
   23a40:	6a 00                	push   $0x0
   23a42:	ff 75 08             	pushl  0x8(%ebp)
   23a45:	e8 6a e8 fd ff       	call   22b4 <z_rb_get_minmax>
   23a4a:	5a                   	pop    %edx
   23a4b:	59                   	pop    %ecx

	if (n != NULL) {
		t = CONTAINER_OF(n, struct k_thread, base.qnode_rb);
	}
	return t;
}
   23a4c:	c9                   	leave  
   23a4d:	c3                   	ret    

00023a4e <update_cache>:
{
   23a4e:	55                   	push   %ebp
   23a4f:	89 e5                	mov    %esp,%ebp
   23a51:	56                   	push   %esi
   23a52:	53                   	push   %ebx
   23a53:	89 c6                	mov    %eax,%esi
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
   23a55:	68 44 41 40 00       	push   $0x404144
   23a5a:	e8 de ff ff ff       	call   23a3d <z_priq_rb_best>
   23a5f:	5a                   	pop    %edx
	return th ? th : _current_cpu->idle_thread;
   23a60:	8b 1d 2c 41 40 00    	mov    0x40412c,%ebx
   23a66:	85 c0                	test   %eax,%eax
   23a68:	74 02                	je     23a6c <update_cache+0x1e>
   23a6a:	89 c3                	mov    %eax,%ebx
	if (preempt_ok != 0) {
   23a6c:	a1 28 41 40 00       	mov    0x404128,%eax
   23a71:	85 f6                	test   %esi,%esi
   23a73:	75 14                	jne    23a89 <update_cache+0x3b>
	if (z_is_thread_prevented_from_running(_current)) {
   23a75:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   23a79:	75 0e                	jne    23a89 <update_cache+0x3b>
	if (is_preempt(_current) || is_metairq(th)) {
   23a7b:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
   23a80:	76 07                	jbe    23a89 <update_cache+0x3b>
		_kernel.ready_q.cache = _current;
   23a82:	a3 40 41 40 00       	mov    %eax,0x404140
   23a87:	eb 0f                	jmp    23a98 <update_cache+0x4a>
		if (th != _current) {
   23a89:	39 c3                	cmp    %eax,%ebx
   23a8b:	74 05                	je     23a92 <update_cache+0x44>
			reset_time_slice();
   23a8d:	e8 99 fd ff ff       	call   2382b <reset_time_slice>
		_kernel.ready_q.cache = th;
   23a92:	89 1d 40 41 40 00    	mov    %ebx,0x404140
}
   23a98:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23a9b:	5b                   	pop    %ebx
   23a9c:	5e                   	pop    %esi
   23a9d:	5d                   	pop    %ebp
   23a9e:	c3                   	ret    

00023a9f <k_sched_unlock>:
{
   23a9f:	55                   	push   %ebp
   23aa0:	89 e5                	mov    %esp,%ebp
   23aa2:	53                   	push   %ebx
	__asm__ volatile (
   23aa3:	9c                   	pushf  
   23aa4:	fa                   	cli    
   23aa5:	5b                   	pop    %ebx
		++_current->base.sched_locked;
   23aa6:	a1 28 41 40 00       	mov    0x404128,%eax
   23aab:	fe 40 0f             	incb   0xf(%eax)
		update_cache(1);
   23aae:	b8 01 00 00 00       	mov    $0x1,%eax
   23ab3:	e8 96 ff ff ff       	call   23a4e <update_cache>
   23ab8:	0f ba e3 09          	bt     $0x9,%ebx
   23abc:	73 01                	jae    23abf <k_sched_unlock+0x20>
	__asm__ volatile (
   23abe:	fb                   	sti    
}
   23abf:	5b                   	pop    %ebx
   23ac0:	5d                   	pop    %ebp
	z_reschedule_unlocked();
   23ac1:	e9 7e fe ff ff       	jmp    23944 <z_reschedule_unlocked>

00023ac6 <z_add_thread_to_ready_q>:
{
   23ac6:	55                   	push   %ebp
   23ac7:	89 e5                	mov    %esp,%ebp
   23ac9:	56                   	push   %esi
   23aca:	53                   	push   %ebx
   23acb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   23ace:	9c                   	pushf  
   23acf:	fa                   	cli    
   23ad0:	5e                   	pop    %esi
		_priq_run_add(&_kernel.ready_q.runq, thread);
   23ad1:	53                   	push   %ebx
   23ad2:	68 44 41 40 00       	push   $0x404144
   23ad7:	e8 8a fe ff ff       	call   23966 <z_priq_rb_add>
   23adc:	58                   	pop    %eax
		update_cache(0);
   23add:	31 c0                	xor    %eax,%eax
		_priq_run_add(&_kernel.ready_q.runq, thread);
   23adf:	5a                   	pop    %edx
	thread->base.thread_state |= states;
   23ae0:	80 4b 0d 40          	orb    $0x40,0xd(%ebx)
		update_cache(0);
   23ae4:	e8 65 ff ff ff       	call   23a4e <update_cache>
   23ae9:	0f ba e6 09          	bt     $0x9,%esi
   23aed:	73 01                	jae    23af0 <z_add_thread_to_ready_q+0x2a>
	__asm__ volatile (
   23aef:	fb                   	sti    
}
   23af0:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23af3:	5b                   	pop    %ebx
   23af4:	5e                   	pop    %esi
   23af5:	5d                   	pop    %ebp
   23af6:	c3                   	ret    

00023af7 <z_thread_timeout>:
{
   23af7:	55                   	push   %ebp
   23af8:	89 e5                	mov    %esp,%ebp
   23afa:	57                   	push   %edi
   23afb:	56                   	push   %esi
   23afc:	53                   	push   %ebx
   23afd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
   23b00:	8d 73 e8             	lea    -0x18(%ebx),%esi
	if (th->base.pended_on != NULL) {
   23b03:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
   23b07:	74 20                	je     23b29 <z_thread_timeout+0x32>
	__asm__ volatile (
   23b09:	9c                   	pushf  
   23b0a:	fa                   	cli    
   23b0b:	5f                   	pop    %edi
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   23b0c:	56                   	push   %esi
   23b0d:	ff 73 f0             	pushl  -0x10(%ebx)
   23b10:	e8 cc fe ff ff       	call   239e1 <z_priq_rb_remove>
   23b15:	58                   	pop    %eax
   23b16:	5a                   	pop    %edx
	thread->base.thread_state &= ~_THREAD_PENDING;
   23b17:	80 63 f5 fd          	andb   $0xfd,-0xb(%ebx)
   23b1b:	0f ba e7 09          	bt     $0x9,%edi
   23b1f:	73 01                	jae    23b22 <z_thread_timeout+0x2b>
	__asm__ volatile (
   23b21:	fb                   	sti    
	thread->base.pended_on = NULL;
   23b22:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23b29:	80 63 f5 fb          	andb   $0xfb,-0xb(%ebx)
	if (z_is_thread_ready(thread)) {
   23b2d:	89 f0                	mov    %esi,%eax
   23b2f:	e8 bb fc ff ff       	call   237ef <z_is_thread_ready>
   23b34:	84 c0                	test   %al,%al
   23b36:	74 0f                	je     23b47 <z_thread_timeout+0x50>
		z_add_thread_to_ready_q(thread);
   23b38:	89 75 08             	mov    %esi,0x8(%ebp)
}
   23b3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23b3e:	5b                   	pop    %ebx
   23b3f:	5e                   	pop    %esi
   23b40:	5f                   	pop    %edi
   23b41:	5d                   	pop    %ebp
   23b42:	e9 7f ff ff ff       	jmp    23ac6 <z_add_thread_to_ready_q>
   23b47:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23b4a:	5b                   	pop    %ebx
   23b4b:	5e                   	pop    %esi
   23b4c:	5f                   	pop    %edi
   23b4d:	5d                   	pop    %ebp
   23b4e:	c3                   	ret    

00023b4f <z_move_thread_to_end_of_prio_q>:
{
   23b4f:	55                   	push   %ebp
   23b50:	89 e5                	mov    %esp,%ebp
   23b52:	56                   	push   %esi
   23b53:	53                   	push   %ebx
   23b54:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   23b57:	9c                   	pushf  
   23b58:	fa                   	cli    
   23b59:	5e                   	pop    %esi
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   23b5a:	53                   	push   %ebx
   23b5b:	68 44 41 40 00       	push   $0x404144
   23b60:	e8 7c fe ff ff       	call   239e1 <z_priq_rb_remove>
   23b65:	58                   	pop    %eax
   23b66:	5a                   	pop    %edx
		_priq_run_add(&_kernel.ready_q.runq, thread);
   23b67:	53                   	push   %ebx
   23b68:	68 44 41 40 00       	push   $0x404144
   23b6d:	e8 f4 fd ff ff       	call   23966 <z_priq_rb_add>
   23b72:	59                   	pop    %ecx
   23b73:	58                   	pop    %eax
		update_cache(thread == _current);
   23b74:	31 c0                	xor    %eax,%eax
	thread->base.thread_state |= states;
   23b76:	80 4b 0d 40          	orb    $0x40,0xd(%ebx)
   23b7a:	39 1d 28 41 40 00    	cmp    %ebx,0x404128
   23b80:	0f 94 c0             	sete   %al
   23b83:	e8 c6 fe ff ff       	call   23a4e <update_cache>
   23b88:	0f ba e6 09          	bt     $0x9,%esi
   23b8c:	73 01                	jae    23b8f <z_move_thread_to_end_of_prio_q+0x40>
	__asm__ volatile (
   23b8e:	fb                   	sti    
}
   23b8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23b92:	5b                   	pop    %ebx
   23b93:	5e                   	pop    %esi
   23b94:	5d                   	pop    %ebp
   23b95:	c3                   	ret    

00023b96 <z_time_slice>:
{
   23b96:	55                   	push   %ebp
   23b97:	89 e5                	mov    %esp,%ebp
	if (slice_time && sliceable(_current)) {
   23b99:	83 3d 44 45 40 00 00 	cmpl   $0x0,0x404544
{
   23ba0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (slice_time && sliceable(_current)) {
   23ba3:	74 45                	je     23bea <z_time_slice+0x54>
   23ba5:	a1 28 41 40 00       	mov    0x404128,%eax
		&& !z_is_thread_timeout_active(t);
   23baa:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
   23baf:	77 39                	ja     23bea <z_time_slice+0x54>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
   23bb1:	0f be 50 0e          	movsbl 0xe(%eax),%edx
   23bb5:	39 15 40 45 40 00    	cmp    %edx,0x404540
   23bbb:	7f 2d                	jg     23bea <z_time_slice+0x54>
		&& !is_idle(t)
   23bbd:	3b 05 40 66 02 00    	cmp    0x26640,%eax
   23bc3:	74 25                	je     23bea <z_time_slice+0x54>
		&& !z_is_thread_timeout_active(t);
   23bc5:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   23bc9:	75 1f                	jne    23bea <z_time_slice+0x54>
		if (ticks >= _current_cpu->slice_ticks) {
   23bcb:	8b 15 30 41 40 00    	mov    0x404130,%edx
   23bd1:	39 ca                	cmp    %ecx,%edx
   23bd3:	7f 0d                	jg     23be2 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   23bd5:	50                   	push   %eax
   23bd6:	e8 74 ff ff ff       	call   23b4f <z_move_thread_to_end_of_prio_q>
   23bdb:	58                   	pop    %eax
}
   23bdc:	c9                   	leave  
			reset_time_slice();
   23bdd:	e9 49 fc ff ff       	jmp    2382b <reset_time_slice>
			_current_cpu->slice_ticks -= ticks;
   23be2:	29 ca                	sub    %ecx,%edx
   23be4:	89 15 30 41 40 00    	mov    %edx,0x404130
}
   23bea:	c9                   	leave  
   23beb:	c3                   	ret    

00023bec <z_remove_thread_from_ready_q>:
{
   23bec:	55                   	push   %ebp
   23bed:	89 e5                	mov    %esp,%ebp
   23bef:	56                   	push   %esi
   23bf0:	53                   	push   %ebx
   23bf1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
   23bf4:	9c                   	pushf  
   23bf5:	fa                   	cli    
   23bf6:	5e                   	pop    %esi
		if (z_is_thread_queued(thread)) {
   23bf7:	f6 43 0d 40          	testb  $0x40,0xd(%ebx)
   23bfb:	74 11                	je     23c0e <z_remove_thread_from_ready_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   23bfd:	53                   	push   %ebx
   23bfe:	68 44 41 40 00       	push   $0x404144
   23c03:	e8 d9 fd ff ff       	call   239e1 <z_priq_rb_remove>
   23c08:	58                   	pop    %eax
   23c09:	5a                   	pop    %edx
	thread->base.thread_state &= ~states;
   23c0a:	80 63 0d bf          	andb   $0xbf,0xd(%ebx)
		update_cache(thread == _current);
   23c0e:	31 c0                	xor    %eax,%eax
   23c10:	39 1d 28 41 40 00    	cmp    %ebx,0x404128
   23c16:	0f 94 c0             	sete   %al
   23c19:	e8 30 fe ff ff       	call   23a4e <update_cache>
   23c1e:	0f ba e6 09          	bt     $0x9,%esi
   23c22:	73 01                	jae    23c25 <z_remove_thread_from_ready_q+0x39>
	__asm__ volatile (
   23c24:	fb                   	sti    
}
   23c25:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23c28:	5b                   	pop    %ebx
   23c29:	5e                   	pop    %esi
   23c2a:	5d                   	pop    %ebp
   23c2b:	c3                   	ret    

00023c2c <pend>:
{
   23c2c:	55                   	push   %ebp
   23c2d:	89 e5                	mov    %esp,%ebp
   23c2f:	57                   	push   %edi
   23c30:	56                   	push   %esi
   23c31:	89 d6                	mov    %edx,%esi
   23c33:	53                   	push   %ebx
   23c34:	89 c3                	mov    %eax,%ebx
   23c36:	83 ec 0c             	sub    $0xc,%esp
   23c39:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	z_remove_thread_from_ready_q(thread);
   23c3c:	50                   	push   %eax
   23c3d:	e8 aa ff ff ff       	call   23bec <z_remove_thread_from_ready_q>
   23c42:	59                   	pop    %ecx
	thread->base.thread_state |= _THREAD_PENDING;
   23c43:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
	if (wait_q != NULL) {
   23c47:	85 f6                	test   %esi,%esi
   23c49:	74 0c                	je     23c57 <pend+0x2b>
		thread->base.pended_on = wait_q;
   23c4b:	89 73 08             	mov    %esi,0x8(%ebx)
		z_priq_wait_add(&wait_q->waitq, thread);
   23c4e:	53                   	push   %ebx
   23c4f:	56                   	push   %esi
   23c50:	e8 11 fd ff ff       	call   23966 <z_priq_rb_add>
   23c55:	58                   	pop    %eax
   23c56:	5a                   	pop    %edx
	if (timeout != K_FOREVER) {
   23c57:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
   23c5b:	74 5d                	je     23cba <pend+0x8e>
	return z_clock_hw_cycles_per_sec;
   23c5d:	a1 24 a7 40 00       	mov    0x40a724,%eax
	return (s32_t)ceiling_fraction(
   23c62:	6a 00                	push   $0x0
	return z_clock_hw_cycles_per_sec;
   23c64:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return (s32_t)ceiling_fraction(
   23c67:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   23c6c:	f7 6d ec             	imull  -0x14(%ebp)
   23c6f:	6a 64                	push   $0x64
   23c71:	52                   	push   %edx
   23c72:	50                   	push   %eax
   23c73:	e8 58 d4 fd ff       	call   10d0 <__divdi3>
   23c78:	89 c6                	mov    %eax,%esi
   23c7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   23c7d:	89 d7                	mov    %edx,%edi
   23c7f:	83 c4 10             	add    $0x10,%esp
   23c82:	f7 6d ec             	imull  -0x14(%ebp)
   23c85:	89 45 ec             	mov    %eax,-0x14(%ebp)
   23c88:	89 f0                	mov    %esi,%eax
   23c8a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   23c8d:	83 c0 ff             	add    $0xffffffff,%eax
   23c90:	89 fa                	mov    %edi,%edx
   23c92:	57                   	push   %edi
   23c93:	83 d2 ff             	adc    $0xffffffff,%edx
   23c96:	03 45 ec             	add    -0x14(%ebp),%eax
   23c99:	13 55 f0             	adc    -0x10(%ebp),%edx
   23c9c:	56                   	push   %esi
   23c9d:	52                   	push   %edx
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   23c9e:	83 c3 18             	add    $0x18,%ebx
   23ca1:	50                   	push   %eax
   23ca2:	e8 29 d4 fd ff       	call   10d0 <__divdi3>
   23ca7:	83 c4 10             	add    $0x10,%esp
		s32_t ticks = _TICK_ALIGN + z_ms_to_ticks(timeout);
   23caa:	40                   	inc    %eax
   23cab:	50                   	push   %eax
   23cac:	68 f7 3a 02 00       	push   $0x23af7
   23cb1:	53                   	push   %ebx
   23cb2:	e8 a9 09 00 00       	call   24660 <z_add_timeout>
   23cb7:	83 c4 0c             	add    $0xc,%esp
}
   23cba:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23cbd:	5b                   	pop    %ebx
   23cbe:	5e                   	pop    %esi
   23cbf:	5f                   	pop    %edi
   23cc0:	5d                   	pop    %ebp
   23cc1:	c3                   	ret    

00023cc2 <z_pend_curr_irqlock>:
{
   23cc2:	55                   	push   %ebp
	pend(_current, wait_q, timeout);
   23cc3:	a1 28 41 40 00       	mov    0x404128,%eax
{
   23cc8:	89 e5                	mov    %esp,%ebp
   23cca:	53                   	push   %ebx
	pend(_current, wait_q, timeout);
   23ccb:	8b 4d 10             	mov    0x10(%ebp),%ecx
   23cce:	8b 55 0c             	mov    0xc(%ebp),%edx
{
   23cd1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	pend(_current, wait_q, timeout);
   23cd4:	e8 53 ff ff ff       	call   23c2c <pend>
   23cd9:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   23cdc:	5b                   	pop    %ebx
   23cdd:	5d                   	pop    %ebp
   23cde:	e9 fb 62 fe ff       	jmp    9fde <__swap>

00023ce3 <z_pend_curr>:
{
   23ce3:	55                   	push   %ebp
	pend(_current, wait_q, timeout);
   23ce4:	a1 28 41 40 00       	mov    0x404128,%eax
{
   23ce9:	89 e5                	mov    %esp,%ebp
   23ceb:	53                   	push   %ebx
	pend(_current, wait_q, timeout);
   23cec:	8b 4d 14             	mov    0x14(%ebp),%ecx
   23cef:	8b 55 10             	mov    0x10(%ebp),%edx
{
   23cf2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	pend(_current, wait_q, timeout);
   23cf5:	e8 32 ff ff ff       	call   23c2c <pend>
   23cfa:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
   23cfd:	5b                   	pop    %ebx
   23cfe:	5d                   	pop    %ebp
   23cff:	e9 da 62 fe ff       	jmp    9fde <__swap>

00023d04 <z_thread_priority_set>:
{
   23d04:	55                   	push   %ebp
   23d05:	89 e5                	mov    %esp,%ebp
   23d07:	57                   	push   %edi
   23d08:	56                   	push   %esi
   23d09:	53                   	push   %ebx
   23d0a:	56                   	push   %esi
   23d0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
   23d0e:	8b 75 0c             	mov    0xc(%ebp),%esi
	__asm__ volatile (
   23d11:	9c                   	pushf  
   23d12:	fa                   	cli    
   23d13:	5f                   	pop    %edi
		need_sched = z_is_thread_ready(thread);
   23d14:	89 d8                	mov    %ebx,%eax
   23d16:	e8 d4 fa ff ff       	call   237ef <z_is_thread_ready>
   23d1b:	88 c2                	mov    %al,%dl
		if (need_sched) {
   23d1d:	84 c0                	test   %al,%al
   23d1f:	74 31                	je     23d52 <z_thread_priority_set+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   23d21:	53                   	push   %ebx
   23d22:	88 45 f3             	mov    %al,-0xd(%ebp)
   23d25:	68 44 41 40 00       	push   $0x404144
   23d2a:	e8 b2 fc ff ff       	call   239e1 <z_priq_rb_remove>
   23d2f:	58                   	pop    %eax
			thread->base.prio = prio;
   23d30:	89 f0                	mov    %esi,%eax
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   23d32:	5a                   	pop    %edx
			thread->base.prio = prio;
   23d33:	88 43 0e             	mov    %al,0xe(%ebx)
			_priq_run_add(&_kernel.ready_q.runq, thread);
   23d36:	53                   	push   %ebx
   23d37:	68 44 41 40 00       	push   $0x404144
   23d3c:	e8 25 fc ff ff       	call   23966 <z_priq_rb_add>
   23d41:	59                   	pop    %ecx
			update_cache(1);
   23d42:	b8 01 00 00 00       	mov    $0x1,%eax
			_priq_run_add(&_kernel.ready_q.runq, thread);
   23d47:	5b                   	pop    %ebx
			update_cache(1);
   23d48:	e8 01 fd ff ff       	call   23a4e <update_cache>
   23d4d:	8a 55 f3             	mov    -0xd(%ebp),%dl
   23d50:	eb 05                	jmp    23d57 <z_thread_priority_set+0x53>
			thread->base.prio = prio;
   23d52:	89 f0                	mov    %esi,%eax
   23d54:	88 43 0e             	mov    %al,0xe(%ebx)
   23d57:	0f ba e7 09          	bt     $0x9,%edi
   23d5b:	73 01                	jae    23d5e <z_thread_priority_set+0x5a>
	__asm__ volatile (
   23d5d:	fb                   	sti    
	if (need_sched && _current->base.sched_locked == 0) {
   23d5e:	84 d2                	test   %dl,%dl
   23d60:	74 17                	je     23d79 <z_thread_priority_set+0x75>
   23d62:	a1 28 41 40 00       	mov    0x404128,%eax
   23d67:	80 78 0f 00          	cmpb   $0x0,0xf(%eax)
   23d6b:	75 0c                	jne    23d79 <z_thread_priority_set+0x75>
}
   23d6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23d70:	5b                   	pop    %ebx
   23d71:	5e                   	pop    %esi
   23d72:	5f                   	pop    %edi
   23d73:	5d                   	pop    %ebp
		z_reschedule_unlocked();
   23d74:	e9 cb fb ff ff       	jmp    23944 <z_reschedule_unlocked>
}
   23d79:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23d7c:	5b                   	pop    %ebx
   23d7d:	5e                   	pop    %esi
   23d7e:	5f                   	pop    %edi
   23d7f:	5d                   	pop    %ebp
   23d80:	c3                   	ret    

00023d81 <z_unpend_first_thread>:
{
   23d81:	55                   	push   %ebp
   23d82:	89 e5                	mov    %esp,%ebp
   23d84:	56                   	push   %esi
   23d85:	53                   	push   %ebx
	__asm__ volatile (
   23d86:	9c                   	pushf  
   23d87:	fa                   	cli    
   23d88:	5e                   	pop    %esi
		ret = _priq_wait_best(&wait_q->waitq);
   23d89:	ff 75 08             	pushl  0x8(%ebp)
   23d8c:	e8 ac fc ff ff       	call   23a3d <z_priq_rb_best>
   23d91:	0f ba e6 09          	bt     $0x9,%esi
   23d95:	5b                   	pop    %ebx
   23d96:	89 c3                	mov    %eax,%ebx
   23d98:	73 01                	jae    23d9b <z_unpend_first_thread+0x1a>
	__asm__ volatile (
   23d9a:	fb                   	sti    

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   23d9b:	85 db                	test   %ebx,%ebx
   23d9d:	74 2a                	je     23dc9 <z_unpend_first_thread+0x48>
	__asm__ volatile (
   23d9f:	9c                   	pushf  
   23da0:	fa                   	cli    
   23da1:	5e                   	pop    %esi
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   23da2:	53                   	push   %ebx
   23da3:	ff 73 08             	pushl  0x8(%ebx)
   23da6:	e8 36 fc ff ff       	call   239e1 <z_priq_rb_remove>
   23dab:	5a                   	pop    %edx
   23dac:	59                   	pop    %ecx
	thread->base.thread_state &= ~_THREAD_PENDING;
   23dad:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
   23db1:	0f ba e6 09          	bt     $0x9,%esi
   23db5:	73 01                	jae    23db8 <z_unpend_first_thread+0x37>
	__asm__ volatile (
   23db7:	fb                   	sti    
	return z_abort_timeout(&thread->base.timeout);
   23db8:	8d 43 18             	lea    0x18(%ebx),%eax
	thread->base.pended_on = NULL;
   23dbb:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
   23dc2:	50                   	push   %eax
   23dc3:	e8 4a 09 00 00       	call   24712 <z_abort_timeout>
   23dc8:	58                   	pop    %eax
}
   23dc9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23dcc:	89 d8                	mov    %ebx,%eax
   23dce:	5b                   	pop    %ebx
   23dcf:	5e                   	pop    %esi
   23dd0:	5d                   	pop    %ebp
   23dd1:	c3                   	ret    

00023dd2 <z_unpend_all>:
	}
	return t;
}

int z_unpend_all(_wait_q_t *wait_q)
{
   23dd2:	55                   	push   %ebp
   23dd3:	89 e5                	mov    %esp,%ebp
   23dd5:	56                   	push   %esi
   23dd6:	53                   	push   %ebx
	int need_sched = 0;
   23dd7:	31 f6                	xor    %esi,%esi
   23dd9:	6a 00                	push   $0x0
   23ddb:	ff 75 08             	pushl  0x8(%ebp)
   23dde:	e8 d1 e4 fd ff       	call   22b4 <z_rb_get_minmax>
   23de3:	5a                   	pop    %edx
   23de4:	89 c3                	mov    %eax,%ebx
   23de6:	59                   	pop    %ecx
	struct k_thread *th;

	while ((th = z_waitq_head(wait_q)) != NULL) {
   23de7:	85 c0                	test   %eax,%eax
   23de9:	74 20                	je     23e0b <z_unpend_all+0x39>
		z_unpend_thread(th);
   23deb:	53                   	push   %ebx
   23dec:	e8 13 fc ff ff       	call   23a04 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   23df1:	89 d8                	mov    %ebx,%eax
   23df3:	5e                   	pop    %esi
   23df4:	e8 f6 f9 ff ff       	call   237ef <z_is_thread_ready>
		z_ready_thread(th);
		need_sched = 1;
   23df9:	be 01 00 00 00       	mov    $0x1,%esi
   23dfe:	84 c0                	test   %al,%al
   23e00:	74 d7                	je     23dd9 <z_unpend_all+0x7>
		z_add_thread_to_ready_q(thread);
   23e02:	53                   	push   %ebx
   23e03:	e8 be fc ff ff       	call   23ac6 <z_add_thread_to_ready_q>
   23e08:	5b                   	pop    %ebx
   23e09:	eb ce                	jmp    23dd9 <z_unpend_all+0x7>
	}

	return need_sched;
}
   23e0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   23e0e:	89 f0                	mov    %esi,%eax
   23e10:	5b                   	pop    %ebx
   23e11:	5e                   	pop    %esi
   23e12:	5d                   	pop    %ebp
   23e13:	c3                   	ret    

00023e14 <z_sched_init>:

void z_sched_init(void)
{
   23e14:	55                   	push   %ebp
#ifdef CONFIG_SCHED_DUMB
	sys_dlist_init(&_kernel.ready_q.runq);
#endif

#ifdef CONFIG_SCHED_SCALABLE
	_kernel.ready_q.runq = (struct _priq_rb) {
   23e15:	ba 44 41 40 00       	mov    $0x404144,%edx
{
   23e1a:	89 e5                	mov    %esp,%ebp
	_kernel.ready_q.runq = (struct _priq_rb) {
   23e1c:	31 c0                	xor    %eax,%eax
{
   23e1e:	57                   	push   %edi
	_kernel.ready_q.runq = (struct _priq_rb) {
   23e1f:	b9 04 00 00 00       	mov    $0x4,%ecx
   23e24:	89 d7                	mov    %edx,%edi
   23e26:	f3 ab                	rep stos %eax,%es:(%edi)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   23e28:	6a 00                	push   $0x0
	_kernel.ready_q.runq = (struct _priq_rb) {
   23e2a:	c7 05 48 41 40 00 07 	movl   $0x23807,0x404148
   23e31:	38 02 00 
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   23e34:	6a 00                	push   $0x0
   23e36:	e8 25 fa ff ff       	call   23860 <k_sched_time_slice_set>
   23e3b:	58                   	pop    %eax
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
   23e3c:	8b 7d fc             	mov    -0x4(%ebp),%edi
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   23e3f:	5a                   	pop    %edx
}
   23e40:	c9                   	leave  
   23e41:	c3                   	ret    

00023e42 <z_impl_k_yield>:
}
#endif
#endif

void z_impl_k_yield(void)
{
   23e42:	55                   	push   %ebp
	__ASSERT(!z_is_in_isr(), "");

	if (!is_idle(_current)) {
   23e43:	a1 40 66 02 00       	mov    0x26640,%eax
{
   23e48:	89 e5                	mov    %esp,%ebp
	if (!is_idle(_current)) {
   23e4a:	39 05 28 41 40 00    	cmp    %eax,0x404128
{
   23e50:	53                   	push   %ebx
	if (!is_idle(_current)) {
   23e51:	74 38                	je     23e8b <z_impl_k_yield+0x49>
	__asm__ volatile (
   23e53:	9c                   	pushf  
   23e54:	fa                   	cli    
   23e55:	5b                   	pop    %ebx
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   23e56:	ff 35 28 41 40 00    	pushl  0x404128
   23e5c:	68 44 41 40 00       	push   $0x404144
   23e61:	e8 7b fb ff ff       	call   239e1 <z_priq_rb_remove>
   23e66:	5a                   	pop    %edx
   23e67:	59                   	pop    %ecx
						 _current);
				_priq_run_add(&_kernel.ready_q.runq,
   23e68:	ff 35 28 41 40 00    	pushl  0x404128
   23e6e:	68 44 41 40 00       	push   $0x404144
   23e73:	e8 ee fa ff ff       	call   23966 <z_priq_rb_add>
   23e78:	58                   	pop    %eax
					      _current);
			}
			update_cache(1);
   23e79:	b8 01 00 00 00       	mov    $0x1,%eax
				_priq_run_add(&_kernel.ready_q.runq,
   23e7e:	5a                   	pop    %edx
			update_cache(1);
   23e7f:	e8 ca fb ff ff       	call   23a4e <update_cache>
   23e84:	0f ba e3 09          	bt     $0x9,%ebx
   23e88:	73 01                	jae    23e8b <z_impl_k_yield+0x49>
	__asm__ volatile (
   23e8a:	fb                   	sti    
	__asm__ volatile (
   23e8b:	9c                   	pushf  
   23e8c:	fa                   	cli    
   23e8d:	58                   	pop    %eax
   23e8e:	50                   	push   %eax
   23e8f:	e8 4a 61 fe ff       	call   9fde <__swap>
   23e94:	58                   	pop    %eax
		}
	}
	z_swap_unlocked();
}
   23e95:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   23e98:	c9                   	leave  
   23e99:	c3                   	ret    

00023e9a <z_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

s32_t z_impl_k_sleep(s32_t duration)
{
   23e9a:	55                   	push   %ebp
   23e9b:	89 e5                	mov    %esp,%ebp
   23e9d:	57                   	push   %edi
   23e9e:	56                   	push   %esi
   23e9f:	53                   	push   %ebx
   23ea0:	83 ec 08             	sub    $0x8,%esp
   23ea3:	8b 75 08             	mov    0x8(%ebp),%esi
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
   23ea6:	85 f6                	test   %esi,%esi
   23ea8:	75 0a                	jne    23eb4 <z_impl_k_sleep+0x1a>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
   23eaa:	e8 93 ff ff ff       	call   23e42 <z_impl_k_yield>
		k_yield();
		return 0;
   23eaf:	e9 a0 00 00 00       	jmp    23f54 <z_impl_k_sleep+0xba>
	return z_clock_hw_cycles_per_sec;
   23eb4:	8b 3d 24 a7 40 00    	mov    0x40a724,%edi
	return (s32_t)ceiling_fraction(
   23eba:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   23ebf:	f7 ef                	imul   %edi
   23ec1:	6a 00                	push   $0x0
   23ec3:	6a 64                	push   $0x64
   23ec5:	52                   	push   %edx
   23ec6:	50                   	push   %eax
   23ec7:	e8 04 d2 fd ff       	call   10d0 <__divdi3>
   23ecc:	83 c4 10             	add    $0x10,%esp
   23ecf:	89 c1                	mov    %eax,%ecx
   23ed1:	83 c0 ff             	add    $0xffffffff,%eax
   23ed4:	89 d3                	mov    %edx,%ebx
   23ed6:	89 45 ec             	mov    %eax,-0x14(%ebp)
   23ed9:	89 f0                	mov    %esi,%eax
   23edb:	83 d2 ff             	adc    $0xffffffff,%edx
   23ede:	53                   	push   %ebx
   23edf:	89 55 f0             	mov    %edx,-0x10(%ebp)
   23ee2:	51                   	push   %ecx
   23ee3:	f7 ef                	imul   %edi
   23ee5:	03 45 ec             	add    -0x14(%ebp),%eax
   23ee8:	13 55 f0             	adc    -0x10(%ebp),%edx
   23eeb:	52                   	push   %edx
   23eec:	50                   	push   %eax
   23eed:	e8 de d1 fd ff       	call   10d0 <__divdi3>
   23ef2:	83 c4 10             	add    $0x10,%esp
	}

	ticks = _TICK_ALIGN + z_ms_to_ticks(duration);
   23ef5:	8d 70 01             	lea    0x1(%eax),%esi
	expected_wakeup_time = ticks + z_tick_get_32();
   23ef8:	e8 eb 09 00 00       	call   248e8 <z_tick_get_32>
   23efd:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
   23f00:	9c                   	pushf  
   23f01:	fa                   	cli    
   23f02:	5f                   	pop    %edi
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	z_remove_thread_from_ready_q(_current);
   23f03:	ff 35 28 41 40 00    	pushl  0x404128
   23f09:	e8 de fc ff ff       	call   23bec <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   23f0e:	a1 28 41 40 00       	mov    0x404128,%eax
   23f13:	89 34 24             	mov    %esi,(%esp)
   23f16:	83 c0 18             	add    $0x18,%eax
   23f19:	68 f7 3a 02 00       	push   $0x23af7
	if (ticks > 0) {
		return __ticks_to_ms(ticks);
	}
#endif

	return 0;
   23f1e:	31 f6                	xor    %esi,%esi
   23f20:	50                   	push   %eax
   23f21:	e8 3a 07 00 00       	call   24660 <z_add_timeout>
   23f26:	83 c4 0c             	add    $0xc,%esp
   23f29:	57                   	push   %edi
   23f2a:	e8 af 60 fe ff       	call   9fde <__swap>
   23f2f:	58                   	pop    %eax
	ticks = expected_wakeup_time - z_tick_get_32();
   23f30:	e8 b3 09 00 00       	call   248e8 <z_tick_get_32>
   23f35:	29 c3                	sub    %eax,%ebx
   23f37:	89 d8                	mov    %ebx,%eax
	if (ticks > 0) {
   23f39:	85 db                	test   %ebx,%ebx
   23f3b:	7e 17                	jle    23f54 <z_impl_k_sleep+0xba>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
   23f3d:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
   23f42:	6a 00                	push   $0x0
   23f44:	f7 e9                	imul   %ecx
   23f46:	6a 64                	push   $0x64
   23f48:	52                   	push   %edx
   23f49:	50                   	push   %eax
   23f4a:	e8 9e d2 fd ff       	call   11ed <__udivdi3>
   23f4f:	83 c4 10             	add    $0x10,%esp
   23f52:	89 c6                	mov    %eax,%esi
}
   23f54:	8d 65 f4             	lea    -0xc(%ebp),%esp
   23f57:	89 f0                	mov    %esi,%eax
   23f59:	5b                   	pop    %ebx
   23f5a:	5e                   	pop    %esi
   23f5b:	5f                   	pop    %edi
   23f5c:	5d                   	pop    %ebp
   23f5d:	c3                   	ret    

00023f5e <z_impl_k_wakeup>:
	return z_impl_k_sleep(duration);
}
#endif

void z_impl_k_wakeup(k_tid_t thread)
{
   23f5e:	55                   	push   %ebp
   23f5f:	89 e5                	mov    %esp,%ebp
   23f61:	53                   	push   %ebx
   23f62:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (z_is_thread_pending(thread)) {
   23f65:	f6 43 0d 02          	testb  $0x2,0xd(%ebx)
   23f69:	75 32                	jne    23f9d <z_impl_k_wakeup+0x3f>
	return z_abort_timeout(&thread->base.timeout);
   23f6b:	8d 43 18             	lea    0x18(%ebx),%eax
   23f6e:	50                   	push   %eax
   23f6f:	e8 9e 07 00 00       	call   24712 <z_abort_timeout>
   23f74:	5a                   	pop    %edx
		return;
	}

	if (z_abort_thread_timeout(thread) < 0) {
   23f75:	85 c0                	test   %eax,%eax
   23f77:	78 24                	js     23f9d <z_impl_k_wakeup+0x3f>
	if (z_is_thread_ready(thread)) {
   23f79:	89 d8                	mov    %ebx,%eax
   23f7b:	e8 6f f8 ff ff       	call   237ef <z_is_thread_ready>
   23f80:	84 c0                	test   %al,%al
   23f82:	74 07                	je     23f8b <z_impl_k_wakeup+0x2d>
		z_add_thread_to_ready_q(thread);
   23f84:	53                   	push   %ebx
   23f85:	e8 3c fb ff ff       	call   23ac6 <z_add_thread_to_ready_q>
   23f8a:	58                   	pop    %eax
		return;
	}

	z_ready_thread(thread);

	if (!z_is_in_isr()) {
   23f8b:	83 3d 20 41 40 00 00 	cmpl   $0x0,0x404120
   23f92:	75 09                	jne    23f9d <z_impl_k_wakeup+0x3f>

	if (IS_ENABLED(CONFIG_SMP) &&
	    !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
		z_sched_ipi();
	}
}
   23f94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   23f97:	c9                   	leave  
		z_reschedule_unlocked();
   23f98:	e9 a7 f9 ff ff       	jmp    23944 <z_reschedule_unlocked>
}
   23f9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   23fa0:	c9                   	leave  
   23fa1:	c3                   	ret    

00023fa2 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   23fa2:	a1 28 41 40 00       	mov    0x404128,%eax
   23fa7:	c3                   	ret    

00023fa8 <z_impl_k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
   23fa8:	55                   	push   %ebp
   23fa9:	b9 04 00 00 00       	mov    $0x4,%ecx
   23fae:	89 e5                	mov    %esp,%ebp
   23fb0:	57                   	push   %edi
   23fb1:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(limit != 0U, "limit cannot be zero");
	__ASSERT(initial_count <= limit, "count cannot be greater than limit");

	sys_trace_void(SYS_TRACE_ID_SEMA_INIT);
	sem->count = initial_count;
   23fb4:	8b 45 0c             	mov    0xc(%ebp),%eax
   23fb7:	89 d7                	mov    %edx,%edi
   23fb9:	89 42 10             	mov    %eax,0x10(%edx)
	sem->limit = limit;
   23fbc:	8b 45 10             	mov    0x10(%ebp),%eax
   23fbf:	89 42 14             	mov    %eax,0x14(%edx)
   23fc2:	31 c0                	xor    %eax,%eax
   23fc4:	f3 ab                	rep stos %eax,%es:(%edi)
	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
   23fc6:	8d 42 18             	lea    0x18(%edx),%eax
   23fc9:	c7 42 04 07 38 02 00 	movl   $0x23807,0x4(%edx)
	list->head = (sys_dnode_t *)list;
   23fd0:	89 42 18             	mov    %eax,0x18(%edx)
	list->tail = (sys_dnode_t *)list;
   23fd3:	89 42 1c             	mov    %eax,0x1c(%edx)

	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);
}
   23fd6:	5f                   	pop    %edi
   23fd7:	5d                   	pop    %ebp
   23fd8:	c3                   	ret    

00023fd9 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   23fd9:	55                   	push   %ebp
   23fda:	89 e5                	mov    %esp,%ebp
   23fdc:	57                   	push   %edi
   23fdd:	56                   	push   %esi
   23fde:	53                   	push   %ebx
   23fdf:	8b 5d 08             	mov    0x8(%ebp),%ebx
   23fe2:	9c                   	pushf  
   23fe3:	fa                   	cli    
   23fe4:	5e                   	pop    %esi
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   23fe5:	53                   	push   %ebx
   23fe6:	e8 96 fd ff ff       	call   23d81 <z_unpend_first_thread>
   23feb:	5a                   	pop    %edx
	if (thread != NULL) {
   23fec:	85 c0                	test   %eax,%eax
   23fee:	74 20                	je     24010 <_image_text_size+0x10>
   23ff0:	89 c7                	mov    %eax,%edi
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   23ff2:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   23ff6:	75 0d                	jne    24005 <_image_text_size+0x5>
	if (z_is_thread_ready(thread)) {
   23ff8:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   23ffc:	75 07                	jne    24005 <_image_text_size+0x5>
		z_add_thread_to_ready_q(thread);
   23ffe:	50                   	push   %eax
   23fff:	e8 c2 fa ff ff       	call   23ac6 <z_add_thread_to_ready_q>
   24004:	58                   	pop    %eax
   24005:	8b 47 28             	mov    0x28(%edi),%eax
   24008:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   2400e:	eb 1d                	jmp    2402d <_image_text_size+0x2d>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
   24010:	8b 53 10             	mov    0x10(%ebx),%edx
   24013:	31 c0                	xor    %eax,%eax
   24015:	39 53 14             	cmp    %edx,0x14(%ebx)
   24018:	0f 95 c0             	setne  %al
   2401b:	01 d0                	add    %edx,%eax
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2401d:	83 c3 18             	add    $0x18,%ebx
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
   24020:	89 43 f8             	mov    %eax,-0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   24023:	6a 02                	push   $0x2
   24025:	53                   	push   %ebx
   24026:	e8 0d 0c 00 00       	call   24c38 <z_handle_obj_poll_events>
   2402b:	59                   	pop    %ecx
   2402c:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   2402d:	56                   	push   %esi
   2402e:	68 65 45 40 00       	push   $0x404565
   24033:	e8 cd f8 ff ff       	call   23905 <z_reschedule>
   24038:	58                   	pop    %eax
   24039:	5a                   	pop    %edx
}
   2403a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   2403d:	5b                   	pop    %ebx
   2403e:	5e                   	pop    %esi
   2403f:	5f                   	pop    %edi
   24040:	5d                   	pop    %ebp
   24041:	c3                   	ret    

00024042 <z_impl_k_sem_take>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_sem_give, K_OBJ_SEM, struct k_sem *);
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   24042:	55                   	push   %ebp
   24043:	89 e5                	mov    %esp,%ebp
   24045:	53                   	push   %ebx
   24046:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24049:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   2404c:	9c                   	pushf  
   2404d:	fa                   	cli    
   2404e:	5a                   	pop    %edx
	__ASSERT(((z_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   2404f:	8b 41 10             	mov    0x10(%ecx),%eax
   24052:	85 c0                	test   %eax,%eax
   24054:	74 08                	je     2405e <z_impl_k_sem_take+0x1c>
		sem->count--;
   24056:	48                   	dec    %eax
   24057:	89 41 10             	mov    %eax,0x10(%ecx)
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
   2405a:	31 c0                	xor    %eax,%eax
   2405c:	eb 09                	jmp    24067 <z_impl_k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
   2405e:	85 db                	test   %ebx,%ebx
   24060:	75 0e                	jne    24070 <z_impl_k_sem_take+0x2e>
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return -EBUSY;
   24062:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   24067:	0f ba e2 09          	bt     $0x9,%edx
   2406b:	73 13                	jae    24080 <z_impl_k_sem_take+0x3e>
	__asm__ volatile (
   2406d:	fb                   	sti    
   2406e:	eb 10                	jmp    24080 <z_impl_k_sem_take+0x3e>
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   24070:	53                   	push   %ebx
   24071:	51                   	push   %ecx
   24072:	52                   	push   %edx
   24073:	68 65 45 40 00       	push   $0x404565
   24078:	e8 66 fc ff ff       	call   23ce3 <z_pend_curr>
   2407d:	83 c4 10             	add    $0x10,%esp
	return ret;
}
   24080:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   24083:	c9                   	leave  
   24084:	c3                   	ret    

00024085 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   24085:	55                   	push   %ebp
   24086:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   24088:	6a ff                	push   $0xffffffff
   2408a:	68 00 04 00 00       	push   $0x400
   2408f:	68 10 92 40 00       	push   $0x409210
   24094:	68 60 41 40 00       	push   $0x404160
   24099:	e8 a8 03 00 00       	call   24446 <k_work_q_start>
   2409e:	83 c4 10             	add    $0x10,%esp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   240a1:	68 db aa 02 00       	push   $0x2aadb
   240a6:	68 78 41 40 00       	push   $0x404178
   240ab:	e8 ef 00 00 00       	call   2419f <z_impl_k_thread_name_set>
   240b0:	58                   	pop    %eax
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   240b1:	31 c0                	xor    %eax,%eax
   240b3:	5a                   	pop    %edx
   240b4:	c9                   	leave  
   240b5:	c3                   	ret    

000240b6 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   240b6:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
   240ba:	75 0c                	jne    240c8 <z_is_thread_ready+0x12>
   240bc:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
   240c0:	0f 94 c0             	sete   %al
   240c3:	0f b6 c0             	movzbl %al,%eax
   240c6:	eb 02                	jmp    240ca <z_is_thread_ready+0x14>
   240c8:	31 c0                	xor    %eax,%eax
   240ca:	83 e0 01             	and    $0x1,%eax
}
   240cd:	c3                   	ret    

000240ce <schedule_new_thread.part.8>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_start, K_OBJ_THREAD, struct k_thread *);
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
   240ce:	55                   	push   %ebp
   240cf:	89 e5                	mov    %esp,%ebp
   240d1:	57                   	push   %edi
   240d2:	56                   	push   %esi
   240d3:	53                   	push   %ebx
   240d4:	89 d3                	mov    %edx,%ebx
   240d6:	83 ec 08             	sub    $0x8,%esp
   240d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return z_clock_hw_cycles_per_sec;
   240dc:	8b 0d 24 a7 40 00    	mov    0x40a724,%ecx
	return (s32_t)ceiling_fraction(
   240e2:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   240e7:	f7 e9                	imul   %ecx
   240e9:	6a 00                	push   $0x0
   240eb:	89 4d ec             	mov    %ecx,-0x14(%ebp)
   240ee:	6a 64                	push   $0x64
   240f0:	52                   	push   %edx
   240f1:	50                   	push   %eax
   240f2:	e8 d9 cf fd ff       	call   10d0 <__divdi3>
   240f7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   240fa:	89 c6                	mov    %eax,%esi
   240fc:	89 d8                	mov    %ebx,%eax
   240fe:	89 d7                	mov    %edx,%edi
   24100:	f7 e9                	imul   %ecx
   24102:	83 c4 10             	add    $0x10,%esp
   24105:	89 c1                	mov    %eax,%ecx
   24107:	89 f0                	mov    %esi,%eax
   24109:	89 d3                	mov    %edx,%ebx
   2410b:	83 c0 ff             	add    $0xffffffff,%eax
   2410e:	89 fa                	mov    %edi,%edx
   24110:	83 d2 ff             	adc    $0xffffffff,%edx
   24113:	57                   	push   %edi
   24114:	01 c1                	add    %eax,%ecx
   24116:	56                   	push   %esi
   24117:	11 d3                	adc    %edx,%ebx
   24119:	53                   	push   %ebx
   2411a:	51                   	push   %ecx
   2411b:	e8 b0 cf fd ff       	call   10d0 <__divdi3>
   24120:	83 c4 10             	add    $0x10,%esp
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
		k_thread_start(thread);
	} else {
		s32_t ticks = _TICK_ALIGN + z_ms_to_ticks(delay);
   24123:	40                   	inc    %eax
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   24124:	50                   	push   %eax
   24125:	8b 45 f0             	mov    -0x10(%ebp),%eax
   24128:	68 f7 3a 02 00       	push   $0x23af7
   2412d:	83 c0 18             	add    $0x18,%eax
   24130:	50                   	push   %eax
   24131:	e8 2a 05 00 00       	call   24660 <z_add_timeout>
   24136:	83 c4 0c             	add    $0xc,%esp
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
   24139:	8d 65 f4             	lea    -0xc(%ebp),%esp
   2413c:	5b                   	pop    %ebx
   2413d:	5e                   	pop    %esi
   2413e:	5f                   	pop    %edi
   2413f:	5d                   	pop    %ebp
   24140:	c3                   	ret    

00024141 <k_is_in_isr>:
	return z_is_in_isr();
   24141:	83 3d 20 41 40 00 00 	cmpl   $0x0,0x404120
   24148:	0f 95 c0             	setne  %al
}
   2414b:	c3                   	ret    

0002414c <z_is_thread_essential>:
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
   2414c:	a1 28 41 40 00       	mov    0x404128,%eax
   24151:	8a 40 0c             	mov    0xc(%eax),%al
   24154:	83 e0 01             	and    $0x1,%eax
}
   24157:	c3                   	ret    

00024158 <z_impl_k_busy_wait>:
{
   24158:	55                   	push   %ebp
		(u64_t)sys_clock_hw_cycles_per_sec() /
   24159:	a1 24 a7 40 00       	mov    0x40a724,%eax
{
   2415e:	89 e5                	mov    %esp,%ebp
   24160:	56                   	push   %esi
   24161:	53                   	push   %ebx
		(u64_t)sys_clock_hw_cycles_per_sec() /
   24162:	89 c3                	mov    %eax,%ebx
   24164:	c1 fb 1f             	sar    $0x1f,%ebx
{
   24167:	8b 55 08             	mov    0x8(%ebp),%edx
		(u64_t)usec_to_wait *
   2416a:	89 d9                	mov    %ebx,%ecx
		(u64_t)sys_clock_hw_cycles_per_sec() /
   2416c:	6a 00                	push   $0x0
		(u64_t)usec_to_wait *
   2416e:	0f af ca             	imul   %edx,%ecx
   24171:	f7 e2                	mul    %edx
		(u64_t)sys_clock_hw_cycles_per_sec() /
   24173:	68 40 42 0f 00       	push   $0xf4240
		(u64_t)usec_to_wait *
   24178:	01 ca                	add    %ecx,%edx
		(u64_t)sys_clock_hw_cycles_per_sec() /
   2417a:	52                   	push   %edx
   2417b:	50                   	push   %eax
   2417c:	e8 6c d0 fd ff       	call   11ed <__udivdi3>
   24181:	83 c4 10             	add    $0x10,%esp
   24184:	89 c3                	mov    %eax,%ebx
	u32_t start_cycles = k_cycle_get_32();
   24186:	e8 84 5d fe ff       	call   9f0f <z_timer_cycle_get_32>
   2418b:	89 c6                	mov    %eax,%esi
		u32_t current_cycles = k_cycle_get_32();
   2418d:	e8 7d 5d fe ff       	call   9f0f <z_timer_cycle_get_32>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
   24192:	29 f0                	sub    %esi,%eax
   24194:	39 d8                	cmp    %ebx,%eax
   24196:	72 f5                	jb     2418d <z_impl_k_busy_wait+0x35>
}
   24198:	8d 65 f8             	lea    -0x8(%ebp),%esp
   2419b:	5b                   	pop    %ebx
   2419c:	5e                   	pop    %esi
   2419d:	5d                   	pop    %ebp
   2419e:	c3                   	ret    

0002419f <z_impl_k_thread_name_set>:
}
   2419f:	c3                   	ret    

000241a0 <z_impl_k_thread_start>:
{
   241a0:	55                   	push   %ebp
   241a1:	89 e5                	mov    %esp,%ebp
   241a3:	53                   	push   %ebx
   241a4:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
   241a7:	9c                   	pushf  
   241a8:	fa                   	cli    
   241a9:	5b                   	pop    %ebx
	if (z_has_thread_started(thread)) {
   241aa:	8a 42 0d             	mov    0xd(%edx),%al
   241ad:	a8 04                	test   $0x4,%al
   241af:	75 09                	jne    241ba <z_impl_k_thread_start+0x1a>
   241b1:	0f ba e3 09          	bt     $0x9,%ebx
   241b5:	73 28                	jae    241df <z_impl_k_thread_start+0x3f>
	__asm__ volatile (
   241b7:	fb                   	sti    
   241b8:	eb 25                	jmp    241df <z_impl_k_thread_start+0x3f>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   241ba:	83 e0 fb             	and    $0xfffffffb,%eax
   241bd:	88 42 0d             	mov    %al,0xd(%edx)
	if (z_is_thread_ready(thread)) {
   241c0:	89 d0                	mov    %edx,%eax
   241c2:	e8 ef fe ff ff       	call   240b6 <z_is_thread_ready>
   241c7:	84 c0                	test   %al,%al
   241c9:	74 07                	je     241d2 <z_impl_k_thread_start+0x32>
		z_add_thread_to_ready_q(thread);
   241cb:	52                   	push   %edx
   241cc:	e8 f5 f8 ff ff       	call   23ac6 <z_add_thread_to_ready_q>
   241d1:	59                   	pop    %ecx
	z_reschedule(&lock, key);
   241d2:	53                   	push   %ebx
   241d3:	68 65 45 40 00       	push   $0x404565
   241d8:	e8 28 f7 ff ff       	call   23905 <z_reschedule>
   241dd:	58                   	pop    %eax
   241de:	5a                   	pop    %edx
}
   241df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   241e2:	c9                   	leave  
   241e3:	c3                   	ret    

000241e4 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   241e4:	55                   	push   %ebp
   241e5:	89 e5                	mov    %esp,%ebp
   241e7:	53                   	push   %ebx
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   241e8:	ff 75 28             	pushl  0x28(%ebp)
   241eb:	ff 75 24             	pushl  0x24(%ebp)
   241ee:	ff 75 20             	pushl  0x20(%ebp)
   241f1:	ff 75 1c             	pushl  0x1c(%ebp)
   241f4:	ff 75 18             	pushl  0x18(%ebp)
   241f7:	ff 75 14             	pushl  0x14(%ebp)
   241fa:	ff 75 10             	pushl  0x10(%ebp)
   241fd:	ff 75 0c             	pushl  0xc(%ebp)
{
   24200:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   24203:	53                   	push   %ebx
   24204:	e8 78 5e fe ff       	call   a081 <z_new_thread>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   24209:	a1 28 41 40 00       	mov    0x404128,%eax
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2420e:	83 c4 24             	add    $0x24,%esp
	new_thread->resource_pool = _current->resource_pool;
   24211:	8b 40 38             	mov    0x38(%eax),%eax
   24214:	89 43 38             	mov    %eax,0x38(%ebx)
	sys_trace_thread_create(new_thread);
}
   24217:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   2421a:	c9                   	leave  
   2421b:	c3                   	ret    

0002421c <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
   2421c:	55                   	push   %ebp
   2421d:	89 e5                	mov    %esp,%ebp
   2421f:	56                   	push   %esi
   24220:	53                   	push   %ebx
	__ASSERT(!z_is_in_isr(), "Threads may not be created in ISRs");

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   24221:	6a 00                	push   $0x0
{
   24223:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   24226:	ff 75 28             	pushl  0x28(%ebp)
   24229:	ff 75 24             	pushl  0x24(%ebp)
   2422c:	ff 75 20             	pushl  0x20(%ebp)
   2422f:	ff 75 1c             	pushl  0x1c(%ebp)
   24232:	ff 75 18             	pushl  0x18(%ebp)
   24235:	ff 75 14             	pushl  0x14(%ebp)
   24238:	ff 75 10             	pushl  0x10(%ebp)
   2423b:	ff 75 0c             	pushl  0xc(%ebp)
{
   2423e:	8b 75 2c             	mov    0x2c(%ebp),%esi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   24241:	53                   	push   %ebx
   24242:	e8 9d ff ff ff       	call   241e4 <z_setup_new_thread>
   24247:	83 c4 28             	add    $0x28,%esp
			  prio, options, NULL);

	if (delay != K_FOREVER) {
   2424a:	83 fe ff             	cmp    $0xffffffff,%esi
   2424d:	74 16                	je     24265 <z_impl_k_thread_create+0x49>
	if (delay == 0) {
   2424f:	85 f6                	test   %esi,%esi
   24251:	75 09                	jne    2425c <z_impl_k_thread_create+0x40>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
   24253:	53                   	push   %ebx
   24254:	e8 47 ff ff ff       	call   241a0 <z_impl_k_thread_start>
   24259:	58                   	pop    %eax
   2425a:	eb 09                	jmp    24265 <z_impl_k_thread_create+0x49>
   2425c:	89 f2                	mov    %esi,%edx
   2425e:	89 d8                	mov    %ebx,%eax
   24260:	e8 69 fe ff ff       	call   240ce <schedule_new_thread.part.8>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   24265:	8d 65 f8             	lea    -0x8(%ebp),%esp
   24268:	89 d8                	mov    %ebx,%eax
   2426a:	5b                   	pop    %ebx
   2426b:	5e                   	pop    %esi
   2426c:	5d                   	pop    %ebp
   2426d:	c3                   	ret    

0002426e <z_thread_single_abort>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void z_thread_single_abort(struct k_thread *thread)
{
   2426e:	55                   	push   %ebp
   2426f:	89 e5                	mov    %esp,%ebp
   24271:	53                   	push   %ebx
   24272:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
   24275:	8b 43 30             	mov    0x30(%ebx),%eax
   24278:	85 c0                	test   %eax,%eax
   2427a:	74 02                	je     2427e <z_thread_single_abort+0x10>
		thread->fn_abort();
   2427c:	ff d0                	call   *%eax

	if (IS_ENABLED(CONFIG_SMP)) {
		z_sched_abort(thread);
	}

	if (z_is_thread_ready(thread)) {
   2427e:	89 d8                	mov    %ebx,%eax
   24280:	e8 31 fe ff ff       	call   240b6 <z_is_thread_ready>
   24285:	84 c0                	test   %al,%al
   24287:	74 08                	je     24291 <z_thread_single_abort+0x23>
		z_remove_thread_from_ready_q(thread);
   24289:	53                   	push   %ebx
   2428a:	e8 5d f9 ff ff       	call   23bec <z_remove_thread_from_ready_q>
   2428f:	eb 1c                	jmp    242ad <z_thread_single_abort+0x3f>
	} else {
		if (z_is_thread_pending(thread)) {
   24291:	f6 43 0d 02          	testb  $0x2,0xd(%ebx)
   24295:	74 07                	je     2429e <z_thread_single_abort+0x30>
			z_unpend_thread_no_timeout(thread);
   24297:	53                   	push   %ebx
   24298:	e8 39 f6 ff ff       	call   238d6 <z_unpend_thread_no_timeout>
   2429d:	5a                   	pop    %edx
		}
		if (z_is_thread_timeout_active(thread)) {
   2429e:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
   242a2:	74 0a                	je     242ae <z_thread_single_abort+0x40>
	return z_abort_timeout(&thread->base.timeout);
   242a4:	8d 43 18             	lea    0x18(%ebx),%eax
   242a7:	50                   	push   %eax
   242a8:	e8 65 04 00 00       	call   24712 <z_abort_timeout>
   242ad:	58                   	pop    %eax
			(void)z_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
   242ae:	80 4b 0d 08          	orb    $0x8,0xd(%ebx)
	z_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	z_thread_perms_all_clear(thread);
#endif
}
   242b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   242b5:	c9                   	leave  
   242b6:	c3                   	ret    

000242b7 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   242b7:	55                   	push   %ebp
   242b8:	89 e5                	mov    %esp,%ebp
   242ba:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
   242bb:	bb 00 a9 40 00       	mov    $0x40a900,%ebx
   242c0:	81 fb 00 a9 40 00    	cmp    $0x40a900,%ebx
   242c6:	73 2f                	jae    242f7 <z_init_static_threads+0x40>
		z_setup_new_thread(
   242c8:	ff 73 2c             	pushl  0x2c(%ebx)
   242cb:	ff 73 20             	pushl  0x20(%ebx)
   242ce:	ff 73 1c             	pushl  0x1c(%ebx)
   242d1:	ff 73 18             	pushl  0x18(%ebx)
   242d4:	ff 73 14             	pushl  0x14(%ebx)
   242d7:	ff 73 10             	pushl  0x10(%ebx)
   242da:	ff 73 0c             	pushl  0xc(%ebx)
   242dd:	ff 73 08             	pushl  0x8(%ebx)
   242e0:	ff 73 04             	pushl  0x4(%ebx)
   242e3:	ff 33                	pushl  (%ebx)
   242e5:	e8 fa fe ff ff       	call   241e4 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
   242ea:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
   242ec:	83 c4 28             	add    $0x28,%esp
		thread_data->init_thread->init_data = thread_data;
   242ef:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
   242f2:	83 c3 30             	add    $0x30,%ebx
   242f5:	eb c9                	jmp    242c0 <z_init_static_threads+0x9>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   242f7:	e8 57 f6 ff ff       	call   23953 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   242fc:	bb 00 a9 40 00       	mov    $0x40a900,%ebx
   24301:	81 fb 00 a9 40 00    	cmp    $0x40a900,%ebx
   24307:	73 21                	jae    2432a <z_init_static_threads+0x73>
		if (thread_data->init_delay != K_FOREVER) {
   24309:	8b 53 24             	mov    0x24(%ebx),%edx
   2430c:	83 fa ff             	cmp    $0xffffffff,%edx
   2430f:	74 14                	je     24325 <z_init_static_threads+0x6e>
			schedule_new_thread(thread_data->init_thread,
   24311:	8b 03                	mov    (%ebx),%eax
	if (delay == 0) {
   24313:	85 d2                	test   %edx,%edx
   24315:	75 09                	jne    24320 <z_init_static_threads+0x69>
   24317:	50                   	push   %eax
   24318:	e8 83 fe ff ff       	call   241a0 <z_impl_k_thread_start>
   2431d:	58                   	pop    %eax
   2431e:	eb 05                	jmp    24325 <z_init_static_threads+0x6e>
   24320:	e8 a9 fd ff ff       	call   240ce <schedule_new_thread.part.8>
	_FOREACH_STATIC_THREAD(thread_data) {
   24325:	83 c3 30             	add    $0x30,%ebx
   24328:	eb d7                	jmp    24301 <z_init_static_threads+0x4a>
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
   2432a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   2432d:	c9                   	leave  
	k_sched_unlock();
   2432e:	e9 6c f7 ff ff       	jmp    23a9f <k_sched_unlock>

00024333 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
   24333:	55                   	push   %ebp
   24334:	89 e5                	mov    %esp,%ebp
   24336:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   24339:	8b 55 14             	mov    0x14(%ebp),%edx
   2433c:	88 50 0c             	mov    %dl,0xc(%eax)
	thread_base->thread_state = (u8_t)initial_state;
   2433f:	8b 55 10             	mov    0x10(%ebp),%edx
   24342:	88 50 0d             	mov    %dl,0xd(%eax)

	thread_base->prio = priority;
   24345:	8b 55 0c             	mov    0xc(%ebp),%edx
   24348:	88 50 0e             	mov    %dl,0xe(%eax)

	thread_base->sched_locked = 0;
   2434b:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
	node->next = NULL;
   2434f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	node->prev = NULL;
   24356:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   2435d:	5d                   	pop    %ebp
   2435e:	c3                   	ret    

0002435f <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
   2435f:	55                   	push   %ebp
   24360:	89 e5                	mov    %esp,%ebp
   24362:	53                   	push   %ebx
   24363:	50                   	push   %eax
	__asm__ volatile (
   24364:	9c                   	pushf  
   24365:	fa                   	cli    
   24366:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0,
		 "essential thread aborted");

	z_thread_single_abort(thread);
   24367:	ff 75 08             	pushl  0x8(%ebp)
   2436a:	e8 ff fe ff ff       	call   2426e <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	z_reschedule(&lock, key);
   2436f:	8d 45 fb             	lea    -0x5(%ebp),%eax
   24372:	89 1c 24             	mov    %ebx,(%esp)
   24375:	50                   	push   %eax
   24376:	e8 8a f5 ff ff       	call   23905 <z_reschedule>
   2437b:	5a                   	pop    %edx
   2437c:	59                   	pop    %ecx
}
   2437d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   24380:	c9                   	leave  
   24381:	c3                   	ret    

00024382 <k_work_submit_to_queue>:
{
   24382:	55                   	push   %ebp
   24383:	89 c1                	mov    %eax,%ecx
   24385:	89 e5                	mov    %esp,%ebp
   24387:	56                   	push   %esi
   24388:	53                   	push   %ebx
   24389:	8b 42 08             	mov    0x8(%edx),%eax
   2438c:	89 c6                	mov    %eax,%esi
   2438e:	89 c3                	mov    %eax,%ebx
   24390:	83 ce 01             	or     $0x1,%esi
   24393:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
   24398:	75 f2                	jne    2438c <k_work_submit_to_queue+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2439a:	80 e3 01             	and    $0x1,%bl
   2439d:	75 09                	jne    243a8 <k_work_submit_to_queue+0x26>
		k_queue_append(&work_q->queue, work);
   2439f:	52                   	push   %edx
   243a0:	51                   	push   %ecx
   243a1:	e8 00 f3 ff ff       	call   236a6 <k_queue_append>
   243a6:	58                   	pop    %eax
   243a7:	5a                   	pop    %edx
}
   243a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
   243ab:	5b                   	pop    %ebx
   243ac:	5e                   	pop    %esi
   243ad:	5d                   	pop    %ebp
   243ae:	c3                   	ret    

000243af <work_timeout>:
	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}

#ifdef CONFIG_SYS_CLOCK_EXISTS
static void work_timeout(struct _timeout *t)
{
   243af:	55                   	push   %ebp
   243b0:	89 e5                	mov    %esp,%ebp
   243b2:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_delayed_work *w = CONTAINER_OF(t, struct k_delayed_work,
						   timeout);

	/* submit work to workqueue */
	k_work_submit_to_queue(w->work_q, &w->work);
}
   243b5:	5d                   	pop    %ebp
	k_work_submit_to_queue(w->work_q, &w->work);
   243b6:	8d 50 f4             	lea    -0xc(%eax),%edx
   243b9:	8b 40 10             	mov    0x10(%eax),%eax
   243bc:	e9 c1 ff ff ff       	jmp    24382 <k_work_submit_to_queue>

000243c1 <work_cancel>:
	z_init_timeout(&work->timeout, work_timeout);
	work->work_q = NULL;
}

static int work_cancel(struct k_delayed_work *work)
{
   243c1:	55                   	push   %ebp
   243c2:	89 e5                	mov    %esp,%ebp
   243c4:	57                   	push   %edi
   243c5:	56                   	push   %esi
   243c6:	53                   	push   %ebx
   243c7:	89 c3                	mov    %eax,%ebx
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   243c9:	83 c0 08             	add    $0x8,%eax
   243cc:	52                   	push   %edx
   243cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   243d0:	8b 43 08             	mov    0x8(%ebx),%eax
	__ASSERT(work->work_q != NULL, "");

	if (k_work_pending(&work->work)) {
   243d3:	a8 01                	test   $0x1,%al
   243d5:	74 4d                	je     24424 <work_cancel+0x63>
		/* Remove from the queue if already submitted */
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   243d7:	8b 43 1c             	mov    0x1c(%ebx),%eax
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   243da:	31 d2                	xor    %edx,%edx
   243dc:	8b 08                	mov    (%eax),%ecx
   243de:	85 c9                	test   %ecx,%ecx
   243e0:	74 3b                	je     2441d <work_cancel+0x5c>
   243e2:	39 cb                	cmp    %ecx,%ebx
   243e4:	75 2c                	jne    24412 <work_cancel+0x51>
Z_GENLIST_REMOVE(sflist, sfnode)
   243e6:	8b 0b                	mov    (%ebx),%ecx
   243e8:	8b 78 04             	mov    0x4(%eax),%edi
   243eb:	83 e1 fc             	and    $0xfffffffc,%ecx
   243ee:	85 d2                	test   %edx,%edx
   243f0:	75 0b                	jne    243fd <work_cancel+0x3c>
	list->head = node;
   243f2:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(sflist, sfnode)
   243f4:	39 fb                	cmp    %edi,%ebx
   243f6:	75 15                	jne    2440d <work_cancel+0x4c>
	list->tail = node;
   243f8:	89 48 04             	mov    %ecx,0x4(%eax)
   243fb:	eb 10                	jmp    2440d <work_cancel+0x4c>
	parent->next_and_flags = cur_flags | (unative_t)child;
   243fd:	8b 32                	mov    (%edx),%esi
   243ff:	83 e6 03             	and    $0x3,%esi
   24402:	09 f1                	or     %esi,%ecx
Z_GENLIST_REMOVE(sflist, sfnode)
   24404:	39 fb                	cmp    %edi,%ebx
	parent->next_and_flags = cur_flags | (unative_t)child;
   24406:	89 0a                	mov    %ecx,(%edx)
Z_GENLIST_REMOVE(sflist, sfnode)
   24408:	75 03                	jne    2440d <work_cancel+0x4c>
	list->tail = node;
   2440a:	89 50 04             	mov    %edx,0x4(%eax)
	parent->next_and_flags = cur_flags | (unative_t)child;
   2440d:	83 23 03             	andl   $0x3,(%ebx)
   24410:	eb 1c                	jmp    2442e <work_cancel+0x6d>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   24412:	8b 39                	mov    (%ecx),%edi
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   24414:	89 ca                	mov    %ecx,%edx
   24416:	83 e7 fc             	and    $0xfffffffc,%edi
   24419:	89 f9                	mov    %edi,%ecx
   2441b:	eb c1                	jmp    243de <work_cancel+0x1d>
			return -EINVAL;
   2441d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   24422:	eb 1a                	jmp    2443e <work_cancel+0x7d>
		}
	} else {
		(void)z_abort_timeout(&work->timeout);
   24424:	8d 43 0c             	lea    0xc(%ebx),%eax
   24427:	50                   	push   %eax
   24428:	e8 e5 02 00 00       	call   24712 <z_abort_timeout>
   2442d:	58                   	pop    %eax
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2442e:	8b 45 f0             	mov    -0x10(%ebp),%eax
	}

	/* Detach from workqueue */
	work->work_q = NULL;
   24431:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
   24438:	f0 83 20 fe          	lock andl $0xfffffffe,(%eax)

	atomic_clear_bit(work->work.flags, K_WORK_STATE_PENDING);

	return 0;
   2443c:	31 c0                	xor    %eax,%eax
}
   2443e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   24441:	5b                   	pop    %ebx
   24442:	5e                   	pop    %esi
   24443:	5f                   	pop    %edi
   24444:	5d                   	pop    %ebp
   24445:	c3                   	ret    

00024446 <k_work_q_start>:
{
   24446:	55                   	push   %ebp
   24447:	89 e5                	mov    %esp,%ebp
   24449:	57                   	push   %edi
   2444a:	56                   	push   %esi
   2444b:	53                   	push   %ebx
   2444c:	83 ec 08             	sub    $0x8,%esp
   2444f:	8b 5d 08             	mov    0x8(%ebp),%ebx
   24452:	8b 45 10             	mov    0x10(%ebp),%eax
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_INIT, k_queue_init, struct k_queue *, queue)
   24455:	53                   	push   %ebx
   24456:	8b 55 14             	mov    0x14(%ebp),%edx
   24459:	8b 7d 0c             	mov    0xc(%ebp),%edi
   2445c:	89 45 ec             	mov    %eax,-0x14(%ebp)
   2445f:	89 55 f0             	mov    %edx,-0x10(%ebp)
   24462:	e8 ea f1 ff ff       	call   23651 <z_impl_k_queue_init>
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
   24467:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   2446e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   24471:	6a 00                	push   $0x0
   24473:	8b 45 ec             	mov    -0x14(%ebp),%eax
   24476:	52                   	push   %edx
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   24477:	8d 73 18             	lea    0x18(%ebx),%esi
   2447a:	6a 00                	push   $0x0
   2447c:	6a 00                	push   $0x0
   2447e:	53                   	push   %ebx
   2447f:	68 85 26 00 00       	push   $0x2685
   24484:	50                   	push   %eax
   24485:	57                   	push   %edi
   24486:	56                   	push   %esi
   24487:	e8 90 fd ff ff       	call   2421c <z_impl_k_thread_create>
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   2448c:	89 75 08             	mov    %esi,0x8(%ebp)
   2448f:	c7 45 0c e4 aa 02 00 	movl   $0x2aae4,0xc(%ebp)
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
   24496:	83 c4 28             	add    $0x28,%esp
}
   24499:	8d 65 f4             	lea    -0xc(%ebp),%esp
   2449c:	5b                   	pop    %ebx
   2449d:	5e                   	pop    %esi
   2449e:	5f                   	pop    %edi
   2449f:	5d                   	pop    %ebp
K_SYSCALL_DECLARE2_VOID(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, k_tid_t, thread_id, const char *, value)
   244a0:	e9 fa fc ff ff       	jmp    2419f <z_impl_k_thread_name_set>

000244a5 <k_delayed_work_init>:
{
   244a5:	55                   	push   %ebp
   244a6:	89 e5                	mov    %esp,%ebp
   244a8:	8b 45 08             	mov    0x8(%ebp),%eax
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   244ab:	8b 55 0c             	mov    0xc(%ebp),%edx
   244ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   244b4:	89 50 04             	mov    %edx,0x4(%eax)
   244b7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	node->next = NULL;
   244be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	node->prev = NULL;
   244c5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	work->work_q = NULL;
   244cc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
}
   244d3:	5d                   	pop    %ebp
   244d4:	c3                   	ret    

000244d5 <k_delayed_work_submit_to_queue>:

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   244d5:	55                   	push   %ebp
   244d6:	89 e5                	mov    %esp,%ebp
   244d8:	57                   	push   %edi
   244d9:	56                   	push   %esi
   244da:	53                   	push   %ebx
   244db:	83 ec 08             	sub    $0x8,%esp
   244de:	8b 5d 08             	mov    0x8(%ebp),%ebx
   244e1:	9c                   	pushf  
   244e2:	fa                   	cli    
   244e3:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q && work->work_q != work_q) {
   244e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   244e7:	8b 40 1c             	mov    0x1c(%eax),%eax
   244ea:	85 c0                	test   %eax,%eax
   244ec:	74 0f                	je     244fd <k_delayed_work_submit_to_queue+0x28>
		err = -EADDRINUSE;
   244ee:	bf d0 ff ff ff       	mov    $0xffffffd0,%edi
	if (work->work_q && work->work_q != work_q) {
   244f3:	39 d8                	cmp    %ebx,%eax
   244f5:	0f 85 9b 00 00 00    	jne    24596 <k_delayed_work_submit_to_queue+0xc1>
   244fb:	eb 06                	jmp    24503 <k_delayed_work_submit_to_queue+0x2e>
	int err = 0;
   244fd:	31 ff                	xor    %edi,%edi
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
   244ff:	85 db                	test   %ebx,%ebx
   24501:	75 12                	jne    24515 <k_delayed_work_submit_to_queue+0x40>
		err = work_cancel(work);
   24503:	8b 45 0c             	mov    0xc(%ebp),%eax
   24506:	e8 b6 fe ff ff       	call   243c1 <work_cancel>
   2450b:	89 c7                	mov    %eax,%edi
		if (err < 0) {
   2450d:	85 c0                	test   %eax,%eax
   2450f:	0f 88 81 00 00 00    	js     24596 <k_delayed_work_submit_to_queue+0xc1>
			goto done;
		}
	}

	/* Attach workqueue so the timeout callback can submit it */
	work->work_q = work_q;
   24515:	8b 45 0c             	mov    0xc(%ebp),%eax

	/* Submit work directly if no delay.  Note that this is a
	 * blocking operation, so release the lock first.
	 */
	if (!delay) {
   24518:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
	work->work_q = work_q;
   2451c:	89 58 1c             	mov    %ebx,0x1c(%eax)
	if (!delay) {
   2451f:	75 15                	jne    24536 <k_delayed_work_submit_to_queue+0x61>
   24521:	0f ba e6 09          	bt     $0x9,%esi
   24525:	73 01                	jae    24528 <k_delayed_work_submit_to_queue+0x53>
	__asm__ volatile (
   24527:	fb                   	sti    
		k_spin_unlock(&lock, key);
		k_work_submit_to_queue(work_q, &work->work);
   24528:	8b 55 0c             	mov    0xc(%ebp),%edx
   2452b:	89 d8                	mov    %ebx,%eax
   2452d:	e8 50 fe ff ff       	call   24382 <k_work_submit_to_queue>
		return 0;
   24532:	31 ff                	xor    %edi,%edi
   24534:	eb 67                	jmp    2459d <k_delayed_work_submit_to_queue+0xc8>
	return z_clock_hw_cycles_per_sec;
   24536:	a1 24 a7 40 00       	mov    0x40a724,%eax
	return (s32_t)ceiling_fraction(
   2453b:	6a 00                	push   $0x0
	return z_clock_hw_cycles_per_sec;
   2453d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return (s32_t)ceiling_fraction(
   24540:	b8 e8 03 00 00       	mov    $0x3e8,%eax
   24545:	f7 6d ec             	imull  -0x14(%ebp)
   24548:	6a 64                	push   $0x64
   2454a:	52                   	push   %edx
   2454b:	50                   	push   %eax
   2454c:	e8 7f cb fd ff       	call   10d0 <__divdi3>
   24551:	89 c1                	mov    %eax,%ecx
   24553:	8b 45 ec             	mov    -0x14(%ebp),%eax
   24556:	89 d3                	mov    %edx,%ebx
   24558:	83 c4 10             	add    $0x10,%esp
   2455b:	f7 6d 10             	imull  0x10(%ebp)
   2455e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   24561:	89 c8                	mov    %ecx,%eax
   24563:	89 55 f0             	mov    %edx,-0x10(%ebp)
   24566:	83 c0 ff             	add    $0xffffffff,%eax
   24569:	89 da                	mov    %ebx,%edx
   2456b:	53                   	push   %ebx
   2456c:	83 d2 ff             	adc    $0xffffffff,%edx
   2456f:	03 45 ec             	add    -0x14(%ebp),%eax
   24572:	13 55 f0             	adc    -0x10(%ebp),%edx
   24575:	51                   	push   %ecx
   24576:	52                   	push   %edx
   24577:	50                   	push   %eax
   24578:	e8 53 cb fd ff       	call   10d0 <__divdi3>
   2457d:	83 c4 10             	add    $0x10,%esp
	}

	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout,
   24580:	40                   	inc    %eax
   24581:	50                   	push   %eax
   24582:	8b 45 0c             	mov    0xc(%ebp),%eax
   24585:	68 af 43 02 00       	push   $0x243af
   2458a:	83 c0 0c             	add    $0xc,%eax
   2458d:	50                   	push   %eax
   2458e:	e8 cd 00 00 00       	call   24660 <z_add_timeout>
   24593:	83 c4 0c             	add    $0xc,%esp
   24596:	0f ba e6 09          	bt     $0x9,%esi
   2459a:	73 01                	jae    2459d <k_delayed_work_submit_to_queue+0xc8>
   2459c:	fb                   	sti    
		     _TICK_ALIGN + z_ms_to_ticks(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
}
   2459d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   245a0:	89 f8                	mov    %edi,%eax
   245a2:	5b                   	pop    %ebx
   245a3:	5e                   	pop    %esi
   245a4:	5f                   	pop    %edi
   245a5:	5d                   	pop    %ebp
   245a6:	c3                   	ret    

000245a7 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
   245a7:	55                   	push   %ebp
	if (!work->work_q) {
		return -EINVAL;
   245a8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
   245ad:	89 e5                	mov    %esp,%ebp
   245af:	53                   	push   %ebx
   245b0:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!work->work_q) {
   245b3:	83 7a 1c 00          	cmpl   $0x0,0x1c(%edx)
   245b7:	74 11                	je     245ca <k_delayed_work_cancel+0x23>
	__asm__ volatile (
   245b9:	9c                   	pushf  
   245ba:	fa                   	cli    
   245bb:	5b                   	pop    %ebx
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   245bc:	89 d0                	mov    %edx,%eax
   245be:	e8 fe fd ff ff       	call   243c1 <work_cancel>
   245c3:	0f ba e3 09          	bt     $0x9,%ebx
   245c7:	73 01                	jae    245ca <k_delayed_work_cancel+0x23>
	__asm__ volatile (
   245c9:	fb                   	sti    

	k_spin_unlock(&lock, key);
	return ret;
}
   245ca:	5b                   	pop    %ebx
   245cb:	5d                   	pop    %ebp
   245cc:	c3                   	ret    

000245cd <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   245cd:	83 3d 48 45 40 00 00 	cmpl   $0x0,0x404548
   245d4:	75 05                	jne    245db <elapsed+0xe>
   245d6:	e9 16 59 fe ff       	jmp    9ef1 <z_clock_elapsed>
}
   245db:	31 c0                	xor    %eax,%eax
   245dd:	c3                   	ret    

000245de <next_timeout>:

static s32_t next_timeout(void)
{
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
   245de:	80 3d 65 45 40 00 01 	cmpb   $0x1,0x404565
   245e5:	19 d2                	sbb    %edx,%edx
{
   245e7:	55                   	push   %ebp
   245e8:	89 e5                	mov    %esp,%ebp
   245ea:	56                   	push   %esi
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
   245eb:	81 e2 00 00 00 80    	and    $0x80000000,%edx
{
   245f1:	53                   	push   %ebx
	return list->head == list;
   245f2:	8b 1d 28 a7 40 00    	mov    0x40a728,%ebx
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
   245f8:	4a                   	dec    %edx
	struct _timeout *to = first();
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
   245f9:	85 db                	test   %ebx,%ebx
   245fb:	74 22                	je     2461f <next_timeout+0x41>
   245fd:	81 fb 28 a7 40 00    	cmp    $0x40a728,%ebx
   24603:	74 1a                	je     2461f <next_timeout+0x41>
   24605:	8b 73 08             	mov    0x8(%ebx),%esi
   24608:	e8 c0 ff ff ff       	call   245cd <elapsed>
   2460d:	31 d2                	xor    %edx,%edx
   2460f:	39 c6                	cmp    %eax,%esi
   24611:	78 0c                	js     2461f <next_timeout+0x41>
   24613:	8b 5b 08             	mov    0x8(%ebx),%ebx
   24616:	e8 b2 ff ff ff       	call   245cd <elapsed>
   2461b:	89 da                	mov    %ebx,%edx
   2461d:	29 c2                	sub    %eax,%edx

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   2461f:	a1 30 41 40 00       	mov    0x404130,%eax
   24624:	85 c0                	test   %eax,%eax
   24626:	74 04                	je     2462c <next_timeout+0x4e>
   24628:	39 d0                	cmp    %edx,%eax
   2462a:	7c 02                	jl     2462e <next_timeout+0x50>
   2462c:	89 d0                	mov    %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   2462e:	5b                   	pop    %ebx
   2462f:	5e                   	pop    %esi
   24630:	5d                   	pop    %ebp
   24631:	c3                   	ret    

00024632 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   24632:	8b 10                	mov    (%eax),%edx
   24634:	85 c0                	test   %eax,%eax
   24636:	74 12                	je     2464a <remove_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
   24638:	3b 05 2c a7 40 00    	cmp    0x40a72c,%eax
   2463e:	74 0a                	je     2464a <remove_timeout+0x18>
	if (next(t) != NULL) {
   24640:	85 d2                	test   %edx,%edx
   24642:	74 06                	je     2464a <remove_timeout+0x18>
		next(t)->dticks += t->dticks;
   24644:	8b 48 08             	mov    0x8(%eax),%ecx
   24647:	01 4a 08             	add    %ecx,0x8(%edx)
	node->prev->next = node->next;
   2464a:	8b 48 04             	mov    0x4(%eax),%ecx
   2464d:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
   2464f:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
   24652:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   24658:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
   2465f:	c3                   	ret    

00024660 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
   24660:	55                   	push   %ebp
   24661:	89 e5                	mov    %esp,%ebp
   24663:	57                   	push   %edi
   24664:	56                   	push   %esi
   24665:	53                   	push   %ebx
   24666:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   24669:	8b 45 0c             	mov    0xc(%ebp),%eax
   2466c:	89 43 0c             	mov    %eax,0xc(%ebx)
	__asm__ volatile (
   2466f:	9c                   	pushf  
   24670:	fa                   	cli    
   24671:	5e                   	pop    %esi
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   24672:	e8 56 ff ff ff       	call   245cd <elapsed>
	ticks = MAX(1, ticks);
   24677:	8b 55 10             	mov    0x10(%ebp),%edx
   2467a:	85 d2                	test   %edx,%edx
   2467c:	7f 05                	jg     24683 <z_add_timeout+0x23>
   2467e:	ba 01 00 00 00       	mov    $0x1,%edx
		to->dticks = ticks + elapsed();
   24683:	01 c2                	add    %eax,%edx
	return list->head == list;
   24685:	a1 28 a7 40 00       	mov    0x40a728,%eax
   2468a:	89 53 08             	mov    %edx,0x8(%ebx)
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2468d:	8b 0d 2c a7 40 00    	mov    0x40a72c,%ecx
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24693:	3d 28 a7 40 00       	cmp    $0x40a728,%eax
   24698:	74 2f                	je     246c9 <z_add_timeout+0x69>
		for (t = first(); t != NULL; t = next(t)) {
   2469a:	85 c0                	test   %eax,%eax
   2469c:	74 2b                	je     246c9 <z_add_timeout+0x69>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   2469e:	8b 78 08             	mov    0x8(%eax),%edi
   246a1:	8b 53 08             	mov    0x8(%ebx),%edx
   246a4:	39 d7                	cmp    %edx,%edi
   246a6:	7e 14                	jle    246bc <z_add_timeout+0x5c>
				t->dticks -= to->dticks;
   246a8:	29 d7                	sub    %edx,%edi
	node->prev = successor->prev;
   246aa:	8b 50 04             	mov    0x4(%eax),%edx
   246ad:	89 78 08             	mov    %edi,0x8(%eax)
   246b0:	89 53 04             	mov    %edx,0x4(%ebx)
	node->next = successor;
   246b3:	89 03                	mov    %eax,(%ebx)
	successor->prev->next = node;
   246b5:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
   246b7:	89 58 04             	mov    %ebx,0x4(%eax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
   246ba:	eb 28                	jmp    246e4 <z_add_timeout+0x84>
			to->dticks -= t->dticks;
   246bc:	29 fa                	sub    %edi,%edx
	return (node == list->tail) ? NULL : node->next;
   246be:	39 c1                	cmp    %eax,%ecx
   246c0:	89 53 08             	mov    %edx,0x8(%ebx)
   246c3:	74 04                	je     246c9 <z_add_timeout+0x69>
   246c5:	8b 00                	mov    (%eax),%eax
   246c7:	eb d1                	jmp    2469a <z_add_timeout+0x3a>
	node->prev = list->tail;
   246c9:	a1 2c a7 40 00       	mov    0x40a72c,%eax
	node->next = list;
   246ce:	c7 03 28 a7 40 00    	movl   $0x40a728,(%ebx)
	node->prev = list->tail;
   246d4:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
   246d7:	a1 2c a7 40 00       	mov    0x40a72c,%eax
   246dc:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
   246de:	89 1d 2c a7 40 00    	mov    %ebx,0x40a72c
	return list->head == list;
   246e4:	a1 28 a7 40 00       	mov    0x40a728,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   246e9:	39 c3                	cmp    %eax,%ebx
   246eb:	75 16                	jne    24703 <z_add_timeout+0xa3>
   246ed:	3d 28 a7 40 00       	cmp    $0x40a728,%eax
   246f2:	74 0f                	je     24703 <z_add_timeout+0xa3>
			z_clock_set_timeout(next_timeout(), false);
   246f4:	e8 e5 fe ff ff       	call   245de <next_timeout>
   246f9:	6a 00                	push   $0x0
   246fb:	50                   	push   %eax
   246fc:	e8 6a 57 fe ff       	call   9e6b <z_clock_set_timeout>
   24701:	58                   	pop    %eax
   24702:	5a                   	pop    %edx
   24703:	0f ba e6 09          	bt     $0x9,%esi
   24707:	73 01                	jae    2470a <z_add_timeout+0xaa>
	__asm__ volatile (
   24709:	fb                   	sti    
		}
	}
}
   2470a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   2470d:	5b                   	pop    %ebx
   2470e:	5e                   	pop    %esi
   2470f:	5f                   	pop    %edi
   24710:	5d                   	pop    %ebp
   24711:	c3                   	ret    

00024712 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   24712:	55                   	push   %ebp
   24713:	89 e5                	mov    %esp,%ebp
   24715:	53                   	push   %ebx
   24716:	8b 45 08             	mov    0x8(%ebp),%eax
	__asm__ volatile (
   24719:	9c                   	pushf  
   2471a:	fa                   	cli    
   2471b:	5b                   	pop    %ebx
	return node->next != NULL;
   2471c:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
   24721:	83 38 00             	cmpl   $0x0,(%eax)
   24724:	74 07                	je     2472d <z_abort_timeout+0x1b>
			remove_timeout(to);
   24726:	e8 07 ff ff ff       	call   24632 <remove_timeout>
			ret = 0;
   2472b:	31 d2                	xor    %edx,%edx
   2472d:	0f ba e3 09          	bt     $0x9,%ebx
   24731:	73 01                	jae    24734 <z_abort_timeout+0x22>
	__asm__ volatile (
   24733:	fb                   	sti    
		}
	}

	return ret;
}
   24734:	5b                   	pop    %ebx
   24735:	89 d0                	mov    %edx,%eax
   24737:	5d                   	pop    %ebp
   24738:	c3                   	ret    

00024739 <z_timeout_remaining>:

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   24739:	55                   	push   %ebp
   2473a:	31 c0                	xor    %eax,%eax
   2473c:	89 e5                	mov    %esp,%ebp
   2473e:	56                   	push   %esi
   2473f:	53                   	push   %ebx
   24740:	8b 4d 08             	mov    0x8(%ebp),%ecx
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   24743:	83 39 00             	cmpl   $0x0,(%ecx)
   24746:	74 40                	je     24788 <z_timeout_remaining+0x4f>
	__asm__ volatile (
   24748:	9c                   	pushf  
   24749:	fa                   	cli    
   2474a:	58                   	pop    %eax
	return list->head == list;
   2474b:	8b 15 28 a7 40 00    	mov    0x40a728,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24751:	31 db                	xor    %ebx,%ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   24753:	8b 35 2c a7 40 00    	mov    0x40a72c,%esi
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24759:	81 fa 28 a7 40 00    	cmp    $0x40a728,%edx
   2475f:	74 17                	je     24778 <z_timeout_remaining+0x3f>
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   24761:	85 d2                	test   %edx,%edx
   24763:	74 13                	je     24778 <z_timeout_remaining+0x3f>
			ticks += t->dticks;
   24765:	03 5a 08             	add    0x8(%edx),%ebx
			if (timeout == t) {
   24768:	39 ca                	cmp    %ecx,%edx
   2476a:	74 0c                	je     24778 <z_timeout_remaining+0x3f>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2476c:	85 d2                	test   %edx,%edx
   2476e:	74 08                	je     24778 <z_timeout_remaining+0x3f>
	return (node == list->tail) ? NULL : node->next;
   24770:	39 f2                	cmp    %esi,%edx
   24772:	74 04                	je     24778 <z_timeout_remaining+0x3f>
   24774:	8b 12                	mov    (%edx),%edx
   24776:	eb e9                	jmp    24761 <z_timeout_remaining+0x28>
   24778:	0f ba e0 09          	bt     $0x9,%eax
   2477c:	73 01                	jae    2477f <z_timeout_remaining+0x46>
	__asm__ volatile (
   2477e:	fb                   	sti    
				break;
			}
		}
	}

	return ticks - elapsed();
   2477f:	e8 49 fe ff ff       	call   245cd <elapsed>
   24784:	29 c3                	sub    %eax,%ebx
   24786:	89 d8                	mov    %ebx,%eax
}
   24788:	5b                   	pop    %ebx
   24789:	5e                   	pop    %esi
   2478a:	5d                   	pop    %ebp
   2478b:	c3                   	ret    

0002478c <z_get_next_timeout_expiry>:

s32_t z_get_next_timeout_expiry(void)
{
   2478c:	55                   	push   %ebp
   2478d:	89 e5                	mov    %esp,%ebp
   2478f:	53                   	push   %ebx
	__asm__ volatile (
   24790:	9c                   	pushf  
   24791:	fa                   	cli    
   24792:	5b                   	pop    %ebx
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   24793:	e8 46 fe ff ff       	call   245de <next_timeout>
   24798:	0f ba e3 09          	bt     $0x9,%ebx
   2479c:	73 01                	jae    2479f <z_get_next_timeout_expiry+0x13>
	__asm__ volatile (
   2479e:	fb                   	sti    
	}
	return ret;
}
   2479f:	5b                   	pop    %ebx
   247a0:	5d                   	pop    %ebp
   247a1:	c3                   	ret    

000247a2 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   247a2:	55                   	push   %ebp
   247a3:	89 e5                	mov    %esp,%ebp
   247a5:	57                   	push   %edi
   247a6:	56                   	push   %esi
   247a7:	53                   	push   %ebx
   247a8:	8b 75 08             	mov    0x8(%ebp),%esi
   247ab:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	__asm__ volatile (
   247ae:	9c                   	pushf  
   247af:	fa                   	cli    
   247b0:	5f                   	pop    %edi
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   247b1:	e8 28 fe ff ff       	call   245de <next_timeout>
		bool sooner = (next == K_FOREVER) || (ticks < next);
   247b6:	83 f8 ff             	cmp    $0xffffffff,%eax
   247b9:	0f 94 c1             	sete   %cl
   247bc:	39 f0                	cmp    %esi,%eax
   247be:	0f 9f c2             	setg   %dl
		 * what we have.  Also don't try to set a timeout when
		 * one is about to expire: drivers have internal logic
		 * that will bump the timeout to the "next" tick if
		 * it's not considered to be settable as directed.
		 */
		if (sooner && !imminent) {
   247c1:	08 d1                	or     %dl,%cl
   247c3:	74 0f                	je     247d4 <z_set_timeout_expiry+0x32>
   247c5:	48                   	dec    %eax
   247c6:	7e 0c                	jle    247d4 <z_set_timeout_expiry+0x32>
			z_clock_set_timeout(ticks, idle);
   247c8:	0f b6 db             	movzbl %bl,%ebx
   247cb:	53                   	push   %ebx
   247cc:	56                   	push   %esi
   247cd:	e8 99 56 fe ff       	call   9e6b <z_clock_set_timeout>
   247d2:	58                   	pop    %eax
   247d3:	5a                   	pop    %edx
   247d4:	0f ba e7 09          	bt     $0x9,%edi
   247d8:	73 01                	jae    247db <z_set_timeout_expiry+0x39>
	__asm__ volatile (
   247da:	fb                   	sti    
		}
	}
}
   247db:	8d 65 f4             	lea    -0xc(%ebp),%esp
   247de:	5b                   	pop    %ebx
   247df:	5e                   	pop    %esi
   247e0:	5f                   	pop    %edi
   247e1:	5d                   	pop    %ebp
   247e2:	c3                   	ret    

000247e3 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   247e3:	55                   	push   %ebp
   247e4:	89 e5                	mov    %esp,%ebp
   247e6:	57                   	push   %edi
   247e7:	56                   	push   %esi
   247e8:	53                   	push   %ebx
   247e9:	83 ec 0c             	sub    $0xc,%esp
   247ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   247ef:	53                   	push   %ebx
   247f0:	e8 a1 f3 ff ff       	call   23b96 <z_time_slice>
   247f5:	5e                   	pop    %esi
	__asm__ volatile (
   247f6:	9c                   	pushf  
   247f7:	fa                   	cli    
   247f8:	58                   	pop    %eax
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   247f9:	89 1d 48 45 40 00    	mov    %ebx,0x404548
	return list->head == list;
   247ff:	25 00 02 00 00       	and    $0x200,%eax
   24804:	8b 1d 28 a7 40 00    	mov    0x40a728,%ebx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
   2480a:	8b 35 b8 41 40 00    	mov    0x4041b8,%esi
   24810:	8b 3d bc 41 40 00    	mov    0x4041bc,%edi
   24816:	8b 15 48 45 40 00    	mov    0x404548,%edx
   2481c:	89 75 ec             	mov    %esi,-0x14(%ebp)
   2481f:	89 7d f0             	mov    %edi,-0x10(%ebp)
   24822:	89 45 e8             	mov    %eax,-0x18(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
   24825:	85 db                	test   %ebx,%ebx
   24827:	74 54                	je     2487d <z_clock_announce+0x9a>
   24829:	81 fb 28 a7 40 00    	cmp    $0x40a728,%ebx
   2482f:	74 4c                	je     2487d <z_clock_announce+0x9a>
   24831:	8b 43 08             	mov    0x8(%ebx),%eax
   24834:	39 d0                	cmp    %edx,%eax
   24836:	7f 40                	jg     24878 <z_clock_announce+0x95>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   24838:	89 c6                	mov    %eax,%esi
   2483a:	89 c7                	mov    %eax,%edi
   2483c:	c1 ff 1f             	sar    $0x1f,%edi
   2483f:	03 75 ec             	add    -0x14(%ebp),%esi
   24842:	13 7d f0             	adc    -0x10(%ebp),%edi
		announce_remaining -= dt;
		t->dticks = 0;
   24845:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		announce_remaining -= dt;
   2484c:	29 c2                	sub    %eax,%edx
		remove_timeout(t);
   2484e:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
   24850:	89 35 b8 41 40 00    	mov    %esi,0x4041b8
   24856:	89 3d bc 41 40 00    	mov    %edi,0x4041bc
		announce_remaining -= dt;
   2485c:	89 15 48 45 40 00    	mov    %edx,0x404548
		remove_timeout(t);
   24862:	e8 cb fd ff ff       	call   24632 <remove_timeout>
   24867:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   2486b:	74 01                	je     2486e <z_clock_announce+0x8b>
	__asm__ volatile (
   2486d:	fb                   	sti    

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
   2486e:	53                   	push   %ebx
   2486f:	ff 53 0c             	call   *0xc(%ebx)
   24872:	59                   	pop    %ecx
	__asm__ volatile (
   24873:	9c                   	pushf  
   24874:	fa                   	cli    
   24875:	58                   	pop    %eax
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   24876:	eb 87                	jmp    247ff <z_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   24878:	29 d0                	sub    %edx,%eax
   2487a:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	curr_tick += announce_remaining;
   2487d:	89 d6                	mov    %edx,%esi
   2487f:	89 d7                	mov    %edx,%edi
   24881:	c1 ff 1f             	sar    $0x1f,%edi
   24884:	03 75 ec             	add    -0x14(%ebp),%esi
   24887:	13 7d f0             	adc    -0x10(%ebp),%edi
   2488a:	89 35 b8 41 40 00    	mov    %esi,0x4041b8
   24890:	89 3d bc 41 40 00    	mov    %edi,0x4041bc
	announce_remaining = 0;
   24896:	c7 05 48 45 40 00 00 	movl   $0x0,0x404548
   2489d:	00 00 00 

	z_clock_set_timeout(next_timeout(), false);
   248a0:	e8 39 fd ff ff       	call   245de <next_timeout>
   248a5:	6a 00                	push   $0x0
   248a7:	50                   	push   %eax
   248a8:	e8 be 55 fe ff       	call   9e6b <z_clock_set_timeout>
   248ad:	58                   	pop    %eax
   248ae:	5a                   	pop    %edx
   248af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   248b3:	74 01                	je     248b6 <z_clock_announce+0xd3>
	__asm__ volatile (
   248b5:	fb                   	sti    

	k_spin_unlock(&timeout_lock, key);
}
   248b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   248b9:	5b                   	pop    %ebx
   248ba:	5e                   	pop    %esi
   248bb:	5f                   	pop    %edi
   248bc:	5d                   	pop    %ebp
   248bd:	c3                   	ret    

000248be <z_tick_get>:
{
	can_wait_forever = 1;
}

s64_t z_tick_get(void)
{
   248be:	55                   	push   %ebp
   248bf:	89 e5                	mov    %esp,%ebp
   248c1:	56                   	push   %esi
   248c2:	53                   	push   %ebx
	__asm__ volatile (
   248c3:	9c                   	pushf  
   248c4:	fa                   	cli    
   248c5:	5e                   	pop    %esi
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   248c6:	e8 26 56 fe ff       	call   9ef1 <z_clock_elapsed>
   248cb:	8b 0d b8 41 40 00    	mov    0x4041b8,%ecx
   248d1:	0f ba e6 09          	bt     $0x9,%esi
   248d5:	8b 1d bc 41 40 00    	mov    0x4041bc,%ebx
   248db:	73 01                	jae    248de <z_tick_get+0x20>
	__asm__ volatile (
   248dd:	fb                   	sti    
   248de:	31 d2                	xor    %edx,%edx
   248e0:	01 c8                	add    %ecx,%eax
   248e2:	11 da                	adc    %ebx,%edx
	}
	return t;
}
   248e4:	5b                   	pop    %ebx
   248e5:	5e                   	pop    %esi
   248e6:	5d                   	pop    %ebp
   248e7:	c3                   	ret    

000248e8 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   248e8:	55                   	push   %ebp
   248e9:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   248eb:	e8 ce ff ff ff       	call   248be <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   248f0:	5d                   	pop    %ebp
   248f1:	c3                   	ret    

000248f2 <z_impl_k_uptime_get_32>:

u32_t z_impl_k_uptime_get_32(void)
{
   248f2:	55                   	push   %ebp
   248f3:	89 e5                	mov    %esp,%ebp
	return __ticks_to_ms(z_tick_get_32());
   248f5:	e8 ee ff ff ff       	call   248e8 <z_tick_get_32>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
   248fa:	ba e8 03 00 00       	mov    $0x3e8,%edx
   248ff:	f7 e2                	mul    %edx
   24901:	6a 00                	push   $0x0
   24903:	6a 64                	push   $0x64
   24905:	52                   	push   %edx
   24906:	50                   	push   %eax
   24907:	e8 e1 c8 fd ff       	call   11ed <__udivdi3>
   2490c:	83 c4 10             	add    $0x10,%esp
}
   2490f:	c9                   	leave  
   24910:	c3                   	ret    

00024911 <z_impl_k_uptime_get>:
	return z_impl_k_uptime_get_32();
}
#endif

s64_t z_impl_k_uptime_get(void)
{
   24911:	55                   	push   %ebp
   24912:	89 e5                	mov    %esp,%ebp
   24914:	51                   	push   %ecx
	return __ticks_to_ms(z_tick_get());
   24915:	e8 a4 ff ff ff       	call   248be <z_tick_get>
   2491a:	6a 00                	push   $0x0
   2491c:	69 ca e8 03 00 00    	imul   $0x3e8,%edx,%ecx
   24922:	ba e8 03 00 00       	mov    $0x3e8,%edx
   24927:	6a 64                	push   $0x64
   24929:	f7 e2                	mul    %edx
   2492b:	01 ca                	add    %ecx,%edx
   2492d:	52                   	push   %edx
   2492e:	50                   	push   %eax
   2492f:	e8 b9 c8 fd ff       	call   11ed <__udivdi3>
   24934:	83 c4 10             	add    $0x10,%esp
}
   24937:	c9                   	leave  
   24938:	c3                   	ret    

00024939 <clear_event_registrations>:

/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int last_registered,
					      k_spinlock_key_t key)
{
   24939:	55                   	push   %ebp
   2493a:	89 e5                	mov    %esp,%ebp
   2493c:	57                   	push   %edi
   2493d:	56                   	push   %esi
   2493e:	be 01 00 00 00       	mov    $0x1,%esi
   24943:	53                   	push   %ebx
   24944:	89 cb                	mov    %ecx,%ebx
	for (; last_registered >= 0; last_registered--) {
   24946:	6b ca 14             	imul   $0x14,%edx,%ecx
   24949:	01 c8                	add    %ecx,%eax
   2494b:	85 d2                	test   %edx,%edx
   2494d:	78 48                	js     24997 <clear_event_registrations+0x5e>
	switch (event->type) {
   2494f:	8a 48 0d             	mov    0xd(%eax),%cl
	event->poller = NULL;
   24952:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	switch (event->type) {
   24959:	83 e1 0f             	and    $0xf,%ecx
   2495c:	80 f9 04             	cmp    $0x4,%cl
   2495f:	77 26                	ja     24987 <clear_event_registrations+0x4e>
   24961:	89 f7                	mov    %esi,%edi
   24963:	d3 e7                	shl    %cl,%edi
   24965:	89 f9                	mov    %edi,%ecx
   24967:	80 e1 16             	and    $0x16,%cl
   2496a:	74 1b                	je     24987 <clear_event_registrations+0x4e>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   2496c:	8b 08                	mov    (%eax),%ecx
   2496e:	85 c9                	test   %ecx,%ecx
   24970:	74 15                	je     24987 <clear_event_registrations+0x4e>
	node->prev->next = node->next;
   24972:	8b 78 04             	mov    0x4(%eax),%edi
   24975:	89 0f                	mov    %ecx,(%edi)
	node->next->prev = node->prev;
   24977:	89 79 04             	mov    %edi,0x4(%ecx)
	node->next = NULL;
   2497a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   24980:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   24987:	0f ba e3 09          	bt     $0x9,%ebx
   2498b:	73 01                	jae    2498e <clear_event_registrations+0x55>
   2498d:	fb                   	sti    
	__asm__ volatile (
   2498e:	9c                   	pushf  
   2498f:	fa                   	cli    
   24990:	5b                   	pop    %ebx
	for (; last_registered >= 0; last_registered--) {
   24991:	4a                   	dec    %edx
   24992:	83 e8 14             	sub    $0x14,%eax
   24995:	eb b4                	jmp    2494b <clear_event_registrations+0x12>
		clear_event_registration(&events[last_registered]);
		k_spin_unlock(&lock, key);
		key = k_spin_lock(&lock);
	}
}
   24997:	5b                   	pop    %ebx
   24998:	5e                   	pop    %esi
   24999:	5f                   	pop    %edi
   2499a:	5d                   	pop    %ebp
   2499b:	c3                   	ret    

0002499c <signal_poll_event>:
}
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   2499c:	55                   	push   %ebp
   2499d:	89 e5                	mov    %esp,%ebp
   2499f:	57                   	push   %edi
   249a0:	56                   	push   %esi
   249a1:	89 d6                	mov    %edx,%esi
   249a3:	53                   	push   %ebx
   249a4:	89 c3                	mov    %eax,%ebx
	if (!event->poller) {
   249a6:	8b 40 08             	mov    0x8(%eax),%eax
   249a9:	85 c0                	test   %eax,%eax
   249ab:	74 45                	je     249f2 <signal_poll_event+0x56>
		goto ready_event;
	}

	struct k_thread *thread = event->poller->thread;
   249ad:	8b 38                	mov    (%eax),%edi

	__ASSERT(event->poller->thread != NULL,
		 "poller should have a thread\n");

	event->poller->is_polling = false;
   249af:	c6 40 04 00          	movb   $0x0,0x4(%eax)

	if (!z_is_thread_pending(thread)) {
   249b3:	f6 47 0d 02          	testb  $0x2,0xd(%edi)
   249b7:	74 39                	je     249f2 <signal_poll_event+0x56>
		goto ready_event;
	}

	if (z_is_thread_timeout_expired(thread)) {
		return -EAGAIN;
   249b9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (z_is_thread_timeout_expired(thread)) {
   249be:	83 7f 20 fe          	cmpl   $0xfffffffe,0x20(%edi)
   249c2:	74 52                	je     24a16 <signal_poll_event+0x7a>
	}

	z_unpend_thread(thread);
   249c4:	57                   	push   %edi
   249c5:	e8 3a f0 ff ff       	call   23a04 <z_unpend_thread>
	z_set_thread_return_value(thread,
   249ca:	31 c0                	xor    %eax,%eax
   249cc:	83 fe 08             	cmp    $0x8,%esi
   249cf:	0f 95 c0             	setne  %al
	z_unpend_thread(thread);
   249d2:	5a                   	pop    %edx
   249d3:	8b 57 28             	mov    0x28(%edi),%edx
	z_set_thread_return_value(thread,
   249d6:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
   249dd:	89 02                	mov    %eax,(%edx)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   249df:	f6 47 0d 1f          	testb  $0x1f,0xd(%edi)
   249e3:	75 0d                	jne    249f2 <signal_poll_event+0x56>
				 state == K_POLL_STATE_CANCELLED ? -EINTR : 0);

	if (!z_is_thread_ready(thread)) {
   249e5:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
   249e9:	75 07                	jne    249f2 <signal_poll_event+0x56>
		z_add_thread_to_ready_q(thread);
   249eb:	57                   	push   %edi
   249ec:	e8 d5 f0 ff ff       	call   23ac6 <z_add_thread_to_ready_q>
   249f1:	58                   	pop    %eax
	event->state |= state;
   249f2:	8b 4b 0c             	mov    0xc(%ebx),%ecx
	event->poller = NULL;
   249f5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
   249fc:	89 ca                	mov    %ecx,%edx
   249fe:	81 e1 ff 0f fe ff    	and    $0xfffe0fff,%ecx
   24a04:	c1 ea 0c             	shr    $0xc,%edx

	z_ready_thread(thread);

ready_event:
	set_event_ready(event, state);
	return 0;
   24a07:	31 c0                	xor    %eax,%eax
	event->state |= state;
   24a09:	09 f2                	or     %esi,%edx
   24a0b:	83 e2 1f             	and    $0x1f,%edx
   24a0e:	c1 e2 0c             	shl    $0xc,%edx
   24a11:	09 ca                	or     %ecx,%edx
   24a13:	89 53 0c             	mov    %edx,0xc(%ebx)
}
   24a16:	8d 65 f4             	lea    -0xc(%ebp),%esp
   24a19:	5b                   	pop    %ebx
   24a1a:	5e                   	pop    %esi
   24a1b:	5f                   	pop    %edi
   24a1c:	5d                   	pop    %ebp
   24a1d:	c3                   	ret    

00024a1e <add_event>:
{
   24a1e:	55                   	push   %ebp
   24a1f:	89 e5                	mov    %esp,%ebp
   24a21:	57                   	push   %edi
   24a22:	56                   	push   %esi
   24a23:	89 d6                	mov    %edx,%esi
   24a25:	53                   	push   %ebx
   24a26:	53                   	push   %ebx
   24a27:	89 c3                	mov    %eax,%ebx
   24a29:	8b 40 04             	mov    0x4(%eax),%eax
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   24a2c:	3b 1b                	cmp    (%ebx),%ebx
   24a2e:	74 26                	je     24a56 <add_event+0x38>
	if ((pending == NULL) ||
   24a30:	85 c0                	test   %eax,%eax
   24a32:	74 22                	je     24a56 <add_event+0x38>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   24a34:	ff 31                	pushl  (%ecx)
   24a36:	8b 40 08             	mov    0x8(%eax),%eax
   24a39:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   24a3c:	ff 30                	pushl  (%eax)
   24a3e:	e8 09 ee ff ff       	call   2384c <z_is_t1_higher_prio_than_t2>
   24a43:	5f                   	pop    %edi
	if ((pending == NULL) ||
   24a44:	84 c0                	test   %al,%al
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   24a46:	5a                   	pop    %edx
	if ((pending == NULL) ||
   24a47:	75 0d                	jne    24a56 <add_event+0x38>
	return list->head == list;
   24a49:	8b 3b                	mov    (%ebx),%edi
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   24a4b:	39 fb                	cmp    %edi,%ebx
   24a4d:	74 07                	je     24a56 <add_event+0x38>
   24a4f:	85 ff                	test   %edi,%edi
   24a51:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   24a54:	75 12                	jne    24a68 <add_event+0x4a>
	node->prev = list->tail;
   24a56:	8b 43 04             	mov    0x4(%ebx),%eax
	node->next = list;
   24a59:	89 1e                	mov    %ebx,(%esi)
	node->prev = list->tail;
   24a5b:	89 46 04             	mov    %eax,0x4(%esi)
	list->tail->next = node;
   24a5e:	8b 43 04             	mov    0x4(%ebx),%eax
   24a61:	89 30                	mov    %esi,(%eax)
	list->tail = node;
   24a63:	89 73 04             	mov    %esi,0x4(%ebx)
   24a66:	eb 32                	jmp    24a9a <add_event+0x7c>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   24a68:	8b 47 08             	mov    0x8(%edi),%eax
   24a6b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   24a6e:	ff 30                	pushl  (%eax)
   24a70:	ff 31                	pushl  (%ecx)
   24a72:	e8 d5 ed ff ff       	call   2384c <z_is_t1_higher_prio_than_t2>
   24a77:	5a                   	pop    %edx
   24a78:	84 c0                	test   %al,%al
   24a7a:	59                   	pop    %ecx
   24a7b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   24a7e:	74 0f                	je     24a8f <add_event+0x71>
	node->prev = successor->prev;
   24a80:	8b 47 04             	mov    0x4(%edi),%eax
	node->next = successor;
   24a83:	89 3e                	mov    %edi,(%esi)
	node->prev = successor->prev;
   24a85:	89 46 04             	mov    %eax,0x4(%esi)
	successor->prev->next = node;
   24a88:	89 30                	mov    %esi,(%eax)
	successor->prev = node;
   24a8a:	89 77 04             	mov    %esi,0x4(%edi)
			return;
   24a8d:	eb 0b                	jmp    24a9a <add_event+0x7c>
	return (node == list->tail) ? NULL : node->next;
   24a8f:	39 7b 04             	cmp    %edi,0x4(%ebx)
   24a92:	74 c2                	je     24a56 <add_event+0x38>
   24a94:	8b 3f                	mov    (%edi),%edi
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   24a96:	85 ff                	test   %edi,%edi
   24a98:	eb ba                	jmp    24a54 <add_event+0x36>
}
   24a9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   24a9d:	5b                   	pop    %ebx
   24a9e:	5e                   	pop    %esi
   24a9f:	5f                   	pop    %edi
   24aa0:	5d                   	pop    %ebp
   24aa1:	c3                   	ret    

00024aa2 <k_poll_event_init>:
{
   24aa2:	55                   	push   %ebp
   24aa3:	89 e5                	mov    %esp,%ebp
   24aa5:	8b 45 08             	mov    0x8(%ebp),%eax
	event->type = type;
   24aa8:	8a 4d 0c             	mov    0xc(%ebp),%cl
   24aab:	83 e1 0f             	and    $0xf,%ecx
   24aae:	8a 50 0d             	mov    0xd(%eax),%dl
	event->poller = NULL;
   24ab1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	event->type = type;
   24ab8:	83 e2 f0             	and    $0xfffffff0,%edx
   24abb:	09 ca                	or     %ecx,%edx
   24abd:	88 50 0d             	mov    %dl,0xd(%eax)
	event->mode = mode;
   24ac0:	8a 55 10             	mov    0x10(%ebp),%dl
   24ac3:	83 e2 01             	and    $0x1,%edx
   24ac6:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
   24ac9:	8a 50 0e             	mov    0xe(%eax),%dl
   24acc:	83 e2 fd             	and    $0xfffffffd,%edx
   24acf:	09 ca                	or     %ecx,%edx
   24ad1:	88 50 0e             	mov    %dl,0xe(%eax)
	event->state = K_POLL_STATE_NOT_READY;
   24ad4:	81 60 0c ff 0f 02 00 	andl   $0x20fff,0xc(%eax)
	event->obj = obj;
   24adb:	8b 55 14             	mov    0x14(%ebp),%edx
   24ade:	89 50 10             	mov    %edx,0x10(%eax)
}
   24ae1:	5d                   	pop    %ebp
   24ae2:	c3                   	ret    

00024ae3 <z_impl_k_poll>:
{
   24ae3:	55                   	push   %ebp
   24ae4:	89 e5                	mov    %esp,%ebp
   24ae6:	57                   	push   %edi
   24ae7:	56                   	push   %esi
	for (int ii = 0; ii < num_events; ii++) {
   24ae8:	31 ff                	xor    %edi,%edi
{
   24aea:	53                   	push   %ebx
	int last_registered = -1, rc;
   24aeb:	83 ce ff             	or     $0xffffffff,%esi
{
   24aee:	83 ec 1c             	sub    $0x1c,%esp
	struct _poller poller = { .thread = _current, .is_polling = true, };
   24af1:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
   24af5:	a1 28 41 40 00       	mov    0x404128,%eax
   24afa:	8b 5d 08             	mov    0x8(%ebp),%ebx
   24afd:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
   24b00:	3b 7d 0c             	cmp    0xc(%ebp),%edi
   24b03:	0f 8d bc 00 00 00    	jge    24bc5 <z_impl_k_poll+0xe2>
   24b09:	9c                   	pushf  
   24b0a:	fa                   	cli    
   24b0b:	8f 45 d8             	popl   -0x28(%ebp)
	switch (event->type) {
   24b0e:	8a 43 0d             	mov    0xd(%ebx),%al
   24b11:	83 e0 0f             	and    $0xf,%eax
   24b14:	3c 02                	cmp    $0x2,%al
   24b16:	74 0a                	je     24b22 <z_impl_k_poll+0x3f>
   24b18:	3c 04                	cmp    $0x4,%al
   24b1a:	74 16                	je     24b32 <z_impl_k_poll+0x4f>
   24b1c:	3c 01                	cmp    $0x1,%al
   24b1e:	75 57                	jne    24b77 <z_impl_k_poll+0x94>
   24b20:	eb 1f                	jmp    24b41 <z_impl_k_poll+0x5e>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SEM_COUNT_GET, k_sem_count_get, unsigned int, struct k_sem *, sem)
   24b22:	8b 53 10             	mov    0x10(%ebx),%edx
		if (k_sem_count_get(event->sem) > 0) {
   24b25:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
   24b29:	74 4c                	je     24b77 <z_impl_k_poll+0x94>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   24b2b:	b9 02 00 00 00       	mov    $0x2,%ecx
   24b30:	eb 1d                	jmp    24b4f <z_impl_k_poll+0x6c>
Z_GENLIST_IS_EMPTY(sflist)
   24b32:	8b 53 10             	mov    0x10(%ebx),%edx
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   24b35:	b9 04 00 00 00       	mov    $0x4,%ecx
		if (!k_queue_is_empty(event->queue)) {
   24b3a:	83 3a 00             	cmpl   $0x0,(%edx)
   24b3d:	75 10                	jne    24b4f <z_impl_k_poll+0x6c>
   24b3f:	eb 36                	jmp    24b77 <z_impl_k_poll+0x94>
		if (event->signal->signaled != 0) {
   24b41:	8b 53 10             	mov    0x10(%ebx),%edx
			*state = K_POLL_STATE_SIGNALED;
   24b44:	b9 01 00 00 00       	mov    $0x1,%ecx
		if (event->signal->signaled != 0) {
   24b49:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
   24b4d:	74 28                	je     24b77 <z_impl_k_poll+0x94>
	event->state |= state;
   24b4f:	8b 53 0c             	mov    0xc(%ebx),%edx
	event->poller = NULL;
   24b52:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
   24b59:	89 d0                	mov    %edx,%eax
   24b5b:	81 e2 ff 0f fe ff    	and    $0xfffe0fff,%edx
   24b61:	c1 e8 0c             	shr    $0xc,%eax
   24b64:	83 e0 1f             	and    $0x1f,%eax
   24b67:	09 c8                	or     %ecx,%eax
   24b69:	c1 e0 0c             	shl    $0xc,%eax
   24b6c:	09 d0                	or     %edx,%eax
   24b6e:	89 43 0c             	mov    %eax,0xc(%ebx)
			poller.is_polling = false;
   24b71:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
   24b75:	eb 3d                	jmp    24bb4 <z_impl_k_poll+0xd1>
		} else if (timeout != K_NO_WAIT && poller.is_polling) {
   24b77:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   24b7b:	74 37                	je     24bb4 <z_impl_k_poll+0xd1>
   24b7d:	8a 55 e0             	mov    -0x20(%ebp),%dl
   24b80:	84 d2                	test   %dl,%dl
   24b82:	74 30                	je     24bb4 <z_impl_k_poll+0xd1>
	switch (event->type) {
   24b84:	3c 02                	cmp    $0x2,%al
   24b86:	74 0d                	je     24b95 <z_impl_k_poll+0xb2>
   24b88:	3c 04                	cmp    $0x4,%al
   24b8a:	74 11                	je     24b9d <z_impl_k_poll+0xba>
   24b8c:	fe c8                	dec    %al
   24b8e:	75 1d                	jne    24bad <z_impl_k_poll+0xca>
		add_event(&event->signal->poll_events, event, poller);
   24b90:	8b 43 10             	mov    0x10(%ebx),%eax
   24b93:	eb 0e                	jmp    24ba3 <z_impl_k_poll+0xc0>
		add_event(&event->sem->poll_events, event, poller);
   24b95:	8b 43 10             	mov    0x10(%ebx),%eax
   24b98:	83 c0 18             	add    $0x18,%eax
   24b9b:	eb 06                	jmp    24ba3 <z_impl_k_poll+0xc0>
		add_event(&event->queue->poll_events, event, poller);
   24b9d:	8b 43 10             	mov    0x10(%ebx),%eax
   24ba0:	83 c0 08             	add    $0x8,%eax
		add_event(&event->signal->poll_events, event, poller);
   24ba3:	8d 4d dc             	lea    -0x24(%ebp),%ecx
   24ba6:	89 da                	mov    %ebx,%edx
   24ba8:	e8 71 fe ff ff       	call   24a1e <add_event>
	event->poller = poller;
   24bad:	8d 45 dc             	lea    -0x24(%ebp),%eax
				++last_registered;
   24bb0:	46                   	inc    %esi
	event->poller = poller;
   24bb1:	89 43 08             	mov    %eax,0x8(%ebx)
   24bb4:	0f ba 65 d8 09       	btl    $0x9,-0x28(%ebp)
   24bb9:	73 01                	jae    24bbc <z_impl_k_poll+0xd9>
	__asm__ volatile (
   24bbb:	fb                   	sti    
	for (int ii = 0; ii < num_events; ii++) {
   24bbc:	47                   	inc    %edi
   24bbd:	83 c3 14             	add    $0x14,%ebx
   24bc0:	e9 3b ff ff ff       	jmp    24b00 <z_impl_k_poll+0x1d>
	__asm__ volatile (
   24bc5:	9c                   	pushf  
   24bc6:	fa                   	cli    
   24bc7:	5b                   	pop    %ebx
	if (!poller.is_polling) {
   24bc8:	8a 45 e0             	mov    -0x20(%ebp),%al
   24bcb:	84 c0                	test   %al,%al
   24bcd:	75 10                	jne    24bdf <z_impl_k_poll+0xfc>
		clear_event_registrations(events, last_registered, key);
   24bcf:	89 d9                	mov    %ebx,%ecx
   24bd1:	89 f2                	mov    %esi,%edx
   24bd3:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
   24bd6:	31 ff                	xor    %edi,%edi
		clear_event_registrations(events, last_registered, key);
   24bd8:	e8 5c fd ff ff       	call   24939 <clear_event_registrations>
   24bdd:	eb 48                	jmp    24c27 <z_impl_k_poll+0x144>
	poller.is_polling = false;
   24bdf:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
		return -EAGAIN;
   24be3:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
	if (timeout == K_NO_WAIT) {
   24be8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   24bec:	74 39                	je     24c27 <z_impl_k_poll+0x144>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   24bee:	31 c0                	xor    %eax,%eax
   24bf0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
   24bf3:	b9 04 00 00 00       	mov    $0x4,%ecx
   24bf8:	f3 ab                	rep stos %eax,%es:(%edi)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   24bfa:	ff 75 10             	pushl  0x10(%ebp)
   24bfd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   24c00:	c7 45 e8 07 38 02 00 	movl   $0x23807,-0x18(%ebp)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   24c07:	50                   	push   %eax
   24c08:	53                   	push   %ebx
   24c09:	68 66 45 40 00       	push   $0x404566
   24c0e:	e8 d0 f0 ff ff       	call   23ce3 <z_pend_curr>
   24c13:	83 c4 10             	add    $0x10,%esp
   24c16:	89 c7                	mov    %eax,%edi
   24c18:	9c                   	pushf  
   24c19:	fa                   	cli    
   24c1a:	5b                   	pop    %ebx
	clear_event_registrations(events, last_registered, key);
   24c1b:	89 d9                	mov    %ebx,%ecx
   24c1d:	89 f2                	mov    %esi,%edx
   24c1f:	8b 45 08             	mov    0x8(%ebp),%eax
   24c22:	e8 12 fd ff ff       	call   24939 <clear_event_registrations>
   24c27:	0f ba e3 09          	bt     $0x9,%ebx
   24c2b:	73 01                	jae    24c2e <z_impl_k_poll+0x14b>
	__asm__ volatile (
   24c2d:	fb                   	sti    
}
   24c2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   24c31:	89 f8                	mov    %edi,%eax
   24c33:	5b                   	pop    %ebx
   24c34:	5e                   	pop    %esi
   24c35:	5f                   	pop    %edi
   24c36:	5d                   	pop    %ebp
   24c37:	c3                   	ret    

00024c38 <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
   24c38:	55                   	push   %ebp
   24c39:	89 e5                	mov    %esp,%ebp
   24c3b:	53                   	push   %ebx
   24c3c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   24c3f:	8b 55 0c             	mov    0xc(%ebp),%edx
	return list->head == list;
   24c42:	8b 01                	mov    (%ecx),%eax
	if (!sys_dlist_is_empty(list)) {
   24c44:	39 c1                	cmp    %eax,%ecx
   24c46:	74 1e                	je     24c66 <z_handle_obj_poll_events+0x2e>
	node->prev->next = node->next;
   24c48:	8b 58 04             	mov    0x4(%eax),%ebx
   24c4b:	8b 08                	mov    (%eax),%ecx
   24c4d:	89 0b                	mov    %ecx,(%ebx)
	node->next->prev = node->prev;
   24c4f:	89 59 04             	mov    %ebx,0x4(%ecx)
	node->next = NULL;
   24c52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   24c58:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
	}
}
   24c5f:	5b                   	pop    %ebx
   24c60:	5d                   	pop    %ebp
		(void) signal_poll_event(poll_event, state);
   24c61:	e9 36 fd ff ff       	jmp    2499c <signal_poll_event>
}
   24c66:	5b                   	pop    %ebx
   24c67:	5d                   	pop    %ebp
   24c68:	c3                   	ret    

00024c69 <z_impl_k_poll_signal_init>:

void z_impl_k_poll_signal_init(struct k_poll_signal *signal)
{
   24c69:	55                   	push   %ebp
   24c6a:	89 e5                	mov    %esp,%ebp
   24c6c:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
   24c6f:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
   24c71:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&signal->poll_events);
	signal->signaled = 0;
   24c74:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	/* signal->result is left unitialized */
	z_object_init(signal);
}
   24c7b:	5d                   	pop    %ebp
   24c7c:	c3                   	ret    

00024c7d <z_impl_k_poll_signal_check>:
}
#endif

void z_impl_k_poll_signal_check(struct k_poll_signal *signal,
			       unsigned int *signaled, int *result)
{
   24c7d:	55                   	push   %ebp
   24c7e:	89 e5                	mov    %esp,%ebp
   24c80:	8b 45 08             	mov    0x8(%ebp),%eax
	*signaled = signal->signaled;
   24c83:	8b 55 0c             	mov    0xc(%ebp),%edx
   24c86:	8b 48 08             	mov    0x8(%eax),%ecx
   24c89:	89 0a                	mov    %ecx,(%edx)
	*result = signal->result;
   24c8b:	8b 50 0c             	mov    0xc(%eax),%edx
   24c8e:	8b 45 10             	mov    0x10(%ebp),%eax
   24c91:	89 10                	mov    %edx,(%eax)
}
   24c93:	5d                   	pop    %ebp
   24c94:	c3                   	ret    

00024c95 <z_impl_k_poll_signal_raise>:
	return 0;
}
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   24c95:	55                   	push   %ebp
   24c96:	89 e5                	mov    %esp,%ebp
   24c98:	53                   	push   %ebx
   24c99:	51                   	push   %ecx
   24c9a:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
   24c9d:	9c                   	pushf  
   24c9e:	fa                   	cli    
   24c9f:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   24ca0:	8b 45 0c             	mov    0xc(%ebp),%eax
	signal->signaled = 1;
   24ca3:	c7 42 08 01 00 00 00 	movl   $0x1,0x8(%edx)
	signal->result = result;
   24caa:	89 42 0c             	mov    %eax,0xc(%edx)
	return list->head == list;
   24cad:	8b 02                	mov    (%edx),%eax
	if (!sys_dlist_is_empty(list)) {
   24caf:	39 c2                	cmp    %eax,%edx
   24cb1:	75 0d                	jne    24cc0 <z_impl_k_poll_signal_raise+0x2b>

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   24cb3:	31 c0                	xor    %eax,%eax
   24cb5:	0f ba e3 09          	bt     $0x9,%ebx
   24cb9:	73 39                	jae    24cf4 <z_impl_k_poll_signal_raise+0x5f>
	__asm__ volatile (
   24cbb:	fb                   	sti    
   24cbc:	31 c0                	xor    %eax,%eax
   24cbe:	eb 34                	jmp    24cf4 <z_impl_k_poll_signal_raise+0x5f>
	node->prev->next = node->next;
   24cc0:	8b 48 04             	mov    0x4(%eax),%ecx
   24cc3:	8b 10                	mov    (%eax),%edx
   24cc5:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
   24cc7:	89 4a 04             	mov    %ecx,0x4(%edx)
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   24cca:	ba 01 00 00 00       	mov    $0x1,%edx
	node->next = NULL;
   24ccf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
   24cd5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   24cdc:	e8 bb fc ff ff       	call   2499c <signal_poll_event>

	z_reschedule(&lock, key);
   24ce1:	53                   	push   %ebx
   24ce2:	68 66 45 40 00       	push   $0x404566
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   24ce7:	89 45 f8             	mov    %eax,-0x8(%ebp)
	z_reschedule(&lock, key);
   24cea:	e8 16 ec ff ff       	call   23905 <z_reschedule>
   24cef:	58                   	pop    %eax
   24cf0:	5a                   	pop    %edx
	return rc;
   24cf1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   24cf4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   24cf7:	c9                   	leave  
   24cf8:	c3                   	ret    

00024cf9 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   24cf9:	55                   	push   %ebp
   24cfa:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
   24cfc:	9c                   	pushf  
   24cfd:	fa                   	cli    
   24cfe:	58                   	pop    %eax
	s32_t ticks = z_get_next_timeout_expiry();
   24cff:	e8 88 fa ff ff       	call   2478c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   24d04:	83 f8 02             	cmp    $0x2,%eax
   24d07:	7f 05                	jg     24d0e <idle+0x15>
   24d09:	b8 01 00 00 00       	mov    $0x1,%eax
   24d0e:	6a 01                	push   $0x1
   24d10:	50                   	push   %eax
   24d11:	e8 8c fa ff ff       	call   247a2 <z_set_timeout_expiry>
   24d16:	58                   	pop    %eax
   24d17:	5a                   	pop    %edx
	k_cpu_idle();
   24d18:	e8 1d 52 fe ff       	call   9f3a <k_cpu_idle>
   24d1d:	eb dd                	jmp    24cfc <idle+0x3>

00024d1f <_OffsetAbsSyms>:

/* size of the MMU_REGION structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__MMU_REGION_SIZEOF, sizeof(struct mmu_region));

GEN_ABS_SYM_END
   24d1f:	c3                   	ret    

00024d20 <_handle_exc_0_vector_0_stub>:
   24d20:	6a 00                	push   $0x0
   24d22:	68 6d a3 00 00       	push   $0xa36d
   24d27:	e9 11 52 fe ff       	jmp    9f3d <_exception_enter>

00024d2c <_handle_exc_2_vector_2_stub>:
   24d2c:	6a 00                	push   $0x0
   24d2e:	68 7a a3 00 00       	push   $0xa37a
   24d33:	e9 05 52 fe ff       	jmp    9f3d <_exception_enter>

00024d38 <_handle_exc_4_vector_4_stub>:
   24d38:	6a 00                	push   $0x0
   24d3a:	68 8a a3 00 00       	push   $0xa38a
   24d3f:	e9 f9 51 fe ff       	jmp    9f3d <_exception_enter>

00024d44 <_handle_exc_5_vector_5_stub>:
   24d44:	6a 00                	push   $0x0
   24d46:	68 9a a3 00 00       	push   $0xa39a
   24d4b:	e9 ed 51 fe ff       	jmp    9f3d <_exception_enter>

00024d50 <_handle_exc_6_vector_6_stub>:
   24d50:	6a 00                	push   $0x0
   24d52:	68 aa a3 00 00       	push   $0xa3aa
   24d57:	e9 e1 51 fe ff       	jmp    9f3d <_exception_enter>

00024d5c <_handle_exc_7_vector_7_stub>:
   24d5c:	6a 00                	push   $0x0
   24d5e:	68 ba a3 00 00       	push   $0xa3ba
   24d63:	e9 d5 51 fe ff       	jmp    9f3d <_exception_enter>

00024d68 <_handle_exc_8_vector_8_stub>:
   24d68:	6a 00                	push   $0x0
   24d6a:	68 ca a3 00 00       	push   $0xa3ca
   24d6f:	e9 c9 51 fe ff       	jmp    9f3d <_exception_enter>

00024d74 <_handle_exc_10_vector_10_stub>:
   24d74:	68 da a3 00 00       	push   $0xa3da
   24d79:	e9 bf 51 fe ff       	jmp    9f3d <_exception_enter>

00024d7e <_handle_exc_11_vector_11_stub>:
   24d7e:	68 ea a3 00 00       	push   $0xa3ea
   24d83:	e9 b5 51 fe ff       	jmp    9f3d <_exception_enter>

00024d88 <_handle_exc_12_vector_12_stub>:
   24d88:	68 fa a3 00 00       	push   $0xa3fa
   24d8d:	e9 ab 51 fe ff       	jmp    9f3d <_exception_enter>

00024d92 <_handle_exc_13_vector_13_stub>:
   24d92:	68 0a a4 00 00       	push   $0xa40a
   24d97:	e9 a1 51 fe ff       	jmp    9f3d <_exception_enter>

00024d9c <_handle_exc_16_vector_16_stub>:
   24d9c:	6a 00                	push   $0x0
   24d9e:	68 1a a4 00 00       	push   $0xa41a
   24da3:	e9 95 51 fe ff       	jmp    9f3d <_exception_enter>

00024da8 <_handle_exc_17_vector_17_stub>:
   24da8:	68 2a a4 00 00       	push   $0xa42a
   24dad:	e9 8b 51 fe ff       	jmp    9f3d <_exception_enter>

00024db2 <_handle_exc_18_vector_18_stub>:
   24db2:	6a 00                	push   $0x0
   24db4:	68 3a a4 00 00       	push   $0xa43a
   24db9:	e9 7f 51 fe ff       	jmp    9f3d <_exception_enter>

00024dbe <_page_fault_handler_vector_14_stub>:
   24dbe:	68 4a a4 00 00       	push   $0xa44a
   24dc3:	e9 75 51 fe ff       	jmp    9f3d <_exception_enter>
   24dc8:	66 90                	xchg   %ax,%ax
   24dca:	66 90                	xchg   %ax,%ax
   24dcc:	66 90                	xchg   %ax,%ax
   24dce:	66 90                	xchg   %ax,%ax
   24dd0:	66 90                	xchg   %ax,%ax
   24dd2:	66 90                	xchg   %ax,%ax
   24dd4:	66 90                	xchg   %ax,%ax
   24dd6:	66 90                	xchg   %ax,%ax
   24dd8:	66 90                	xchg   %ax,%ax
   24dda:	66 90                	xchg   %ax,%ax
   24ddc:	66 90                	xchg   %ax,%ax
   24dde:	66 90                	xchg   %ax,%ax
   24de0:	66 90                	xchg   %ax,%ax
   24de2:	66 90                	xchg   %ax,%ax
   24de4:	66 90                	xchg   %ax,%ax
   24de6:	66 90                	xchg   %ax,%ax
   24de8:	66 90                	xchg   %ax,%ax
   24dea:	66 90                	xchg   %ax,%ax
   24dec:	66 90                	xchg   %ax,%ax
   24dee:	66 90                	xchg   %ax,%ax
   24df0:	66 90                	xchg   %ax,%ax
   24df2:	66 90                	xchg   %ax,%ax
   24df4:	66 90                	xchg   %ax,%ax
   24df6:	66 90                	xchg   %ax,%ax
   24df8:	66 90                	xchg   %ax,%ax
   24dfa:	66 90                	xchg   %ax,%ax
   24dfc:	66 90                	xchg   %ax,%ax
   24dfe:	66 90                	xchg   %ax,%ax
   24e00:	66 90                	xchg   %ax,%ax
   24e02:	66 90                	xchg   %ax,%ax
   24e04:	66 90                	xchg   %ax,%ax
   24e06:	66 90                	xchg   %ax,%ax
   24e08:	66 90                	xchg   %ax,%ax
   24e0a:	66 90                	xchg   %ax,%ax
   24e0c:	66 90                	xchg   %ax,%ax
   24e0e:	66 90                	xchg   %ax,%ax
   24e10:	66 90                	xchg   %ax,%ax
   24e12:	66 90                	xchg   %ax,%ax
   24e14:	66 90                	xchg   %ax,%ax
   24e16:	66 90                	xchg   %ax,%ax
   24e18:	66 90                	xchg   %ax,%ax
   24e1a:	66 90                	xchg   %ax,%ax
   24e1c:	66 90                	xchg   %ax,%ax
   24e1e:	66 90                	xchg   %ax,%ax
   24e20:	66 90                	xchg   %ax,%ax
   24e22:	66 90                	xchg   %ax,%ax
   24e24:	66 90                	xchg   %ax,%ax
   24e26:	66 90                	xchg   %ax,%ax
   24e28:	66 90                	xchg   %ax,%ax
   24e2a:	66 90                	xchg   %ax,%ax
   24e2c:	66 90                	xchg   %ax,%ax
   24e2e:	66 90                	xchg   %ax,%ax
   24e30:	66 90                	xchg   %ax,%ax
   24e32:	66 90                	xchg   %ax,%ax
   24e34:	66 90                	xchg   %ax,%ax
   24e36:	66 90                	xchg   %ax,%ax
   24e38:	66 90                	xchg   %ax,%ax
   24e3a:	66 90                	xchg   %ax,%ax
   24e3c:	66 90                	xchg   %ax,%ax
   24e3e:	66 90                	xchg   %ax,%ax
   24e40:	66 90                	xchg   %ax,%ax
   24e42:	66 90                	xchg   %ax,%ax
   24e44:	66 90                	xchg   %ax,%ax
   24e46:	66 90                	xchg   %ax,%ax
   24e48:	66 90                	xchg   %ax,%ax
   24e4a:	66 90                	xchg   %ax,%ax
   24e4c:	66 90                	xchg   %ax,%ax
   24e4e:	66 90                	xchg   %ax,%ax
   24e50:	66 90                	xchg   %ax,%ax
   24e52:	66 90                	xchg   %ax,%ax
   24e54:	66 90                	xchg   %ax,%ax
   24e56:	66 90                	xchg   %ax,%ax
   24e58:	66 90                	xchg   %ax,%ax
   24e5a:	66 90                	xchg   %ax,%ax
   24e5c:	66 90                	xchg   %ax,%ax
   24e5e:	66 90                	xchg   %ax,%ax
   24e60:	66 90                	xchg   %ax,%ax
   24e62:	66 90                	xchg   %ax,%ax
   24e64:	66 90                	xchg   %ax,%ax
   24e66:	66 90                	xchg   %ax,%ax
   24e68:	66 90                	xchg   %ax,%ax
   24e6a:	66 90                	xchg   %ax,%ax
   24e6c:	66 90                	xchg   %ax,%ax
   24e6e:	66 90                	xchg   %ax,%ax
   24e70:	66 90                	xchg   %ax,%ax
   24e72:	66 90                	xchg   %ax,%ax
   24e74:	66 90                	xchg   %ax,%ax
   24e76:	66 90                	xchg   %ax,%ax
   24e78:	66 90                	xchg   %ax,%ax
   24e7a:	66 90                	xchg   %ax,%ax
   24e7c:	66 90                	xchg   %ax,%ax
   24e7e:	66 90                	xchg   %ax,%ax
   24e80:	66 90                	xchg   %ax,%ax
   24e82:	66 90                	xchg   %ax,%ax
   24e84:	66 90                	xchg   %ax,%ax
   24e86:	66 90                	xchg   %ax,%ax
   24e88:	66 90                	xchg   %ax,%ax
   24e8a:	66 90                	xchg   %ax,%ax
   24e8c:	66 90                	xchg   %ax,%ax
   24e8e:	66 90                	xchg   %ax,%ax
   24e90:	66 90                	xchg   %ax,%ax
   24e92:	66 90                	xchg   %ax,%ax
   24e94:	66 90                	xchg   %ax,%ax
   24e96:	66 90                	xchg   %ax,%ax
   24e98:	66 90                	xchg   %ax,%ax
   24e9a:	66 90                	xchg   %ax,%ax
   24e9c:	66 90                	xchg   %ax,%ax
   24e9e:	66 90                	xchg   %ax,%ax
   24ea0:	66 90                	xchg   %ax,%ax
   24ea2:	66 90                	xchg   %ax,%ax
   24ea4:	66 90                	xchg   %ax,%ax
   24ea6:	66 90                	xchg   %ax,%ax
   24ea8:	66 90                	xchg   %ax,%ax
   24eaa:	66 90                	xchg   %ax,%ax
   24eac:	66 90                	xchg   %ax,%ax
   24eae:	66 90                	xchg   %ax,%ax
   24eb0:	66 90                	xchg   %ax,%ax
   24eb2:	66 90                	xchg   %ax,%ax
   24eb4:	66 90                	xchg   %ax,%ax
   24eb6:	66 90                	xchg   %ax,%ax
   24eb8:	66 90                	xchg   %ax,%ax
   24eba:	66 90                	xchg   %ax,%ax
   24ebc:	66 90                	xchg   %ax,%ax
   24ebe:	66 90                	xchg   %ax,%ax
   24ec0:	66 90                	xchg   %ax,%ax
   24ec2:	66 90                	xchg   %ax,%ax
   24ec4:	66 90                	xchg   %ax,%ax
   24ec6:	66 90                	xchg   %ax,%ax
   24ec8:	66 90                	xchg   %ax,%ax
   24eca:	66 90                	xchg   %ax,%ax
   24ecc:	66 90                	xchg   %ax,%ax
   24ece:	66 90                	xchg   %ax,%ax
   24ed0:	66 90                	xchg   %ax,%ax
   24ed2:	66 90                	xchg   %ax,%ax
   24ed4:	66 90                	xchg   %ax,%ax
   24ed6:	66 90                	xchg   %ax,%ax
   24ed8:	66 90                	xchg   %ax,%ax
   24eda:	66 90                	xchg   %ax,%ax
   24edc:	66 90                	xchg   %ax,%ax
   24ede:	66 90                	xchg   %ax,%ax
   24ee0:	66 90                	xchg   %ax,%ax
   24ee2:	66 90                	xchg   %ax,%ax
   24ee4:	66 90                	xchg   %ax,%ax
   24ee6:	66 90                	xchg   %ax,%ax
   24ee8:	66 90                	xchg   %ax,%ax
   24eea:	66 90                	xchg   %ax,%ax
   24eec:	66 90                	xchg   %ax,%ax
   24eee:	66 90                	xchg   %ax,%ax
   24ef0:	66 90                	xchg   %ax,%ax
   24ef2:	66 90                	xchg   %ax,%ax
   24ef4:	66 90                	xchg   %ax,%ax
   24ef6:	66 90                	xchg   %ax,%ax
   24ef8:	66 90                	xchg   %ax,%ax
   24efa:	66 90                	xchg   %ax,%ax
   24efc:	66 90                	xchg   %ax,%ax
   24efe:	66 90                	xchg   %ax,%ax
   24f00:	66 90                	xchg   %ax,%ax
   24f02:	66 90                	xchg   %ax,%ax
   24f04:	66 90                	xchg   %ax,%ax
   24f06:	66 90                	xchg   %ax,%ax
   24f08:	66 90                	xchg   %ax,%ax
   24f0a:	66 90                	xchg   %ax,%ax
   24f0c:	66 90                	xchg   %ax,%ax
   24f0e:	66 90                	xchg   %ax,%ax
   24f10:	66 90                	xchg   %ax,%ax
   24f12:	66 90                	xchg   %ax,%ax
   24f14:	66 90                	xchg   %ax,%ax
   24f16:	66 90                	xchg   %ax,%ax
   24f18:	66 90                	xchg   %ax,%ax
   24f1a:	66 90                	xchg   %ax,%ax
   24f1c:	66 90                	xchg   %ax,%ax
   24f1e:	66 90                	xchg   %ax,%ax
   24f20:	66 90                	xchg   %ax,%ax
   24f22:	66 90                	xchg   %ax,%ax
   24f24:	66 90                	xchg   %ax,%ax
   24f26:	66 90                	xchg   %ax,%ax
   24f28:	66 90                	xchg   %ax,%ax
   24f2a:	66 90                	xchg   %ax,%ax
   24f2c:	66 90                	xchg   %ax,%ax
   24f2e:	66 90                	xchg   %ax,%ax
   24f30:	66 90                	xchg   %ax,%ax
   24f32:	66 90                	xchg   %ax,%ax
   24f34:	66 90                	xchg   %ax,%ax
   24f36:	66 90                	xchg   %ax,%ax
   24f38:	66 90                	xchg   %ax,%ax
   24f3a:	66 90                	xchg   %ax,%ax
   24f3c:	66 90                	xchg   %ax,%ax
   24f3e:	66 90                	xchg   %ax,%ax
   24f40:	66 90                	xchg   %ax,%ax
   24f42:	66 90                	xchg   %ax,%ax
   24f44:	66 90                	xchg   %ax,%ax
   24f46:	66 90                	xchg   %ax,%ax
   24f48:	66 90                	xchg   %ax,%ax
   24f4a:	66 90                	xchg   %ax,%ax
   24f4c:	66 90                	xchg   %ax,%ax
   24f4e:	66 90                	xchg   %ax,%ax
   24f50:	66 90                	xchg   %ax,%ax
   24f52:	66 90                	xchg   %ax,%ax
   24f54:	66 90                	xchg   %ax,%ax
   24f56:	66 90                	xchg   %ax,%ax
   24f58:	66 90                	xchg   %ax,%ax
   24f5a:	66 90                	xchg   %ax,%ax
   24f5c:	66 90                	xchg   %ax,%ax
   24f5e:	66 90                	xchg   %ax,%ax
   24f60:	66 90                	xchg   %ax,%ax
   24f62:	66 90                	xchg   %ax,%ax
   24f64:	66 90                	xchg   %ax,%ax
   24f66:	66 90                	xchg   %ax,%ax
   24f68:	66 90                	xchg   %ax,%ax
   24f6a:	66 90                	xchg   %ax,%ax
   24f6c:	66 90                	xchg   %ax,%ax
   24f6e:	66 90                	xchg   %ax,%ax
   24f70:	66 90                	xchg   %ax,%ax
   24f72:	66 90                	xchg   %ax,%ax
   24f74:	66 90                	xchg   %ax,%ax
   24f76:	66 90                	xchg   %ax,%ax
   24f78:	66 90                	xchg   %ax,%ax
   24f7a:	66 90                	xchg   %ax,%ax
   24f7c:	66 90                	xchg   %ax,%ax
   24f7e:	66 90                	xchg   %ax,%ax
   24f80:	66 90                	xchg   %ax,%ax
   24f82:	66 90                	xchg   %ax,%ax
   24f84:	66 90                	xchg   %ax,%ax
   24f86:	66 90                	xchg   %ax,%ax
   24f88:	66 90                	xchg   %ax,%ax
   24f8a:	66 90                	xchg   %ax,%ax
   24f8c:	66 90                	xchg   %ax,%ax
   24f8e:	66 90                	xchg   %ax,%ax
   24f90:	66 90                	xchg   %ax,%ax
   24f92:	66 90                	xchg   %ax,%ax
   24f94:	66 90                	xchg   %ax,%ax
   24f96:	66 90                	xchg   %ax,%ax
   24f98:	66 90                	xchg   %ax,%ax
   24f9a:	66 90                	xchg   %ax,%ax
   24f9c:	66 90                	xchg   %ax,%ax
   24f9e:	66 90                	xchg   %ax,%ax
   24fa0:	66 90                	xchg   %ax,%ax
   24fa2:	66 90                	xchg   %ax,%ax
   24fa4:	66 90                	xchg   %ax,%ax
   24fa6:	66 90                	xchg   %ax,%ax
   24fa8:	66 90                	xchg   %ax,%ax
   24faa:	66 90                	xchg   %ax,%ax
   24fac:	66 90                	xchg   %ax,%ax
   24fae:	66 90                	xchg   %ax,%ax
   24fb0:	66 90                	xchg   %ax,%ax
   24fb2:	66 90                	xchg   %ax,%ax
   24fb4:	66 90                	xchg   %ax,%ax
   24fb6:	66 90                	xchg   %ax,%ax
   24fb8:	66 90                	xchg   %ax,%ax
   24fba:	66 90                	xchg   %ax,%ax
   24fbc:	66 90                	xchg   %ax,%ax
   24fbe:	66 90                	xchg   %ax,%ax
   24fc0:	66 90                	xchg   %ax,%ax
   24fc2:	66 90                	xchg   %ax,%ax
   24fc4:	66 90                	xchg   %ax,%ax
   24fc6:	66 90                	xchg   %ax,%ax
   24fc8:	66 90                	xchg   %ax,%ax
   24fca:	66 90                	xchg   %ax,%ax
   24fcc:	66 90                	xchg   %ax,%ax
   24fce:	66 90                	xchg   %ax,%ax
   24fd0:	66 90                	xchg   %ax,%ax
   24fd2:	66 90                	xchg   %ax,%ax
   24fd4:	66 90                	xchg   %ax,%ax
   24fd6:	66 90                	xchg   %ax,%ax
   24fd8:	66 90                	xchg   %ax,%ax
   24fda:	66 90                	xchg   %ax,%ax
   24fdc:	66 90                	xchg   %ax,%ax
   24fde:	66 90                	xchg   %ax,%ax
   24fe0:	66 90                	xchg   %ax,%ax
   24fe2:	66 90                	xchg   %ax,%ax
   24fe4:	66 90                	xchg   %ax,%ax
   24fe6:	66 90                	xchg   %ax,%ax
   24fe8:	66 90                	xchg   %ax,%ax
   24fea:	66 90                	xchg   %ax,%ax
   24fec:	66 90                	xchg   %ax,%ax
   24fee:	66 90                	xchg   %ax,%ax
   24ff0:	66 90                	xchg   %ax,%ax
   24ff2:	66 90                	xchg   %ax,%ax
   24ff4:	66 90                	xchg   %ax,%ax
   24ff6:	66 90                	xchg   %ax,%ax
   24ff8:	66 90                	xchg   %ax,%ax
   24ffa:	66 90                	xchg   %ax,%ax
   24ffc:	66 90                	xchg   %ax,%ax
   24ffe:	66 90                	xchg   %ax,%ax
